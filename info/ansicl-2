This is ansicl, produced by makeinfo version 6.7 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: Generic Function Lambda Lists,  Next: Specialized Lambda Lists,  Prev: Ordinary Lambda Lists,  Up: Lambda Lists

3.4.2 Generic Function Lambda Lists
-----------------------------------

A “generic function lambda list” is used to describe the overall shape
of the argument list to be accepted by a generic function.  Individual
method signatures might contribute additional keyword parameters to the
lambda list of the effective method.

A generic function lambda list is used by ‘defgeneric’.

A generic function lambda list has the following syntax:

LAMBDA-LIST::=
     ({var}*
      [&optional {var | (var)}*]
      [&rest VAR]
      ‘[’&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}*
     [&allow-other-keys]‘]’)

A generic function lambda list can contain the lambda list keywords
shown in the next figure.

‘&allow-other-keys’   ‘&optional’
‘&key’                ‘&rest’

Figure 3.14: Lambda List Keywords used by Generic Function Lambda Lists

A generic function lambda list differs from an ordinary lambda list in
the following ways:

Required arguments

     Zero or more required parameters must be specified.

Optional and keyword arguments

     Optional parameters and keyword parameters may not have default
     initial value forms nor use supplied-p parameters.

Use of ‘&aux’

     The use of ‘&aux’ is not allowed.


File: ansicl,  Node: Specialized Lambda Lists,  Next: Macro Lambda Lists,  Prev: Generic Function Lambda Lists,  Up: Lambda Lists

3.4.3 Specialized Lambda Lists
------------------------------

A “specialized lambda list” is used to specialize a method for a
particular signature and to describe how arguments matching that
signature are received by the method.  The defined names in the next
figure use specialized lambda lists in some way; see the dictionary
entry for each for information about how.

defmethod   defgeneric

Figure 3.15: Standardized Operators that use Specialized Lambda Lists

A specialized lambda list can contain the lambda list keywords shown in
the next figure.

‘&allow-other-keys’   ‘&key’        ‘&rest’
‘&aux’                ‘&optional’

Figure 3.16: Lambda List Keywords used by Specialized Lambda Lists

A specialized lambda list is syntactically the same as an ordinary
lambda list except that each required parameter may optionally be
associated with a class or object for which that parameter is
specialized.

LAMBDA-LIST::=
     ({var | (var [specializer])}*
     [&optional {var | (var [init-form [supplied-p-parameter]])}*]
     [&rest VAR]
     [&key {var ({var | (keyword-name var)} [init-form
     [supplied-p-parameter]])}* [&allow-other-keys]]
     [&aux {var | (var [init-form])}*])


File: ansicl,  Node: Macro Lambda Lists,  Next: Destructuring Lambda Lists,  Prev: Specialized Lambda Lists,  Up: Lambda Lists

3.4.4 Macro Lambda Lists
------------------------

A “macro lambda list” is used in describing macros defined by the
operators in the next figure.

define-compiler-macro   defmacro   macrolet
define-setf-expander

Figure 3.17: Operators that use Macro Lambda Lists

With the additional restriction that an environment parameter may appear
only once (at any of the positions indicated), a macro lambda list has
the following syntax:

REQVARS::=
     {var | ↓pattern}*

OPTVARS::=
     [&optional {var | ({var ↓pattern} [init-form
     [supplied-p-parameter]])}*]

RESTVARS::=
     [{&rest | &body} {var | ↓pattern}]

KEYVARS::=
     [&key {var | ({var | (keyword-name {var | ↓pattern})} [init-form
     [supplied-p-parameter]])}* [&allow-other-keys]]

AUXVARS::=
     [&aux {var | (var [init-form])}*]
ENVVAR::=
     [&environment VAR]
WHOLEVAR::=
     [&whole VAR]
LAMBDA-LIST::=
     (↓wholevar ↓envvar ↓reqvars ↓envvar ↓optvars ↓envvar
     ↓restvar ↓envvar ↓keyvars ↓envvar ↓auxvars ↓envvar) |
     (↓wholevar ↓envvar ↓reqvars ↓envvar ↓optvars ↓envvar ‘.’  VAR)
PATTERN::=
     (↓wholevar ↓reqvars ↓optvars ↓restvar ↓keyvars ↓auxvars) |
     (↓wholevar ↓reqvars ↓optvars ‘.’  VAR)

A macro lambda list can contain the lambda list keywords shown in the
next figure.

‘&allow-other-keys’   ‘&environment’   ‘&rest’
‘&aux’                ‘&key’           ‘&whole’
‘&body’               ‘&optional’

Figure 3.18: Lambda List Keywords used by Macro Lambda Lists

Optional parameters (introduced by ‘&optional’) and keyword parameters
(introduced by ‘&key’) can be supplied in a macro lambda list, just as
in an ordinary lambda list.  Both may contain default initialization
forms and supplied-p parameters.

‘&body’ is identical in function to ‘&rest’, but it can be used to
inform certain output-formatting and editing functions that the
remainder of the form is treated as a body, and should be indented
accordingly.  Only one of ‘&body’ or ‘&rest’ can be used at any
particular level; see *note Section 3.4.4.1 (Destructuring by Lambda
Lists): DestructuringByLambdaLists.  ‘&body’ can appear at any level of
a macro lambda list; for details, see *note Section 3.4.4.1
(Destructuring by Lambda Lists): DestructuringByLambdaLists.

‘&whole’ is followed by a single variable that is bound to the entire
macro-call form; this is the value that the macro function receives as
its first argument.  If ‘&whole’ and a following variable appear, they
must appear first in LAMBDA-LIST, before any other parameter or lambda
list keyword.  ‘&whole’ can appear at any level of a macro lambda list.
At inner levels, the ‘&whole’ variable is bound to the corresponding
part of the argument, as with ‘&rest’, but unlike ‘&rest’, other
arguments are also allowed.  The use of ‘&whole’ does not affect the
pattern of arguments specified.

‘&environment’ is followed by a single variable that is bound to an
environment representing the lexical environment in which the macro call
is to be interpreted.  This environment should be used with
‘macro-function’, ‘get-setf-expansion’, ‘compiler-macro-function’, and
‘macroexpand’ (for example) in computing the expansion of the macro, to
ensure that any lexical bindings or definitions established in the
compilation environment are taken into account.  ‘&environment’ can only
appear at the top level of a macro lambda list, and can only appear
once, but can appear anywhere in that list; the ‘&environment’ parameter
is bound along with ‘&whole’ before any other variables in the lambda
list, regardless of where ‘&environment’ appears in the lambda list.
The object that is bound to the environment parameter has dynamic
extent.

Destructuring allows a macro lambda list to express the structure of a
macro call syntax.  If no lambda list keywords appear, then the macro
lambda list is a tree containing parameter names at the leaves.  The
pattern and the macro form must have compatible tree structure; that is,
their tree structure must be equivalent, or it must differ only in that
some leaves of the pattern match non-atomic objects of the macro form.
For information about error detection in this situation, see *note
Section 3.5.1.7 (Destructuring Mismatch): DestructuringMismatch.

A destructuring lambda list (whether at top level or embedded) can be
dotted, ending in a parameter name.  This situation is treated exactly
as if the parameter name that ends the list had appeared preceded by
‘&rest’.

It is permissible for a macro form (or a subexpression of a macro form)
to be a dotted list only when ‘(... &rest var)’ or ‘(... . var)’ is used
to match it.  It is the responsibility of the macro to recognize and
deal with such situations.

3.4.4.1 Destructuring by Lambda Lists
.....................................

Anywhere in a macro lambda list where a parameter name can appear, and
where ordinary lambda list syntax (as described in *note Section 3.4.1
(Ordinary Lambda Lists): Ordinary Lambda Lists.) does not otherwise
allow a list, a destructuring lambda list can appear in place of the
parameter name.  When this is done, then the argument that would match
the parameter is treated as a (possibly dotted) list, to be used as an
argument list for satisfying the parameters in the embedded lambda list.
This is known as destructuring.

Destructuring is the process of decomposing a compound object into its
component parts, using an abbreviated, declarative syntax, rather than
writing it out by hand using the primitive component-accessing
functions.  Each component part is bound to a variable.

A destructuring operation requires an object to be decomposed, a pattern
that specifies what components are to be extracted, and the names of the
variables whose values are to be the components.

3.4.4.1.1 Data-directed Destructuring by Lambda Lists
.....................................................

In data-directed destructuring, the pattern is a sample object of the
type to be decomposed.  Wherever a component is to be extracted, a
symbol appears in the pattern; this symbol is the name of the variable
whose value will be that component.

3.4.4.1.1.1 Examples of Data-directed Destructuring by Lambda Lists
...................................................................

An example pattern is

‘(a b c)’

which destructures a list of three elements.  The variable ‘a’ is
assigned to the first element, ‘b’ to the second, etc.  A more complex
example is

‘((first . rest) . more)’

The important features of data-directed destructuring are its syntactic
simplicity and the ability to extend it to lambda-list-directed
destructuring.

3.4.4.1.2 Lambda-list-directed Destructuring by Lambda Lists
............................................................

An extension of data-directed destructuring of trees is
lambda-list-directed destructuring.  This derives from the analogy
between the three-element destructuring pattern

‘(first second third)’

and the three-argument lambda list

‘(first second third)’

Lambda-list-directed destructuring is identical to data-directed
destructuring if no lambda list keywords appear in the pattern.  Any
list in the pattern (whether a sub-list or the whole pattern itself)
that contains a lambda list keyword is interpreted specially.  Elements
of the list to the left of the first lambda list keyword are treated as
destructuring patterns, as usual, but the remaining elements of the list
are treated like a function’s lambda list except that where a variable
would normally be required, an arbitrary destructuring pattern is
allowed.  Note that in case of ambiguity, lambda list syntax is
preferred over destructuring syntax.  Thus, after ‘&optional’ a list of
elements is a list of a destructuring pattern and a default value form.

The detailed behavior of each lambda list keyword in a
lambda-list-directed destructuring pattern is as follows:

‘&optional’

     Each following element is a variable or a list of a destructuring
     pattern, a default value form, and a supplied-p variable.  The
     default value and the supplied-p variable can be omitted.  If the
     list being destructured ends early, so that it does not have an
     element to match against this destructuring (sub)-pattern, the
     default form is evaluated and destructured instead.  The supplied-p
     variable receives the value ‘nil’ if the default form is used,
     ‘t’ otherwise.

‘&rest’, ‘&body’

     The next element is a destructuring pattern that matches the rest
     of the list.  ‘&body’ is identical to ‘&rest’ but declares that
     what is being matched is a list of forms that constitutes the body
     of form.  This next element must be the last unless a lambda list
     keyword follows it.

‘&aux’

     The remaining elements are not destructuring patterns at all, but
     are auxiliary variable bindings.

‘&whole’

     The next element is a destructuring pattern that matches the entire
     form in a macro, or the entire subexpression at inner levels.

‘&key’

     Each following element is one of

          a variable,

     or

          a list of a variable, an optional initialization form, and an
          optional supplied-p variable.

     or

          a list of a list of a keyword and a destructuring pattern, an
          optional initialization form, and an optional supplied-p
          variable.

     The rest of the list being destructured is taken to be alternating
     keywords and values and is taken apart appropriately.

‘&allow-other-keys’

     Stands by itself.


File: ansicl,  Node: Destructuring Lambda Lists,  Next: Boa Lambda Lists,  Prev: Macro Lambda Lists,  Up: Lambda Lists

3.4.5 Destructuring Lambda Lists
--------------------------------

A “destructuring lambda list” is used by ‘destructuring-bind’.

Destructuring lambda lists are closely related to macro lambda lists;
see *note Section 3.4.4 (Macro Lambda Lists): Macro Lambda Lists.  A
destructuring lambda list can contain all of the lambda list keywords
listed for macro lambda lists except for ‘&environment’, and supports
destructuring in the same way.  Inner lambda lists nested within a macro
lambda list have the syntax of destructuring lambda lists.

A destructuring lambda list has the following syntax:

REQVARS::=
     {var | ↓lambda-list}*

OPTVARS::=
     [&optional {var | ({var ↓lambda-list} [init-form
     [supplied-p-parameter]])}*]

RESTVARS::=
     [{&rest | &body} {var | ↓lambda-list}]

KEYVARS::=
     [&key {var | ({var | (keyword-name {var | ↓lambda-list})}
     [init-form [supplied-p-parameter]])}* [&allow-other-keys]]

AUXVARS::=
     [&aux {var | (var [init-form])}*]
ENVVAR::=
     [&environment VAR]
WHOLEVAR::=
     [&whole VAR]
LAMBDA-LIST::=
     (↓wholevar ↓reqvars ↓optvars ↓restvar ↓keyvars ↓auxvars) |
     (↓wholevar ↓reqvars ↓optvars ‘.’  VAR)


File: ansicl,  Node: Boa Lambda Lists,  Next: Defsetf Lambda Lists,  Prev: Destructuring Lambda Lists,  Up: Lambda Lists

3.4.6 Boa Lambda Lists
----------------------

A “boa lambda list” is a lambda list that is syntactically like an
ordinary lambda list, but that is processed in “by order of argument”
style.

A boa lambda list is used only in a ‘defstruct’ form, when explicitly
specifying the lambda list of a constructor function (sometimes called a
“boa constructor”).

The ‘&optional’, ‘&rest’, ‘&aux’, ‘&key’, and ‘&allow-other-keys’ lambda
list keywords are recognized in a boa lambda list.  The way these lambda
list keywords differ from their use in an ordinary lambda list follows.

Consider this example, which describes how ‘destruct’ processes its
:constructor option.

      (:constructor create-foo
              (a &optional b (c 'sea) &rest d &aux e (f 'eff)))

This defines ‘create-foo’ to be a constructor of one or more arguments.
The first argument is used to initialize the ‘a’ slot.  The second
argument is used to initialize the ‘b’ slot.  If there isn’t any second
argument, then the default value given in the body of the ‘defstruct’
(if given) is used instead.  The third argument is used to initialize
the ‘c’ slot.  If there isn’t any third argument, then the symbol ‘sea’
is used instead.  Any arguments following the third argument are
collected into a list and used to initialize the ‘d’ slot.  If there are
three or fewer arguments, then ‘nil’ is placed in the ‘d’ slot.  The ‘e’
slot is not initialized; its initial value is implementation-defined.
Finally, the ‘f’ slot is initialized to contain the symbol ‘eff’.
‘&key’ and ‘&allow-other-keys’ arguments default in a manner similar to
that of ‘&optional’ arguments: if no default is supplied in the lambda
list then the default value given in the body of the ‘defstruct’ (if
given) is used instead.  For example:

      (defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)
                                                  &key (d 2)
                                                  &aux e (f 'eff))))
        (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))

      (create-foo 10) → #S(FOO A 10 B 2 C SEA D 2 E implemention-dependent F EFF)
      (create-foo 10 'bee 'see :d 'dee)
     → #S(FOO A 10 B BEE C SEE D DEE E implemention-dependent F EFF)

If keyword arguments of the form ‘((key var) [default [svar]])’ are
specified, the slot name is matched with var (not key).

The actions taken in the ‘b’ and ‘e’ cases were carefully chosen to
allow the user to specify all possible behaviors.  The ‘&aux’ variables
can be used to completely override the default initializations given in
the body.

If no default value is supplied for an aux variable variable, the
consequences are undefined if an attempt is later made to read the
corresponding slot’s value before a value is explicitly assigned.  If
such a slot has a :type option specified, this suppressed initialization
does not imply a type mismatch situation; the declared type is only
required to apply when the slot is finally assigned.

With this definition, the following can be written:

      (create-foo 1 2)

instead of

      (make-foo :a 1 :b 2)

and ‘create-foo’ provides defaulting different from that of ‘make-foo’.

Additional arguments that do not correspond to slot names but are merely
present to supply values used in subsequent initialization computations
are allowed.  For example, in the definition

      (defstruct (frob (:constructor create-frob
                       (a &key (b 3 have-b) (c-token 'c)
                               (c (list c-token (if have-b 7 2))))))
              a b c)

the ‘c-token’ argument is used merely to supply a value used in the
initialization of the ‘c’ slot.  The supplied-p parameters associated
with optional parameters and keyword parameters might also be used this
way.


File: ansicl,  Node: Defsetf Lambda Lists,  Next: Deftype Lambda Lists,  Prev: Boa Lambda Lists,  Up: Lambda Lists

3.4.7 Defsetf Lambda Lists
--------------------------

A “defsetf lambda list” is used by ‘defsetf’.

A defsetf lambda list has the following syntax:

LAMBDA-LIST::=
     ({var}*
     [&optional {var | (var [init-form [supplied-p-parameter]])}*]
     [&rest VAR]
     ‘[’&key {var ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}*
     [&allow-other-keys]‘]’
     [&environment VAR]

A defsetf lambda list can contain the lambda list keywords shown in the
next figure.

‘&allow-other-keys’   ‘&key’        ‘&rest’
‘&environment’        ‘&optional’

Figure 3.19: Lambda List Keywords used by Defsetf Lambda Lists

A defsetf lambda list differs from an ordinary lambda list only in that
it does not permit the use of ‘&aux’, and that it permits use of
‘&environment’, which introduces an environment parameter.


File: ansicl,  Node: Deftype Lambda Lists,  Next: Define-modify-macro Lambda Lists,  Prev: Defsetf Lambda Lists,  Up: Lambda Lists

3.4.8 Deftype Lambda Lists
--------------------------

A “deftype lambda list” is used by ‘deftype’.

A deftype lambda list has the same syntax as a macro lambda list, and
can therefore contain the lambda list keywords as a macro lambda list.

A deftype lambda list differs from a macro lambda list only in that if
no INIT-FORM is supplied for an optional parameter or keyword parameter
in the LAMBDA-LIST, the default value for that parameter is the symbol *
(rather than ‘nil’).


File: ansicl,  Node: Define-modify-macro Lambda Lists,  Next: Define-method-combination Arguments Lambda Lists,  Prev: Deftype Lambda Lists,  Up: Lambda Lists

3.4.9 Define-modify-macro Lambda Lists
--------------------------------------

A “define-modify-macro lambda list” is used by ‘define-modify-macro’.

A define-modify-macro lambda list can contain the lambda list keywords
shown in the next figure.

‘&optional’   ‘&rest’

Figure 3.20: Lambda List Keywords used by Define-modify-macro Lambda
Lists

Define-modify-macro lambda lists are similar to ordinary lambda lists,
but do not support keyword arguments.  ‘define-modify-macro’ has no need
match keyword arguments, and a rest parameter is sufficient.  Aux
variables are also not supported, since ‘define-modify-macro’ has no
body forms which could refer to such bindings.  See the macro *note
define-modify-macro::.


File: ansicl,  Node: Define-method-combination Arguments Lambda Lists,  Next: Syntactic Interaction of Documentation Strings and Declarations,  Prev: Define-modify-macro Lambda Lists,  Up: Lambda Lists

3.4.10 Define-method-combination Arguments Lambda Lists
-------------------------------------------------------

A “define-method-combination arguments lambda list” is used by the
:arguments option to ‘define-method-combination’.

A define-method-combination arguments lambda list can contain the lambda
list keywords shown in the next figure.

‘&allow-other-keys’   ‘&key’        ‘&rest’
‘&aux’                ‘&optional’   ‘&whole’

Figure 3.21: Lambda List Keywords used by Define-method-combination
arguments Lambda Lists

Define-method-combination arguments lambda lists are similar to ordinary
lambda lists, but also permit the use of ‘&whole’.


File: ansicl,  Node: Syntactic Interaction of Documentation Strings and Declarations,  Prev: Define-method-combination Arguments Lambda Lists,  Up: Lambda Lists

3.4.11 Syntactic Interaction of Documentation Strings and Declarations
----------------------------------------------------------------------

In a number of situations, a documentation string can appear amidst a
series of declare expressions prior to a series of forms.

In that case, if a string S appears where a documentation string is
permissible and is not followed by either a declare expression or a form
then S is taken to be a form; otherwise, S is taken as a documentation
string.  The consequences are unspecified if more than one such
documentation string is present.


File: ansicl,  Node: Error Checking in Function Calls,  Next: Traversal Rules and Side Effects,  Prev: Lambda Lists,  Up: Evaluation and Compilation

3.5 Error Checking in Function Calls
====================================

* Menu:

* Argument Mismatch Detection::


File: ansicl,  Node: Argument Mismatch Detection,  Up: Error Checking in Function Calls

3.5.1 Argument Mismatch Detection
---------------------------------

3.5.1.1 Safe and Unsafe Calls
.............................

A call is a “safe call” if each of the following is either safe code or
system code (other than system code that results from macro expansion of
programmer code):

   • the call.
   • the definition of the function being called.
   • the point of functional evaluation

The following special cases require some elaboration:

   • If the function being called is a generic function, it is
     considered safe if all of the following are safe code or system
     code:

        – its definition (if it was defined explicitly).
        – the method definitions for all applicable methods.
        – the definition of its method combination.

   • For the form ‘(coerce X 'function)’, where X is a lambda
     expression, the value of the optimize quality ‘safety’ in the
     global environment at the time the ‘coerce’ is executed applies to
     the resulting function.

   • For a call to the function ‘ensure-generic-function’, the value of
     the optimize quality ‘safety’ in the environment object passed as
     the :environment argument applies to the resulting generic
     function.

   • For a call to ‘compile’ with a lambda expression as the argument,
     the value of the optimize quality ‘safety’ in the global
     environment at the time ‘compile’ is called applies to the
     resulting compiled function.

   • For a call to ‘compile’ with only one argument, if the original
     definition of the function was safe, then the resulting compiled
     function must also be safe.

   • A call to a method by ‘call-next-method’ must be considered safe if
     each of the following is safe code or system code:

        – the definition of the generic function (if it was defined
          explicitly).
        – the method definitions for all applicable methods.
        – the definition of the method combination.
        – the point of entry into the body of the method defining form,
          where the binding of ‘call-next-method’ is established.
        – the point of functional evaluation of the name
          ‘call-next-method’.

An “unsafe call” is a call that is not a safe call.

The informal intent is that the programmer can rely on a call to be
safe, even when system code is involved, if all reasonable steps have
been taken to ensure that the call is safe.  For example, if a
programmer calls ‘mapcar’ from safe code and supplies a function that
was compiled as safe, the implementation is required to ensure that
‘mapcar’ makes a safe call as well.

3.5.1.1.1 Error Detection Time in Safe Calls
............................................

If an error is signaled in a safe call, the exact point of the signal is
implementation-dependent.  In particular, it might be signaled at
compile time or at run time, and if signaled at run time, it might be
prior to, during, or after executing the call.  However, it is always
prior to the execution of the body of the function being called.

3.5.1.2 Too Few Arguments
.........................

It is not permitted to supply too few arguments to a function.  Too few
arguments means fewer arguments than the number of required parameters
for the function.

If this situation occurs in a safe call, an error of type
‘program-error’ must be signaled; and in an unsafe call the situation
has undefined consequences.

3.5.1.3 Too Many Arguments
..........................

It is not permitted to supply too many arguments to a function.  Too
many arguments means more arguments than the number of required
parameters plus the number of optional parameters; however, if the
function uses ‘&rest’ or ‘&key’, it is not possible for it to receive
too many arguments.

If this situation occurs in a safe call, an error of type
‘program-error’ must be signaled; and in an unsafe call the situation
has undefined consequences.

3.5.1.4 Unrecognized Keyword Arguments
......................................

It is not permitted to supply a keyword argument to a function using a
name that is not recognized by that function unless keyword argument
checking is suppressed as described in *note Section 3.4.1.4.1
(Suppressing Keyword Argument Checking): SuppressingKeyArgChecks.

If this situation occurs in a safe call, an error of type
‘program-error’ must be signaled; and in an unsafe call the situation
has undefined consequences.

3.5.1.5 Invalid Keyword Arguments
.................................

It is not permitted to supply a keyword argument to a function using a
name that is not a symbol.

If this situation occurs in a safe call, an error of type
‘program-error’ must be signaled unless keyword argument checking is
suppressed as described in *note Section 3.4.1.4.1 (Suppressing Keyword
Argument Checking): SuppressingKeyArgChecks.; and in an unsafe call the
situation has undefined consequences.

3.5.1.6 Odd Number of Keyword Arguments
.......................................

An odd number of arguments must not be supplied for the keyword
parameters.

If this situation occurs in a safe call, an error of type
‘program-error’ must be signaled unless keyword argument checking is
suppressed as described in *note Section 3.4.1.4.1 (Suppressing Keyword
Argument Checking): SuppressingKeyArgChecks.; and in an unsafe call the
situation has undefined consequences.

3.5.1.7 Destructuring Mismatch
..............................

When matching a destructuring lambda list against a form, the pattern
and the form must have compatible tree structure, as described in *note
Section 3.4.4 (Macro Lambda Lists): Macro Lambda Lists.

Otherwise, in a safe call, an error of type ‘program-error’ must be
signaled; and in an unsafe call the situation has undefined
consequences.

3.5.1.8 Errors When Calling a Next Method
.........................................

If ‘call-next-method’ is called with arguments, the ordered set of
applicable methods for the changed set of arguments for
‘call-next-method’ must be the same as the ordered set of applicable
methods for the original arguments to the generic function, or else an
error should be signaled.

The comparison between the set of methods applicable to the new
arguments and the set applicable to the original arguments is
insensitive to order differences among methods with the same
specializers.

If ‘call-next-method’ is called with arguments that specify a different
ordered set of applicable methods and there is no next method available,
the test for different methods and the associated error signaling (when
present) takes precedence over calling ‘no-next-method’.


File: ansicl,  Node: Traversal Rules and Side Effects,  Next: Destructive Operations,  Prev: Error Checking in Function Calls,  Up: Evaluation and Compilation

3.6 Traversal Rules and Side Effects
====================================

The consequences are undefined when code executed during an
object-traversing operation destructively modifies the object in a way
that might affect the ongoing traversal operation.  In particular, the
following rules apply.

List traversal

     For list traversal operations, the cdr chain of the list is not
     allowed to be destructively modified.

Array traversal

     For array traversal operations, the array is not allowed to be
     adjusted and its fill pointer, if any, is not allowed to be
     changed.

Hash-table traversal

     For hash table traversal operations, new elements may not be added
     or deleted except that the element corresponding to the current
     hash key may be changed or removed.

Package traversal

     For package traversal operations (e.g., ‘do-symbols’), new symbols
     may not be interned in or uninterned from the package being
     traversed or any package that it uses except that the current
     symbol may be uninterned from the package being traversed.


File: ansicl,  Node: Destructive Operations,  Next: lambda (Symbol),  Prev: Traversal Rules and Side Effects,  Up: Evaluation and Compilation

3.7 Destructive Operations
==========================

* Menu:

* Modification of Literal Objects::
* Transfer of Control during a Destructive Operation::


File: ansicl,  Node: Modification of Literal Objects,  Next: Transfer of Control during a Destructive Operation,  Up: Destructive Operations

3.7.1 Modification of Literal Objects
-------------------------------------

The consequences are undefined if literal objects are destructively
modified.  For this purpose, the following operations are considered
destructive:

‘random-state’

     Using it as an argument to the function ‘random’.

‘cons’

     Changing the caror performing a destructive operation on an object
     which is either the car

‘array’

     Storing a new value into some element of the array, or performing a
     destructive operation on an object that is already such an element.

     Changing the fill pointer, dimensions, or displacement of the array
     (regardless of whether the array is actually adjustable).

     Performing a destructive operation on another array that is
     displaced to the array or that otherwise shares its contents with
     the array.

‘hash-table’

     Performing a destructive operation on any key.

     Storing a new valueor performing a destructive operation on any
     object that is such a value.

     Adding or removing entries from the hash table.

‘structure-object’

     Storing a new value into any slot, or performing a destructive
     operation on an object that is the value of some slot.

‘standard-object’

     Storing a new value into any slot, or performing a destructive
     operation on an object that is the value of some slot.

     Changing the class of the object (e.g., using the function
     ‘change-class’).

‘readtable’

     Altering the readtable case.

     Altering the syntax type of any character in this readtable.

     Altering the reader macro function associated with any character in
     the readtable, or altering the reader macro functions associated
     with characters defined as dispatching macro characters in the
     readtable.

‘stream’

     Performing I/O operations on the stream, or closing the stream.

All other standardized types

     [This category includes, for example, ‘character’, ‘condition’,
     ‘function’, ‘method-combination’, ‘method’, ‘number’, ‘package’,
     ‘pathname’, ‘restart’, and ‘symbol’.]

     There are no standardized destructive operations defined on objects
     of these types.


File: ansicl,  Node: Transfer of Control during a Destructive Operation,  Prev: Modification of Literal Objects,  Up: Destructive Operations

3.7.2 Transfer of Control during a Destructive Operation
--------------------------------------------------------

Should a transfer of control out of a destructive operation occur (e.g.,
due to an error) the state of the OBJECT being modified is
implementation-dependent.

3.7.2.1 Examples of Transfer of Control during a Destructive Operation
......................................................................

The following examples illustrate some of the many ways in which the
implementation-dependent nature of the modification can manifest itself.

      (let ((a (list 2 1 4 3 7 6 'five)))
        (ignore-errors (sort a #'<))
        a)
     → (1 2 3 4 6 7 FIVE)
     or→ (2 1 4 3 7 6 FIVE)
     or→ (2)

      (prog foo ((a (list 1 2 3 4 5 6 7 8 9 10)))
        (sort a #'(lambda (x y) (if (zerop (random 5)) (return-from foo a) (> x y)))))
     → (1 2 3 4 5 6 7 8 9 10)
     or→ (3 4 5 6 2 7 8 9 10 1)
     or→ (1 2 4 3)


File: ansicl,  Node: lambda (Symbol),  Next: lambda (Macro),  Prev: Destructive Operations,  Up: Evaluation and Compilation

lambda (Symbol)
===============

Syntax:
.......

 -- Special Form: lambda lambda-list 〚{declaration}* | documentation〛
          {form}*

Arguments:
..........

LAMBDA-LIST—an ordinary lambda list.

DECLARATION—a declare expression; not evaluated.

DOCUMENTATION—a string; not evaluated.

FORM—a form.

Description:
............

A lambda expression is a list that can be used in place of a function
name in certain contexts to denote a function by directly describing its
behavior rather than indirectly by referring to the name of an
established function.

DOCUMENTATION is attached to the denoted FUNCTION (if any is actually
created) as a documentation string.

See Also:
.........

*note function (Special Operator)::, *note documentation::, *note
Section 3.1.3 (Lambda Expressions): Lambda Expressions, *note Section
3.1.2.1.2.4 (Lambda Forms): LambdaForms, *note Section 3.4.11 (Syntactic
Interaction of Documentation Strings and Declarations): Syntactic
Interaction of Documentation Strings and Declarations.

Notes:
......

The lambda form

      ((lambda LAMBDA-LIST . BODY) . ARGUMENTS)

is semantically equivalent to the function form

      (funcall #'(lambda LAMBDA-LIST . BODY) . ARGUMENTS)


File: ansicl,  Node: lambda (Macro),  Next: compile,  Prev: lambda (Symbol),  Up: Evaluation and Compilation

lambda (Macro)
==============

Syntax:
.......

 -- Macro: lambda lambda-list 〚{declaration}* | documentation〛 {form}*
          → FUNCTION

Arguments and Values:
.....................

LAMBDA-LIST—an ordinary lambda list.

DECLARATION—a declare expression; not evaluated.

DOCUMENTATION—a string; not evaluated.

FORM—a form.

FUNCTION—a function.

Description:
............

Provides a shorthand notation for a ‘function’ special form involving a
lambda expression such that:

         (lambda LAMBDA-LIST 〚{declaration}* | documentation〛 {form}*)
      ≡ (function (lambda LAMBDA-LIST 〚{declaration}* | documentation〛 {form}*))
      ≡ #'(lambda LAMBDA-LIST 〚{declaration}* | documentation〛 {form}*)

Examples:
.........

      (funcall (lambda (x) (+ x 3)) 4) → 7

See Also:
.........

*note lambda (Symbol):: (symbol)

Notes:
......

This macro could be implemented by:

     (defmacro lambda (&whole form &rest bvl-decls-and-body)
       (declare (ignore bvl-decls-and-body))
       `#',form)


File: ansicl,  Node: compile,  Next: eval,  Prev: lambda (Macro),  Up: Evaluation and Compilation

compile (Function)
==================

Syntax:
.......

 -- Function: compile name &optional definition → function, warnings-p,
          failure-p

Arguments and Values:
.....................

NAME—a function name, or ‘nil’.

DEFINITION—a lambda expression or a function.  The default is the
function definition of NAME if it names a function, or the macro
function of NAME if it names a macro.  The consequences are undefined if
no DEFINITION is supplied when the NAME is ‘nil’.

FUNCTION—the FUNCTION-NAME, or a compiled function.

WARNINGS-P—a generalized boolean.

FAILURE-P—a generalized boolean.

Description:
............

Compiles an interpreted function.

‘compile’ produces a compiled function from DEFINITION.  If the
DEFINITION is a lambda expression, it is coerced to a function.  If the
DEFINITION is already a compiled function, ‘compile’ either produces
that function itself (i.e., is an identity operation) or an equivalent
function.

If the NAME is ‘nil’, the resulting compiled function is returned
directly as the primary value.  If a non-nil NAME is given, then the
resulting compiled function replaces the existing function definition of
NAME and the NAME is returned as the primary value; if NAME is a symbol
that names a macro, its macro function is updated and the NAME is
returned as the primary value.

Literal objects appearing in code processed by the ‘compile’ function
are neither copied nor coalesced.  The code resulting from the execution
of ‘compile’ references objects that are ‘eql’ to the corresponding
objects in the source code.

‘compile’ is permitted, but not required, to establish a handler for
conditions of type ‘error’.  For example, the handler might issue a
warning and restart compilation from some implementation-dependent point
in order to let the compilation proceed without manual intervention.

The secondary value, WARNINGS-P, is false if no conditions of type
‘error’ or ‘warning’ were detected by the compiler, and true otherwise.

The tertiary value, FAILURE-P, is false if no conditions of type ‘error’
or ‘warning’ (other than ‘style-warning’) were detected by the compiler,
and true otherwise.

Examples:
.........

      (defun foo () "bar") → FOO
      (compiled-function-p #'foo) → implementation-dependent
      (compile 'foo) → FOO
      (compiled-function-p #'foo) → true
      (setf (symbol-function 'foo)
            (compile nil '(lambda () "replaced"))) → #<Compiled-Function>
      (foo) → "replaced"

Affected By:
............

‘*error-output*’, ‘*macroexpand-hook*’.

The presence of macro definitions and proclamations.

Exceptional Situations:
.......................

The consequences are undefined if the lexical environment surrounding
the function to be compiled contains any bindings other than those for
macros, symbol macros, or declarations.

For information about errors detected during the compilation process,
see *note Section 3.2.5 (Exceptional Situations in the Compiler):
Exceptional Situations in the Compiler.

See Also:
.........

*note compile-file::


File: ansicl,  Node: eval,  Next: eval-when,  Prev: compile,  Up: Evaluation and Compilation

eval (Function)
===============

Syntax:
.......

 -- Function: eval form → {result}*

Arguments and Values:
.....................

FORM—a form.

RESULTS—the values yielded by the evaluation of FORM.

Description:
............

Evaluates FORM in the current dynamic environment and the null lexical
environment.

‘eval’ is a user interface to the evaluator.

The evaluator expands macro calls as if through the use of
‘macroexpand-1’.

Constants appearing in code processed by ‘eval’ are not copied nor
coalesced.  The code resulting from the execution of ‘eval’ references
objects that are ‘eql’ to the corresponding objects in the source code.

Examples:
.........

      (setq form '(1+ a) a 999) → 999
      (eval form) → 1000
      (eval 'form) → (1+ A)
      (let ((a '(this would break if eval used local value))) (eval form))
     → 1000

See Also:
.........

*note macroexpand-1::, *note Section 3.1.2 (The Evaluation Model): The
Evaluation Model.

Notes:
......

To obtain the current dynamic value of a symbol, use of ‘symbol-value’
is equivalent (and usually preferable) to use of ‘eval’.

Note that an ‘eval’ form involves two levels of evaluation for its
argument.  First, FORM is evaluated by the normal argument evaluation
mechanism as would occur with any call.  The object that results from
this normal argument evaluation becomes the value of the FORM parameter,
and is then evaluated as part of the ‘eval’ form.  For example:

      (eval (list 'cdr (car '((quote (a . b)) c)))) → b

The argument form ‘(list 'cdr (car '((quote (a . b)) c)))’ is evaluated
in the usual way to produce the argument ‘(cdr (quote (a . b)))’; ‘eval’
then evaluates its argument, ‘(cdr (quote (a . b)))’, to produce ‘b’.
Since a single evaluation already occurs for any argument form in any
function form, ‘eval’ is sometimes said to perform “an extra level of
evaluation.”


File: ansicl,  Node: eval-when,  Next: load-time-value,  Prev: eval,  Up: Evaluation and Compilation

eval-when (Special Operator)
============================

Syntax:
.......

 -- Special Form: eval-when ({situation}*) {form}* → {result}*

Arguments and Values:
.....................

SITUATION—One of the symbols :compile-toplevel , :load-toplevel ,
:execute , compile , load , or eval .

The use of eval, compile, and load is deprecated.

FORMS—an implicit progn.

RESULTS—the values of the forms if they are executed, or ‘nil’ if they
are not.

Description:
............

The body of an ‘eval-when’ form is processed as an implicit progn, but
only in the SITUATIONS listed.

The use of the SITUATIONS :compile-toplevel (or ‘compile’) and
:load-toplevel (or ‘load’) controls whether and when evaluation occurs
when ‘eval-when’ appears as a top level form in code processed by
‘compile-file’.  See *note Section 3.2.3 (File Compilation): File
Compilation.

The use of the SITUATION :execute (or ‘eval’) controls whether
evaluation occurs for other ‘eval-when’ forms; that is, those that are
not top level forms, or those in code processed by ‘eval’ or ‘compile’.
If the :execute situation is specified in such a form, then the body
FORMS are processed as an implicit progn; otherwise, the ‘eval-when’
form returns ‘nil’.

‘eval-when’ normally appears as a top level form, but it is meaningful
for it to appear as a non-top-level form.  However, the compile-time
side effects described in *note Section 3.2 (Compilation): Compilation.
only take place when ‘eval-when’ appears as a top level form.

Examples:
.........

One example of the use of ‘eval-when’ is that for the compiler to be
able to read a file properly when it uses user-defined reader macros, it
is necessary to write

      (eval-when (:compile-toplevel :load-toplevel :execute)
        (set-macro-character #\$ #'(lambda (stream char)
                                     (declare (ignore char))
                                     (list 'dollar (read stream))))) → T

This causes the call to ‘set-macro-character’ to be executed in the
compiler’s execution environment, thereby modifying its reader syntax
table.

     ;;;     The EVAL-WHEN in this case is not at toplevel, so only the :EXECUTE
     ;;;     keyword is considered. At compile time, this has no effect.
     ;;;     At load time (if the LET is at toplevel), or at execution time
     ;;;     (if the LET is embedded in some other form which does not execute
     ;;;     until later) this sets (SYMBOL-FUNCTION 'FOO1) to a function which
     ;;;     returns 1.
      (let ((x 1))
        (eval-when (:execute :load-toplevel :compile-toplevel)
          (setf (symbol-function 'foo1) #'(lambda () x))))

     ;;;     If this expression occurs at the toplevel of a file to be compiled,
     ;;;     it has BOTH a compile time AND a load-time effect of setting
     ;;;     (SYMBOL-FUNCTION 'FOO2) to a function which returns 2.
      (eval-when (:execute :load-toplevel :compile-toplevel)
        (let ((x 2))
          (eval-when (:execute :load-toplevel :compile-toplevel)
            (setf (symbol-function 'foo2) #'(lambda () x)))))

     ;;;     If this expression occurs at the toplevel of a file to be compiled,
     ;;;     it has BOTH a compile time AND a load-time effect of setting the
     ;;;     function cell of FOO3 to a function which returns 3.
      (eval-when (:execute :load-toplevel :compile-toplevel)
        (setf (symbol-function 'foo3) #'(lambda () 3)))

     ;;; #4: This always does nothing. It simply returns NIL.
      (eval-when (:compile-toplevel)
        (eval-when (:compile-toplevel)
          (print 'foo4)))

     ;;;     If this form occurs at toplevel of a file to be compiled, FOO5 is
     ;;;     printed at compile time. If this form occurs in a non-top-level
     ;;;     position, nothing is printed at compile time. Regardless of context,
     ;;;     nothing is ever printed at load time or execution time.
      (eval-when (:compile-toplevel)
        (eval-when (:execute)
          (print 'foo5)))

     ;;;     If this form occurs at toplevel of a file to be compiled, FOO6 is
     ;;;     printed at compile time.  If this form occurs in a non-top-level
     ;;;     position, nothing is printed at compile time. Regardless of context,
     ;;;     nothing is ever printed at load time or execution time.
      (eval-when (:execute :load-toplevel)
        (eval-when (:compile-toplevel)
          (print 'foo6)))

See Also:
.........

*note compile-file::, *note Section 3.2 (Compilation): Compilation.

Notes:
......

The following effects are logical consequences of the definition of
‘eval-when’:

   • Execution of a single ‘eval-when’ expression executes the body code
     at most once.

   • Macros intended for use in top level forms should be written so
     that side-effects are done by the forms in the macro expansion.
     The macro-expander itself should not do the side-effects.

     For example:

     Wrong:

           (defmacro foo ()
             (really-foo)
             `(really-foo))

     Right:

           (defmacro foo ()
             `(eval-when (:compile-toplevel :execute :load-toplevel) (really-foo)))

     Adherence to this convention means that such macros behave
     intuitively when appearing as non-top-level forms.

   • Placing a variable binding around an ‘eval-when’ reliably captures
     the binding because the compile-time-too mode cannot occur (i.e.,
     introducing a variable binding means that the ‘eval-when’ is not a
     top level form).  For example,

           (let ((x 3))
             (eval-when (:execute :load-toplevel :compile-toplevel) (print x)))

     prints ‘3’ at execution (i.e., load) time, and does not print
     anything at compile time.  This is important so that expansions of
     ‘defun’ and ‘defmacro’ can be done in terms of ‘eval-when’ and can
     correctly capture the lexical environment.

           (defun bar (x) (defun foo () (+ x 3)))

     might expand into

           (defun bar (x)
             (progn (eval-when (:compile-toplevel)
                      (compiler::notice-function-definition 'foo '(x)))
                    (eval-when (:execute :load-toplevel)
                      (setf (symbol-function 'foo) #'(lambda () (+ x 3))))))

     which would be treated by the above rules the same as

           (defun bar (x)
             (setf (symbol-function 'foo) #'(lambda () (+ x 3))))

     when the definition of ‘bar’ is not a top level form.


File: ansicl,  Node: load-time-value,  Next: quote,  Prev: eval-when,  Up: Evaluation and Compilation

load-time-value (Special Operator)
==================================

Syntax:
.......

 -- Special Form: load-time-value form &optional read-only-p → object

Arguments and Values:
.....................

FORM—a form; evaluated as described below.

READ-ONLY-P—a boolean; not evaluated.

OBJECT—the primary value resulting from evaluating FORM.

Description:
............

‘load-time-value’ provides a mechanism for delaying evaluation of FORM
until the expression is in the run-time environment; see *note Section
3.2 (Compilation): Compilation.

READ-ONLY-P designates whether the result can be considered a constant
object.  If ‘t’, the result is a read-only quantity that can, if
appropriate to the implementation, be copied into read-only space and/or
coalesced with similar constant objects from other programs.  If
‘nil’ (the default), the result must be neither copied nor coalesced; it
must be considered to be potentially modifiable data.

If a ‘load-time-value’ expression is processed by ‘compile-file’, the
compiler performs its normal semantic processing (such as macro
expansion and translation into machine code) on FORM, but arranges for
the execution of FORM to occur at load time in a null lexical
environment, with the result of this evaluation then being treated as a
literal object at run time.  It is guaranteed that the evaluation of
FORM will take place only once when the file is loaded, but the order of
evaluation with respect to the evaluation of top level forms in the file
is implementation-dependent.

If a ‘load-time-value’ expression appears within a function compiled
with ‘compile’, the FORM is evaluated at compile time in a null lexical
environment.  The result of this compile-time evaluation is treated as a
literal object in the compiled code.

If a ‘load-time-value’ expression is processed by ‘eval’, FORM is
evaluated in a null lexical environment, and one value is returned.
Implementations that implicitly compile (or partially compile)
expressions processed by ‘eval’ might evaluate FORM only once, at the
time this compilation is performed.

If the same list ‘(load-time-value FORM)’ is evaluated or compiled more
than once, it is implementation-dependent whether FORM is evaluated only
once or is evaluated more than once.  This can happen both when an
expression being evaluated or compiled shares substructure, and when the
same form is processed by ‘eval’ or ‘compile’ multiple times.  Since a
‘load-time-value’ expression can be referenced in more than one place
and can be evaluated multiple times by ‘eval’, it is
implementation-dependent whether each execution returns a fresh object
or returns the same object as some other execution.  Users must use
caution when destructively modifying the resulting object.

If two lists ‘(load-time-value FORM)’ that are the same under ‘equal’
but are not identical are evaluated or compiled, their values always
come from distinct evaluations of FORM.  Their values may not be
coalesced unless READ-ONLY-P is ‘t’.

Examples:
.........

     ;;; The function INCR1 always returns the same value, even in different images.
     ;;; The function INCR2 always returns the same value in a given image,
     ;;; but the value it returns might vary from image to image.
     (defun incr1 (x) (+ x #.(random 17)))
     (defun incr2 (x) (+ x (load-time-value (random 17))))

     ;;; The function FOO1-REF references the nth element of the first of
     ;;; the *FOO-ARRAYS* that is available at load time.  It is permissible for
     ;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the
     ;;; updated values.
     (defvar *foo-arrays* (list (make-array 7) (make-array 8)))
     (defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))
     (defun set-foo1-ref (n val)
       (setf (aref (load-time-value (first *my-arrays*) nil) n) val))

     ;;; The function BAR1-REF references the nth element of the first of
     ;;; the *BAR-ARRAYS* that is available at load time.  The programmer has
     ;;; promised that the array will be treated as read-only, so the system
     ;;; can copy or coalesce the array.
     (defvar *bar-arrays* (list (make-array 7) (make-array 8)))
     (defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))

     ;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
     ;;; even though NIL was specified, because the object was already read-only
     ;;; when it was written as a literal vector rather than created by a constructor.
     ;;; User programs must treat the vector v as read-only.
     (defun baz-ref (n)
       (let ((v (load-time-value #(A B C) nil)))
         (values (svref v n) v)))

     ;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
     ;;; even though NIL was specified in the outer situation because T was specified
     ;;; in the inner situation.  User programs must treat the vector v as read-only.
     (defun baz-ref (n)
       (let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))
         (values (svref v n) v)))

See Also:
.........

*note compile-file::, *note compile::, *note eval::, *note Section
3.2.2.2 (Minimal Compilation): MinimalCompilation, *note Section 3.2
(Compilation): Compilation.

Notes:
......

‘load-time-value’ must appear outside of quoted structure in a “for
evaluation” position.  In situations which would appear to call for use
of ‘load-time-value’ within a quoted structure, the backquote reader
macro is probably called for; see *note Section 2.4.6 (Backquote):
Backquote.

Specifying ‘nil’ for READ-ONLY-P is not a way to force an object to
become modifiable if it has already been made read-only.  It is only a
way to say that, for an object that is modifiable, this operation is not
intended to make that object read-only.


File: ansicl,  Node: quote,  Next: compiler-macro-function,  Prev: load-time-value,  Up: Evaluation and Compilation

quote (Special Operator)
========================

Syntax:
.......

 -- Special Form: quote object → object

Arguments and Values:
.....................

OBJECT—an object; not evaluated.

Description:
............

The ‘quote’ special operator just returns OBJECT.

The consequences are undefined if literal objects (including quoted
objects) are destructively modified.

Examples:
.........

      (setq a 1) → 1
      (quote (setq a 3)) → (SETQ A 3)
      a → 1
      'a → A
      ''a → (QUOTE A)
      '''a → (QUOTE (QUOTE A))
      (setq a 43) → 43
      (list a (cons a 3)) → (43 (43 . 3))
      (list (quote a) (quote (cons a 3))) → (A (CONS A 3))
      1 → 1
      '1 → 1
      "foo" → "foo"
      '"foo" → "foo"
      (car '(a b)) → A
      '(car '(a b)) → (CAR (QUOTE (A B)))
      #(car '(a b)) → #(CAR (QUOTE (A B)))
      '#(car '(a b)) → #(CAR (QUOTE (A B)))

See Also:
.........

*note Section 3.1 (Evaluation): Evaluation, *note Section 2.4.3
(Single-Quote): Single-Quote, *note Section 3.2.1 (Compiler
Terminology): Compiler Terminology.

Notes:
......

The textual notation ‘'OBJECT’ is equivalent to ‘(quote OBJECT)’; see
*note Section 3.2.1 (Compiler Terminology): Compiler Terminology.

Some objects, called self-evaluating objects, do not require quotation
by ‘quote’.  However, symbols and lists are used to represent parts of
programs, and so would not be useable as constant data in a program
without ‘quote’.  Since ‘quote’ suppresses the evaluation of these
objects, they become data rather than program.


File: ansicl,  Node: compiler-macro-function,  Next: define-compiler-macro,  Prev: quote,  Up: Evaluation and Compilation

compiler-macro-function (Accessor)
==================================

Syntax:
.......

 -- Function: compiler-macro-function name &optional environment →
          function
(setf (compiler-macro-function name &optional environment) new-function)

Arguments and Values:
.....................

NAME—a function name.

ENVIRONMENT—an environment object.

FUNCTION, NEW-FUNCTION—a compiler macro function, or ‘nil’.

Description:
............

Accesses the compiler macro function named NAME, if any, in the
ENVIRONMENT.

A value of ‘nil’ denotes the absence of a compiler macro function named
NAME.

Exceptional Situations:
.......................

The consequences are undefined if ENVIRONMENT is non-nil in a use of
‘setf’ of ‘compiler-macro-function’.

See Also:
.........

*note define-compiler-macro::, *note Section 3.2.2.1 (Compiler Macros):
CompilerMacros.


File: ansicl,  Node: define-compiler-macro,  Next: defmacro,  Prev: compiler-macro-function,  Up: Evaluation and Compilation

define-compiler-macro (Macro)
=============================

Syntax:
.......

 -- Macro: define-compiler-macro name lambda-list 〚{declaration}* |
          documentation〛 {form}* → name

Arguments and Values:
.....................

NAME—a function name.

LAMBDA-LIST—a macro lambda list.

DECLARATION—a declare expression; not evaluated.

DOCUMENTATION—a string; not evaluated.

FORM—a form.

Description:
............

This is the normal mechanism for defining a compiler macro function.
Its manner of definition is the same as for ‘defmacro’; the only
differences are:

   • The NAME can be a function name naming any function or macro.

   • The expander function is installed as a compiler macro function for
     the NAME, rather than as a macro function.

   • The ‘&whole’ argument is bound to the form argument that is passed
     to the compiler macro function.  The remaining lambda-list
     parameters are specified as if this form contained the function
     name in the car and the actual arguments in the cdr, but if the car
     of the actual form is the symbol ‘funcall’, then the destructuring
     of the arguments is actually performed using its cddr instead.

     DOCUMENTATION is attached as a documentation string to NAME (as
     kind ‘compiler-macro’) and to the compiler macro function.

   • Unlike an ordinary macro, a compiler macro can decline to provide
     an expansion merely by returning a form that is the same as the
     original (which can be obtained by using ‘&whole’).

Examples:
.........

      (defun square (x) (expt x 2)) → SQUARE
      (define-compiler-macro square (&whole form arg)
        (if (atom arg)
            `(expt ,arg 2)
            (case (car arg)
              (square (if (= (length arg) 2)
                          `(expt ,(nth 1 arg) 4)
                          form))
              (expt   (if (= (length arg) 3)
                          (if (numberp (nth 2 arg))
                              `(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))
                              `(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))
                          form))
              (otherwise `(expt ,arg 2))))) → SQUARE
      (square (square 3)) → 81
      (macroexpand '(square x)) → (SQUARE X), false
      (funcall (compiler-macro-function 'square) '(square x) nil)
     → (EXPT X 2)
      (funcall (compiler-macro-function 'square) '(square (square x)) nil)
     → (EXPT X 4)
      (funcall (compiler-macro-function 'square) '(funcall #'square x) nil)
     → (EXPT X 2)

      (defun distance-positional (x1 y1 x2 y2)
        (sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))
     → DISTANCE-POSITIONAL
      (defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))
        (distance-positional x1 y1 x2 y2))
     → DISTANCE
      (define-compiler-macro distance (&whole form
                                       &rest key-value-pairs
                                       &key (x1 0  x1-p)
                                            (y1 0  y1-p)
                                            (x2 x1 x2-p)
                                            (y2 y1 y2-p)
                                       &allow-other-keys
                                       &environment env)
        (flet ((key (n) (nth (* n 2) key-value-pairs))
               (arg (n) (nth (1+ (* n 2)) key-value-pairs))
               (simplep (x)
                 (let ((expanded-x (macroexpand x env)))
                   (or (constantp expanded-x env)
                       (symbolp expanded-x)))))
          (let ((n (/ (length key-value-pairs) 2)))
            (multiple-value-bind (x1s y1s x2s y2s others)
                (loop for (key) on key-value-pairs by #'cddr
                      count (eq key ':x1) into x1s
                      count (eq key ':y1) into y1s
                      count (eq key ':x2) into x2s
                      count (eq key ':y1) into y2s
                      count (not (member key '(:x1 :x2 :y1 :y2)))
                        into others
                      finally (return (values x1s y1s x2s y2s others)))
              (cond ((and (= n 4)
                          (eq (key 0) :x1)
                          (eq (key 1) :y1)
                          (eq (key 2) :x2)
                          (eq (key 3) :y2))
                     `(distance-positional ,x1 ,y1 ,x2 ,y2))
                    ((and (if x1-p (and (= x1s 1) (simplep x1)) t)
                          (if y1-p (and (= y1s 1) (simplep y1)) t)
                          (if x2-p (and (= x2s 1) (simplep x2)) t)
                          (if y2-p (and (= y2s 1) (simplep y2)) t)
                          (zerop others))
                     `(distance-positional ,x1 ,y1 ,x2 ,y2))
                    ((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)
                          (zerop others))
                     (let ((temps (loop repeat n collect (gensym))))
                       `(let ,(loop for i below n
                                    collect (list (nth i temps) (arg i)))
                          (distance
                            ,@(loop for i below n
                                    append (list (key i) (nth i temps)))))))
                    (t form))))))
     → DISTANCE
      (dolist (form
                '((distance :x1 (setq x 7) :x2 (decf x) :y1 (decf x) :y2 (decf x))
                  (distance :x1 (setq x 7) :y1 (decf x) :x2 (decf x) :y2 (decf x))
                  (distance :x1 (setq x 7) :y1 (incf x))
                  (distance :x1 (setq x 7) :y1 (incf x) :x1 (incf x))
                  (distance :x1 a1 :y1 b1 :x2 a2 :y2 b2)
                  (distance :x1 a1 :x2 a2 :y1 b1 :y2 b2)
                  (distance :x1 a1 :y1 b1 :z1 c1 :x2 a2 :y2 b2 :z2 c2)))
        (print (funcall (compiler-macro-function 'distance) form nil)))
     ▷ (LET ((#:G6558 (SETQ X 7))
     ▷       (#:G6559 (DECF X))
     ▷       (#:G6560 (DECF X))
     ▷       (#:G6561 (DECF X)))
     ▷   (DISTANCE :X1 #:G6558 :X2 #:G6559 :Y1 #:G6560 :Y2 #:G6561))
     ▷ (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X))
     ▷ (LET ((#:G6567 (SETQ X 7))
     ▷       (#:G6568 (INCF X)))
     ▷   (DISTANCE :X1 #:G6567 :Y1 #:G6568))
     ▷ (DISTANCE :X1 (SETQ X 7) :Y1 (INCF X) :X1 (INCF X))
     ▷ (DISTANCE-POSITIONAL A1 B1 A2 B2)
     ▷ (DISTANCE-POSITIONAL A1 B1 A2 B2)
     ▷ (DISTANCE :X1 A1 :Y1 B1 :Z1 C1 :X2 A2 :Y2 B2 :Z2 C2)
     → NIL

See Also:
.........

*note compiler-macro-function::, *note defmacro::, *note
documentation::, *note Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations): Syntactic Interaction of
Documentation Strings and Declarations.

Notes:
......

The consequences of writing a compiler macro definition for a function
in the ‘COMMON-LISP’ package are undefined; it is quite possible that in
some implementations such an attempt would override an equivalent or
equally important definition.  In general, it is recommended that a
programmer only write compiler macro definitions for functions he or she
personally maintains–writing a compiler macro definition for a function
maintained elsewhere is normally considered a violation of traditional
rules of modularity and data abstraction.


File: ansicl,  Node: defmacro,  Next: macro-function,  Prev: define-compiler-macro,  Up: Evaluation and Compilation

defmacro (Macro)
================

Syntax:
.......

 -- Macro: defmacro name lambda-list 〚{declaration}* | documentation〛
          {form}* → name

Arguments and Values:
.....................

NAME—a symbol.

LAMBDA-LIST—a macro lambda list.

DECLARATION—a declare expression; not evaluated.

DOCUMENTATION—a string; not evaluated.

FORM—a form.

Description:
............

Defines NAME as a macro by associating a macro function with that NAME
in the global environment.  The macro function is defined in the same
lexical environment in which the ‘defmacro’ form appears.

The parameter variables in LAMBDA-LIST are bound to destructured
portions of the macro call.

The expansion function accepts two arguments, a form and an environment.
The expansion function returns a form.  The body of the expansion
function is specified by FORMS.  FORMS are executed in order.  The value
of the last FORM executed is returned as the expansion of the macro.
The body FORMS of the expansion function (but not the LAMBDA-LIST) are
implicitly enclosed in a block whose name is NAME.

The LAMBDA-LIST conforms to the requirements described in *note Section
3.4.4 (Macro Lambda Lists): Macro Lambda Lists.

DOCUMENTATION is attached as a documentation string to NAME (as kind
‘function’) and to the macro function.

‘defmacro’ can be used to redefine a macro or to replace a function
definition with a macro definition.

Recursive expansion of the form returned must terminate, including the
expansion of other macros which are subforms of other forms returned.

The consequences are undefined if the result of fully macroexpanding a
form contains any circular list structure except in literal objects.

If a ‘defmacro’ form appears as a top level form, the compiler must
store the macro definition at compile time, so that occurrences of the
macro later on in the file can be expanded correctly.  Users must ensure
that the body of the macro can be evaluated at compile time if it is
referenced within the file being compiled.

Examples:
.........

      (defmacro mac1 (a b) "Mac1 multiplies and adds"
                 `(+ ,a (* ,b 3))) → MAC1
      (mac1 4 5) → 19
      (documentation 'mac1 'function) → "Mac1 multiplies and adds"
      (defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x) `'(,a ,b ,c ,d ,x)) → MAC2
      (mac2 6) → (6 T 3 NIL NIL)
      (mac2 6 3 8) → (6 T 3 T (8))
      (defmacro mac3 (&whole r a &optional (b 3) &rest x &key c (d a))
         `'(,r ,a ,b ,c ,d ,x)) → MAC3
      (mac3 1 6 :d 8 :c 9 :d 10) → ((MAC3 1 6 :D 8 :C 9 :D 10) 1 6 9 8 (:D 8 :C 9 :D 10))

The stipulation that an embedded destructuring lambda list is permitted
only where ordinary lambda list syntax would permit a parameter name but
not a list is made to prevent ambiguity.  For example, the following is
not valid:

      (defmacro loser (x &optional (a b &rest c) &rest z)
        ...)

because ordinary lambda list syntax does permit a list following
&optional; the list ‘(a b &rest c)’ would be interpreted as describing
an optional parameter named ‘a’ whose default value is that of the form
‘b’, with a supplied-p parameter named ‘&rest’ (not valid), and an
extraneous symbol ‘c’ in the list (also not valid).  An almost correct
way to express this is

      (defmacro loser (x &optional ((a b &rest c)) &rest z)
        ...)

The extra set of parentheses removes the ambiguity.  However, the
definition is now incorrect because a macro call such as ‘(loser (car
pool))’ would not provide any argument form for the lambda list ‘(a b
&rest c)’, and so the default value against which to match the lambda
list would be ‘nil’ because no explicit default value was specified.
The consequences of this are unspecified since the empty list, ‘nil’,
does not have forms to satisfy the parameters ‘a’ and ‘b’.  The fully
correct definition would be either

      (defmacro loser (x &optional ((a b &rest c) '(nil nil)) &rest z)
        ...)

or

      (defmacro loser (x &optional ((&optional a b &rest c)) &rest z)
        ...)

These differ slightly: the first requires that if the macro call
specifies ‘a’ explicitly then it must also specify ‘b’ explicitly,
whereas the second does not have this requirement.  For example,

      (loser (car pool) ((+ x 1)))

would be a valid call for the second definition but not for the first.

      (defmacro dm1a (&whole x) `',x)
      (macroexpand '(dm1a))  → (QUOTE (DM1A))
      (macroexpand '(dm1a a)) is an error.

      (defmacro dm1b (&whole x a &optional b) `'(,x ,a ,b))
      (macroexpand '(dm1b))  is an error.
      (macroexpand '(dm1b q))  → (QUOTE ((DM1B Q) Q NIL))
      (macroexpand '(dm1b q r)) → (QUOTE ((DM1B Q R) Q R))
      (macroexpand '(dm1b q r s)) is an error.

      (defmacro dm2a (&whole form a b) `'(form ,form a ,a b ,b))
      (macroexpand '(dm2a x y)) → (QUOTE (FORM (DM2A X Y) A X B Y))
      (dm2a x y) → (FORM (DM2A X Y) A X B Y)

      (defmacro dm2b (&whole form a (&whole b (c . d) &optional (e 5))
                      &body f &environment env)
        ``(,',form ,,a ,',b ,',(macroexpand c env) ,',d ,',e ,',f))
      ;Note that because backquote is involved, implementations may differ
      ;slightly in the nature (though not the functionality) of the expansion.
      (macroexpand '(dm2b x1 (((incf x2) x3 x4)) x5 x6))
      → (LIST* '(DM2B X1 (((INCF X2) X3 X4))
                        X5 X6)
                 X1
                 '((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6))),
          T
      (let ((x1 5))
        (macrolet ((segundo (x) `(cadr ,x)))
          (dm2b x1 (((segundo x2) x3 x4)) x5 x6)))
      → ((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)
           5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))

See Also:
.........

*note define-compiler-macro::, *note destructuring-bind::, *note
documentation::, *note macroexpand::, *note *macroexpand-hook*::, *note
macrolet::, *note macro-function::, *note Section 3.1 (Evaluation):
Evaluation, *note Section 3.2 (Compilation): Compilation, *note Section
3.4.11 (Syntactic Interaction of Documentation Strings and
Declarations): Syntactic Interaction of Documentation Strings and
Declarations.


File: ansicl,  Node: macro-function,  Next: macroexpand; macroexpand-1,  Prev: defmacro,  Up: Evaluation and Compilation

macro-function (Accessor)
=========================

Syntax:
.......

 -- Function: macro-function symbol &optional environment → function
(setf (macro-function symbol &optional environment) new-function)

Arguments and Values:
.....................

SYMBOL—a symbol.

ENVIRONMENT—an environment object.

FUNCTION—a macro function or ‘nil’.

NEW-FUNCTION—a macro function.

Description:
............

Determines whether SYMBOL has a function definition as a macro in the
specified ENVIRONMENT.

If so, the macro expansion function, a function of two arguments, is
returned.  If SYMBOL has no function definition in the lexical
environment ENVIRONMENT, or its definition is not a macro,
‘macro-function’ returns ‘nil’.

It is possible for both ‘macro-function’ and ‘special-operator-p’ to
return true of SYMBOL.  The macro definition must be available for use
by programs that understand only the standard Common Lisp special forms.

Examples:
.........

      (defmacro macfun (x) '(macro-function 'macfun)) → MACFUN
      (not (macro-function 'macfun)) → false

      (macrolet ((foo (&environment env)
                    (if (macro-function 'bar env)
                       ''yes
                       ''no)))
         (list (foo)
               (macrolet ((bar () :beep))
                  (foo))))

     → (NO YES)

Affected By:
............

‘(setf macro-function)’, ‘defmacro’, and ‘macrolet’.

Exceptional Situations:
.......................

The consequences are undefined if ENVIRONMENT is non-nil in a use of
‘setf’ of ‘macro-function’.

See Also:
.........

*note defmacro::, *note Section 3.1 (Evaluation): Evaluation.

Notes:
......

‘setf’ can be used with ‘macro-function’ to install a macro as a
symbol’s global function definition:

      (setf (macro-function symbol) fn)

The value installed must be a function that accepts two arguments, the
entire macro call and an environment, and computes the expansion for
that call.  Performing this operation causes SYMBOL to have only that
macro definition as its global function definition; any previous
definition, whether as a macro or as a function, is lost.


File: ansicl,  Node: macroexpand; macroexpand-1,  Next: define-symbol-macro,  Prev: macro-function,  Up: Evaluation and Compilation

macroexpand, macroexpand-1 (Function)
=====================================

Syntax:
.......

 -- Function: macroexpand form &optional env → expansion, expanded-p
 -- Function: macroexpand-1 form &optional env → expansion, expanded-p

Arguments and Values:
.....................

FORM—a form.

ENV—an environment object.  The default is ‘nil’.

EXPANSION—a form.

EXPANDED-P—a generalized boolean.

Description:
............

‘macroexpand’ and ‘macroexpand-1’ expand macros.

If FORM is a macro form, then ‘macroexpand-1’ expands the macro form
call once.

‘macroexpand’ repeatedly expands FORM until it is no longer a macro
form.  In effect, ‘macroexpand’ calls ‘macroexpand-1’ repeatedly until
the secondary value it returns is ‘nil’.

If FORM is a macro form, then the EXPANSION is a macro expansion and
EXPANDED-P is true.  Otherwise, the EXPANSION is the given FORM and
EXPANDED-P is false.

Macro expansion is carried out as follows.  Once ‘macroexpand-1’ has
determined that the FORM is a macro form, it obtains an appropriate
expansion function for the macro or symbol macro.  The value of
‘*macroexpand-hook*’ is coerced to a function and then called as a
function of three arguments: the expansion function, the FORM, and the
ENV.  The value returned from this call is taken to be the expansion of
the FORM.

In addition to macro definitions in the global environment, any local
macro definitions established within ENV by ‘macrolet’ or
‘symbol-macrolet’ are considered.  If only FORM is supplied as an
argument, then the environment is effectively null, and only global
macro definitions as established by ‘defmacro’ are considered.  Macro
definitions are shadowed by local function definitions.

Examples:
.........

      (defmacro alpha (x y) `(beta ,x ,y)) → ALPHA
      (defmacro beta (x y) `(gamma ,x ,y)) → BETA
      (defmacro delta (x y) `(gamma ,x ,y)) → EPSILON
      (defmacro expand (form &environment env)
        (multiple-value-bind (expansion expanded-p)
            (macroexpand form env)
          `(values ',expansion ',expanded-p))) → EXPAND
      (defmacro expand-1 (form &environment env)
        (multiple-value-bind (expansion expanded-p)
            (macroexpand-1 form env)
          `(values ',expansion ',expanded-p))) → EXPAND-1
      
      
     ;; Simple examples involving just the global environment
      (macroexpand-1 '(alpha a b)) → (BETA A B), true
      (expand-1 (alpha a b)) → (BETA A B), true
      (macroexpand '(alpha a b)) → (GAMMA A B), true
      (expand (alpha a b)) → (GAMMA A B), true
      (macroexpand-1 'not-a-macro) → NOT-A-MACRO, false
      (expand-1 not-a-macro) → NOT-A-MACRO, false
      (macroexpand '(not-a-macro a b)) → (NOT-A-MACRO A B), false
      (expand (not-a-macro a b)) → (NOT-A-MACRO A B), false
      
      
     ;; Examples involving lexical environments
      (macrolet ((alpha (x y) `(delta ,x ,y)))
        (macroexpand-1 '(alpha a b))) → (BETA A B), true
      (macrolet ((alpha (x y) `(delta ,x ,y)))
        (expand-1 (alpha a b))) → (DELTA A B), true
      (macrolet ((alpha (x y) `(delta ,x ,y)))
        (macroexpand '(alpha a b))) → (GAMMA A B), true
      (macrolet ((alpha (x y) `(delta ,x ,y)))
        (expand (alpha a b))) → (GAMMA A B), true
      (macrolet ((beta (x y) `(epsilon ,x ,y)))
        (expand (alpha a b))) → (EPSILON A B), true
      (let ((x (list 1 2 3)))
        (symbol-macrolet ((a (first x)))
          (expand a))) → (FIRST X), true
      (let ((x (list 1 2 3)))
        (symbol-macrolet ((a (first x)))
          (macroexpand 'a))) → A, false
      (symbol-macrolet ((b (alpha x y)))
        (expand-1 b)) → (ALPHA X Y), true
      (symbol-macrolet ((b (alpha x y)))
        (expand b)) → (GAMMA X Y), true
      (symbol-macrolet ((b (alpha x y))
                        (a b))
        (expand-1 a)) → B, true
      (symbol-macrolet ((b (alpha x y))
                        (a b))
        (expand a)) → (GAMMA X Y), true
      
      
     ;; Examples of shadowing behavior
      (flet ((beta (x y) (+ x y)))
        (expand (alpha a b))) → (BETA A B), true
      (macrolet ((alpha (x y) `(delta ,x ,y)))
        (flet ((alpha (x y) (+ x y)))
          (expand (alpha a b)))) → (ALPHA A B), false
      (let ((x (list 1 2 3)))
        (symbol-macrolet ((a (first x)))
          (let ((a x))
            (expand a)))) → A, false

Affected By:
............

‘defmacro’, ‘setf’ of ‘macro-function’, ‘macrolet’, ‘symbol-macrolet’

See Also:
.........

*note *macroexpand-hook*::, *note defmacro::, *note setf:: of *note
macro-function::, *note macrolet::, *note symbol-macrolet::, *note
Section 3.1 (Evaluation): Evaluation.

Notes:
......

Neither ‘macroexpand’ nor ‘macroexpand-1’ makes any explicit attempt to
expand macro forms that are either subforms of the FORM or subforms of
the EXPANSION.  Such expansion might occur implicitly, however, due to
the semantics or implementation of the macro function.


File: ansicl,  Node: define-symbol-macro,  Next: symbol-macrolet,  Prev: macroexpand; macroexpand-1,  Up: Evaluation and Compilation

define-symbol-macro (Macro)
===========================

Syntax:
.......

 -- Macro: define-symbol-macro symbol expansion → symbol

Arguments and Values:
.....................

SYMBOL—a symbol.

EXPANSION—a form.

Description:
............

Provides a mechanism for globally affecting the macro expansion of the
indicated SYMBOL.

Globally establishes an expansion function for the symbol macro named by
SYMBOL.  The only guaranteed property of an expansion function for a
symbol macro is that when it is applied to the form and the environment
it returns the correct expansion.  (In particular, it is
implementation-dependent whether the expansion is conceptually stored in
the expansion function, the environment, or both.)

Each global reference to SYMBOL (i.e., not shadowedbinding for a
variable or symbol macro named by the same symbol) is expanded by the
normal macro expansion process; see *note Section 3.1.2.1.1 (Symbols as
Forms): SymbolsAsForms.  The expansion of a symbol macro is subject to
further macro expansion in the same lexical environment as the symbol
macro reference, exactly analogous to normal macros.

The consequences are unspecified if a ‘special’ declaration is made for
SYMBOL while in the scope of this definition (i.e., when it is not
shadowedor symbol macro named by the same symbol).

Any use of ‘setq’ to set the value of the SYMBOL while in the scope of
this definition is treated as if it were a ‘setf’.  ‘psetq’ of SYMBOL is
treated as if it were a ‘psetf’, and ‘multiple-value-setq’ is treated as
if it were a ‘setf’ of ‘values’.

A binding for a symbol macro can be shadowedby ‘let’ or
‘symbol-macrolet’.

Examples:
.........

     (defvar *things* (list 'alpha 'beta 'gamma)) → *THINGS*

     (define-symbol-macro thing1 (first *things*)) → THING1
     (define-symbol-macro thing2 (second *things*)) → THING2
     (define-symbol-macro thing3 (third *things*)) → THING3

     thing1 → ALPHA
     (setq thing1 'ONE) → ONE
     *things* → (ONE BETA GAMMA)
     (multiple-value-setq (thing2 thing3) (values 'two 'three)) → TWO
     thing3 → THREE
     *things* → (ONE TWO THREE)

     (list thing2 (let ((thing2 2)) thing2)) → (TWO 2)

Exceptional Situations:
.......................

If SYMBOL is already defined as a global variable, an error of type
‘program-error’ is signaled.

See Also:
.........

*note symbol-macrolet::, *note macroexpand::


File: ansicl,  Node: symbol-macrolet,  Next: *macroexpand-hook*,  Prev: define-symbol-macro,  Up: Evaluation and Compilation

symbol-macrolet (Special Operator)
==================================

Syntax:
.......

 -- Special Form: symbol-macrolet ({(symbol expansion)}*) {declaration}*
          {form}* → {result}*

Arguments and Values:
.....................

SYMBOL—a symbol.

EXPANSION—a form.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—the values returned by the FORMS.

Description:
............

‘symbol-macrolet’ provides a mechanism for affecting the macro expansion
environment for symbols.

‘symbol-macrolet’ lexically establishes expansion functions for each of
the symbol macros named by SYMBOLS.  The only guaranteed property of an
expansion function for a symbol macro is that when it is applied to the
form and the environment it returns the correct expansion.  (In
particular, it is implementation-dependent whether the expansion is
conceptually stored in the expansion function, the environment, or
both.)

Each reference to SYMBOL as a variable within the lexical scope of
‘symbol-macrolet’ is expanded by the normal macro expansion process; see
*note Section 3.1.2.1.1 (Symbols as Forms): SymbolsAsForms.  The
expansion of a symbol macro is subject to further macro expansion in the
same lexical environment as the symbol macro invocation, exactly
analogous to normal macros.

Exactly the same DECLARATIONS are allowed as for ‘let’ with one
exception: ‘symbol-macrolet’ signals an error if a ‘special’ declaration
names one of the symbols being defined by ‘symbol-macrolet’.

When the FORMS of the ‘symbol-macrolet’ form are expanded, any use of
‘setq’ to set the value of one of the specified variables is treated as
if it were a ‘setf’.  ‘psetq’ of a symbol defined as a symbol macro is
treated as if it were a ‘psetf’, and ‘multiple-value-setq’ is treated as
if it were a ‘setf’ of ‘values’.

The use of ‘symbol-macrolet’ can be shadowed by ‘let’.  In other words,
‘symbol-macrolet’ only substitutes for occurrences of SYMBOL that would
be in the scope of a lexical binding of SYMBOL surrounding the FORMS.

Examples:
.........

     ;;; The following is equivalent to
     ;;;   (list 'foo (let ((x 'bar)) x)),
     ;;; not
     ;;;   (list 'foo (let (('foo 'bar)) 'foo))
      (symbol-macrolet ((x 'foo))
        (list x (let ((x 'bar)) x)))
     → (foo bar)
     not→ (foo foo)

      (symbol-macrolet ((x '(foo x)))
        (list x))
     → ((FOO X))

Exceptional Situations:
.......................

If an attempt is made to bind a symbol that is defined as a global
variable, an error of type ‘program-error’ is signaled.

If DECLARATION contains a ‘special’ declaration that names one of the
symbols being bound by ‘symbol-macrolet’, an error of type
‘program-error’ is signaled.

See Also:
.........

*note with-slots::, *note macroexpand::

Notes:
......

The special form ‘symbol-macrolet’ is the basic mechanism that is used
to implement ‘with-slots’.

If a ‘symbol-macrolet’ form is a top level form, the FORMS are also
processed as top level forms.  See *note Section 3.2.3 (File
Compilation): File Compilation.


File: ansicl,  Node: *macroexpand-hook*,  Next: proclaim,  Prev: symbol-macrolet,  Up: Evaluation and Compilation

*macroexpand-hook* (Variable)
=============================

Value Type:
...........

a designator for a function of three arguments: a macro function, a
macro form, and an environment object.

Initial Value:
..............

a designator for a function that is equivalent to the function
‘funcall’, but that might have additional implementation-dependent
side-effects.

Description:
............

Used as the expansion interface hook by ‘macroexpand-1’ to control the
macro expansion process.  When a macro form is to be expanded, this
function is called with three arguments: the macro function, the macro
form, and the environment in which the macro form is to be expanded.
The environment object has dynamic extent; the consequences are
undefined if the environment object is referred to outside the dynamic
extent of the macro expansion function.

Examples:
.........

      (defun hook (expander form env)
         (format t "Now expanding: ~S~%" form)
         (funcall expander form env)) → HOOK
      (defmacro machook (x y) `(/ (+ ,x ,y) 2)) → MACHOOK
      (macroexpand '(machook 1 2)) → (/ (+ 1 2) 2), true
      (let ((*macroexpand-hook* #'hook)) (macroexpand '(machook 1 2)))
     ▷ Now expanding (MACHOOK 1 2)
     → (/ (+ 1 2) 2), true

See Also:
.........

*note macroexpand::, *note macroexpand-1::, *note funcall::, *note
Section 3.1 (Evaluation): Evaluation.

Notes:
......

The net effect of the chosen initial value is to just invoke the macro
function, giving it the macro form and environment as its two arguments.

Users or user programs can assign this variable to customize or trace
the macro expansion mechanism.  Note, however, that this variable is a
global resource, potentially shared by multiple programs; as such, if
any two programs depend for their correctness on the setting of this
variable, those programs may not be able to run in the same Lisp image.
For this reason, it is frequently best to confine its uses to debugging
situations.

Users who put their own function into ‘*macroexpand-hook*’ should
consider saving the previous value of the hook, and calling that value
from their own.


File: ansicl,  Node: proclaim,  Next: declaim,  Prev: *macroexpand-hook*,  Up: Evaluation and Compilation

proclaim (Function)
===================

Syntax:
.......

 -- Function: proclaim declaration-specifier → implementation-dependent

Arguments and Values:
.....................

DECLARATION-SPECIFIER—a declaration specifier.

Description:
............

Establishes the declaration specified by DECLARATION-SPECIFIER in the
global environment.

Such a declaration, sometimes called a global declaration or a
proclamation, is always in force unless locally shadowed.

Names of variables and functions within DECLARATION-SPECIFIER refer to
dynamic variables and global function definitions, respectively.

The next figure shows a list of DECLARATION IDENTIFIERS that can be used
with ‘proclaim’.

declaration   inline      optimize   type
ftype         notinline   special

Figure 3.22: Global Declaration Specifiers

An implementation is free to support other (implementation-defined)
declaration identifiers as well.

Examples:
.........

      (defun declare-variable-types-globally (type vars)
        (proclaim `(type ,type ,@vars))
        type)

      ;; Once this form is executed, the dynamic variable *TOLERANCE*
      ;; must always contain a float.
      (declare-variable-types-globally 'float '(*tolerance*))
     → FLOAT

See Also:
.........

*note declaim::, *note declare::, *note Section 3.2 (Compilation):
Compilation.

Notes:
......

Although the execution of a ‘proclaim’ form has effects that might
affect compilation, the compiler does not make any attempt to recognize
and specially process ‘proclaim’ forms.  A proclamation such as the
following, even if a top level form, does not have any effect until it
is executed:

     (proclaim '(special *x*))

If compile time side effects are desired, ‘eval-when’ may be useful.
For example:

      (eval-when (:execute :compile-toplevel :load-toplevel)
        (proclaim '(special *x*)))

In most such cases, however, it is preferrable to use ‘declaim’ for this
purpose.

Since ‘proclaim’ forms are ordinary function forms, macro forms can
expand into them.


File: ansicl,  Node: declaim,  Next: declare,  Prev: proclaim,  Up: Evaluation and Compilation

declaim (Macro)
===============

Syntax:
.......

 -- Macro: declaim {declaration-specifier}* → implementation-dependent

Arguments and Values:
.....................

DECLARATION-SPECIFIER—a declaration specifier; not evaluated.

Description:
............

Establishes the declarations specified by the DECLARATION-SPECIFIERS.

If a use of this macro appears as a top level form in a file being
processed by the file compiler, the proclamations are also made at
compile-time.  As with other defining macros, it is unspecified whether
or not the compile-time side-effects of a ‘declaim’ persist after the
file has been compiled.

Examples:
.........

See Also:
.........

*note declare::, *note proclaim::


File: ansicl,  Node: declare,  Next: ignore; ignorable,  Prev: declaim,  Up: Evaluation and Compilation

declare (Symbol)
================

Syntax:
.......

 -- Special Form: declare {declaration-specifier}*

Arguments:
..........

DECLARATION-SPECIFIER—a declaration specifier; not evaluated.

Description:
............

A declare expression, sometimes called a declaration, can occur only at
the beginning of the bodies of certain forms; that is, it may be
preceded only by other declare expressions, or by a documentation string
if the context permits.

A declare expression can occur in a lambda expression or in any of the
forms listed in the next figure.

defgeneric                  do-external-symbols    prog
define-compiler-macro       do-symbols             prog*
define-method-combination   dolist                 restart-case
define-setf-expander        dotimes                symbol-macrolet
defmacro                    flet                   with-accessors
defmethod                   handler-case           with-hash-table-iterator
defsetf                     labels                 with-input-from-string
deftype                     let                    with-open-file
defun                       let*                   with-open-stream
destructuring-bind          locally                with-output-to-string
do                          macrolet               with-package-iterator
do*                         multiple-value-bind    with-slots
do-all-symbols              pprint-logical-block

Figure 3.23: Standardized Forms In Which Declarations Can Occur

A declare expression can only occur where specified by the syntax of
these forms.  The consequences of attempting to evaluate a declare
expression are undefined.  In situations where such expressions can
appear, explicit checks are made for their presence and they are never
actually evaluated; it is for this reason that they are called “declare
expressions” rather than “declare forms.”

Macro forms cannot expand into declarations; declare expressions must
appear as actual subexpressions of the form to which they refer.

The next figure shows a list of declaration identifiers that can be used
with declare.

dynamic-extent   ignore      optimize
ftype            inline      special
ignorable        notinline   type

Figure 3.24: Local Declaration Specifiers

An implementation is free to support other (implementation-defined)
declaration identifiers as well.

Examples:
.........

      (defun nonsense (k x z)
        (foo z x)                     ;First call to foo
        (let ((j (foo k x))           ;Second call to foo
              (x (* k k)))
          (declare (inline foo) (special x z))
          (foo x j z)))               ;Third call to foo

In this example, the ‘inline’ declaration applies only to the third call
to ‘foo’, but not to the first or second ones.  The ‘special’
declaration of ‘x’ causes ‘let’ to make a dynamic binding for ‘x’, and
causes the reference to ‘x’ in the body of ‘let’ to be a dynamic
reference.  The reference to ‘x’ in the second call to ‘foo’ is a local
reference to the second parameter of ‘nonsense’.  The reference to ‘x’
in the first call to ‘foo’ is a local reference, not a ‘special’ one.
The ‘special’ declaration of ‘z’ causes the reference to ‘z’ in the
third call to ‘foo’ to be a dynamic reference; it does not refer to the
parameter to ‘nonsense’ named ‘z’, because that parameter binding has
not been declared to be ‘special’.  (The ‘special’ declaration of ‘z’
does not appear in the body of ‘defun’, but in an inner form, and
therefore does not affect the binding of the parameter.)

Exceptional Situations:
.......................

The consequences of trying to use a declare expression as a form to be
evaluated are undefined.

See Also:
.........

*note proclaim::, *note Section 4.2.3 (Type Specifiers): Type
Specifiers, *note declaration::, *note dynamic-extent::, *note ftype::,
*note ignorable::, *note ignore::, *note inline::, *note notinline::,
*note optimize::, *note type::


File: ansicl,  Node: ignore; ignorable,  Next: dynamic-extent,  Prev: declare,  Up: Evaluation and Compilation

ignore, ignorable (Declaration)
===============================

Syntax:
.......

‘(ignore {VAR | (function FN)}*)’

‘(ignorable {VAR | (function FN)}*)’

Arguments:
..........

VAR—a variable name.

FN—a function name.

Valid Context:
..............

declaration

Binding Types Affected:
.......................

variable, function

Description:
............

The ‘ignore’ and ‘ignorable’ declarations refer to for-value references
to variable bindings for the VARS and to function bindings for the FNS.

An ‘ignore’ declaration specifies that for-value references to the
indicated bindings will not occur within the scope of the declaration.
Within the scope of such a declaration, it is desirable for a compiler
to issue a warning about the presence of either a for-value reference to
any VAR or FN, or a ‘special’ declaration for any VAR.

An ‘ignorable’ declaration specifies that for-value references to the
indicated bindings might or might not occur within the scope of the
declaration.  Within the scope of such a declaration, it is not
desirable for a compiler to issue a warning about the presence or
absence of either a for-value reference to any VAR or FN, or a ‘special’
declaration for any VAR.

When not within the scope of a ‘ignore’ or ‘ignorable’ declaration, it
is desirable for a compiler to issue a warning about any VAR for which
there is neither a for-value reference nor a ‘special’ declaration, or
about any FN for which there is no for-value reference.

Any warning about a “used” or “unused” binding must be of type
‘style-warning’, and may not affect program semantics.

The stream variables established by ‘with-open-file’,
‘with-open-stream’, ‘with-input-from-string’, and
‘with-output-to-string’, and all iteration variables are, by definition,
always “used”.  Using ‘(declare (ignore V))’, for such a variable V has
unspecified consequences.

See Also:
.........

*note declare::


File: ansicl,  Node: dynamic-extent,  Next: type,  Prev: ignore; ignorable,  Up: Evaluation and Compilation

dynamic-extent (Declaration)
============================

Syntax:
.......

‘(dynamic-extent 〚{var}* | (function FN)*〛)’

Arguments:
..........

VAR—a variable name.

FN—a function name.

Valid Context:
..............

declaration

Binding Types Affected:
.......................

variable, function

Description:
............

In some containing form, F, this declaration asserts for each VARAND FOR
EACH VALUE VAND FOR EACH OBJECT XIS AN OTHERWISE INACCESSIBLE PART OF
VVBECOMES THE VALUE OF VARTHAT JUST AFTER THE EXECUTION OF F TERMINATES,
X(IF F ESTABLISHED A BINDING FOR VAROR STILL AN OTHERWISE INACCESSIBLE
PART OF THE CURRENT VALUE OF VARFOR VARTHE SAME RELATION HOLDS FOR EACH
FNEXCEPT THAT THE BINDINGS ARE IN THE FUNCTION NAMESPACE.
The compiler is permitted to use this information in any way that is
appropriate to the implementation and that does not conflict with the
semantics of Common Lisp.

‘dynamic-extent’ declarations can be free declarations or bound
declarations.

The VARS and FNS named in a ‘dynamic-extent’ declaration must not refer
to symbol macro or macro bindings.

Examples:
.........

Since stack allocation of the initial value entails knowing at the
object’s creation time that the object can be stack-allocated, it is not
generally useful to make a ‘dynamic-extent’ declaration for variables
which have no lexically apparent initial value.  For example, it is
probably useful to write:

      (defun f ()
        (let ((x (list 1 2 3)))
          (declare (dynamic-extent x))
              ...))

This would permit those compilers that wish to do so to stack allocate
the list held by the local variable ‘x’.  It is permissible, but in
practice probably not as useful, to write:

      (defun g (x) (declare (dynamic-extent x)) ...)
      (defun f () (g (list 1 2 3)))

Most compilers would probably not stack allocate the argument to ‘g’ in
‘f’ because it would be a modularity violation for the compiler to
assume facts about ‘g’ from within ‘f’.  Only an implementation that was
willing to be responsible for recompiling ‘f’ if the definition of ‘g’
changed incompatibly could legitimately stack allocate the list argument
to ‘g’ in ‘f’.

Here is another example:

      (declaim (inline g))
      (defun g (x) (declare (dynamic-extent x)) ...)
      (defun f () (g (list 1 2 3)))

      (defun f ()
        (flet ((g (x) (declare (dynamic-extent x)) ...))
          (g (list 1 2 3))))


In the previous example, some compilers might determine that
optimization was possible and others might not.

A variant of this is the so-called “stack allocated rest list” that can
be achieved (in implementations supporting the optimization) by:

      (defun f (&rest x)
        (declare (dynamic-extent x))
        ...)

Note that although the initial value of ‘x’ is not explicit, the ‘f’
function is responsible for assembling the list ‘x’ from the passed
arguments, so the ‘f’ function can be optimized by the compiler to
construct a stack-allocated list instead of a heap-allocated list in
implementations that support such.

In the following example,

      (let ((x (list 'a1 'b1 'c1))
            (y (cons 'a2 (cons 'b2 (cons 'c2 nil)))))
        (declare (dynamic-extent x y))
        ...)

The otherwise inaccessible parts of ‘x’ are three conses, and the
otherwise inaccessible parts of ‘y’ are three other conses.  None of the
symbols ‘a1’, ‘b1’, ‘c1’, ‘a2’, ‘b2’, ‘c2’, or ‘nil’ is an otherwise
inaccessible part of ‘x’ or ‘y’ because each is interned and hence
accessible by the package (or packages) in which it is interned.
However, if a freshly allocated uninterned symbol had been used, it
would have been an otherwise inaccessible part of the list which
contained it.

     ;; In this example, the implementation is permitted to stack allocate
     ;; the list that is bound to X.
      (let ((x (list 1 2 3)))
        (declare (dynamic-extent x))
        (print x)
        :done)
     ▷ (1 2 3)
     → :DONE

     ;; In this example, the list to be bound to L can be stack-allocated.
      (defun zap (x y z)
        (do ((l (list x y z) (cdr l)))
            ((null l))
          (declare (dynamic-extent l))
          (prin1 (car l)))) → ZAP
      (zap 1 2 3)
     ▷ 123
     → NIL

     ;; Some implementations might open-code LIST-ALL-PACKAGES in a way
     ;; that permits using stack allocation of the list to be bound to L.
      (do ((l (list-all-packages) (cdr l)))
          ((null l))
        (declare (dynamic-extent l))
        (let ((name (package-name (car l))))
          (when (string-search "COMMON-LISP" name) (print name))))
     ▷ "COMMON-LISP"
     ▷ "COMMON-LISP-USER"
     → NIL

     ;; Some implementations might have the ability to stack allocate
     ;; rest lists.  A declaration such as the following should be a cue
     ;; to such implementations that stack-allocation of the rest list
     ;; would be desirable.
      (defun add (&rest x)
        (declare (dynamic-extent x))
        (apply #'+ x)) → ADD
      (add 1 2 3) → 6

      (defun zap (n m)
        ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).
        ;; It may be slow, but with a good compiler at least it
        ;; doesn't waste much heap storage.  :-}
        (let ((a (make-array n)))
          (declare (dynamic-extent a))
          (dotimes (i n)
            (declare (dynamic-extent i))
            (setf (aref a i) (random (+ i 1))))
          (aref a m))) → ZAP
      (< (zap 5 3) 3) → true

The following are in error, since the value of ‘x’ is used outside of
its extent:

      (length (list (let ((x (list 1 2 3)))  ; Invalid
                     (declare (dynamic-extent x))
                     x)))

      (progn (let ((x (list 1 2 3)))  ; Invalid
               (declare (dynamic-extent x))
               x)
             nil)

See Also:
.........

*note declare::

Notes:
......

The most common optimization is to stack allocate the initial value of
the objects named by the VARS.

It is permissible for an implementation to simply ignore this
declaration.


File: ansicl,  Node: type,  Next: inline; notinline,  Prev: dynamic-extent,  Up: Evaluation and Compilation

type (Declaration)
==================

Syntax:
.......

‘(type TYPESPEC {var}*)’

‘(TYPESPEC {var}*)’

Arguments:
..........

TYPESPEC—a type specifier.

VAR—a variable name.

Valid Context:
..............

declaration or proclamation

Binding Types Affected:
.......................

variable

Description:
............

Affects only variable bindings and specifies that the VARS take on
values only of the specified TYPESPEC.  In particular, values assigned
to the variables by ‘setq’, as well as the initial values of the VARS
must be of the specified TYPESPEC.  ‘type’ declarations never apply to
function bindings (see ‘ftype’).

A type declaration of a symbol defined by ‘symbol-macrolet’ is
equivalent to wrapping a ‘the’ expression around the expansion of that
symbol, although the symbol’s macro expansion is not actually affected.

The meaning of a type declaration is equivalent to changing each
reference to a variable (VAR) within the scope of the declaration to
‘(the TYPESPEC VAR)’, changing each expression assigned to the variable
(NEW-VALUE) within the scope of the declaration to ‘(the TYPESPEC
NEW-VALUE)’, and executing ‘(the TYPESPEC VAR)’ at the moment the scope
of the declaration is entered.

A type declaration is valid in all declarations.  The interpretation of
a type declaration is as follows:

  1. During the execution of any reference to the declared variable
     within the scope of the declaration, the consequences are undefined
     if the value of the declared variable is not of the declared type.

  2. During the execution of any ‘setq’ of the declared variable within
     the scope of the declaration, the consequences are undefined if the
     newly assigned value of the declared variable is not of the
     declared type.

  3. At the moment the scope of the declaration is entered, the
     consequences are undefined if the value of the declared variable is
     not of the declared type.

A type declaration affects only variable references within its scope.

If nested type declarations refer to the same variable, then the value
of the variable must be a member of the intersection of the declared
types.

If there is a local ‘type’ declaration for a dynamic variable, and there
is also a global ‘type’ proclamation for that same variable, then the
value of the variable within the scope of the local declaration must be
a member of the intersection of the two declared types.

‘type’ declarations can be free declarations or bound declarations.

A symbol cannot be both the name of a type and the name of a
declaration.  Defining a symbol as the name of a class, structure,
condition, or type, when the symbol has been declared as a declaration
name, or vice versa, signals an error.

Within the lexical scope of an ‘array’ type declaration, all references
to array elements are assumed to satisfy the expressed array element
type (as opposed to the upgraded array element type).  A compiler can
treat the code within the scope of the ‘array’ type declaration as if
each access of an array element were surrounded by an appropriate ‘the’
form.

Examples:
.........

      (defun f (x y)
        (declare (type fixnum x y))
        (let ((z (+ x y)))
          (declare (type fixnum z))
          z)) → F
      (f 1 2) → 3
      ;; The previous definition of F is equivalent to
      (defun f (x y)
        ;; This declaration is a shorthand form of the TYPE declaration
        (declare (fixnum x y))
        ;; To declare the type of a return value, it's not necessary to
        ;; create a named variable.  A THE special form can be used instead.
        (the fixnum (+ x y))) → F
      (f 1 2) → 3

      (defvar *one-array* (make-array 10 :element-type '(signed-byte 5)))
      (defvar *another-array* (make-array 10 :element-type '(signed-byte 8)))

      (defun frob (an-array)
        (declare (type (array (signed-byte 5) 1) an-array))
        (setf (aref an-array 1) 31)
        (setf (aref an-array 2) 127)
        (setf (aref an-array 3) (* 2 (aref an-array 3)))
        (let ((foo 0))
          (declare (type (signed-byte 5) foo))
          (setf foo (aref an-array 0))))

      (frob *one-array*)
      (frob *another-array*)

 

 

The above definition of ‘frob’ is equivalent to:

      (defun frob (an-array)
        (setf (the (signed-byte 5) (aref an-array 1)) 31)
        (setf (the (signed-byte 5) (aref an-array 2)) 127)
        (setf (the (signed-byte 5) (aref an-array 3))
              (* 2 (the (signed-byte 5) (aref an-array 3))))
        (let ((foo 0))
          (declare (type (signed-byte 5) foo))
          (setf foo (the (signed-byte 5) (aref an-array 0)))))

Given an implementation in which fixnums are 29 bits but ‘fixnum’ arrays
are upgraded to signed 32-bit arrays, the following could be compiled
with all fixnum arithmetic:

      (defun bump-counters (counters)
        (declare (type (array fixnum *) bump-counters))
        (dotimes (i (length counters))
          (incf (aref counters i))))

See Also:
.........

*note declare::, *note declaim::, *note proclaim::

Notes:
......

‘(TYPESPEC {var}*)’ is an abbreviation for ‘(type TYPESPEC {var}*)’.

A ‘type’ declaration for the arguments to a function does not
necessarily imply anything about the type of the result.  The following
function is not permitted to be compiled using implementation-dependent
fixnum-only arithmetic:

      (defun f (x y) (declare (fixnum x y)) (+ x y))

To see why, consider ‘(f most-positive-fixnum 1)’.  Common Lisp defines
that ‘F’ must return a bignum here, rather than signal an error or
produce a mathematically incorrect result.  If you have special
knowledge such “fixnum overflow” cases will not come up, you can declare
the result value to be in the fixnum range, enabling some compilers to
use more efficient arithmetic:

      (defun f (x y)
        (declare (fixnum x y))
        (the fixnum (+ x y)))

Note, however, that in the three-argument case, because of the
possibility of an implicit intermediate value growing too large, the
following will not cause implementation-dependent fixnum-only arithmetic
to be used:

      (defun f (x y)
        (declare (fixnum x y z))
        (the fixnum (+ x y z)))

To see why, consider ‘(f most-positive-fixnum 1 -1).’ Although the
arguments and the result are all fixnums, an intermediate value is not a
fixnum.  If it is important that implementation-dependent fixnum-only
arithmetic be selected in implementations that provide it, consider
writing something like this instead:

      (defun f (x y)
        (declare (fixnum x y z))
        (the fixnum (+ (the fixnum (+ x y)) z)))


File: ansicl,  Node: inline; notinline,  Next: ftype,  Prev: type,  Up: Evaluation and Compilation

inline, notinline (Declaration)
===============================

Syntax:
.......

‘(inline {function-name}*)’

‘(notinline {function-name}*)’

Arguments:
..........

FUNCTION-NAME—a function name.

Valid Context:
..............

declaration or proclamation

Binding Types Affected:
.......................

function

Description:
............

‘inline’ specifies that it is desirable for the compiler to produce
inline calls to the functions named by FUNCTION-NAMES; that is, the code
for a specified FUNCTION-NAME should be integrated into the calling
routine, appearing “in line” in place of a procedure call.  A compiler
is free to ignore this declaration.  ‘inline’ declarations never apply
to variable bindings.

If one of the functions mentioned has a lexically apparent local
definition (as made by ‘flet’ or ‘labels’), then the declaration applies
to that local definition and not to the global function definition.

While no conforming implementation is required to perform inline
expansion of user-defined functions, those implementations that do
attempt to recognize the following paradigm:

To define a function ‘f’ that is not ‘inline’ by default but for which
‘(declare (inline f))’ will make F be locally inlined, the proper
definition sequence is:

      (declaim (inline f))
      (defun f ...)
      (declaim (notinline f))

The ‘inline’ proclamation preceding the ‘defun’ form ensures that the
compiler has the opportunity save the information necessary for inline
expansion, and the ‘notinline’ proclamation following the ‘defun’ form
prevents ‘f’ from being expanded inline everywhere.

‘notinline’ specifies that it is undesirable to compile the functions
named by FUNCTION-NAMES in-line.  A compiler is not free to ignore this
declaration; calls to the specified functions must be implemented as
out-of-line subroutine calls.

If one of the functions mentioned has a lexically apparent local
definition (as made by ‘flet’ or ‘labels’), then the declaration applies
to that local definition and not to the global function definition.

In the presence of a compiler macro definition for FUNCTION-NAME, a
‘notinline’ declaration prevents that compiler macro from being used.
An ‘inline’ declaration may be used to encourage use of compiler macro
definitions.  ‘inline’ and ‘notinline’ declarations otherwise have no
effect when the lexically visible definition of FUNCTION-NAME is a macro
definition.

‘inline’ and ‘notinline’ declarations can be free declarations or bound
declarations.  ‘inline’ and ‘notinline’ declarations of functions that
appear before the body of a ‘flet’ or ‘labels’ form that defines that
function are bound declarations.  Such declarations in other contexts
are free declarations.

Examples:
.........

      ;; The globally defined function DISPATCH should be open-coded,
      ;; if the implementation supports inlining, unless a NOTINLINE
      ;; declaration overrides this effect.
      (declaim (inline dispatch))
      (defun dispatch (x) (funcall (get (car x) 'dispatch) x))
      ;; Here is an example where inlining would be encouraged.
      (defun top-level-1 () (dispatch (read-command)))
      ;; Here is an example where inlining would be prohibited.
      (defun top-level-2 ()
        (declare (notinline dispatch))
        (dispatch (read-command)))
      ;; Here is an example where inlining would be prohibited.
      (declaim (notinline dispatch))
      (defun top-level-3 () (dispatch (read-command)))
      ;; Here is an example where inlining would be encouraged.
      (defun top-level-4 ()
        (declare (inline dispatch))
        (dispatch (read-command)))

See Also:
.........

*note declare::, *note declaim::, *note proclaim::


File: ansicl,  Node: ftype,  Next: declaration,  Prev: inline; notinline,  Up: Evaluation and Compilation

ftype (Declaration)
===================

Syntax:
.......

‘(ftype TYPE {function-name}*)’

Arguments:
..........

FUNCTION-NAME—a function name.

TYPE—a type specifier.

Valid Context:
..............

declaration or proclamation

Binding Types Affected:
.......................

function

Description:
............

Specifies that the functions named by FUNCTION-NAMES are of the
functional type TYPE.  For example:

      (declare (ftype (function (integer list) t) ith)
               (ftype (function (number) float) sine cosine))

If one of the functions mentioned has a lexically apparent local
definition (as made by ‘flet’ or ‘labels’), then the declaration applies
to that local definition and not to the global function definition.
‘ftype’ declarations never apply to variable bindings (see ‘type’).

The lexically apparent bindings of FUNCTION-NAMES must not be macro
definitions.  (This is because ‘ftype’ declares the functional
definition of each function name to be of a particular subtype of
‘function’, and macros do not denote functions.)

‘ftype’ declarations can be free declarations or bound declarations.
‘ftype’ declarations of functions that appear before the body of a
‘flet’ or ‘labels’ form that defines that function are bound
declarations.  Such declarations in other contexts are free
declarations.

See Also:
.........

*note declare::, *note declaim::, *note proclaim::


File: ansicl,  Node: declaration,  Next: optimize,  Prev: ftype,  Up: Evaluation and Compilation

declaration (Declaration)
=========================

Syntax:
.......

‘(declaration {name}*)’

Arguments:
..........

NAME—a symbol.

Valid Context:
..............

proclamation only

Description:
............

Advises the compiler that each NAME is a valid but potentially
non-standard declaration name.  The purpose of this is to tell one
compiler not to issue warnings for declarations meant for another
compiler or other program processor.

Examples:
.........

      (declaim (declaration author target-language target-machine))
      (declaim (target-language ada))
      (declaim (target-machine IBM-650))
      (defun strangep (x)
        (declare (author "Harry Tweeker"))
        (member x '(strange weird odd peculiar)))

See Also:
.........

*note declaim::, *note proclaim::


File: ansicl,  Node: optimize,  Next: special,  Prev: declaration,  Up: Evaluation and Compilation

optimize (Declaration)
======================

Syntax:
.......

‘(optimize {QUALITY | (QUALITY VALUE)}*)’

Arguments:
..........

QUALITY—an optimize quality.

VALUE—one of the integers ‘0’, ‘1’, ‘2’, or ‘3’.

Valid Context:
..............

declaration or proclamation

Description:
............

Advises the compiler that each QUALITY should be given attention
according to the specified corresponding VALUE.  Each QUALITY must be a
symbol naming an optimize quality; the names and meanings of the
standard OPTIMIZE QUALITIES are shown in the next figure.

Name                  Meaning
----------------------------------------------------------
‘compilation-speed’   speed of the compilation process
‘debug’               ease of debugging
‘safety’              run-time error checking
‘space’               both code size and run-time space
‘speed’               speed of the object code

Figure 3.25: Optimize qualities

There may be other, implementation-defined optimize qualities.

A VALUE ‘0’ means that the corresponding QUALITY is totally unimportant,
and ‘3’ that the QUALITY is extremely important; ‘1’ and ‘2’ are
intermediate values, with ‘1’ the neutral value.  ‘(QUALITY 3)’ can be
abbreviated to QUALITY.

Note that code which has the optimization ‘(safety 3)’, or just
‘safety’, is called safe code.

The consequences are unspecified if a QUALITY appears more than once
with different VALUES.

Examples:
.........

      (defun often-used-subroutine (x y)
        (declare (optimize (safety 2)))
        (error-check x y)
        (hairy-setup x)
        (do ((i 0 (+ i 1))
             (z x (cdr z)))
            ((null z))
          ;; This inner loop really needs to burn.
          (declare (optimize speed))
          (declare (fixnum i))
          ))

See Also:
.........

*note declare::, *note declaim::, *note proclaim::, *note Section 3.3.4
(Declaration Scope): Declaration Scope.

Notes:
......

An ‘optimize’ declaration never applies to either a variable or a
function binding.  An ‘optimize’ declaration can only be a free
declaration.  For more information, see *note Section 3.3.4 (Declaration
Scope): Declaration Scope.


File: ansicl,  Node: special,  Next: locally,  Prev: optimize,  Up: Evaluation and Compilation

special (Declaration)
=====================

Syntax:
.......

‘(special {var}*)’

Arguments:
..........

VAR—a symbol.

Valid Context:
..............

declaration or proclamation

Binding Types Affected:
.......................

variable

Description:
............

Specifies that all of the VARS named are dynamic.  This specifier
affects variable bindings and affects references.  All variable bindings
affected are made to be dynamic bindings, and affected variable
references refer to the current dynamic binding.  For example:

      (defun hack (thing *mod*)    ;The binding of the parameter
        (declare (special *mod*))  ; *mod* is visible to hack1,
        (hack1 (car thing)))       ; but not that of thing.
      (defun hack1 (arg)
        (declare (special *mod*))  ;Declare references to *mod*
                                   ;within hack1 to be special.
        (if (atom arg) *mod*
            (cons (hack1 (car arg)) (hack1 (cdr arg)))))

A ‘special’ declaration does not affect inner bindings of a VAR; the
inner bindings implicitly shadow a ‘special’ declaration and must be
explicitly re-declared to be ‘special’.  ‘special’ declarations never
apply to function bindings.

‘special’ declarations can be either bound declarations, affecting both
a binding and references, or free declarations, affecting only
references, depending on whether the declaration is attached to a
variable binding.

When used in a proclamation, a ‘special’ declaration specifier applies
to all bindings as well as to all references of the mentioned variables.
For example, after

      (declaim (special x))

then in a function definition such as

      (defun example (x) ...)

the parameter ‘x’ is bound as a dynamic variable rather than as a
lexical variable.

Examples:
.........

     (defun declare-eg (y)                 ;this y is special
      (declare (special y))
      (let ((y t))                         ;this y is lexical
           (list y
                 (locally (declare (special y)) y)))) ;this y refers to the
                                                      ;special binding of y
     → DECLARE-EG
      (declare-eg nil) → (T NIL)

     (setf (symbol-value 'x) 6)
     (defun foo (x)                         ;a lexical binding of x
       (print x)
       (let ((x (1+ x)))                    ;a special binding of x
         (declare (special x))              ;and a lexical reference
         (bar))
       (1+ x))
     (defun bar ()
       (print (locally (declare (special x))
                x)))
     (foo 10)
     ▷ 10
     ▷ 11
     → 11

     (setf (symbol-value 'x) 6)
     (defun bar (x y)            ;[1] 1st occurrence of x
       (let ((old-x x)           ;[2] 2nd occurrence of x -- same as 1st occurrence
             (x y))              ;[3] 3rd occurrence of x
         (declare (special x))
         (list old-x x)))
     (bar 'first 'second) → (FIRST SECOND)

      (defun few (x &optional (y *foo*))
        (declare (special *foo*))
        ...)

The reference to ‘*foo*’ in the first line of this example is not
‘special’ even though there is a ‘special’ declaration in the second
line.

      (declaim (special prosp)) → implementation-dependent
      (setq prosp 1 reg 1) → 1
      (let ((prosp 2) (reg 2))         ;the binding of prosp is special
         (set 'prosp 3) (set 'reg 3)   ;due to the preceding proclamation,
         (list prosp reg))             ;whereas the variable reg is lexical
     → (3 2)
      (list prosp reg) → (1 3)

      (declaim (special x))          ;x is always special.
      (defun example (x y)
        (declare (special y))
        (let ((y 3) (x (* x 2)))
          (print (+ y (locally (declare (special y)) y)))
          (let ((y 4)) (declare (special y)) (foo x)))) → EXAMPLE

In the contorted code above, the outermost and innermost bindings of ‘y’
are dynamic, but the middle binding is lexical.  The two arguments to
‘+’ are different, one being the value, which is ‘3’, of the lexical
variable ‘y’, and the other being the value of the dynamic variable
named ‘y’ (a binding of which happens, coincidentally, to lexically
surround it at an outer level).  All the bindings of ‘x’ and references
to ‘x’ are dynamic, however, because of the proclamation that ‘x’ is
always ‘special’.

See Also:
.........

*note defparameter::, *note defvar::


File: ansicl,  Node: locally,  Next: the,  Prev: special,  Up: Evaluation and Compilation

locally (Special Operator)
==========================

Syntax:
.......

 -- Special Form: locally {declaration}* {form}* → {result}*

Arguments and Values:
.....................

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—the values of the FORMS.

Description:
............

Sequentially evaluates a body of FORMS in a lexical environment where
the given DECLARATIONS have effect.

Examples:
.........

      (defun sample-function (y)  ;this y is regarded as special
        (declare (special y))
        (let ((y t))              ;this y is regarded as lexical
          (list y
                (locally (declare (special y))
                  ;; this next y is regarded as special
                  y))))
     → SAMPLE-FUNCTION
      (sample-function nil) → (T NIL)
      (setq x '(1 2 3) y '(4 . 5)) → (4 . 5)

     ;;; The following declarations are not notably useful in specific.
     ;;; They just offer a sample of valid declaration syntax using LOCALLY.
      (locally (declare (inline floor) (notinline car cdr))
               (declare (optimize space))
         (floor (car x) (cdr y))) → 0, 1

     ;;; This example shows a definition of a function that has a particular set
     ;;; of OPTIMIZE settings made locally to that definition.
      (locally (declare (optimize (safety 3) (space 3) (speed 0)))
        (defun frob (w x y &optional (z (foo x y)))
          (mumble x y z w)))
     → FROB

     ;;; This is like the previous example, except that the optimize settings
     ;;; remain in effect for subsequent definitions in the same compilation unit.
      (declaim (optimize (safety 3) (space 3) (speed 0)))
      (defun frob (w x y &optional (z (foo x y)))
        (mumble x y z w))
     → FROB

See Also:
.........

*note declare::

Notes:
......

The ‘special’ declaration may be used with ‘locally’ to affect
references to, rather than bindings of, variables.

If a ‘locally’ form is a top level form, the body FORMS are also
processed as top level forms.  See *note Section 3.2.3 (File
Compilation): File Compilation.


File: ansicl,  Node: the,  Next: special-operator-p,  Prev: locally,  Up: Evaluation and Compilation

the (Special Operator)
======================

Syntax:
.......

 -- Special Form: the value-type form → {result}*

Arguments and Values:
.....................

VALUE-TYPE—a type specifier; not evaluated.

FORM—a form; evaluated.

RESULTS—the values resulting from the evaluation of FORM.  These values
must conform to the type supplied by VALUE-TYPE; see below.

Description:
............

‘the’ specifies that the values[1a] returned by FORM are of the types
specified by VALUE-TYPE.  The consequences are undefined if any RESULT
is not of the declared type.

It is permissible for FORM to yield a different number of values than
are specified by VALUE-TYPE, provided that the values for which TYPES
are declared are indeed of those types.  Missing values are treated as
‘nil’ for the purposes of checking their types.

Regardless of number of values declared by VALUE-TYPE, the number of
values returned by the ‘the’ special form is the same as the number of
values returned by FORM.

Examples:
.........

      (the symbol (car (list (gensym)))) → #:G9876
      (the fixnum (+ 5 7)) → 12
      (the (values) (truncate 3.2 2)) → 1, 1.2
      (the integer (truncate 3.2 2)) → 1, 1.2
      (the (values integer) (truncate 3.2 2)) → 1, 1.2
      (the (values integer float) (truncate 3.2 2))   → 1, 1.2
      (the (values integer float symbol) (truncate 3.2 2)) → 1, 1.2
      (the (values integer float symbol t null list)
           (truncate 3.2 2)) → 1, 1.2
      (let ((i 100))
         (declare (fixnum i))
         (the fixnum (1+ i))) → 101
      (let* ((x (list 'a 'b 'c))
             (y 5))
         (setf (the fixnum (car x)) y)
         x) → (5 B C)

Exceptional Situations:
.......................

The consequences are undefined if the values yielded by the FORM are not
of the type specified by VALUE-TYPE.

See Also:
.........

*note values (Type Specifier)::

Notes:
......

The ‘values’ type specifier can be used to indicate the types of
multiple values:

      (the (values integer integer) (floor x y))
      (the (values string t)
           (gethash the-key the-string-table))

‘setf’ can be used with ‘the’ type declarations.  In this case the
declaration is transferred to the form that specifies the new value.
The resulting ‘setf’ form is then analyzed.


File: ansicl,  Node: special-operator-p,  Next: constantp,  Prev: the,  Up: Evaluation and Compilation

special-operator-p (Function)
=============================

Syntax:
.......

 -- Function: special-operator-p symbol → generalized-boolean

Arguments and Values:
.....................

SYMBOL—a symbol.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if SYMBOL is a special operator; otherwise, returns false.

Examples:
.........

      (special-operator-p 'if) → true
      (special-operator-p 'car) → false
      (special-operator-p 'one) → false

Exceptional Situations:
.......................

Should signal ‘type-error’ if its argument is not a symbol.

Notes:
......

Historically, this function was called ‘special-form-p’.  The name was
finally declared a misnomer and changed, since it returned true for
special operators, not special forms.


File: ansicl,  Node: constantp,  Prev: special-operator-p,  Up: Evaluation and Compilation

constantp (Function)
====================

Syntax:
.......

 -- Function: constantp form &optional environment → generalized-boolean

Arguments and Values:
.....................

FORM—a form.

ENVIRONMENT—an environment object.  The default is ‘nil’.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if FORM can be determined by the implementation to be a
constant form in the indicated ENVIRONMENT; otherwise, it returns false
indicating either that the form is not a constant form or that it cannot
be determined whether or not form is a constant form.

The following kinds of forms are considered constant forms:

   • Self-evaluating objects (such as numbers, characters, and the
     various kinds of arrays) are always considered constant forms and
     must be recognized as such by ‘constantp’.

   • Constant variables, such as keywords, symbols defined by Common
     Lisp as constant (such as ‘nil’, ‘t’, and ‘pi’), and symbols
     declared as constant by the user in the indicated ENVIRONMENT using
     ‘defconstant’ are always considered constant forms and must be
     recognized as such by ‘constantp’.

   • ‘quote’ forms are always considered constant forms and must be
     recognized as such by ‘constantp’.

   • An implementation is permitted, but not required, to detect
     additional constant forms.  If it does, it is also permitted, but
     not required, to make use of information in the ENVIRONMENT.
     Examples of constant forms for which ‘constantp’ might or might not
     return true are: ‘(sqrt pi)’, ‘(+ 3 2)’, ‘(length '(a b c))’, and
     ‘(let ((x 7)) (zerop x))’.

If an implementation chooses to make use of the ENVIRONMENT information,
such actions as expanding macros or performing function inlining are
permitted to be used, but not required; however, expanding compiler
macros is not permitted.

Examples:
.........

      (constantp 1) → true
      (constantp 'temp) → false
      (constantp ''temp)) → true
      (defconstant this-is-a-constant 'never-changing) → THIS-IS-A-CONSTANT
      (constantp 'this-is-a-constant) → true
      (constantp "temp") → true
      (setq a 6) → 6
      (constantp a) → true
      (constantp '(sin pi)) → implementation-dependent
      (constantp '(car '(x))) → implementation-dependent
      (constantp '(eql x x)) → implementation-dependent
      (constantp '(typep x 'nil)) → implementation-dependent
      (constantp '(typep x 't)) → implementation-dependent
      (constantp '(values this-is-a-constant)) → implementation-dependent
      (constantp '(values 'x 'y)) → implementation-dependent
      (constantp '(let ((a '(a b c))) (+ (length a) 6))) → implementation-dependent

Affected By:
............

The state of the global environment (e.g., which symbols have been
declared to be the names of constant variables).

See Also:
.........

*note defconstant::


File: ansicl,  Node: Types and Classes,  Next: Data and Control Flow,  Prev: Evaluation and Compilation,  Up: Top

4 Types and Classes
*******************

* Menu:

* Introduction to Types and Classes::
* Types::
* Classes::

Dictionary

* nil (Type)::
* boolean::
* function (System Class)::
* compiled-function::
* generic-function::
* standard-generic-function::
* class::
* built-in-class::
* structure-class::
* standard-class::
* method::
* standard-method::
* structure-object::
* standard-object::
* method-combination::
* t (System Class)::
* satisfies::
* member (Type Specifier)::
* not (Type Specifier)::
* and (Type Specifier)::
* or (Type Specifier)::
* values (Type Specifier)::
* eql (Type Specifier)::
* coerce::
* deftype::
* subtypep::
* type-of::
* typep::
* type-error::
* type-error-datum; type-error-expected-type::
* simple-type-error::


File: ansicl,  Node: Introduction to Types and Classes,  Next: Types,  Up: Types and Classes

4.1 Introduction to Types and Classes
=====================================

A type is a (possibly infinite) set of objects.  An object can belong to
more than one type.  Types are never explicitly represented as objects
by Common Lisp.  Instead, they are referred to indirectly by the use of
type specifiers, which are objects that denote types.

New types can be defined using ‘deftype’, ‘defstruct’, ‘defclass’, and
‘define-condition’.

The function ‘typep’, a set membership test, is used to determine
whether a given object is of a given type.  The function ‘subtypep’, a
subset test, is used to determine whether a given type is a subtype of
another given type.  The function ‘type-of’ returns a particular type to
which a given object belongs, even though that object must belong to one
or more other types as well.  (For example, every object is of type ‘t’,
but ‘type-of’ always returns a type specifier for a type more specific
than ‘t’.)

Objects, not variables, have types.  Normally, any variable can have any
object as its value.  It is possible to declare that a variable takes on
only values of a given type by making an explicit type declaration.
Types are arranged in a directed acyclic graph, except for the presence
of equivalences.

Declarations can be made about types using declare, ‘proclaim’,
‘declaim’, or ‘the’.  For more information about declarations, see *note
Section 3.3 (Declarations): Declarations.

Among the fundamental objects of the object system are classes.  A class
determines the structure and behavior of a set of other objects, which
are called its instances.  Every object is a direct instance of a class.
The class of an object determines the set of operations that can be
performed on the object.  For more information, see *note Section 4.3
(Classes): Classes.

It is possible to write functions that have behavior specialized to the
class of the objects which are their arguments.  For more information,
see *note Section 7.6 (Generic Functions and Methods): Generic Functions
and Methods.

The class of the class of an object is called its “metaclass”.  For more
information about metaclasses, see *note Section 7.4 (Meta-Objects):
Meta-Objects.


File: ansicl,  Node: Types,  Next: Classes,  Prev: Introduction to Types and Classes,  Up: Types and Classes

4.2 Types
=========

* Menu:

* Data Type Definition::
* Type Relationships::
* Type Specifiers::


File: ansicl,  Node: Data Type Definition,  Next: Type Relationships,  Up: Types

4.2.1 Data Type Definition
--------------------------

Information about type usage is located in the sections specified in
*note Figure 4.1: TypeInfoXrefs.  *note Figure 4.7:
ObjectSystemClasses. lists some classes that are particularly relevant
to the object system.  *note Figure 9.1:
StandardizedConditionTypes. lists the defined condition types.

Section                                                                     Data Type
*note Section 4.3 (Classes): Classes.                                       Object System types
*note Section 7.5 (Slots): Slots.                                           Object System types
*note Chapter 7 (Objects): Objects.                                         Object System types
*note Section 7.6 (Generic Functions and Methods): Generic Functions and Methods.Object System types
*note Section 9.1 (Condition System Concepts): Condition System Concepts.   Condition System types
*note Chapter 4 (Types and Classes): Types and Classes.                     Miscellaneous types
*note Chapter 2 (Syntax): Syntax.                                           All types—read and print syntax
*note Section 22.1 (The Lisp Printer): The Lisp Printer.                    All types—print syntax
*note Section 3.2 (Compilation): Compilation.                               All types—compilation issues

Figure 4.1: Cross-References to Data Type Information


File: ansicl,  Node: Type Relationships,  Next: Type Specifiers,  Prev: Data Type Definition,  Up: Types

4.2.2 Type Relationships
------------------------

   • The types ‘cons’, ‘symbol’, ‘array’, ‘number’, ‘character’,
     ‘hash-table’, ‘function’, ‘readtable’, ‘package’, ‘pathname’,
     ‘stream’, ‘random-state’, ‘condition’, ‘restart’, and any single
     other type created by ‘defstruct’, ‘define-condition’, or
     ‘defclass’ are pairwise disjoint, except for type relations
     explicitly established by specifying superclasses in ‘defclass’ or
     ‘define-condition’ or the :include option of ‘destruct’.

   • Any two types created by ‘defstruct’ are disjoint unless one is a
     supertype of the other by virtue of the ‘defstruct’ :include
     option.

   • Any two distinct classes created by ‘defclass’ or
     ‘define-condition’ are disjoint unless they have a common subclass
     or one class is a subclass of the other.

   • An implementation may be extended to add other subtype
     relationships between the specified types, as long as they do not
     violate the type relationships and disjointness requirements
     specified here.  An implementation may define additional types that
     are subtypes or supertypes of any specified types, as long as each
     additional type is a subtype of type ‘t’ and a supertype of type
     ‘nil’ and the disjointness requirements are not violated.

     At the discretion of the implementation, either ‘standard-object’
     or ‘structure-object’ might appear in any class precedence list for
     a system class that does not already specify either
     ‘standard-object’ or ‘structure-object’.  If it does, it must
     precede the class ‘t’ and follow all other standardized classes.


File: ansicl,  Node: Type Specifiers,  Prev: Type Relationships,  Up: Types

4.2.3 Type Specifiers
---------------------

Type specifiers can be symbols, classes, or lists.  *note Figure 4.2:
StandardizedAtomicTypeSpecs. lists symbols that are standardized atomic
type specifiers, and *note Figure 4.3:
StandardizedCompoundTypeSpecNames. lists standardized compound type
specifier names.  For syntax information, see the dictionary entry for
the corresponding type specifier.  It is possible to define new type
specifiers using ‘defclass’, ‘define-condition’, ‘defstruct’, or
‘deftype’.

arithmetic-error                   function             simple-condition
array                              generic-function     simple-error
atom                               hash-table           simple-string
base-char                          integer              simple-type-error
base-string                        keyword              simple-vector
bignum                             list                 simple-warning
bit                                logical-pathname     single-float
bit-vector                         long-float           standard-char
broadcast-stream                   method               standard-class
built-in-class                     method-combination   standard-generic-function
cell-error                         nil                  standard-method
character                          null                 standard-object
class                              number               storage-condition
compiled-function                  package              stream
complex                            package-error        stream-error
concatenated-stream                parse-error          string
condition                          pathname             string-stream
cons                               print-not-readable   structure-class
control-error                      program-error        structure-object
division-by-zero                   random-state         style-warning
double-float                       ratio                symbol
echo-stream                        rational             synonym-stream
end-of-file                        reader-error         t
error                              readtable            two-way-stream
extended-char                      real                 type-error
file-error                         restart              unbound-slot
file-stream                        sequence             unbound-variable
fixnum                             serious-condition    undefined-function
float                              short-float          unsigned-byte
floating-point-inexact             signed-byte          vector
floating-point-invalid-operation   simple-array         warning
floating-point-overflow            simple-base-string
floating-point-underflow           simple-bit-vector

Figure 4.2: Standardized Atomic Type Specifiers

If a type specifier is a list, the car of the list is a symbol, and the
rest of the list is subsidiary type information.  Such a type specifier
is called a “compound type specifier”.  Except as explicitly stated
otherwise, the subsidiary items can be unspecified.  The unspecified
subsidiary items are indicated by writing ‘*’.  For example, to
completely specify a vector, the type of the elements and the length of
the vector must be present.

      (vector double-float 100)

The following leaves the length unspecified:

      (vector double-float *)

The following leaves the element type unspecified:

      (vector * 100)

Suppose that two type specifiers are the same except that the first has
a ‘*’ where the second has a more explicit specification.  Then the
second denotes a subtype of the type denoted by the first.

If a list has one or more unspecified items at the end, those items can
be dropped.  If dropping all occurrences of ‘*’ results in a singleton
list, then the parentheses can be dropped as well (the list can be
replaced by the symbol in its car).  For example, ‘(vector double-float
*)’ can be abbreviated to ‘(vector double-float)’, and ‘(vector * *)’
can be abbreviated to ‘(vector)’ and then to ‘vector’.

and            long-float     simple-base-string
array          member         simple-bit-vector
base-string    mod            simple-string
bit-vector     not            simple-vector
complex        or             single-float
cons           rational       string
double-float   real           unsigned-byte
eql            satisfies      values
float          short-float    vector
function       signed-byte
integer        simple-array

Figure 4.3: Standardized Compound Type Specifier Names

The next figure show the defined names that can be used as compound type
specifier names but that cannot be used as atomic type specifiers.

and      mod   satisfies
eql      not   values
member   or

Figure 4.4: Standardized Compound-Only Type Specifier Names

New type specifiers can come into existence in two ways.

   • Defining a structure by using ‘defstruct’ without using the :type
     specifier or defining a class by using ‘defclass’ or
     ‘define-condition’ automatically causes the name of the structure
     or class to be a new type specifier symbol.
   • ‘deftype’ can be used to define “derived type specifiers”, which
     act as ‘abbreviations’ for other type specifiers.

A class object can be used as a type specifier.  When used this way, it
denotes the set of all members of that class.

The next figure shows some defined names relating to types and
declarations.

coerce             defstruct   subtypep
declaim            deftype     the
declare            ftype       type
defclass           locally     type-of
define-condition   proclaim    typep

Figure 4.5: Defined names relating to types and declarations.

The next figure shows all defined names that are type specifier names,
whether for atomic type specifiers or compound type specifiers; this
list is the union of the lists in *note Figure 4.2:
StandardizedAtomicTypeSpecs.  and *note Figure 4.3:
StandardizedCompoundTypeSpecNames.

and                                function             simple-array
arithmetic-error                   generic-function     simple-base-string
array                              hash-table           simple-bit-vector
atom                               integer              simple-condition
base-char                          keyword              simple-error
base-string                        list                 simple-string
bignum                             logical-pathname     simple-type-error
bit                                long-float           simple-vector
bit-vector                         member               simple-warning
broadcast-stream                   method               single-float
built-in-class                     method-combination   standard-char
cell-error                         mod                  standard-class
character                          nil                  standard-generic-function
class                              not                  standard-method
compiled-function                  null                 standard-object
complex                            number               storage-condition
concatenated-stream                or                   stream
condition                          package              stream-error
cons                               package-error        string
control-error                      parse-error          string-stream
division-by-zero                   pathname             structure-class
double-float                       print-not-readable   structure-object
echo-stream                        program-error        style-warning
end-of-file                        random-state         symbol
eql                                ratio                synonym-stream
error                              rational             t
extended-char                      reader-error         two-way-stream
file-error                         readtable            type-error
file-stream                        real                 unbound-slot
fixnum                             restart              unbound-variable
float                              satisfies            undefined-function
floating-point-inexact             sequence             unsigned-byte
floating-point-invalid-operation   serious-condition    values
floating-point-overflow            short-float          vector
floating-point-underflow           signed-byte          warning

Figure 4.6: Standardized Type Specifier Names


File: ansicl,  Node: Classes,  Next: nil (Type),  Prev: Types,  Up: Types and Classes

4.3 Classes
===========

While the object system is general enough to describe all standardized
classes (including, for example, ‘number’, ‘hash-table’, and ‘symbol’),
the next figure contains a list of classes that are especially relevant
to understanding the object system.

built-in-class     method-combination          standard-object
class              standard-class              structure-class
generic-function   standard-generic-function   structure-object
method             standard-method

Figure 4.7: Object System Classes

* Menu:

* Introduction to Classes::
* Defining Classes::
* Creating Instances of Classes::
* Inheritance::
* Determining the Class Precedence List::
* Redefining Classes::
* Integrating Types and Classes::


File: ansicl,  Node: Introduction to Classes,  Next: Defining Classes,  Up: Classes

4.3.1 Introduction to Classes
-----------------------------

A “class” is an object that determines the structure and behavior of a
set of other objects, which are called its “instances”.

A class can inherit structure and behavior from other classes.  A class
whose definition refers to other classes for the purpose of inheriting
from them is said to be a subclass of each of those classes.  The
classes that are designated for purposes of inheritance are said to be
superclasses of the inheriting class.

A class can have a name.  The function ‘class-name’ takes a class object
and returns its name.  The name of an anonymous class is ‘nil’.  A
symbol can name a class.  The function ‘find-class’ takes a symbol and
returns the class that the symbol names.  A class has a proper name if
the name is a symbol and if the name of the class names that class.
That is, a class C has the proper name S if S= ‘(class-name C)’ and C=
‘(find-class S)’.  Notice that it is possible for ‘(find-class Sand SIf
C= (find-class S), we say that C is the class named S. ’
A class Ca “direct superclass” of a class Cif Cas a superclass in its
definition.  In this case C“direct subclass” of CA class C“superclass”
of a class Cclasses CCIn this case, C“subclass” of CA class is
considered neither a superclass nor a subclass of itself.  That is, if
Cthen CThe set of classes consisting of some given class C along with
all of its superclasses is called “C and its superclasses.”

Each class has a “class precedence list”, which is a total ordering on
the set of the given class and its superclasses.  The total ordering is
expressed as a list ordered from most specific to least specific.  The
class precedence list is used in several ways.  In general, more
specific classes can “shadow”otherwise be inherited from less specific
classes.  The method selection and combination process uses the class
precedence list to order methods from most specific to least specific.

When a class is defined, the order in which its direct superclasses are
mentioned in the defining form is important.  Each class has a “local
precedence order”, which is a list consisting of the class followed by
its direct superclasses in the order mentioned in the defining form.

A class precedence list is always consistent with the local precedence
order of each class in the list.  The classes in each local precedence
order appear within the class precedence list in the same order.  If the
local precedence orders are inconsistent with each other, no class
precedence list can be constructed, and an error is signaled.  The class
precedence list and its computation is discussed in *note Section 4.3.5
(Determining the Class Precedence List): Determining the Class
Precedence List.

classes are organized into a directed acyclic graph.  There are two
distinguished classes, named ‘t’ and ‘standard-object’.  The class named
‘t’ has no superclasses.  It is a superclass of every class except
itself.  The class named ‘standard-object’ is an instance of the class
‘standard-class’ and is a superclass of every class that is an instance
of the class ‘standard-class’ except itself.

There is a mapping from the object system class space into the type
space.  Many of the standard types specified in this document have a
corresponding class that has the same name as the type.  Some types do
not have a corresponding class.  The integration of the type and class
systems is discussed in *note Section 4.3.7 (Integrating Types and
Classes): Integrating Types and Classes.

Classes are represented by objects that are themselves instances of
classes.  The class of the class of an object is termed the “metaclass”
of that object.  When no misinterpretation is possible, the term
metaclass is used to refer to a class that has instances that are
themselves classes.  The metaclass determines the form of inheritance
used by the classes that are its instances and the representation of the
instances of those classes.  The object system provides a default
metaclass, ‘standard-class’, that is appropriate for most programs.

Except where otherwise specified, all classes mentioned in this standard
are instances of the class ‘standard-class’, all generic functions are
instances of the class ‘standard-generic-function’, and all methods are
instances of the class ‘standard-method’.

4.3.1.1 Standard Metaclasses
............................

The object system provides a number of predefined metaclasses.  These
include the classes ‘standard-class’, ‘built-in-class’, and
‘structure-class’:

   • The class ‘standard-class’ is the default class of classes defined
     by ‘defclass’.

   • The class ‘built-in-class’ is the class whose instances are classes
     that have special implementations with restricted capabilities.
     Any class that corresponds to a standard type might be an instance
     of ‘built-in-class’.  The predefined type specifiers that are
     required to have corresponding classes are listed in *note Figure
     4.8: ClassTypeCorrespondence.  It is implementation-dependent
     whether each of these classes is implemented as a built-in class.

   • All classes defined by means of ‘defstruct’ are instances of the
     class ‘structure-class’.


File: ansicl,  Node: Defining Classes,  Next: Creating Instances of Classes,  Prev: Introduction to Classes,  Up: Classes

4.3.2 Defining Classes
----------------------

The macro ‘defclass’ is used to define a new named class.

The definition of a class includes:

   • The name of the new class.  For newly-defined classes this name is
     a proper name.

   • The list of the direct superclasses of the new class.

   • A set of “slot specifiers”.  Each slot specifier includes the name
     of the slot and zero or more slot options.  A slot option pertains
     only to a single slot.  If a class definition contains two slot
     specifiers with the same name, an error is signaled.

   • A set of class options.  Each class option pertains to the class as
     a whole.

The slot options and class options of the ‘defclass’ form provide
mechanisms for the following:

   • Supplying a default initial value form for a given slot.

   • Requesting that methods for generic functions be automatically
     generated for reading or writing slots.

   • Controlling whether a given slot is shared by all instances of the
     class or whether each instance of the class has its own slot.

   • Supplying a set of initialization arguments and initialization
     argument defaults to be used in instance creation.

   • Indicating that the metaclass is to be other than the default.  The
     :metaclass option is reserved for future use; an implementation can
     be extended to make use of the :metaclass option.

   • Indicating the expected type for the value stored in the slot.

   • Indicating the documentation string for the slot.


File: ansicl,  Node: Creating Instances of Classes,  Next: Inheritance,  Prev: Defining Classes,  Up: Classes

4.3.3 Creating Instances of Classes
-----------------------------------

The generic function ‘make-instance’ creates and returns a new instance
of a class.  The object system provides several mechanisms for
specifying how a new instance is to be initialized.  For example, it is
possible to specify the initial values for slots in newly created
instances either by giving arguments to ‘make-instance’ or by providing
default initial values.  Further initialization activities can be
performed by methods written for generic functions that are part of the
initialization protocol.  The complete initialization protocol is
described in *note Section 7.1 (Object Creation and Initialization):
Object Creation and Initialization.


File: ansicl,  Node: Inheritance,  Next: Determining the Class Precedence List,  Prev: Creating Instances of Classes,  Up: Classes

4.3.4 Inheritance
-----------------

A class can inherit methods, slots, and some ‘defclass’ options from its
superclasses.  Other sections describe the inheritance of methods, the
inheritance of slots and slot options, and the inheritance of class
options.

4.3.4.1 Examples of Inheritance
...............................

      (defclass C1 ()
          ((S1 :initform 5.4 :type number)
           (S2 :allocation :class)))

      (defclass C2 (C1)
          ((S1 :initform 5 :type integer)
           (S2 :allocation :instance)
           (S3 :accessor C2-S3)))

Instances of the class ‘C1’ have a local slot named ‘S1’, whose default
initial value is 5.4 and whose value should always be a number.  The
class ‘C1’ also has a shared slot named ‘S2’.

There is a local slot named ‘S1’ in instances of ‘C2’.  The default
initial value of ‘S1’ is 5.  The value of ‘S1’ should always be of type
‘(and integer number)’.  There are also local slots named ‘S2’ and ‘S3’
in instances of ‘C2’.  The class ‘C2’ has a method for ‘C2-S3’ for
reading the value of slot ‘S3’; there is also a method for ‘(setf
C2-S3)’ that writes the value of ‘S3’.

4.3.4.2 Inheritance of Class Options
....................................

The :default-initargs class option is inherited.  The set of defaulted
initialization arguments for a class is the union of the sets of
initialization arguments supplied in the :default-initargs class options
of the class and its superclasses.  When more than one default initial
value form is supplied for a given initialization argument, the default
initial value form that is used is the one supplied by the class that is
most specific according to the class precedence list.

If a given :default-initargs class option specifies an initialization
argument of the same name more than once, an error of type
‘program-error’ is signaled.


File: ansicl,  Node: Determining the Class Precedence List,  Next: Redefining Classes,  Prev: Inheritance,  Up: Classes

4.3.5 Determining the Class Precedence List
-------------------------------------------

The ‘defclass’ form for a class provides a total ordering on that class
and its direct superclasses.  This ordering is called the “local
precedence order”.  It is an ordered list of the class and its direct
superclasses.  The “class precedence list” for a class C is a total
ordering on C and its superclasses that is consistent with the local
precedence orders for each of C and its superclasses.

A class precedes its direct superclasses, and a direct superclass
precedes all other direct superclasses specified to its right in the
superclasses list of the ‘defclass’ form.  For every class C, define
     R
where Cthe direct superclasses of C in the order in which they are
mentioned in the ‘defclass’ form.  These ordered pairs generate the
total ordering on the class C and its direct superclasses.

Let S

     R=⋃
.

The set R might or might not generate a partial ordering, depending on
whether the Rconsistent; it is assumed that they are consistent and that
R generates a partial ordering.  When the R

To compute the class precedence list for C, topologically sort the
elements of Spartial ordering generated by R. When the topological sort
must select a class from a set of two or more classes, none of which are
preceded by other classes with respect to R, the class selected is
chosen deterministically, as described below.

If R is inconsistent, an error is signaled.

4.3.5.1 Topological Sorting
...........................

Topological sorting proceeds by finding a class C in Sthat no other
class precedes that element according to the elements in R. The class C
is placed first in the result.  Remove C from SD∈ Sclasses with no
predecessors to the end of the result.  Stop when no element can be
found that has no predecessor.

If Sinconsistent.  If every class in the finite set of classes is
preceded by another, then R contains a loop.  That is, there is a chain
of classes CC

Sometimes there are several classes from Spredecessors.  In this case
select the one that has a direct subclass rightmost in the class
precedence list computed so far.  (If there is no such candidate class,
R does not generate a partial ordering—the R

In more precise terms, let {Nthe classes from Sconstructed so far.
Csuch that there exists an i where 1≤ i≤ m and Nis a direct superclass
of C

The effect of this rule for selecting from a set of classes with no
predecessors is that the classes in a simple superclass chain are
adjacent in the class precedence list and that classes in each
relatively separated subgraph are adjacent in the class precedence list.
For example, let Telement in common is the class J. Suppose that no
superclass of J appears in either Tand that J is in the superclass chain
of every class in both TLet Cand let CSuppose C is a class whose direct
superclasses are Cfor C starts with C and is followed by all classes in
TAll the classes of TThe class J and its superclasses appear last.

4.3.5.2 Examples of Class Precedence List Determination
.......................................................

This example determines a class precedence list for the class ‘pie’.
The following classes are defined:

      (defclass pie (apple cinnamon) ())

      (defclass apple (fruit) ())

      (defclass cinnamon (spice) ())

      (defclass fruit (food) ())

      (defclass spice (food) ())

      (defclass food () ())

The set Sstandard-object, t}.  The set R = {‘(pie, apple), (apple,
cinnamon), (apple, fruit), (cinnamon, spice), (fruit, food), (spice,
food), (food, standard-object), (standard-object, t)’}.

The class ‘pie’ is not preceded by anything, so it comes first; the
result so far is ‘(pie)’.  Remove ‘pie’ from S and pairs mentioning
‘pie’ from R to get S = {‘apple, cinnamon, fruit, spice, food,
standard-object, t’} and R = {‘(apple, cinnamon), (apple, fruit),
(cinnamon, spice), (fruit, food), (spice, food), (food,
standard-object), (standard-object, t)’}.

The class ‘apple’ is not preceded by anything, so it is next; the result
is ‘(pie apple)’.  Removing ‘apple’ and the relevant pairs results in
S = {‘cinnamon, fruit, spice, food, standard-object, t’} and R =
{‘(cinnamon, spice), (fruit, food), (spice, food), (food,
standard-object), (standard-object, t)’}.

The classes ‘cinnamon’ and ‘fruit’ are not preceded by anything, so the
one with a direct subclass rightmost in the class precedence list
computed so far goes next.  The class ‘apple’ is a direct subclass of
‘fruit’, and the class ‘pie’ is a direct subclass of ‘cinnamon’.
Because ‘apple’ appears to the right of ‘pie’ in the class precedence
list, ‘fruit’ goes next, and the result so far is ‘(pie apple fruit)’.
S = {‘cinnamon, spice, food, standard-object, t’}; R = {‘(cinnamon,
spice), (spice, food), (food, standard-object), (standard-object, t)’}.

The class ‘cinnamon’ is next, giving the result so far as ‘(pie apple
fruit cinnamon)’.  At this point S = {‘spice, food, standard-object,
t’}; R = {‘(spice, food), (food, standard-object), (standard-object,
t)’}.

The classes ‘spice’, ‘food’, ‘standard-object’, and ‘t’ are added in
that order, and the class precedence list is ‘(pie apple fruit cinnamon
spice food standard-object t)’.

It is possible to write a set of class definitions that cannot be
ordered.  For example:

      (defclass new-class (fruit apple) ())

      (defclass apple (fruit) ())

The class ‘fruit’ must precede ‘apple’ because the local ordering of
superclasses must be preserved.  The class ‘apple’ must precede ‘fruit’
because a class always precedes its own superclasses.  When this
situation occurs, an error is signaled, as happens here when the system
tries to compute the class precedence list of ‘new-class’.

The following might appear to be a conflicting set of definitions:

      (defclass pie (apple cinnamon) ())

      (defclass pastry (cinnamon apple) ())

      (defclass apple () ())

      (defclass cinnamon () ())

The class precedence list for ‘pie’ is ‘(pie apple cinnamon
standard-object t)’.

The class precedence list for ‘pastry’ is ‘(pastry cinnamon apple
standard-object t)’.

It is not a problem for ‘apple’ to precede ‘cinnamon’ in the ordering of
the superclasses of ‘pie’ but not in the ordering for ‘pastry’.
However, it is not possible to build a new class that has both ‘pie’ and
‘pastry’ as superclasses.


File: ansicl,  Node: Redefining Classes,  Next: Integrating Types and Classes,  Prev: Determining the Class Precedence List,  Up: Classes

4.3.6 Redefining Classes
------------------------

A class that is a direct instance of ‘standard-class’ can be redefined
if the new class is also a direct instance of ‘standard-class’.
Redefining a class modifies the existing class object to reflect the new
class definition; it does not create a new class object for the class.
Any method object created by a :reader, :writer, or :accessor option
specified by the old ‘defclass’ form is removed from the corresponding
generic function.  Methods specified by the new ‘defclass’ form are
added.

When the class C is redefined, changes are propagated to its instances
and to instances of any of its subclasses.  Updating such an instance
occurs at an implementation-dependent time, but no later than the next
time a slot of that instance is read or written.  Updating an instance
does not change its identity as defined by the function ‘eq’.  The
updating process may change the slots of that particular instance, but
it does not create a new instance.  Whether updating an instance
consumes storage is implementation-dependent.

Note that redefining a class may cause slots to be added or deleted.  If
a class is redefined in a way that changes the set of local slots
accessible in instances, the instances are updated.  It is
implementation-dependent whether instances are updated if a class is
redefined in a way that does not change the set of local slots
accessible in instances.

The value of a slot that is specified as shared both in the old class
and in the new class is retained.  If such a shared slot was unbound in
the old class, it is unbound in the new class.  Slots that were local in
the old class and that are shared in the new class are initialized.
Newly added shared slots are initialized.

Each newly added shared slot is set to the result of evaluating the
captured initialization form for the slot that was specified in the
‘defclass’ form for the new class.  If there was no initialization form,
the slot is unbound.

If a class is redefined in such a way that the set of local slots
accessible in an instance of the class is changed, a two-step process of
updating the instances of the class takes place.  The process may be
explicitly started by invoking the generic function
‘make-instances-obsolete’.  This two-step process can happen in other
circumstances in some implementations.  For example, in some
implementations this two-step process is triggered if the order of slots
in storage is changed.

The first step modifies the structure of the instance by adding new
local slots and discarding local slots that are not defined in the new
version of the class.  The second step initializes the newly-added local
slots and performs any other user-defined actions.  These two steps are
further specified in the next two sections.

4.3.6.1 Modifying the Structure of Instances
............................................

The first step modifies the structure of instances of the redefined
class to conform to its new class definition.  Local slots specified by
the new class definition that are not specified as either local or
shared by the old class are added, and slots not specified as either
local or shared by the new class definition that are specified as local
by the old class are discarded.  The names of these added and discarded
slots are passed as arguments to ‘update-instance-for-redefined-class’
as described in the next section.

The values of local slots specified by both the new and old classes are
retained.  If such a local slot was unbound, it remains unbound.

The value of a slot that is specified as shared in the old class and as
local in the new class is retained.  If such a shared slot was unbound,
the local slot is unbound.

4.3.6.2 Initializing Newly Added Local Slots
............................................

The second step initializes the newly added local slots and performs any
other user-defined actions.  This step is implemented by the generic
function ‘update-instance-for-redefined-class’, which is called after
completion of the first step of modifying the structure of the instance.

The generic function ‘update-instance-for-redefined-class’ takes four
required arguments: the instance being updated after it has undergone
the first step, a list of the names of local slots that were added, a
list of the names of local slots that were discarded, and a property
list containing the slot names and values of slots that were discarded
and had values.  Included among the discarded slots are slots that were
local in the old class and that are shared in the new class.

The generic function ‘update-instance-for-redefined-class’ also takes
any number of initialization arguments.  When it is called by the system
to update an instance whose class has been redefined, no initialization
arguments are provided.

There is a system-supplied primary method for
‘update-instance-for-redefined-class’ whose parameter specializer for
its instance argument is the class ‘standard-object’.  First this method
checks the validity of initialization arguments and signals an error if
an initialization argument is supplied that is not declared as valid.
(For more information, see *note Section 7.1.2 (Declaring the Validity
of Initialization Arguments): Declaring the Validity of Initialization
Arguments.)  Then it calls the generic function ‘shared-initialize’ with
the following arguments: the instance, the list of names of the newly
added slots, and the initialization arguments it received.

4.3.6.3 Customizing Class Redefinition
......................................

Methods for ‘update-instance-for-redefined-class’ may be defined to
specify actions to be taken when an instance is updated.  If only after
methods for ‘update-instance-for-redefined-class’ are defined, they will
be run after the system-supplied primary method for initialization and
therefore will not interfere with the default behavior of
‘update-instance-for-redefined-class’.  Because no initialization
arguments are passed to ‘update-instance-for-redefined-class’ when it is
called by the system, the initialization forms for slots that are filled
by before methods for ‘update-instance-for-redefined-class’ will not be
evaluated by ‘shared-initialize’.

Methods for ‘shared-initialize’ may be defined to customize class
redefinition.  For more information, see *note Section 7.1.5
(Shared-Initialize): Shared-Initialize.


File: ansicl,  Node: Integrating Types and Classes,  Prev: Redefining Classes,  Up: Classes

4.3.7 Integrating Types and Classes
-----------------------------------

The object system maps the space of classes into the space of types.
Every class that has a proper name has a corresponding type with the
same name.

The proper name of every class is a valid type specifier.  In addition,
every class object is a valid type specifier.  Thus the expression
‘(typep OBJECT CLASS)’ evaluates to true if the class of OBJECT is CLASS
itself or a subclass of class.  The evaluation of the expression
‘(subtypep class1 class2)’ returns the values true and true if ‘class1’
is a subclass of ‘class2’ or if they are the same class; otherwise it
returns the values false and true.  If I is an instance of some class C
named S and C is an instance of ‘standard-class’, the evaluation of the
expression ‘(type-of I)’ returns S if S is the proper name of C;
otherwise, it returns C.

Because the names of classes and class objects are type specifiers, they
may be used in the special form ‘the’ and in type declarations.

Many but not all of the predefined type specifiers have a corresponding
class with the same proper name as the type.  These type specifiers are
listed in *note Figure 4.8: ClassTypeCorrespondence.  For example, the
type ‘array’ has a corresponding class named ‘array’.  No type specifier
that is a list, such as ‘(vector double-float 100)’, has a corresponding
class.  The operator ‘deftype’ does not create any classes.

Each class that corresponds to a predefined type specifier can be
implemented in one of three ways, at the discretion of each
implementation.  It can be a standard class, a structure class, or a
system class.

A built-in class is one whose generalized instances have restricted
capabilities or special representations.  Attempting to use ‘defclass’
to define subclasses of a ‘built-in-class’ signals an error.  Calling
‘make-instance’ to create a generalized instance of a built-in class
signals an error.  Calling ‘slot-value’ on a generalized instance of a
built-in class signals an error.  Redefining a built-in class or using
‘change-class’ to change the class of an object to or from a built-in
class signals an error.  However, built-in classes can be used as
parameter specializers in methods.

It is possible to determine whether a class is a built-in class by
checking the metaclass.  A standard class is an instance of the class
‘standard-class’, a built-in class is an instance of the class
‘built-in-class’, and a structure class is an instance of the class
‘structure-class’.

Each structure type created by ‘defstruct’ without using the :type
option has a corresponding class.  This class is a generalized instance
of the class ‘structure-class’.  The :include option of ‘defstruct’
creates a direct subclass of the class that corresponds to the included
structure type.

It is implementation-dependent whether slots are involved in the
operation of functions defined in this specification on instances of
classes defined in this specification, except when slots are explicitly
defined by this specification.

If in a particular implementation a class defined in this specification
has slots that are not defined by this specfication, the names of these
slots must not be external symbols of packages defined in this
specification nor otherwise accessible in the ‘CL-USER’ package.

The purpose of specifying that many of the standard type specifiers have
a corresponding class is to enable users to write methods that
discriminate on these types.  Method selection requires that a class
precedence list can be determined for each class.

The hierarchical relationships among the type specifiers are mirrored by
relationships among the classes corresponding to those types.

*note Figure 4.8: ClassTypeCorrespondence. lists the set of classes that
correspond to predefined type specifiers.

arithmetic-error                   generic-function     simple-error
array                              hash-table           simple-type-error
bit-vector                         integer              simple-warning
broadcast-stream                   list                 standard-class
built-in-class                     logical-pathname     standard-generic-function
cell-error                         method               standard-method
character                          method-combination   standard-object
class                              null                 storage-condition
complex                            number               stream
concatenated-stream                package              stream-error
condition                          package-error        string
cons                               parse-error          string-stream
control-error                      pathname             structure-class
division-by-zero                   print-not-readable   structure-object
echo-stream                        program-error        style-warning
end-of-file                        random-state         symbol
error                              ratio                synonym-stream
file-error                         rational             t
file-stream                        reader-error         two-way-stream
float                              readtable            type-error
floating-point-inexact             real                 unbound-slot
floating-point-invalid-operation   restart              unbound-variable
floating-point-overflow            sequence             undefined-function
floating-point-underflow           serious-condition    vector
function                           simple-condition     warning

Figure 4.8: Classes that correspond to pre-defined type specifiers

The class precedence list information specified in the entries for each
of these classes are those that are required by the object system.

Individual implementations may be extended to define other type
specifiers to have a corresponding class.  Individual implementations
may be extended to add other subclass relationships and to add other
elements to the class precedence lists as long as they do not violate
the type relationships and disjointness requirements specified by this
standard.  A standard class defined with no direct superclasses is
guaranteed to be disjoint from all of the classes in the table, except
for the class named ‘t’.


File: ansicl,  Node: nil (Type),  Next: boolean,  Prev: Classes,  Up: Types and Classes

nil (Type)
==========

Supertypes:
...........

all types

Description:
............

The type ‘nil’ contains no objects and so is also called the empty type.
The type ‘nil’ is a subtype of every type.  No object is of type ‘nil’.

Notes:
......

The type containing the object ‘nil’ is the type ‘null’, not the type
‘nil’.


File: ansicl,  Node: boolean,  Next: function (System Class),  Prev: nil (Type),  Up: Types and Classes

boolean (Type)
==============

Supertypes:
...........

‘boolean’, ‘symbol’, ‘t’

Description:
............

The type ‘boolean’ contains the symbols t and nil, which represent true
and false, respectively.

See Also:
.........

*note t (Constant Variable)::, *note nil (Constant Variable)::, *note
if::, *note not (Function)::, *note complement::

Notes:
......

Conditional operations, such as ‘if’, permit the use of generalized
booleans, not just booleans; any non-nil value, not just t, counts as
true for a generalized boolean.  However, as a matter of convention, the
symbol t is considered the canonical value to use even for a generalized
boolean when no better choice presents itself.


File: ansicl,  Node: function (System Class),  Next: compiled-function,  Prev: boolean,  Up: Types and Classes

function (System Class)
=======================

Class Precedence List:
......................

‘function’, ‘t’

Description:
............

A function is an object that represents code to be executed when an
appropriate number of arguments is supplied.  A function is produced by
the ‘function’ special form, the function ‘coerce’, or the function
‘compile’.  A function can be directly invoked by using it as the first
argument to ‘funcall’, ‘apply’, or ‘multiple-value-call’.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(function [arg-typespec [value-typespec]])

ARG-TYPESPEC::=
     ({typespec}*
      [&optional {typespec}*]
      [&rest TYPESPEC]
      [&key {(keyword typespec)}*])

Compound Type Specifier Arguments:
..................................

TYPESPEC—a type specifier.

VALUE-TYPESPEC—a type specifier.

Compound Type Specifier Description:
....................................

The list form of the ‘function’ type-specifier can be used only for
declaration and not for discrimination.  Every element of this type is a
function that accepts arguments of the types specified by the ARGJ-TYPES
and returns values that are members of the types specified by
VALUE-TYPE.  The ‘&optional’, ‘&rest’, ‘&key’, and ‘&allow-other-keys’
markers can appear in the list of argument types.  The type specifier
provided with ‘&rest’ is the type of each actual argument, not the type
of the corresponding variable.

The ‘&key’ parameters should be supplied as lists of the form ‘(KEYWORD
TYPE)’.  The KEYWORD must be a valid keyword-name symbol as must be
supplied in the actual arguments of a call.  This is usually a symbol in
the ‘KEYWORD’ package but can be any symbol.  When ‘&key’ is given in a
‘function’ type specifier lambda list, the keyword parameters given are
exhaustive unless ‘&allow-other-keys’ is also present.
‘&allow-other-keys’ is an indication that other keyword arguments might
actually be supplied and, if supplied, can be used.  For example, the
type of the function ‘make-list’ could be declared as follows:

      (function ((integer 0) &key (:initial-element t)) list)

The VALUE-TYPE can be a ‘values’ type specifier in order to indicate the
types of multiple values.

Consider a declaration of the following form:

      (ftype (function (arg0-type arg1-type ...) val-type) f))

Any form ‘(f arg0 arg1 ...)’ within the scope of that declaration is
equivalent to the following:

      (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))

That is, the consequences are undefined if any of the arguments are not
of the specified types or the result is not of the specified type.  In
particular, if any argument is not of the correct type, the result is
not guaranteed to be of the specified type.

Thus, an ‘ftype’ declaration for a function describes calls to the
function, not the actual definition of the function.

Consider a declaration of the following form:

      (type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)

This declaration has the interpretation that, within the scope of the
declaration, the consequences are unspecified if the value of
‘fn-valued-variable’ is called with arguments not of the specified
types; the value resulting from a valid call will be of type ‘val-type’.

As with variable type declarations, nested declarations imply
intersections of types, as follows:

   • Consider the following two declarations of ‘ftype’:

           (ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))

     and

           (ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))

     If both these declarations are in effect, then within the shared
     scope of the declarations, calls to ‘f’ can be treated as if ‘f’
     were declared as follows:

           (ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)
                            (and val-type1 val-type2))
                  f))

     It is permitted to ignore one or all of the ‘ftype’ declarations in
     force.

   • If two (or more) type declarations are in effect for a variable,
     and they are both ‘function’ declarations, the declarations combine
     similarly.


File: ansicl,  Node: compiled-function,  Next: generic-function,  Prev: function (System Class),  Up: Types and Classes

compiled-function (Type)
========================

Supertypes:
...........

‘compiled-function’, ‘function’, ‘t’

Description:
............

Any function may be considered by an implementation to be a a compiled
function if it contains no references to macros that must be expanded at
run time, and it contains no unresolved references to load time values.
See *note Section 3.2.2 (Compilation Semantics): Compilation Semantics.

Functions whose definitions appear lexically within a file that has been
compiled with ‘compile-file’ and then loaded with ‘load’ are of type
‘compiled-function’.  Functions produced by the ‘compile’ function are
of type ‘compiled-function’.  Other functions might also be of type
‘compiled-function’.


File: ansicl,  Node: generic-function,  Next: standard-generic-function,  Prev: compiled-function,  Up: Types and Classes

generic-function (System Class)
===============================

Class Precedence List:
......................

‘generic-function’, ‘function’, ‘t’

Description:
............

A “generic function” is a function whose behavior depends on the classes
or identities of the arguments supplied to it.  A generic function
object contains a set of methods, a lambda list, a method combination
type, and other information.  The methods define the class-specific
behavior and operations of the generic function; a method is said to
specialize a generic function.  When invoked, a generic function
executes a subset of its methods based on the classes or identities of
its arguments.

A generic function can be used in the same ways that an ordinary
function can be used; specifically, a generic function can be used as an
argument to ‘funcall’ and ‘apply’, and can be given a global or a local
name.


File: ansicl,  Node: standard-generic-function,  Next: class,  Prev: generic-function,  Up: Types and Classes

standard-generic-function (System Class)
========================================

Class Precedence List:
......................

‘standard-generic-function’, ‘generic-function’, ‘function’, ‘t’

Description:
............

The class ‘standard-generic-function’ is the default class of generic
functions established by ‘defmethod’, ‘ensure-generic-function’,
‘defgeneric’, and ‘defclass’ forms.


File: ansicl,  Node: class,  Next: built-in-class,  Prev: standard-generic-function,  Up: Types and Classes

class (System Class)
====================

Class Precedence List:
......................

‘class’, ‘standard-object’, ‘t’

Description:
............

The type ‘class’ represents objects that determine the structure and
behavior of their instances.  Associated with an object of type ‘class’
is information describing its place in the directed acyclic graph of
classes, its slots, and its options.


File: ansicl,  Node: built-in-class,  Next: structure-class,  Prev: class,  Up: Types and Classes

built-in-class (System Class)
=============================

Class Precedence List:
......................

‘built-in-class’, ‘class’, ‘standard-object’, ‘t’

Description:
............

A built-in class is a class whose instances have restricted capabilities
or special representations.  Attempting to use ‘defclass’ to define
subclasses of a built-in class signals an error of type ‘error’.
Calling ‘make-instance’ to create an instance of a built-in class
signals an error of type ‘error’.  Calling ‘slot-value’ on an instance
of a built-in class signals an error of type ‘error’.  Redefining a
built-in class or using ‘change-class’ to change the class of an
instance to or from a built-in class signals an error of type ‘error’.
However, built-in classes can be used as parameter specializers in
methods.


File: ansicl,  Node: structure-class,  Next: standard-class,  Prev: built-in-class,  Up: Types and Classes

structure-class (System Class)
==============================

Class Precedence List:
......................

‘structure-class’, ‘class’, ‘standard-object’, ‘t’

Description:
............

All classes defined by means of ‘defstruct’ are instances of the class
‘structure-class’.


File: ansicl,  Node: standard-class,  Next: method,  Prev: structure-class,  Up: Types and Classes

standard-class (System Class)
=============================

Class Precedence List:
......................

‘standard-class’, ‘class’, ‘standard-object’, ‘t’

Description:
............

The class ‘standard-class’ is the default class of classes defined by
‘defclass’.


File: ansicl,  Node: method,  Next: standard-method,  Prev: standard-class,  Up: Types and Classes

method (System Class)
=====================

Class Precedence List:
......................

‘method’, ‘t’

Description:
............

A method is an object that represents a modular part of the behavior of
a generic function.

A method contains code to implement the method’s behavior, a sequence of
parameter specializers that specify when the given method is applicable,
and a sequence of qualifiers that is used by the method combination
facility to distinguish among methods.  Each required parameter of each
method has an associated parameter specializer, and the method will be
invoked only on arguments that satisfy its parameter specializers.

The method combination facility controls the selection of methods, the
order in which they are run, and the values that are returned by the
generic function.  The object system offers a default method combination
type and provides a facility for declaring new types of method
combination.

See Also:
.........

*note Section 7.6 (Generic Functions and Methods): Generic Functions and
Methods.


File: ansicl,  Node: standard-method,  Next: structure-object,  Prev: method,  Up: Types and Classes

standard-method (System Class)
==============================

Class Precedence List:
......................

‘standard-method’, ‘method’, ‘standard-object’, ‘t’

Description:
............

The class ‘standard-method’ is the default class of methods defined by
the ‘defmethod’ and ‘defgeneric’ forms.


File: ansicl,  Node: structure-object,  Next: standard-object,  Prev: standard-method,  Up: Types and Classes

structure-object (Class)
========================

Class Precedence List:
......................

‘structure-object’, ‘t’

Description:
............

The class ‘structure-object’ is an instance of ‘structure-class’ and is
a superclass of every class that is an instance of ‘structure-class’
except itself, and is a superclass of every class that is defined by
‘defstruct’.

See Also:
.........

*note defstruct::, *note Section 2.4.8.13 (Sharpsign S): SharpsignS,
*note Section 22.1.3.12 (Printing Structures): PrintingStructures.


File: ansicl,  Node: standard-object,  Next: method-combination,  Prev: structure-object,  Up: Types and Classes

standard-object (Class)
=======================

Class Precedence List:
......................

‘standard-object’, ‘t’

Description:
............

The class ‘standard-object’ is an instance of ‘standard-class’ and is a
superclass of every class that is an instance of ‘standard-class’ except
itself.


File: ansicl,  Node: method-combination,  Next: t (System Class),  Prev: standard-object,  Up: Types and Classes

method-combination (System Class)
=================================

Class Precedence List:
......................

‘method-combination’, ‘t’

Description:
............

Every method combination object is an indirect instance of the class
‘method-combination’.  A method combination object represents the
information about the method combination being used by a generic
function.  A method combination object contains information about both
the type of method combination and the arguments being used with that
type.


File: ansicl,  Node: t (System Class),  Next: satisfies,  Prev: method-combination,  Up: Types and Classes

t (System Class)
================

Class Precedence List:
......................

‘t’

Description:
............

The set of all objects.  The type ‘t’ is a supertype of every type,
including itself.  Every object is of type ‘t’.


File: ansicl,  Node: satisfies,  Next: member (Type Specifier),  Prev: t (System Class),  Up: Types and Classes

satisfies (Type Specifier)
==========================

Compound Type Specifier Kind:
.............................

Predicating.

Compound Type Specifier Syntax:
...............................

(satisfies predicate-name)

Compound Type Specifier Arguments:
..................................

PREDICATE-NAME—a symbol.

Compound Type Specifier Description:
....................................

This denotes the set of all objects that satisfy the predicate
PREDICATE-NAME, which must be a symbol whose global function definition
is a one-argument predicate.  A name is required for PREDICATE-NAME;
lambda expressions are not allowed.  For example, the type specifier
‘(and integer (satisfies evenp))’ denotes the set of all even integers.
The form ‘(typep X '(satisfies P))’ is equivalent to ‘(if (P X) t nil)’.

The argument is required.  The symbol * can be the argument, but it
denotes itself (the symbol *), and does not represent an unspecified
value.

The symbol ‘satisfies’ is not valid as a type specifier.


File: ansicl,  Node: member (Type Specifier),  Next: not (Type Specifier),  Prev: satisfies,  Up: Types and Classes

member (Type Specifier)
=======================

Compound Type Specifier Kind:
.............................

Combining.

Compound Type Specifier Syntax:
...............................

(member {object}*)

Compound Type Specifier Arguments:
..................................

OBJECT—an object.

Compound Type Specifier Description:
....................................

This denotes the set containing the named OBJECTS.  An object is of this
type if and only if it is ‘eql’ to one of the specified OBJECTS.

The type specifiers ‘(member)’ and ‘nil’ are equivalent.  * can be among
the OBJECTS, but if so it denotes itself (the symbol *) and does not
represent an unspecified value.  The symbol member is not valid as a
type specifier; and, specifically, it is not an abbreviation for either
‘(member)’ or ‘(member *)’.

See Also:
.........

the type ‘eql’


File: ansicl,  Node: not (Type Specifier),  Next: and (Type Specifier),  Prev: member (Type Specifier),  Up: Types and Classes

not (Type Specifier)
====================

Compound Type Specifier Kind:
.............................

Combining.

Compound Type Specifier Syntax:
...............................

(not typespec)

Compound Type Specifier Arguments:
..................................

TYPESPEC—a type specifier.

Compound Type Specifier Description:
....................................

This denotes the set of all objects that are not of the type TYPESPEC.

The argument is required, and cannot be *.

The symbol ‘not’ is not valid as a type specifier.


File: ansicl,  Node: and (Type Specifier),  Next: or (Type Specifier),  Prev: not (Type Specifier),  Up: Types and Classes

and (Type Specifier)
====================

Compound Type Specifier Kind:
.............................

Combining.

Compound Type Specifier Syntax:
...............................

(and {typespec}*)

Compound Type Specifier Arguments:
..................................

TYPESPEC—a type specifier.

Compound Type Specifier Description:
....................................

This denotes the set of all objects of the type determined by the
intersection of the TYPESPECS.

* is not permitted as an argument.

The type specifiers ‘(and)’ and ‘t’ are equivalent.  The symbol and is
not valid as a type specifier, and, specifically, it is not an
abbreviation for ‘(and)’.


File: ansicl,  Node: or (Type Specifier),  Next: values (Type Specifier),  Prev: and (Type Specifier),  Up: Types and Classes

or (Type Specifier)
===================

Compound Type Specifier Kind:
.............................

Combining.

Compound Type Specifier Syntax:
...............................

(or {typespec}*)

Compound Type Specifier Arguments:
..................................

TYPESPEC—a type specifier.

Compound Type Specifier Description:
....................................

This denotes the set of all objects of the type determined by the union
of the TYPESPECS.  For example, the type ‘list’ by definition is the
same as ‘(or null cons)’.  Also, the value returned by ‘position’ is an
object of type ‘(or null (integer 0 *))’; i.e., either ‘nil’ or a
non-negative integer.

* is not permitted as an argument.

The type specifiers ‘(or)’ and ‘nil’ are equivalent.  The symbol ‘or’ is
not valid as a type specifier; and, specifically, it is not an
abbreviation for ‘(or)’.


File: ansicl,  Node: values (Type Specifier),  Next: eql (Type Specifier),  Prev: or (Type Specifier),  Up: Types and Classes

values (Type Specifier)
=======================

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(values ↓value-typespec)

VALUE-TYPESPEC::=
     {typespec}* [&optional {typespec}*] [&rest typespec]
     [‘&allow-other-keys’]

Compound Type Specifier Arguments:
..................................

TYPESPEC—a type specifier.

Compound Type Specifier Description:
....................................

This type specifier can be used only as the VALUE-TYPE in a ‘function’
type specifier or a ‘the’ special form.  It is used to specify
individual types when multiple values are involved.  The ‘&optional’ and
‘&rest’ markers can appear in the VALUE-TYPE list; they indicate the
parameter list of a function that, when given to ‘multiple-value-call’
along with the values, would correctly receive those values.

The symbol * may not be among the VALUE-TYPES.

The symbol values is not valid as a type specifier; and, specifically,
it is not an abbreviation for ‘(values)’.


File: ansicl,  Node: eql (Type Specifier),  Next: coerce,  Prev: values (Type Specifier),  Up: Types and Classes

eql (Type Specifier)
====================

Compound Type Specifier Kind:
.............................

Combining.

Compound Type Specifier Syntax:
...............................

(eql object)

Compound Type Specifier Arguments:
..................................

OBJECT—an object.

Compound Type Specifier Description:
....................................

Represents the type of all X for which ‘(eql OBJECT X)’ is true.

The argument OBJECT is required.  The OBJECT can be *, but if so it
denotes itself (the symbol *) and does not represent an unspecified
value.  The symbol eql is not valid as an atomic type specifier.


File: ansicl,  Node: coerce,  Next: deftype,  Prev: eql (Type Specifier),  Up: Types and Classes

coerce (Function)
=================

Syntax:
.......

 -- Function: coerce object result-type → result

Arguments and Values:
.....................

OBJECT—an object.

RESULT-TYPE—a type specifier.

RESULT—an object, of type RESULT-TYPE except in situations described in
*note Section 12.1.5.3 (Rule of Canonical Representation for Complex
Rationals): RuleOfCanonRepForComplexRationals.

Description:
............

Coerces the OBJECT to type RESULT-TYPE.

If OBJECT is already of type RESULT-TYPE, the OBJECT itself is returned,
regardless of whether it would have been possible in general to coerce
an object of some other type to RESULT-TYPE.

Otherwise, the OBJECT is coerced to type RESULT-TYPE according to the
following rules:

‘sequence’

     If the RESULT-TYPE is a recognizable subtype of ‘list’, and the
     object is a sequence, then the RESULT is a list that has the same
     elements as OBJECT.

     If the RESULT-TYPE is a recognizable subtype of ‘vector’, and the
     object is a sequence, then the RESULT is a vector that has the same
     elements as OBJECT.  If RESULT-TYPE is a specialized type, the
     RESULT has an actual array element type that is the result of
     upgrading the element type part of that specialized type.  If no
     element type is specified, the element type defaults to ‘t’.  If
     the implementation cannot determine the element type, an error is
     signaled.

‘character’

     If the RESULT-TYPE is ‘character’ and the object is a character
     designator, the RESULT is the character it denotes.

‘complex’

     If the RESULT-TYPE is ‘complex’ and the object is a real, then the
     RESULT is obtained by constructing a complex whose real part is the
     object and whose imaginary part is the result of coercing an
     integer zero to the type of the object (using ‘coerce’).  (If the
     real part is a rational, however, then the result must be
     represented as a rational rather than a complex; see *note Section
     12.1.5.3 (Rule of Canonical Representation for Complex Rationals):
     RuleOfCanonRepForComplexRationals.  So, for example, ‘(coerce 3
     'complex)’ is permissible, but will return ‘3’, which is not a
     complex.)

‘float’

     If the RESULT-TYPE is any of ‘float’, ‘short-float’,
     ‘single-float’, ‘double-float’, ‘long-float’, and the object is a
     real, then the RESULT is a float of type RESULT-TYPE which is equal
     in sign and magnitude to the object to whatever degree of
     representational precision is permitted by that float
     representation.  (If the RESULT-TYPE is ‘float’ and OBJECT is not
     already a float, then the RESULT is a single float.)

‘function’

     If the RESULT-TYPE is ‘function’, and OBJECT is any function name
     that is fbound but that is globally defined neither as a macro name
     nor as a special operator, then the RESULT is the functional value
     of OBJECT.

     If the RESULT-TYPE is ‘function’, and OBJECT is a lambda
     expression, then the RESULT is a closure of OBJECT in the null
     lexical environment.

‘t’

     Any OBJECT can be coerced to an object of type ‘t’.  In this case,
     the OBJECT is simply returned.

Examples:
.........

      (coerce '(a b c) 'vector) → #(A B C)
      (coerce 'a 'character) → #\A
      (coerce 4.56 'complex) → #C(4.56 0.0)
      (coerce 4.5s0 'complex) → #C(4.5s0 0.0s0)
      (coerce 7/2 'complex) → 7/2
      (coerce 0 'short-float) → 0.0s0
      (coerce 3.5L0 'float) → 3.5L0
      (coerce 7/2 'float) → 3.5
      (coerce (cons 1 2) t) → (1 . 2)

All the following forms should signal an error:

      (coerce '(a b c) '(vector * 4))
      (coerce #(a b c) '(vector * 4))
      (coerce '(a b c) '(vector * 2))
      (coerce #(a b c) '(vector * 2))
      (coerce "foo" '(string 2))
      (coerce #(#\a #\b #\c) '(string 2))
      (coerce '(0 1) '(simple-bit-vector 3))

Exceptional Situations:
.......................

If a coercion is not possible, an error of type ‘type-error’ is
signaled.

‘(coerce x 'nil)’ always signals an error of type ‘type-error’.

An error of type ‘error’ is signaled if the RESULT-TYPE is ‘function’
but OBJECT is a symbol that is not fbound or if the symbol names a macro
or a special operator.

An error of type ‘type-error’ should be signaled if RESULT-TYPE
specifies the number of elements and OBJECT is of a different length.

See Also:
.........

*note rational::, *note floor::, *note char-code::, *note char-int::

Notes:
......

Coercions from floats to rationals and from ratios to integers are not
provided because of rounding problems.

      (coerce x 't) ≡ (identity x) ≡ x


File: ansicl,  Node: deftype,  Next: subtypep,  Prev: coerce,  Up: Types and Classes

deftype (Macro)
===============

Syntax:
.......

 -- Macro: deftype name lambda-list 〚{declaration}* | documentation〛
          {form}* → name

Arguments and Values:
.....................

NAME—a symbol.

LAMBDA-LIST—a deftype lambda list.

DECLARATION—a declare expression; not evaluated.

DOCUMENTATION—a string; not evaluated.

FORM—a form.

Description:
............

‘deftype’ defines a derived type specifier named NAME.

The meaning of the new type specifier is given in terms of a function
which expands the type specifier into another type specifier, which
itself will be expanded if it contains references to another derived
type specifier.

The newly defined type specifier may be referenced as a list of the form
‘(NAME ARG_1 ARG_2 ...)’.  The number of arguments must be appropriate
to the LAMBDA-LIST.  If the new type specifier takes no arguments, or if
all of its arguments are optional, the type specifier may be used as an
atomic type specifier.

The argument expressions to the type specifier, ARG_1 ... ARG_N, are not
evaluated.  Instead, these literal objects become the objects to which
corresponding parameters become bound.

The body of the ‘deftype’ form (but not the LAMBDA-LIST) is implicitly
enclosed in a block named NAME, and is evaluated as an implicit progn,
returning a new type specifier.

The lexical environment of the body is the one which was current at the
time the ‘deftype’ form was evaluated, augmented by the variables in the
LAMBDA-LIST.

Recursive expansion of the type specifier returned as the expansion must
terminate, including the expansion of type specifiers which are nested
within the expansion.

The consequences are undefined if the result of fully expanding a type
specifier contains any circular structure, except within the objects
referred to by ‘member’ and ‘eql’ type specifiers.

DOCUMENTATION is attached to NAME as a documentation string of kind
type.

If a ‘deftype’ form appears as a top level form, the compiler must
ensure that the NAME is recognized in subsequent type declarations.  The
programmer must ensure that the body of a ‘deftype’ form can be
evaluated at compile time if the NAME is referenced in subsequent type
declarations.  If the expansion of a type specifier is not defined fully
at compile time (perhaps because it expands into an unknown type
specifier or a ‘satisfies’ of a named function that isn’t defined in the
compile-time environment), an implementation may ignore any references
to this type in declarations and/or signal a warning.

Examples:
.........

      (defun equidimensional (a)
        (or (< (array-rank a) 2)
            (apply #'= (array-dimensions a)))) → EQUIDIMENSIONAL
      (deftype square-matrix (&optional type size)
        `(and (array ,type (,size ,size))
              (satisfies equidimensional))) → SQUARE-MATRIX

See Also:
.........

*note declare::, *note defmacro::, *note documentation::, *note Section
4.2.3 (Type Specifiers): Type Specifiers, *note Section 3.4.11
(Syntactic Interaction of Documentation Strings and Declarations):
Syntactic Interaction of Documentation Strings and Declarations.


File: ansicl,  Node: subtypep,  Next: type-of,  Prev: deftype,  Up: Types and Classes

subtypep (Function)
===================

Syntax:
.......

 -- Function: subtypep type-1 type-2 &optional environment → subtype-p,
          valid-p

Arguments and Values:
.....................

TYPE-1—a type specifier.

TYPE-2—a type specifier.

ENVIRONMENT—an environment object.  The default is ‘nil’, denoting the
null lexical environment and the current global environment.

SUBTYPE-P—a generalized boolean.

VALID-P—a generalized boolean.

Description:
............

If TYPE-1 is a recognizable subtype of TYPE-2, the first value is true.
Otherwise, the first value is false, indicating that either TYPE-1 is
not a subtype of TYPE-2, or else TYPE-1 is a subtype of TYPE-2 but is
not a recognizable subtype.

A second value is also returned indicating the ‘certainty’ of the first
value.  If this value is true, then the first value is an accurate
indication of the subtype relationship.  (The second value is always
true when the first value is true.)

The next figure summarizes the possible combinations of values that
might result.

Value 1   Value 2   Meaning
---------------------------------------------------------------------------
true      true      TYPE-1 is definitely a subtype of TYPE-2.
false     true      TYPE-1 is definitely not a subtype of TYPE-2.
false     false     ‘subtypep’ could not determine the relationship,
                    so TYPE-1 might or might not be a subtype of TYPE-2.

Figure 4.9: Result possibilities for subtypep

‘subtypep’ is permitted to return the values false and false only when
at least one argument involves one of these type specifiers: ‘and’,
‘eql’, the list form of ‘function’, ‘member’, ‘not’, ‘or’, ‘satisfies’,
or ‘values’.  (A type specifier ‘involves’ such a symbol if, after being
type expanded, it contains that symbol in a position that would call for
its meaning as a type specifier to be used.)  One consequence of this is
that if neither TYPE-1 nor TYPE-2 involves any of these type specifiers,
then ‘subtypep’ is obliged to determine the relationship accurately.  In
particular, ‘subtypep’ returns the values true and true if the arguments
are ‘equal’ and do not involve any of these type specifiers.

‘subtypep’ never returns a second value of ‘nil’ when both TYPE-1 and
TYPE-2 involve only the names in *note Figure 4.2:
StandardizedAtomicTypeSpecs, or names of types defined by ‘defstruct’,
‘define-condition’, or ‘defclass’, or derived types that expand into
only those names.  While type specifiers listed in *note Figure 4.2:
StandardizedAtomicTypeSpecs. and names of ‘defclass’ and ‘defstruct’ can
in some cases be implemented as derived types, ‘subtypep’ regards them
as primitive.

The relationships between types reflected by ‘subtypep’ are those
specific to the particular implementation.  For example, if an
implementation supports only a single type of floating-point numbers, in
that implementation ‘(subtypep 'float 'long-float)’ returns the values
true and true (since the two types are identical).

For all T1 and T2 other than ‘*’, ‘(array T1)’ and ‘(array T2)’ are two
different type specifiers that always refer to the same sets of things
if and only if they refer to arrays of exactly the same specialized
representation, i.e., if ‘(upgraded-array-element-type 'T1)’ and
‘(upgraded-array-element-type 'T2)’ return two different type specifiers
that always refer to the same sets of objects.  This is another way of
saying that ‘`(array TYPE-SPECIFIER)’ and ‘`(array
,(upgraded-array-element-type 'TYPE-SPECIFIER))’ refer to the same set
of specialized array representations.  For all T1 and T2 other than ‘*’,
the intersection of ‘(array T1)’ and ‘(array T2)’ is the empty set if
and only if they refer to arrays of different, distinct specialized
representations.

Therefore,

      (subtypep '(array T1) '(array T2)) → true

if and only if

      (upgraded-array-element-type 'T1)  and
      (upgraded-array-element-type 'T2)

return two different type specifiers that always refer to the same sets
of objects.

For all type-specifiers T1 and T2 other than ‘*’,

      (subtypep '(complex T1) '(complex T2)) → true, true

if:

  1. ‘T1’ is a subtype of ‘T2’, or
  2. ‘(upgraded-complex-part-type 'T1)’ and ‘(upgraded-complex-part-type
     'T2)’ return two different type specifiers that always refer to the
     same sets of objects; in this case, ‘(complex T1)’ and ‘(complex
     T2)’ both refer to the same specialized representation.

The values are false and true otherwise.

The form

      (subtypep '(complex single-float) '(complex float))

must return true in all implementations, but

      (subtypep '(array single-float) '(array float))

returns true only in implementations that do not have a specialized
array representation for single floats distinct from that for other
floats.

Examples:
.........

      (subtypep 'compiled-function 'function) → true, true
      (subtypep 'null 'list) → true, true
      (subtypep 'null 'symbol) → true, true
      (subtypep 'integer 'string) → false, true
      (subtypep '(satisfies dummy) nil) → false, implementation-dependent
      (subtypep '(integer 1 3) '(integer 1 4)) → true, true
      (subtypep '(integer (0) (0)) 'nil) → true, true
      (subtypep 'nil '(integer (0) (0))) → true, true
      (subtypep '(integer (0) (0)) '(member)) → true, true ;or false, false
      (subtypep '(member) 'nil) → true, true ;or false, false
      (subtypep 'nil '(member)) → true, true ;or false, false

Let ‘<aet-x>’ and ‘<aet-y>’ be two distinct type specifiers that do not
always refer to the same sets of objects in a given implementation, but
for which ‘make-array’, will return an object of the same array type.

Thus, in each case,

       (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))
                 (array-element-type (make-array 0 :element-type '<aet-y>)))
     → true, true

       (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))
                 (array-element-type (make-array 0 :element-type '<aet-x>)))
     → true, true

If ‘(array <aet-x>)’ and ‘(array <aet-y>)’ are different names for
exactly the same set of objects, these names should always refer to the
same sets of objects.  That implies that the following set of tests are
also true:

      (subtypep '(array <aet-x>) '(array <aet-y>)) → true, true
      (subtypep '(array <aet-y>) '(array <aet-x>)) → true, true

See Also:
.........

*note Section 4.2 (Types): Types.

Notes:
......

The small differences between the ‘subtypep’ specification for the
‘array’ and ‘complex’ types are necessary because there is no creation
function for complexes which allows the specification of the resultant
part type independently of the actual types of the parts.  Thus in the
case of the type ‘complex’, the actual type of the parts is referred to,
although a number can be a member of more than one type.  For example,
‘17’ is of type ‘(mod 18)’ as well as type ‘(mod 256)’ and type
‘integer’; and ‘2.3f5’ is of type ‘single-float’ as well as type
‘float’.


File: ansicl,  Node: type-of,  Next: typep,  Prev: subtypep,  Up: Types and Classes

type-of (Function)
==================

Syntax:
.......

 -- Function: type-of object → typespec

Arguments and Values:
.....................

OBJECT—an object.

TYPESPEC—a type specifier.

Description:
............

Returns a type specifier, TYPESPEC, for a type that has the OBJECT as an
element.  The TYPESPEC satisfies the following:

  1. For any OBJECT that is an element of some built-in type:

       a. the type returned is a recognizable subtype of that built-in
          type.

       b. the type returned does not involve ‘and’, ‘eql’, ‘member’,
          ‘not’, ‘or’, ‘satisfies’, or ‘values’.

  2. For all OBJECTS, ‘(typep OBJECT (type-of OBJECT))’ returns true.
     Implicit in this is that type specifiers which are not valid for
     use with ‘typep’, such as the list form of the ‘function’ type
     specifier, are never returned by ‘type-of’.

  3. The type returned by ‘type-of’ is always a recognizable subtype of
     the class returned by ‘class-of’.  That is,

           (subtypep (type-of OBJECT) (class-of OBJECT)) → true, true

  4. For OBJECTS of metaclass ‘structure-class’ or ‘standard-class’, and
     for conditions, ‘type-of’ returns the proper name of the class
     returned by ‘class-of’ if it has a proper name, and otherwise
     returns the class itself.  In particular, for OBJECTS created by
     the constructor function of a structure defined with ‘defstruct’
     without a :type option, ‘type-of’ returns the structure name; and
     for OBJECTS created by ‘make-condition’, the TYPESPEC is the name
     of the condition type.

  5. For each of the types ‘short-float’, ‘single-float’,
     ‘double-float’, or ‘long-float’ of which the OBJECT is an element,
     the TYPESPEC is a recognizable subtype of that type.

Examples:
.........


      (type-of 'a) → SYMBOL
      (type-of '(1 . 2))
     → CONS
     or→ (CONS FIXNUM FIXNUM)
      (type-of #c(0 1))
     → COMPLEX
     or→ (COMPLEX INTEGER)
      (defstruct temp-struct x y z) → TEMP-STRUCT
      (type-of (make-temp-struct)) → TEMP-STRUCT
      (type-of "abc")
     → STRING
     or→ (STRING 3)
      (subtypep (type-of "abc") 'string) → true, true
      (type-of (expt 2 40))
     → BIGNUM
     or→ INTEGER
     or→ (INTEGER 1099511627776 1099511627776)
     or→ SYSTEM::TWO-WORD-BIGNUM
     or→ FIXNUM
      (subtypep (type-of 112312) 'integer) → true, true
      (defvar *foo* (make-array 5 :element-type t)) → *FOO*
      (class-name (class-of *foo*)) → VECTOR
      (type-of *foo*)
     → VECTOR
     or→ (VECTOR T 5)

See Also:
.........

*note array-element-type::, *note class-of::, *note defstruct::, *note
typecase::, *note typep::, *note Section 4.2 (Types): Types.

Notes:
......

Implementors are encouraged to arrange for ‘type-of’ to return a
portable value.


File: ansicl,  Node: typep,  Next: type-error,  Prev: type-of,  Up: Types and Classes

typep (Function)
================

Syntax:
.......

 -- Function: typep object type-specifier &optional environment →
          generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

TYPE-SPECIFIER—any type specifier except values, or a type specifier
list whose first element is either function or values.

ENVIRONMENT—an environment object.  The default is ‘nil’, denoting the
null lexical environment and the and current global environment.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of the type specified by TYPE-SPECIFIER;
otherwise, returns false.

A TYPE-SPECIFIER of the form ‘(satisfies fn)’ is handled by applying the
function ‘fn’ to OBJECT.

‘(typep OBJECT '(array TYPE-SPECIFIER))’, where TYPE-SPECIFIER is not
‘*’, returns true if and only if OBJECT is an array that could be the
result of supplying TYPE-SPECIFIER as the :element-type argument to
‘make-array’.  ‘(array *)’ refers to all arrays regardless of element
type, while ‘(array TYPE-SPECIFIER)’ refers only to those arrays that
can result from giving TYPE-SPECIFIER as the :element-type argument to
‘make-array’.  A similar interpretation applies to ‘(simple-array
TYPE-SPECIFIER)’ and ‘(vector TYPE-SPECIFIER)’.  See *note Section
15.1.2.1 (Array Upgrading): ArrayUpgrading.

‘(typep OBJECT '(complex TYPE-SPECIFIER))’ returns true for all complex
numbers that can result from giving numbers of type TYPE-SPECIFIER to
the function ‘complex’, plus all other complex numbers of the same
specialized representation.  Both the real and the imaginary parts of
any such complex number must satisfy:

      (typep realpart 'type-specifier)
      (typep imagpart 'type-specifier)

See the function *note upgraded-complex-part-type::.

Examples:
.........

      (typep 12 'integer) → true
      (typep (1+ most-positive-fixnum) 'fixnum) → false
      (typep nil t) → true
      (typep nil nil) → false
      (typep 1 '(mod 2)) → true
      (typep #c(1 1) '(complex (eql 1))) → true
     ;; To understand this next example, you might need to refer to
     ;; *note Section 12.1.5.3 (Rule of Canonical Representation for Complex Rationals): RuleOfCanonRepForComplexRationals.
      (typep #c(0 0) '(complex (eql 0))) → false

Let ‘Adenote different types, but for which ’
      (upgraded-array-element-type 'A

and

      (upgraded-array-element-type 'A

denote the same type.  Notice that

      (typep (make-array 0 :element-type 'A (typep (make-array 0 :element-type 'A (typep (make-array 0 :element-type 'A (typep (make-array 0 :element-type 'A

Exceptional Situations:
.......................

An error of type ‘error’ is signaled if TYPE-SPECIFIER is ‘values’, or a
type specifier list whose first element is either function or values.

The consequences are undefined if the TYPE-SPECIFIER is not a type
specifier.

See Also:
.........

*note type-of::, *note upgraded-array-element-type::, *note
upgraded-complex-part-type::, *note Section 4.2.3 (Type Specifiers):
Type Specifiers.

Notes:
......

Implementations are encouraged to recognize and optimize the case of
‘(typep X (the class Y))’, since it does not involve any need for
expansion of ‘deftype’ information at runtime.




File: ansicl,  Node: type-error,  Next: type-error-datum; type-error-expected-type,  Prev: typep,  Up: Types and Classes

type-error (Condition Type)
===========================

Class Precedence List:
......................

‘type-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘type-error’ represents a situation in which an object is not
of the expected type.  The “offending datum” and “expected type” are
initialized by the initialization arguments named :datum and
:expected-type to ‘make-condition’, and are accessed by the functions
‘type-error-datum’ and ‘type-error-expected-type’.

See Also:
.........

*note type-error-datum::, *note type-error-expected-type::


File: ansicl,  Node: type-error-datum; type-error-expected-type,  Next: simple-type-error,  Prev: type-error,  Up: Types and Classes

type-error-datum, type-error-expected-type (Function)
=====================================================

Syntax:
.......

 -- Function: type-error-datum condition → datum
 -- Function: type-error-expected-type condition → expected-type

Arguments and Values:
.....................

CONDITION—a condition of type ‘type-error’.

DATUM—an object.

EXPECTED-TYPE—a type specifier.

Description:
............

‘type-error-datum’ returns the offending datum in the situation
represented by the CONDITION.

‘type-error-expected-type’ returns the expected type of the offending
datum in the situation represented by the CONDITION.

Examples:
.........

      (defun fix-digits (condition)
        (check-type condition type-error)
        (let* ((digits '(zero one two three four
                        five six seven eight nine))
              (val (position (type-error-datum condition) digits)))
          (if (and val (subtypep 'fixnum (type-error-expected-type condition)))
              (store-value 7))))

      (defun foo (x)
        (handler-bind ((type-error #'fix-digits))
          (check-type x number)
          (+ x 3)))

      (foo 'seven)
     → 10

See Also:
.........

*note type-error::, *note Chapter 9 (Conditions): Conditions.


File: ansicl,  Node: simple-type-error,  Prev: type-error-datum; type-error-expected-type,  Up: Types and Classes

simple-type-error (Condition Type)
==================================

Class Precedence List:
......................

‘simple-type-error’, ‘simple-condition’, ‘type-error’, ‘error’,
‘serious-condition’, ‘condition’, ‘t’

Description:
............

Conditions of type ‘simple-type-error’ are like conditions of type
‘type-error’, except that they provide an alternate mechanism for
specifying how the condition is to be reported; see the type *note
simple-condition::.

See Also:
.........

*note simple-condition::, *note simple-condition-format-control::, *note
simple-condition-format-arguments::, *note type-error-datum::, *note
type-error-expected-type::


File: ansicl,  Node: Data and Control Flow,  Next: Iteration,  Prev: Types and Classes,  Up: Top

5 Data and Control Flow
***********************

* Menu:

* Generalized Reference::
* Transfer of Control to an Exit Point::

Dictionary

* apply::
* defun::
* fdefinition::
* fboundp::
* fmakunbound::
* flet; labels; macrolet::
* funcall::
* function (Special Operator)::
* function-lambda-expression::
* functionp::
* compiled-function-p::
* call-arguments-limit::
* lambda-list-keywords::
* lambda-parameters-limit::
* defconstant::
* defparameter; defvar::
* destructuring-bind::
* let; let*::
* progv::
* setq::
* psetq::
* block::
* catch::
* go::
* return-from::
* return::
* tagbody::
* throw::
* unwind-protect::
* nil (Constant Variable)::
* not (Function)::
* t (Constant Variable)::
* eq::
* eql (Function)::
* equal::
* equalp::
* identity::
* complement::
* constantly::
* every; some; notevery; notany::
* and (Macro)::
* cond::
* if::
* or (Macro)::
* when; unless::
* case; ccase; ecase::
* typecase; ctypecase; etypecase::
* multiple-value-bind::
* multiple-value-call::
* multiple-value-list::
* multiple-value-prog1::
* multiple-value-setq::
* values (Accessor)::
* values-list::
* multiple-values-limit::
* nth-value::
* prog; prog*::
* prog1; prog2::
* progn::
* define-modify-macro::
* defsetf::
* define-setf-expander::
* get-setf-expansion::
* setf; psetf::
* shiftf::
* rotatef::
* control-error::
* program-error::
* undefined-function::


File: ansicl,  Node: Generalized Reference,  Next: Transfer of Control to an Exit Point,  Up: Data and Control Flow

5.1 Generalized Reference
=========================

* Menu:

* Overview of Places and Generalized Reference::
* Kinds of Places::
* Treatment of Other Macros Based on SETF::


File: ansicl,  Node: Overview of Places and Generalized Reference,  Next: Kinds of Places,  Up: Generalized Reference

5.1.1 Overview of Places and Generalized Reference
--------------------------------------------------

A “generalized reference” is the use of a form, sometimes called a
“place”, as if it were a variable that could be read and written.  The
value of a place is the object to which the place form evaluates.  The
value of a place can be changed by using ‘setf’.  The concept of binding
a place is not defined in Common Lisp, but an implementation is
permitted to extend the language by defining this concept.

The next figure contains examples of the use of ‘setf’.  Note that the
values returned by evaluating the forms in column two are not
necessarily the same as those obtained by evaluating the forms in column
three.  In general, the exact macro expansion of a ‘setf’ form is not
guaranteed and can even be implementation-dependent; all that is
guaranteed is that the expansion is an update form that works for that
particular implementation, that the left-to-right evaluation of subforms
is preserved, and that the ultimate result of evaluating ‘setf’ is the
value or values being stored.

Access function      Update Function      Update using ‘setf’
----------------------------------------------------------------------------
‘x’                  ‘(setq x datum)’     ‘(setf x datum)’
‘(car x)’            ‘(rplaca x datum)’   ‘(setf (car x) datum)’
‘(symbol-value x)’   ‘(set x datum)’      ‘(setf (symbol-value x) datum)’

Figure 5.1: Examples of setf

The next figure shows operators relating to places and generalized
reference.

assert                 defsetf              push
ccase                  get-setf-expansion   remf
ctypecase              getf                 rotatef
decf                   incf                 setf
define-modify-macro    pop                  shiftf
define-setf-expander   psetf

Figure 5.2: Operators relating to places and generalized reference.

Some of the operators above manipulate places and some manipulate setf
expanders.  A setf expansion can be derived from any place.  New setf
expanders can be defined by using ‘defsetf’ and ‘define-setf-expander’.

5.1.1.1 Evaluation of Subforms to Places
........................................

The following rules apply to the evaluation of subforms in a place:

  1. The evaluation ordering of subforms within a place is determined by
     the order specified by the second value returned by
     ‘get-setf-expansion’.  For all places defined by this specification
     (e.g., ‘getf’, ‘ldb’, ...), this order of evaluation is
     left-to-right.  When a place is derived from a macro expansion,
     this rule is applied after the macro is expanded to find the
     appropriate place.

     Places defined by using ‘defmacro’ or ‘define-setf-expander’ use
     the evaluation order defined by those definitions.  For example,
     consider the following:

           (defmacro wrong-order (x y) `(getf ,y ,x))

     This following form evaluates ‘place2’ first and then ‘place1’
     because that is the order they are evaluated in the macro
     expansion:

           (push value (wrong-order place1 place2))

  2. For the macros that manipulate places (‘push’, ‘pushnew’, ‘remf’,
     ‘incf’, ‘decf’, ‘shiftf’, ‘rotatef’, ‘psetf’, ‘setf’, ‘pop’, and
     those defined by ‘define-modify-macro’) the subforms of the macro
     call are evaluated exactly once in left-to-right order, with the
     subforms of the places evaluated in the order specified in (1).

     ‘push’, ‘pushnew’, ‘remf’, ‘incf’, ‘decf’, ‘shiftf’, ‘rotatef’,
     ‘psetf’, ‘pop’ evaluate all subforms before modifying any of the
     place locations.  ‘setf’ (in the case when ‘setf’ has more than two
     arguments) performs its operation on each pair in sequence.  For
     example, in

           (setf place1 value1 place2 value2 ...)

     the subforms of ‘place1’ and ‘value1’ are evaluated, the location
     specified by ‘place1’ is modified to contain the value returned by
     ‘value1’, and then the rest of the ‘setf’ form is processed in a
     like manner.

  3. For ‘check-type’, ‘ctypecase’, and ‘ccase’, subforms of the place
     are evaluated once as in (1), but might be evaluated again if the
     type check fails in the case of ‘check-type’ or none of the cases
     hold in ‘ctypecase’ and ‘ccase’.

  4. For ‘assert’, the order of evaluation of the generalized references
     is not specified.

Rules 2, 3 and 4 cover all standardized macros that manipulate places.

5.1.1.1.1 Examples of Evaluation of Subforms to Places
......................................................

      (let ((ref2 (list '())))
        (push (progn (princ "1") 'ref-1)
              (car (progn (princ "2") ref2))))
     ▷ 12
     → (REF1)

      (let (x)
         (push (setq x (list 'a))
               (car (setq x (list 'b))))
          x)
     → (((A) . B))

‘push’ first evaluates ‘(setq x (list 'a)) → (a)’, then evaluates ‘(setq
x (list 'b)) → (b)’, then modifies the car of this latest value to be
‘((a) . b)’.

5.1.1.2 Setf Expansions
.......................

Sometimes it is possible to avoid evaluating subforms of a place
multiple times or in the wrong order.  A setf expansion for a given
access form can be expressed as an ordered collection of five objects:

List of temporary variables

     a list of symbols naming temporary variables to be bound
     sequentially, as if by ‘let*’, to values resulting from value
     forms.

List of value forms

     a list of forms (typically, subforms of the place) which when
     evaluated yield the values to which the corresponding temporary
     variables should be bound.

List of store variables

     a list of symbols naming temporary store variables which are to
     hold the new values that will be assigned to the place.

Storing form

     a form which can reference both the temporary and the store
     variables, and which changes the value of the place and guarantees
     to return as its values the values of the store variables, which
     are the correct values for ‘setf’ to return.

Accessing form

     a form which can reference the temporary variables, and which
     returns the value of the place.

The value returned by the accessing form is affected by execution of the
storing form, but either of these forms might be evaluated any number of
times.

It is possible to do more than one ‘setf’ in parallel via ‘psetf’,
‘shiftf’, and ‘rotatef’.  Because of this, the setf expander must
produce new temporary and store variable names every time.  For examples
of how to do this, see ‘gensym’.

For each standardized accessor function F, unless it is explicitly
documented otherwise, it is implementation-dependent whether the ability
to use an F form as a ‘setf’ place is implemented by a setf expander or
a setf function.  Also, it follows from this that it is
implementation-dependent whether the name ‘(setf F)’ is fbound.

5.1.1.2.1 Examples of Setf Expansions
.....................................

Examples of the contents of the constituents of setf expansions follow.

For a variable X:

‘()’               ;list of temporary variables
‘()’               ;list of value forms
‘(g0001)’          ;list of store variables
‘(setq X g0001)’   ;storing form
X                  ;accessing form

Figure 5.3: Sample Setf Expansion of a Variable

For ‘(car EXP)’:

‘(g0002)’                              ;list of temporary variables
‘(EXP)’                                ;list of value forms
‘(g0003)’                              ;list of store variables
‘(progn (rplaca g0002 g0003) g0003)’   ;storing form
‘(car g0002)’                          ;accessing form

Figure 5.4: Sample Setf Expansion of a CAR Form

For ‘(subseq SEQ S E)’:

‘(g0004 g0005 g0006)’                           ;list of temporary variables
‘(SEQ S E)’                                     ;list of value forms
‘(g0007)’                                       ;list of store variables
‘(progn (replace g0004 g0007 :start1 g0005
:end1 g0006) g0007)’
                                                ;storing form
‘(subseq g0004 g0005 g0006)’                    ; accessing form

Figure 5.5: Sample Setf Expansion of a SUBSEQ Form

In some cases, if a subform of a place is itself a place, it is
necessary to expand the subform in order to compute some of the values
in the expansion of the outer place.  For ‘(ldb BS (car EXP))’:

‘(g0001 g0002)’                                 ;list of temporary variables
‘(BS EXP)’                                      ;list of value forms
‘(g0003)’                                       ;list of store variables
‘(progn (rplaca g0002 (dpb g0003 g0001 (car
g0002))) g0003)’
                                                ;storing form
‘(ldb g0001 (car g0002))’                       ; accessing form

Figure 5.6: Sample Setf Expansion of a LDB Form


File: ansicl,  Node: Kinds of Places,  Next: Treatment of Other Macros Based on SETF,  Prev: Overview of Places and Generalized Reference,  Up: Generalized Reference

5.1.2 Kinds of Places
---------------------

Several kinds of places are defined by Common Lisp; this section
enumerates them.  This set can be extended by implementations and by
programmer code.

5.1.2.1 Variable Names as Places
................................

The name of a lexical variable or dynamic variable can be used as a
place.

5.1.2.2 Function Call Forms as Places
.....................................

A function form can be used as a place if it falls into one of the
following categories:

   • A function call form whose first element is the name of any one of
     the functions in the next figure.

     aref     cdadr                     get
     bit      cdar                      gethash
     caaaar   cddaar                    logical-pathname-translations
     caaadr   cddadr                    macro-function
     caaar    cddar                     ninth
     caadar   cdddar                    nth
     caaddr   cddddr                    readtable-case
     caadr    cdddr                     rest
     caar     cddr                      row-major-aref
     cadaar   cdr                       sbit
     cadadr   char                      schar
     cadar    class-name                second
     caddar   compiler-macro-function   seventh
     cadddr   documentation             sixth
     caddr    eighth                    slot-value
     cadr     elt                       subseq
     car      fdefinition               svref
     cdaaar   fifth                     symbol-function
     cdaadr   fill-pointer              symbol-plist
     cdaar    find-class                symbol-value
     cdadar   first                     tenth
     cdaddr   fourth                    third

     Figure 5.7: Functions that setf can be used with—1

     In the case of ‘subseq’, the replacement value must be a sequence
     whose elements might be contained by the sequence argument to
     ‘subseq’, but does not have to be a sequence of the same type as
     the sequence of which the subsequence is specified.  If the length
     of the replacement value does not equal the length of the
     subsequence to be replaced, then the shorter length determines the
     number of elements to be stored, as for ‘replace’.

   • A function call form whose first element is the name of a selector
     function constructed by ‘defstruct’.  The function name must refer
     to the global function definition, rather than a locally defined
     function.

   • A function call form whose first element is the name of any one of
     the functions in the next figure, provided that the supplied
     argument to that function is in turn a place form; in this case the
     new place has stored back into it the result of applying the
     supplied “update” function.

     Function       Argument that is a PLACE   Update function used
     name
     ---------------------------------------------------------------------
     ‘ldb’          second                     ‘dpb’
     ‘mask-field’   second                     ‘deposit-field’
     ‘getf’         first                      implementation-dependent

     Figure 5.8: Functions that setf can be used with—2

     During the ‘setf’ expansion of these forms, it is necessary to call
     ‘get-setf-expansion’ in order to figure out how the inner, nested
     generalized variable must be treated.

     The information from ‘get-setf-expansion’ is used as follows.

     ‘ldb’

          In a form such as:

          ‘(setf (ldb BYTE-SPEC PLACE-FORM) VALUE-FORM)’

          the place referred to by the PLACE-FORM must always be both
          read and written; note that the update is to the generalized
          variable specified by PLACE-FORM, not to any object of type
          ‘integer’.

          Thus this ‘setf’ should generate code to do the following:

            1. Evaluate BYTE-SPEC (and bind it into a temporary
               variable).
            2. Bind the temporary variables for PLACE-FORM.
            3. Evaluate VALUE-FORM (and bind its value or values into
               the store variable).
            4. Do the read from PLACE-FORM.
            5. Do the write into PLACE-FORM with the given bits of the
               integer fetched in step 4 replaced with the value from
               step 3.

          If the evaluation of VALUE-FORM in step 3 alters what is found
          in PLACE-FORM, such as setting different bits of integer, then
          the change of the bits denoted by BYTE-SPEC is to that altered
          integer, because step 4 is done after the VALUE-FORM
          evaluation.  Nevertheless, the evaluations required for
          binding the temporary variables are done in steps 1 and 2, and
          thus the expected left-to-right evaluation order is seen.  For
          example:

                (setq integer #x69) → #x69
                (rotatef (ldb (byte 4 4) integer)
                         (ldb (byte 4 0) integer))
                integer → #x96
               ;;; This example is trying to swap two independent bit fields
               ;;; in an integer.  Note that the generalized variable of
               ;;; interest here is just the (possibly local) program variable
               ;;; integer.

     ‘mask-field’

          This case is the same as ‘ldb’ in all essential aspects.

     ‘getf’

          In a form such as:

          ‘(setf (getf PLACE-FORM IND-FORM) VALUE-FORM)’

          the place referred to by PLACE-FORM must always be both read
          and written; note that the update is to the generalized
          variable specified by PLACE-FORM, not necessarily to the
          particular list that is the property list in question.

          Thus this ‘setf’ should generate code to do the following:

            1. Bind the temporary variables for PLACE-FORM.
            2. Evaluate IND-FORM (and bind it into a temporary
               variable).
            3. Evaluate VALUE-FORM (and bind its value or values into
               the store variable).
            4. Do the read from PLACE-FORM.
            5. Do the write into PLACE-FORM with a possibly-new property
               list obtained by combining the values from steps 2, 3,
               and 4.  (Note that the phrase “possibly-new property
               list” can mean that the former property list is somehow
               destructively re-used, or it can mean partial or full
               copying of it.  Since either copying or destructive
               re-use can occur, the treatment of the resultant value
               for the possibly-new property list must proceed as if it
               were a different copy needing to be stored back into the
               generalized variable.)

          If the evaluation of VALUE-FORM in step 3 alters what is found
          in PLACE-FORM, such as setting a different named property in
          the list, then the change of the property denoted by IND-FORM
          is to that altered list, because step 4 is done after the
          VALUE-FORM evaluation.  Nevertheless, the evaluations required
          for binding the temporary variables are done in steps 1 and 2,
          and thus the expected left-to-right evaluation order is seen.

          For example:

                (setq s (setq r (list (list 'a 1 'b 2 'c 3)))) → ((a 1 b 2 c 3))
                (setf (getf (car r) 'b)
                      (progn (setq r nil) 6)) → 6
                r → NIL
                s → ((A 1 B 6 C 3))
               ;;; Note that the (setq r nil) does not affect the actions of
               ;;; the SETF because the value of R had already been saved in
               ;;; a temporary variable as part of the step 1. Only the CAR
               ;;; of this value will be retrieved, and subsequently modified
               ;;; after the value computation.

5.1.2.3 VALUES Forms as Places
..............................

A ‘values’ form can be used as a place, provided that each of its
subforms is also a place form.

A form such as

‘(setf (values PLACE-1 ... PLACE-N) VALUES-FORM)’

does the following:

  1. The subforms of each nested PLACE are evaluated in left-to-right
     order.
  2. The VALUES-FORM is evaluated, and the first store variable from
     each PLACE is bound to its return values as if by
     ‘multiple-value-bind’.
  3. If the setf expansion for any PLACE involves more than one store
     variable, then the additional store variables are bound to ‘nil’.
  4. The storing forms for each PLACE are evaluated in left-to-right
     order.

The storing form in the setf expansion of ‘values’ returns as multiple
valuesvariables in step 2.  That is, the number of values returned is
the same as the number of place forms.  This may be more or fewer values
than are produced by the VALUES-FORM.

5.1.2.4 THE Forms as Places
...........................

A ‘the’ form can be used as a place, in which case the declaration is
transferred to the NEWVALUE form, and the resulting ‘setf’ is analyzed.
For example,

      (setf (the integer (cadr x)) (+ y 3))

is processed as if it were

      (setf (cadr x) (the integer (+ y 3)))

5.1.2.5 APPLY Forms as Places
.............................

The following situations involving ‘setf’ of ‘apply’ must be supported:

   • ‘(setf (apply #'aref ARRAY {subscript}* MORE-SUBSCRIPTS)
     NEW-ELEMENT)’
   • ‘(setf (apply #'bit ARRAY {subscript}* MORE-SUBSCRIPTS)
     NEW-ELEMENT)’
   • ‘(setf (apply #'sbit ARRAY {subscript}* MORE-SUBSCRIPTS)
     NEW-ELEMENT)’

In all three cases, the element of ARRAY designated by the concatenation
of SUBSCRIPTS and MORE-SUBSCRIPTS (i.e., the same element which would be
read by the call to apply if it were not part of a ‘setf’ form) is
changed to have the value given by NEW-ELEMENT.  For these usages, the
function name (‘aref’, ‘bit’, or ‘sbit’) must refer to the global
function definition, rather than a locally defined function.

No other standardized function is required to be supported, but an
implementation may define such support.  An implementation may also
define support for implementation-defined operators.

If a user-defined function is used in this context, the following
equivalence is true, except that care is taken to preserve proper
left-to-right evaluation of argument subforms:

      (setf (apply #'NAME {arg}*) VAL)
      ≡ (apply #'(setf NAME) VAL {arg}*)

5.1.2.6 Setf Expansions and Places
..................................

Any compound form for which the operator has a setf expander defined can
be used as a place.  The operator must refer to the global function
definition, rather than a locally defined function or macro.

5.1.2.7 Macro Forms as Places
.............................

A macro form can be used as a place, in which case Common Lisp expands
the macro form as if by ‘macroexpand-1’ and then uses the macro
expansion in place of the original place.  Such macro expansion is
attempted only after exhausting all other possibilities other than
expanding into a call to a function named ‘(setf READER)’.

5.1.2.8 Symbol Macros as Places
...............................

A reference to a symbol that has been established as a symbol macro can
be used as a place.  In this case, ‘setf’ expands the reference and then
analyzes the resulting form.

5.1.2.9 Other Compound Forms as Places
......................................

For any other compound form for which the operator is a symbol F, the
‘setf’ form expands into a call to the function named ‘(setf F)’.  The
first argument in the newly constructed function form is NEWVALUE and
the remaining arguments are the remaining elements of PLACE.  This
expansion occurs regardless of whether F or ‘(setf F)’ is defined as a
function locally, globally, or not at all.  For example,

‘(setf (F ARG1 ARG2 ...) NEW-VALUE)’

expands into a form with the same effect and value as

      (let ((#:temp-1 arg1)          ;force correct order of evaluation
            (#:temp-2 arg2)
            ...
            (#:temp-0 NEW-VALUE))
        (funcall (function (setf F)) #:temp-0 #:temp-1 #:temp-2...))

A function named ‘(setf F)’ must return its first argument as its only
value in order to preserve the semantics of ‘setf’.


File: ansicl,  Node: Treatment of Other Macros Based on SETF,  Prev: Kinds of Places,  Up: Generalized Reference

5.1.3 Treatment of Other Macros Based on SETF
---------------------------------------------

For each of the “read-modify-write” operators in the next figure, and
for any additional macros defined by the programmer using
‘define-modify-macro’, an exception is made to the normal rule of
left-to-right evaluation of arguments.  Evaluation of argument forms
occurs in left-to-right order, with the exception that for the PLACE
argument, the actual read of the “old value” from that PLACE happens
after all of the argument form evaluations, and just before a “new
value” is computed and written back into the PLACE.

Specifically, each of these operators can be viewed as involving a form
with the following general syntax:

      (operator {preceding-form}* PLACE {following-form}*)

The evaluation of each such form proceeds like this:

  1. Evaluate each of the PRECEDING-FORMS, in left-to-right order.
  2. Evaluate the subforms of the PLACE, in the order specified by the
     second value of the setf expansion for that PLACE.
  3. Evaluate each of the FOLLOWING-FORMS, in left-to-right order.
  4. Read the old value from PLACE.
  5. Compute the new value.
  6. Store the new value into PLACE.

decf   pop    pushnew
incf   push   remf

Figure 5.9: Read-Modify-Write Macros


File: ansicl,  Node: Transfer of Control to an Exit Point,  Next: apply,  Prev: Generalized Reference,  Up: Data and Control Flow

5.2 Transfer of Control to an Exit Point
========================================

When a transfer of control is initiated by ‘go’, ‘return-from’, or
‘throw’ the following events occur in order to accomplish the transfer
of control.  Note that for ‘go’, the exit point is the form within the
‘tagbody’ that is being executed at the time the ‘go’ is performed; for
‘return-from’, the exit point is the corresponding ‘block’ form; and for
‘throw’, the exit point is the corresponding ‘catch’ form.

  1. Intervening exit points are “abandoned” (i.e., their extent ends
     and it is no longer valid to attempt to transfer control through
     them).

  2. The cleanup clauses of any intervening ‘unwind-protect’ clauses are
     evaluated.

  3. Intervening dynamic bindings of ‘special’ variables, catch tags,
     condition handlers, and restarts are undone.

  4. The extent of the exit point being invoked ends, and control is
     passed to the target.

The extent of an exit being “abandoned” because it is being passed over
ends as soon as the transfer of control is initiated.  That is, event 1
occurs at the beginning of the initiation of the transfer of control.
The consequences are undefined if an attempt is made to transfer control
to an exit point whose dynamic extent has ended.

Events 2 and 3 are actually performed interleaved, in the order
corresponding to the reverse order in which they were established.  The
effect of this is that the cleanup clauses of an ‘unwind-protect’ see
the same dynamic bindings of variables and catch tags as were visible
when the ‘unwind-protect’ was entered.

Event 4 occurs at the end of the transfer of control.


File: ansicl,  Node: apply,  Next: defun,  Prev: Transfer of Control to an Exit Point,  Up: Data and Control Flow

apply (Function)
================

Syntax:
.......

 -- Function: apply function &rest args+ → {result}*

Arguments and Values:
.....................

FUNCTION—a function designator.

ARGS—a spreadable argument list designator.

RESULTS—the values returned by FUNCTION.

Description:
............

Applies the FUNCTION to the ARGS.

When the FUNCTION receives its arguments via ‘&rest’, it is permissible
(but not required) for the implementation to bind the rest parameter to
an object that shares structure with the last argument to ‘apply’.
Because a function can neither detect whether it was called via ‘apply’
nor whether (if so) the last argument to ‘apply’ was a constant,
conforming programs must neither rely on the list structure of a rest
list to be freshly consed, nor modify that list structure.

‘setf’ can be used with ‘apply’ in certain circumstances; see *note
Section 5.1.2.5 (APPLY Forms as Places): SETFofAPPLY.

Examples:
.........

      (setq f '+) → +
      (apply f '(1 2)) → 3
      (setq f #'-) → #<FUNCTION ->
      (apply f '(1 2)) → -1
      (apply #'max 3 5 '(2 7 3)) → 7
      (apply 'cons '((+ 2 3) 4)) → ((+ 2 3) . 4)
      (apply #'+ '()) → 0

      (defparameter *some-list* '(a b c))
      (defun strange-test (&rest x) (eq x *some-list*))
      (apply #'strange-test *some-list*) → implementation-dependent

      (defun bad-boy (&rest x) (rplacd x 'y))
      (bad-boy 'a 'b 'c) has undefined consequences.
      (apply #'bad-boy *some-list*) has undefined consequences.

      (defun foo (size &rest keys &key double &allow-other-keys)
        (let ((v (apply #'make-array size :allow-other-keys t keys)))
          (if double (concatenate (type-of v) v v) v)))
      (foo 4 :initial-contents '(a b c d) :double t)
         → #(A B C D A B C D)

See Also:
.........

*note funcall::, *note fdefinition::, *note function (Special
Operator)::, *note Section 3.1 (Evaluation): Evaluation, *note Section
5.1.2.5 (APPLY Forms as Places): SETFofAPPLY.


File: ansicl,  Node: defun,  Next: fdefinition,  Prev: apply,  Up: Data and Control Flow

defun (Macro)
=============

Syntax:
.......

 -- Macro: defun function-name lambda-list 〚{declaration}* |
          documentation〛 {form}* → function-name

Arguments and Values:
.....................

FUNCTION-NAME—a function name.

LAMBDA-LIST—an ordinary lambda list.

DECLARATION—a declare expression; not evaluated.

DOCUMENTATION—a string; not evaluated.

FORMS—an implicit progn.

BLOCK-NAME—the function block name of the FUNCTION-NAME.

Description:
............

Defines a new function named FUNCTION-NAME in the global environment.
The body of the function defined by ‘defun’ consists of FORMS; they are
executed as an implicit progn when the function is called.  ‘defun’ can
be used to define a new function, to install a corrected version of an
incorrect definition, to redefine an already-defined function, or to
redefine a macro as a function.

‘defun’ implicitly puts a ‘block’ named BLOCK-NAME around the body FORMS
(but not the forms in the LAMBDA-LIST) of the function defined.

DOCUMENTATION is attached as a documentation string to NAME (as kind
‘function’) and to the function object.

Evaluating ‘defun’ causes FUNCTION-NAME to be a global name for the
function specified by the lambda expression

      (lambda LAMBDA-LIST
        〚{declaration}* | documentation〛
        (block BLOCK-NAME {form}*))

processed in the lexical environment in which ‘defun’ was executed.

(None of the arguments are evaluated at macro expansion time.)

‘defun’ is not required to perform any compile-time side effects.  In
particular, ‘defun’ does not make the function definition available at
compile time.  An implementation may choose to store information about
the function for the purposes of compile-time error-checking (such as
checking the number of arguments on calls), or to enable the function to
be expanded inline.

Examples:
.........

      (defun recur (x)
       (when (> x 0)
         (recur (1- x)))) → RECUR
      (defun ex (a b &optional c (d 66) &rest keys &key test (start 0))
         (list a b c d keys test start)) → EX
      (ex 1 2) → (1 2 NIL 66 NIL NIL 0)
      (ex 1 2 3 4 :test 'equal :start 50)
     → (1 2 3 4 (:TEST EQUAL :START 50) EQUAL 50)
      (ex :test 1 :start 2) → (:TEST 1 :START 2 NIL NIL 0)

      ;; This function assumes its callers have checked the types of the
      ;; arguments, and authorizes the compiler to build in that assumption.
      (defun discriminant (a b c)
        (declare (number a b c))
        "Compute the discriminant for a quadratic equation."
        (- (* b b) (* 4 a c))) → DISCRIMINANT
      (discriminant 1 2/3 -2) → 76/9

      ;; This function assumes its callers have not checked the types of the
      ;; arguments, and performs explicit type checks before making any assumptions.
      (defun careful-discriminant (a b c)
        "Compute the discriminant for a quadratic equation."
        (check-type a number)
        (check-type b number)
        (check-type c number)
        (locally (declare (number a b c))
          (- (* b b) (* 4 a c)))) → CAREFUL-DISCRIMINANT
      (careful-discriminant 1 2/3 -2) → 76/9

See Also:
.........

*note flet::, *note labels::, *note block::, *note return-from::, *note
declare::, *note documentation::, *note Section 3.1 (Evaluation):
Evaluation, *note Section 3.4.1 (Ordinary Lambda Lists): Ordinary Lambda
Lists, *note Section 3.4.11 (Syntactic Interaction of Documentation
Strings and Declarations): Syntactic Interaction of Documentation
Strings and Declarations.

Notes:
......

‘return-from’ can be used to return prematurely from a function defined
by ‘defun’.

Additional side effects might take place when additional information
(typically debugging information) about the function definition is
recorded.


File: ansicl,  Node: fdefinition,  Next: fboundp,  Prev: defun,  Up: Data and Control Flow

fdefinition (Accessor)
======================

Syntax:
.......

 -- Function: fdefinition function-name → definition
(setf (fdefinition function-name) new-definition)

Arguments and Values:
.....................

FUNCTION-NAME—a function name.  In the non-‘setf’ case, the name must be
fbound in the global environment.

DEFINITION—Current global function definition named by FUNCTION-NAME.

NEW-DEFINITION—a function.

Description:
............

‘fdefinition’ accesses the current global function definition named by
FUNCTION-NAME.  The definition may be a function or may be an object
representing a special form or macro.  The value returned by
‘fdefinition’ when ‘fboundp’ returns true but the FUNCTION-NAME denotes
a macro or special form is not well-defined, but ‘fdefinition’ does not
signal an error.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if FUNCTION-NAME is not a
function name.

An error of type ‘undefined-function’ is signaled in the non-‘setf’ case
if FUNCTION-NAME is not fbound.

See Also:
.........

*note fboundp::, *note fmakunbound::, *note macro-function::, *note
special-operator-p::, *note symbol-function::

Notes:
......

‘fdefinition’ cannot access the value of a lexical function name
produced by ‘flet’ or ‘labels’; it can access only the global function
value.

‘setf’ can be used with ‘fdefinition’ to replace a global function
definition when the FUNCTION-NAME’s function definition does not
represent a special form.  ‘setf’ of ‘fdefinition’ requires a function
as the new value.  It is an error to set the ‘fdefinition’ of a
FUNCTION-NAME to a symbol, a list, or the value returned by
‘fdefinition’ on the name of a macro or special form.


File: ansicl,  Node: fboundp,  Next: fmakunbound,  Prev: fdefinition,  Up: Data and Control Flow

fboundp (Function)
==================

Syntax:
.......

 -- Function: fboundp name → generalized-boolean

Pronunciation:
..............

[ˌefˈba\.undpē]

Arguments and Values:
.....................

NAME—a function name.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if NAME is fbound; otherwise, returns false.

Examples:
.........

      (fboundp 'car) → true
      (fboundp 'nth-value) → false
      (fboundp 'with-open-file) → true
      (fboundp 'unwind-protect) → true
      (defun my-function (x) x) → MY-FUNCTION
      (fboundp 'my-function) → true
      (let ((saved-definition (symbol-function 'my-function)))
        (unwind-protect (progn (fmakunbound 'my-function)
                               (fboundp 'my-function))
          (setf (symbol-function 'my-function) saved-definition)))
     → false
      (fboundp 'my-function) → true
      (defmacro my-macro (x) `',x) → MY-MACRO
      (fboundp 'my-macro) → true
      (fmakunbound 'my-function) → MY-FUNCTION
      (fboundp 'my-function) → false
      (flet ((my-function (x) x))
        (fboundp 'my-function)) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NAME is not a function
name.

See Also:
.........

*note symbol-function::, *note fmakunbound::, *note fdefinition::

Notes:
......

It is permissible to call ‘symbol-function’ on any symbol that is
fbound.

‘fboundp’ is sometimes used to “guard” an access to the function cell,
as in:
     (if (fboundp x) (symbol-function x))

Defining a setf expander F does not cause the setf function ‘(setf F)’
to become defined.


File: ansicl,  Node: fmakunbound,  Next: flet; labels; macrolet,  Prev: fboundp,  Up: Data and Control Flow

fmakunbound (Function)
======================

Syntax:
.......

 -- Function: fmakunbound name → name

Pronunciation:
..............

[ˌefˈmakə nˌba\.und] or [ˌefˈmā kə nˌba\.und]

Arguments and Values:
.....................

NAME—a function name.

Description:
............

Removes the function or macro definition, if any, of NAME in the global
environment.

Examples:
.........

     (defun add-some (x) (+ x 19)) → ADD-SOME
      (fboundp 'add-some) → true
      (flet ((add-some (x) (+ x 37)))
         (fmakunbound 'add-some)
         (add-some 1)) → 38
      (fboundp 'add-some) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NAME is not a function
name.

The consequences are undefined if NAME is a special operator.

See Also:
.........

*note fboundp::, *note makunbound::


File: ansicl,  Node: flet; labels; macrolet,  Next: funcall,  Prev: fmakunbound,  Up: Data and Control Flow

flet, labels, macrolet (Special Operator)
=========================================

Syntax:
.......

 -- Special Form: flet
          ({(FUNCTION-NAME  LAMBDA-LIST 〚{local-declaration}* | local-documentation〛 {local-form}*)}*)
          {declaration}* {form}* → {result}*

 -- Special Form: labels
          ({(FUNCTION-NAME  LAMBDA-LIST 〚{local-declaration}* | local-documentation〛 {local-form}*)}*)
          {declaration}* {form}* → {result}*

 -- Special Form: macrolet
          ({(NAME  LAMBDA-LIST 〚{local-declaration}* | local-documentation〛 {local-form}*)}*)
          {declaration}* {form}* → {result}*

Arguments and Values:
.....................

FUNCTION-NAME—a function name.

NAME—a symbol.

LAMBDA-LIST—a lambda list; for ‘flet’ and ‘labels’, it is an ordinary
lambda list; for ‘macrolet’, it is a macro lambda list.

LOCAL-DECLARATION—a declare expression; not evaluated.

DECLARATION—a declare expression; not evaluated.

LOCAL-DOCUMENTATION—a string; not evaluated.

LOCAL-FORMS, FORMS—an implicit progn.

RESULTS—the values of the FORMS.

Description:
............

‘flet’, ‘labels’, and ‘macrolet’ define local functions and macros, and
execute FORMS using the local definitions.  FORMS are executed in order
of occurrence.

The body forms (but not the lambda list) of each function created by
‘flet’ and ‘labels’ and each macro created by ‘macrolet’ are enclosed in
an implicit block whose name is the function block name of the
FUNCTION-NAME or NAME, as appropriate.

The scope of the DECLARATIONS between the list of local function/macro
definitions and the body FORMS in ‘flet’ and ‘labels’ does not include
the bodies of the locally defined functions, except that for ‘labels’,
any ‘inline’, ‘notinline’, or ‘ftype’ declarations that refer to the
locally defined functions do apply to the local function bodies.  That
is, their scope is the same as the function name that they affect.  The
scope of these DECLARATIONS does not include the bodies of the macro
expander functions defined by ‘macrolet’.

flet

     ‘flet’ defines locally named functions and executes a series of
     FORMS with these definition bindings.  Any number of such local
     functions can be defined.

     The scope of the name binding encompasses only the body.  Within
     the body of ‘flet’, FUNCTION-NAMES matching those defined by ‘flet’
     refer to the locally defined functions rather than to the global
     function definitions of the same name.  Also, within the scope of
     ‘flet’, global setf expander definitions of the FUNCTION-NAME
     defined by ‘flet’ do not apply.  Note that this applies to
     ‘(defsetf f ...)’, not ‘(defmethod (setf f) ...)’.

     The names of functions defined by ‘flet’ are in the lexical
     environment; they retain their local definitions only within the
     body of ‘flet’.  The function definition bindings are visible only
     in the body of ‘flet’, not the definitions themselves.  Within the
     function definitions, local function names that match those being
     defined refer to functions or macros defined outside the ‘flet’.
     ‘flet’ can locally shadow a global function name, and the new
     definition can refer to the global definition.

     Any LOCAL-DOCUMENTATION is attached to the corresponding local
     FUNCTION (if one is actually created) as a documentation string.

labels

     ‘labels’ is equivalent to ‘flet’ except that the scope of the
     defined function names for ‘labels’ encompasses the function
     definitions themselves as well as the body.

macrolet

     ‘macrolet’ establishes local macro definitions, using the same
     format used by ‘defmacro’.

     Within the body of ‘macrolet’, global setf expander definitions of
     the NAMES defined by the ‘macrolet’ do not apply; rather, ‘setf’
     expands the macro form and recursively process the resulting form.

     The macro-expansion functions defined by ‘macrolet’ are defined in
     the lexical environment in which the ‘macrolet’ form appears.
     Declarations and ‘macrolet’ and ‘symbol-macrolet’ definitions
     affect the local macro definitions in a ‘macrolet’, but the
     consequences are undefined if the local macro definitions reference
     any local variable or function bindings that are visible in that
     lexical environment.

     Any LOCAL-DOCUMENTATION is attached to the corresponding local
     MACRO FUNCTION as a documentation string.

Examples:
.........

      (defun foo (x flag)
        (macrolet ((fudge (z)
                      ;The parameters x and flag are not accessible
                      ; at this point; a reference to flag would be to
                      ; the global variable of that name.
                      ` (if flag (* ,z ,z) ,z)))
         ;The parameters x and flag are accessible here.
          (+ x
             (fudge x)
             (fudge (+ x 1)))))
      ≡
      (defun foo (x flag)
        (+ x
           (if flag (* x x) x)
           (if flag (* (+ x 1) (+ x 1)) (+ x 1))))

after macro expansion.  The occurrences of ‘x’ and ‘flag’ legitimately
refer to the parameters of the function ‘foo’ because those parameters
are visible at the site of the macro call which produced the expansion.

      (flet ((flet1 (n) (+ n n)))
         (flet ((flet1 (n) (+ 2 (flet1 n))))
           (flet1 2))) → 6

      (defun dummy-function () 'top-level) → DUMMY-FUNCTION
      (funcall #'dummy-function) → TOP-LEVEL
      (flet ((dummy-function () 'shadow))
           (funcall #'dummy-function)) → SHADOW
      (eq (funcall #'dummy-function) (funcall 'dummy-function))
     → true
      (flet ((dummy-function () 'shadow))
        (eq (funcall #'dummy-function)
            (funcall 'dummy-function)))
     → false

      (defun recursive-times (k n)
        (labels ((temp (n)
                   (if (zerop n) 0 (+ k (temp (1- n))))))
          (temp n))) → RECURSIVE-TIMES
      (recursive-times 2 3) → 6

      (defmacro mlets (x &environment env)
         (let ((form `(babbit ,x)))
           (macroexpand form env))) → MLETS
      (macrolet ((babbit (z) `(+ ,z ,z))) (mlets 5)) → 10

      (flet ((safesqrt (x) (sqrt (abs x))))
       ;; The safesqrt function is used in two places.
        (safesqrt (apply #'+ (map 'list #'safesqrt '(1 2 3 4 5 6)))))
     → 3.291173

      (defun integer-power (n k)
        (declare (integer n))
        (declare (type (integer 0 *) k))
        (labels ((expt0 (x k a)
                   (declare (integer x a) (type (integer 0 *) k))
                   (cond ((zerop k) a)
                         ((evenp k) (expt1 (* x x) (floor k 2) a))
                         (t (expt0 (* x x) (floor k 2) (* x a)))))
                 (expt1 (x k a)
                   (declare (integer x a) (type (integer 0 *) k))
                   (cond ((evenp k) (expt1 (* x x) (floor k 2) a))
                         (t (expt0 (* x x) (floor k 2) (* x a))))))
         (expt0 n k 1))) → INTEGER-POWER

      (defun example (y l)
        (flet ((attach (x)
                 (setq l (append l (list x)))))
          (declare (inline attach))
          (dolist (x y)
            (unless (null (cdr x))
              (attach x)))
          l))

      (example '((a apple apricot) (b banana) (c cherry) (d) (e))
               '((1) (2) (3) (4 2) (5) (6 3 2)))
     → ((1) (2) (3) (4 2) (5) (6 3 2) (A APPLE APRICOT) (B BANANA) (C CHERRY))

See Also:
.........

*note declare::, *note defmacro::, *note defun::, *note documentation::,
*note let::, *note Section 3.1 (Evaluation): Evaluation, *note Section
3.4.11 (Syntactic Interaction of Documentation Strings and
Declarations): Syntactic Interaction of Documentation Strings and
Declarations.

Notes:
......

It is not possible to define recursive functions with ‘flet’.  ‘labels’
can be used to define mutually recursive functions.

If a ‘macrolet’ form is a top level form, the body FORMS are also
processed as top level forms.  See *note Section 3.2.3 (File
Compilation): File Compilation.


File: ansicl,  Node: funcall,  Next: function (Special Operator),  Prev: flet; labels; macrolet,  Up: Data and Control Flow

funcall (Function)
==================

Syntax:
.......

 -- Function: funcall function &rest args → {result}*

Arguments and Values:
.....................

FUNCTION—a function designator.

ARGS—arguments to the FUNCTION.

RESULTS—the values returned by the FUNCTION.

Description:
............

‘funcall’ applies FUNCTION to ARGS.  If FUNCTION is a symbol, it is
coerced to a function as if by finding its functional value in the
global environment.

Examples:
.........

      (funcall #'+ 1 2 3) → 6
      (funcall 'car '(1 2 3)) → 1
      (funcall 'position 1 '(1 2 3 2 1) :start 1) → 4
      (cons 1 2) → (1 . 2)
      (flet ((cons (x y) `(kons ,x ,y)))
        (let ((cons (symbol-function '+)))
          (funcall #'cons
                   (funcall 'cons 1 2)
                   (funcall cons 1 2))))
     → (KONS (1 . 2) 3)

Exceptional Situations:
.......................

An error of type ‘undefined-function’ should be signaled if FUNCTION is
a symbol that does not have a global definition as a function or that
has a global definition as a macro or a special operator.

See Also:
.........

*note apply::, *note function (Special Operator)::, *note Section 3.1
(Evaluation): Evaluation.

Notes:
......

      (funcall FUNCTION ARG1 ARG2 ...)
      ≡ (apply FUNCTION ARG1 ARG2 ... nil)
      ≡ (apply FUNCTION (list ARG1 ARG2 ...))

The difference between ‘funcall’ and an ordinary function call is that
in the former case the FUNCTION is obtained by ordinary evaluation of a
form, and in the latter case it is obtained by the special
interpretation of the function position that normally occurs.


File: ansicl,  Node: function (Special Operator),  Next: function-lambda-expression,  Prev: funcall,  Up: Data and Control Flow

function (Special Operator)
===========================

Syntax:
.......

 -- Special Form: function name → function

Arguments and Values:
.....................

NAME—a function name or lambda expression.

FUNCTION—a function object.

Description:
............

The value of ‘function’ is the functional value of NAME in the current
lexical environment.

If NAME is a function name, the functional definition of that name is
that established by the innermost lexically enclosing ‘flet’, ‘labels’,
or ‘macrolet’ form, if there is one.  Otherwise the global functional
definition of the function name is returned.

If NAME is a lambda expression, then a lexical closure is returned.  In
situations where a closure over the same set of bindings might be
produced more than once, the various resulting closures might or might
not be ‘eq’.

It is an error to use ‘function’ on a function name that does not denote
a function in the lexical environment in which the ‘function’ form
appears.  Specifically, it is an error to use ‘function’ on a symbol
that denotes a macro or special form.  An implementation may choose not
to signal this error for performance reasons, but implementations are
forbidden from defining the failure to signal an error as a useful
behavior.

Examples:
.........

      (defun adder (x) (function (lambda (y) (+ x y))))

The result of ‘(adder 3)’ is a function that adds ‘3’ to its argument:

      (setq add3 (adder 3))
      (funcall add3 5) → 8

This works because ‘function’ creates a closure of the lambda expression
that is able to refer to the value ‘3’ of the variable ‘x’ even after
control has returned from the function ‘adder’.

See Also:
.........

*note defun::, *note fdefinition::, *note flet::, *note labels::, *note
symbol-function::, *note Section 3.1.2.1.1 (Symbols as Forms):
SymbolsAsForms, *note Section 2.4.8.2 (Sharpsign Single-Quote):
SharpsignQuote, *note Section 22.1.3.13 (Printing Other Objects):
PrintingOtherObjects.

Notes:
......

The notation ‘#'NAME’ may be used as an abbreviation for ‘(function
NAME)’.


File: ansicl,  Node: function-lambda-expression,  Next: functionp,  Prev: function (Special Operator),  Up: Data and Control Flow

function-lambda-expression (Function)
=====================================

Syntax:
.......

 -- Function: function-lambda-expression function → lambda-expression,
          closure-p, name

Arguments and Values:
.....................

FUNCTION—a function.

LAMBDA-EXPRESSION—a lambda expression or ‘nil’.

CLOSURE-P—a generalized boolean.

NAME—an object.

Description:
............

Returns information about FUNCTION as follows:

The primary value, LAMBDA-EXPRESSION, is FUNCTION’s defining lambda
expression, or ‘nil’ if the information is not available.  The lambda
expression may have been pre-processed in some ways, but it should
remain a suitable argument to ‘compile’ or ‘function’.  Any
implementation may legitimately return ‘nil’  as the LAMBDA-EXPRESSION
of any FUNCTION.

The secondary value, CLOSURE-P, is ‘nil’ if FUNCTION’s definition was
enclosed in the null lexical environment or something non-nil if
FUNCTION’s definition might have been enclosed in some non-null lexical
environment.  Any implementation may legitimately return true as the
CLOSURE-P of any FUNCTION.

The tertiary value, NAME, is the “name” of FUNCTION.  The name is
intended for debugging only and is not necessarily one that would be
valid for use as a name in ‘defun’ or ‘function’, for example.  By
convention, ‘nil’ is used to mean that FUNCTION has no name.  Any
implementation may legitimately return ‘nil’  as the NAME of any
FUNCTION.

Examples:
.........

The following examples illustrate some possible return values, but are
not intended to be exhaustive:

      (function-lambda-expression #'(lambda (x) x))
     → NIL, false, NIL
     or→ NIL, true, NIL
     or→ (LAMBDA (X) X), true, NIL
     or→ (LAMBDA (X) X), false, NIL

      (function-lambda-expression
         (funcall #'(lambda () #'(lambda (x) x))))
     → NIL, false, NIL
     or→ NIL, true, NIL
     or→ (LAMBDA (X) X), true, NIL
     or→ (LAMBDA (X) X), false, NIL

      (function-lambda-expression
         (funcall #'(lambda (x) #'(lambda () x)) nil))
     → NIL, true, NIL
     or→ (LAMBDA () X), true, NIL
     not→ NIL, false, NIL
     not→ (LAMBDA () X), false, NIL

      (flet ((foo (x) x))
        (setf (symbol-function 'bar) #'foo)
        (function-lambda-expression #'bar))
     → NIL, false, NIL
     or→ NIL, true, NIL
     or→ (LAMBDA (X) (BLOCK FOO X)), true, NIL
     or→ (LAMBDA (X) (BLOCK FOO X)), false, FOO
     or→ (SI::BLOCK-LAMBDA FOO (X) X), false, FOO

      (defun foo ()
        (flet ((bar (x) x))
          #'bar))
      (function-lambda-expression (foo))
     → NIL, false, NIL
     or→ NIL, true, NIL
     or→ (LAMBDA (X) (BLOCK BAR X)), true, NIL
     or→ (LAMBDA (X) (BLOCK BAR X)), true, (:INTERNAL FOO 0 BAR)
     or→ (LAMBDA (X) (BLOCK BAR X)), false, "BAR in FOO"

Notes:
......

Although implementations are free to return “‘nil’, true, ‘nil’” in all
cases, they are encouraged to return a lambda expression as the primary
value in the case where the argument was created by a call to ‘compile’
or ‘eval’ (as opposed to being created by loading a compiled file).


File: ansicl,  Node: functionp,  Next: compiled-function-p,  Prev: function-lambda-expression,  Up: Data and Control Flow

functionp (Function)
====================

Syntax:
.......

 -- Function: functionp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘function’; otherwise, returns false.

Examples:
.........

      (functionp 'append) → false
      (functionp #'append) → true
      (functionp (symbol-function 'append)) → true
      (flet ((f () 1)) (functionp #'f)) → true
      (functionp (compile nil '(lambda () 259))) → true
      (functionp nil) → false
      (functionp 12) → false
      (functionp '(lambda (x) (* x x))) → false
      (functionp #'(lambda (x) (* x x))) → true

Notes:
......

      (functionp OBJECT) ≡ (typep OBJECT 'function)


File: ansicl,  Node: compiled-function-p,  Next: call-arguments-limit,  Prev: functionp,  Up: Data and Control Flow

compiled-function-p (Function)
==============================

Syntax:
.......

 -- Function: compiled-function-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘compiled-function’; otherwise,
returns false.

Examples:
.........

      (defun f (x) x) → F
      (compiled-function-p #'f)
     → false
     or→ true
      (compiled-function-p 'f) → false
      (compile 'f) → F
      (compiled-function-p #'f) → true
      (compiled-function-p 'f) → false
      (compiled-function-p (compile nil '(lambda (x) x)))
     → true
      (compiled-function-p #'(lambda (x) x))
     → false
     or→ true
      (compiled-function-p '(lambda (x) x)) → false

See Also:
.........

*note compile::, *note compile-file::, *note compiled-function::

Notes:
......

      (compiled-function-p OBJECT) ≡ (typep OBJECT 'compiled-function)


File: ansicl,  Node: call-arguments-limit,  Next: lambda-list-keywords,  Prev: compiled-function-p,  Up: Data and Control Flow

call-arguments-limit (Constant Variable)
========================================

Constant Value:
...............

An integer not smaller than ‘50’ and at least as great as the value of
‘lambda-parameters-limit’, the exact magnitude of which is
implementation-dependent.

Description:
............

The upper exclusive bound on the number of arguments that may be passed
to a function.

See Also:
.........

*note lambda-parameters-limit::, *note multiple-values-limit::


File: ansicl,  Node: lambda-list-keywords,  Next: lambda-parameters-limit,  Prev: call-arguments-limit,  Up: Data and Control Flow

lambda-list-keywords (Constant Variable)
========================================

Constant Value:
...............

a list, the elements of which are implementation-dependent, but which
must contain at least the symbols ‘&allow-other-keys’, ‘&aux’, ‘&body’,
‘&environment’, ‘&key’, ‘&optional’, ‘&rest’, and ‘&whole’.

Description:
............

A list of all the lambda list keywords used in the implementation,
including the additional ones used only by macro definition forms.

See Also:
.........

*note defun::, *note flet::, *note defmacro::, *note macrolet::, *note
Section 3.1.2 (The Evaluation Model): The Evaluation Model.


File: ansicl,  Node: lambda-parameters-limit,  Next: defconstant,  Prev: lambda-list-keywords,  Up: Data and Control Flow

lambda-parameters-limit (Constant Variable)
===========================================

Constant Value:
...............

implementation-dependent, but not smaller than ‘50’.

Description:
............

A positive integer that is the upper exclusive bound on the number of
parameter names that can appear in a single lambda list.

See Also:
.........

*note call-arguments-limit::

Notes:
......

Implementors are encouraged to make the value of
‘lambda-parameters-limit’ as large as possible.


File: ansicl,  Node: defconstant,  Next: defparameter; defvar,  Prev: lambda-parameters-limit,  Up: Data and Control Flow

defconstant (Macro)
===================

Syntax:
.......

 -- Macro: defconstant name initial-value [documentation] → name

Arguments and Values:
.....................

NAME—a symbol; not evaluated.

INITIAL-VALUE—a form; evaluated.

DOCUMENTATION—a string; not evaluated.

Description:
............

‘defconstant’ causes the global variable named by NAME to be given a
value that is the result of evaluating INITIAL-VALUE.

A constant defined by ‘defconstant’ can be redefined with ‘defconstant’.
However, the consequences are undefined if an attempt is made to assign
a value to the symbol using another operator, or to assign it to a
different value using a subsequent ‘defconstant’.

If DOCUMENTATION is supplied, it is attached to NAME as a documentation
string of kind variable.

‘defconstant’ normally appears as a top level form, but it is meaningful
for it to appear as a non-top-level form.  However, the compile-time
side effects described below only take place when ‘defconstant’ appears
as a top level form.

The consequences are undefined if there are any bindings of the variable
named by NAME at the time ‘defconstant’ is executed or if the value is
not ‘eql’ to the value of INITIAL-VALUE.

The consequences are undefined when constant symbols are rebound as
either lexical or dynamic variables.  In other words, a reference to a
symbol declared with ‘defconstant’ always refers to its global value.

The side effects of the execution of ‘defconstant’ must be equivalent to
at least the side effects of the execution of the following code:

      (setf (symbol-value 'name) initial-value)
      (setf (documentation 'name 'variable) 'documentation)

If a ‘defconstant’ form appears as a top level form, the compiler must
recognize that NAME names a constant variable.  An implementation may
choose to evaluate the value-form at compile time, load time, or both.
Therefore, users must ensure that the INITIAL-VALUE can be evaluated at
compile time (regardless of whether or not references to NAME appear in
the file) and that it always evaluates to the same value.

Examples:
.........

      (defconstant this-is-a-constant 'never-changing "for a test") → THIS-IS-A-CONSTANT
     this-is-a-constant → NEVER-CHANGING
      (documentation 'this-is-a-constant 'variable) → "for a test"
      (constantp 'this-is-a-constant) → true

See Also:
.........

*note declaim::, *note defparameter::, *note defvar::, *note
documentation::, *note proclaim::, *note Section 3.1.2.1.1.3 (Constant
Variables): ConstantVars, *note Section 3.2 (Compilation): Compilation.


File: ansicl,  Node: defparameter; defvar,  Next: destructuring-bind,  Prev: defconstant,  Up: Data and Control Flow

defparameter, defvar (Macro)
============================

Syntax:
.......

 -- Macro: defparameter name initial-value [documentation] → name
 -- Macro: defvar name [initial-value [documentation]] → name

Arguments and Values:
.....................

NAME—a symbol; not evaluated.

INITIAL-VALUE—a form; for ‘defparameter’, it is always evaluated, but
for ‘defvar’ it is evaluated only if NAME is not already bound.

DOCUMENTATION—a STRING; not evaluated.

Description:
............

‘defparameter’ and ‘defvar’ establish NAME as a dynamic variable.

‘defparameter’ unconditionally assigns the INITIAL-VALUE to the dynamic
variable named NAME.  ‘defvar’, by contrast, assigns INITIAL-VALUE (if
supplied) to the dynamic variable named NAME only if NAME is not already
bound.

If no INITIAL-VALUE is supplied, ‘defvar’ leaves the value cell of the
dynamic variable named NAME undisturbed; if NAME was previously bound,
its old value persists, and if it was previously unbound, it remains
unbound.

If DOCUMENTATION is supplied, it is attached to NAME as a documentation
string of kind variable.

‘defparameter’ and ‘defvar’ normally appear as a top level form, but it
is meaningful for them to appear as non-top-level forms.  However, the
compile-time side effects described below only take place when they
appear as top level forms.

Examples:
.........

      (defparameter *p* 1) → *P*
      *p* → 1
      (constantp '*p*) → false
      (setq *p* 2) → 2
      (defparameter *p* 3) → *P*
      *p* → 3

      (defvar *v* 1) → *V*
      *v* → 1
      (constantp '*v*) → false
      (setq *v* 2) → 2
      (defvar *v* 3) → *V*
      *v* → 2

      (defun foo ()
        (let ((*p* 'p) (*v* 'v))
          (bar))) → FOO
      (defun bar () (list *p* *v*)) → BAR
      (foo) → (P V)

The principal operational distinction between ‘defparameter’ and
‘defvar’ is that ‘defparameter’ makes an unconditional assignment to
NAME, while ‘defvar’ makes a conditional one.  In practice, this means
that ‘defparameter’ is useful in situations where loading or reloading
the definition would want to pick up a new value of the variable, while
‘defvar’ is used in situations where the old value would want to be
retained if the file were loaded or reloaded.  For example, one might
create a file which contained:

      (defvar *the-interesting-numbers* '())
      (defmacro define-interesting-number (name n)
        `(progn (defvar ,name ,n)
                (pushnew ,name *the-interesting-numbers*)
                ',name))
      (define-interesting-number *my-height* 168) ;cm
      (define-interesting-number *my-weight* 13)  ;stones

Here the initial value, ‘()’, for the variable
‘*the-interesting-numbers*’ is just a seed that we are never likely to
want to reset to something else once something has been grown from it.
As such, we have used ‘defvar’ to avoid having the
‘*interesting-numbers*’ information reset if the file is loaded a second
time.  It is true that the two calls to ‘define-interesting-number’ here
would be reprocessed, but if there were additional calls in another
file, they would not be and that information would be lost.  On the
other hand, consider the following code:

      (defparameter *default-beep-count* 3)
      (defun beep (&optional (n *default-beep-count*))
        (dotimes (i n) (si:%beep 1000. 100000.) (sleep 0.1)))

Here we could easily imagine editing the code to change the initial
value of ‘*default-beep-count*’, and then reloading the file to pick up
the new value.  In order to make value updating easy, we have used
‘defparameter’.

On the other hand, there is potential value to using ‘defvar’ in this
situation.  For example, suppose that someone had predefined an
alternate value for ‘*default-beep-count*’, or had loaded the file and
then manually changed the value.  In both cases, if we had used ‘defvar’
instead of ‘defparameter’, those user preferences would not be
overridden by (re)loading the file.

The choice of whether to use ‘defparameter’ or ‘defvar’ has visible
consequences to programs, but is nevertheless often made for subjective
reasons.

Side Effects:
.............

If a ‘defvar’ or ‘defparameter’ form appears as a top level form, the
compiler must recognize that the NAME has been proclaimed ‘special’.
However, it must neither evaluate the INITIAL-VALUE form nor assign the
dynamic variable named NAME at compile time.

There may be additional (implementation-defined) compile-time or
run-time side effects, as long as such effects do not interfere with the
correct operation of conforming programs.

Affected By:
............

‘defvar’ is affected by whether NAME is already bound.

See Also:
.........

*note declaim::, *note defconstant::, *note documentation::, *note
Section 3.2 (Compilation): Compilation.

Notes:
......

It is customary to name dynamic variables with an asterisk at the
beginning and end of the name.  e.g., ‘*foo*’ is a good name for a
dynamic variable, but not for a lexical variable; ‘foo’ is a good name
for a lexical variable, but not for a dynamic variable.  This naming
convention is observed for all defined names in Common Lisp; however,
neither conforming programs nor conforming implementations are obliged
to adhere to this convention.

The intent of the permission for additional side effects is to allow
implementations to do normal “bookkeeping” that accompanies definitions.
For example, the macro expansion of a ‘defvar’ or ‘defparameter’ form
might include code that arranges to record the name of the source file
in which the definition occurs.

‘defparameter’ and ‘defvar’ might be defined as follows:

      (defmacro defparameter (name initial-value
                              &optional (documentation nil documentation-p))
        `(progn (declaim (special ,name))
                (setf (symbol-value ',name) ,initial-value)
                ,(when documentation-p
                   `(setf (documentation ',name 'variable) ',documentation))
                ',name))
      (defmacro defvar (name &optional
                             (initial-value nil initial-value-p)
                             (documentation nil documentation-p))
        `(progn (declaim (special ,name))
                ,(when initial-value-p
                   `(unless (boundp ',name)
                      (setf (symbol-value ',name) ,initial-value)))
                ,(when documentation-p
                   `(setf (documentation ',name 'variable) ',documentation))
                ',name))


File: ansicl,  Node: destructuring-bind,  Next: let; let*,  Prev: defparameter; defvar,  Up: Data and Control Flow

destructuring-bind (Macro)
==========================

Syntax:
.......

 -- Macro: destructuring-bind lambda-list expression {declaration}*
          {form}* → {result}*

Arguments and Values:
.....................

LAMBDA-LIST—a destructuring lambda list.

EXPRESSION—a form.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—the values returned by the forms.

Description:
............

‘destructuring-bind’ binds the variables specified in LAMBDA-LIST to the
corresponding values in the tree structure resulting from the evaluation
of EXPRESSION; then ‘destructuring-bind’ evaluates FORMS.

The LAMBDA-LIST supports destructuring as described in *note Section
3.4.5 (Destructuring Lambda Lists): Destructuring Lambda Lists.

Examples:
.........

      (defun iota (n) (loop for i from 1 to n collect i))       ;helper
      (destructuring-bind ((a &optional (b 'bee)) one two three)
          `((alpha) ,@(iota 3))
        (list a b three two one)) → (ALPHA BEE 3 2 1)

Exceptional Situations:
.......................

If the result of evaluating the EXPRESSION does not match the
destructuring pattern, an error of type ‘error’ should be signaled.

See Also:
.........

*note macrolet::, *note defmacro::


File: ansicl,  Node: let; let*,  Next: progv,  Prev: destructuring-bind,  Up: Data and Control Flow

let, let* (Special Operator)
============================

Syntax:
.......

 -- Special Form: let ({var | (var [init-form])}*) {declaration}*
          {form}* → {result}*

 -- Special Form: let* ({var | (var [init-form])}*) {declaration}*
          {form}* → {result}*

Arguments and Values:
.....................

VAR—a symbol.

INIT-FORM—a form.

DECLARATION—a declare expression; not evaluated.

FORM—a form.

RESULTS—the values returned by the forms.

Description:
............

‘let’ and ‘let*’ create new variable bindings and execute a series of
FORMS that use these bindings.  ‘let’ performs the bindings in parallel
and ‘let*’ does them sequentially.

The form

      (let ((VAR1 INIT-FORM-1)
            (VAR2 INIT-FORM-2)
            ...
            (VARM INIT-FORM-M))
        DECLARATION1
        DECLARATION2
        ...
        DECLARATIONP
        FORM1
        FORM2
        ...
        FORMN)

first evaluates the expressions INIT-FORM-1, INIT-FORM-2, and so on, in
that order, saving the resulting values.  Then all of the variables VARJ
are bound to the corresponding values; each binding is lexical unless
there is a ‘special’ declaration to the contrary.  The expressions FORMK
are then evaluated in order; the values of all but the last are
discarded (that is, the body of a ‘let’ is an implicit progn).

‘let*’ is similar to ‘let’, but the bindings of variables are performed
sequentially rather than in parallel.  The expression for the INIT-FORM
of a VAR can refer to VARS previously bound in the ‘let*’.

The form

      (let* ((VAR1 INIT-FORM-1)
             (VAR2 INIT-FORM-2)
             ...
             (VARM INIT-FORM-M))
        DECLARATION1
        DECLARATION2
        ...
        DECLARATIONP
        FORM1
        FORM2
        ...
        FORMN)

first evaluates the expression INIT-FORM-1, then binds the variable VAR1
to that value; then it evaluates INIT-FORM-2 and binds VAR2, and so on.
The expressions FORMJ are then evaluated in order; the values of all but
the last are discarded (that is, the body of ‘let*’ is an implicit
‘progn’).

For both ‘let’ and ‘let*’, if there is not an INIT-FORM associated with
a VAR, VAR is initialized to ‘nil’.

The special form ‘let’ has the property that the scope of the name
binding does not include any initial value form.  For ‘let*’, a
variable’s scope also includes the remaining initial value forms for
subsequent variable bindings.

Examples:
.........

      (setq a 'top) → TOP
      (defun dummy-function () a) → DUMMY-FUNCTION
      (let ((a 'inside) (b a))
         (format nil "~S ~S ~S" a b (dummy-function))) → "INSIDE TOP TOP"
      (let* ((a 'inside) (b a))
         (format nil "~S ~S ~S" a b (dummy-function))) → "INSIDE INSIDE TOP"
      (let ((a 'inside) (b a))
         (declare (special a))
         (format nil "~S ~S ~S" a b (dummy-function))) → "INSIDE TOP INSIDE"

 

 

The code

      (let (x)
        (declare (integer x))
        (setq x (gcd y z))
        ...)

is incorrect; although ‘x’ is indeed set before it is used, and is set
to a value of the declared type integer, nevertheless ‘x’ initially
takes on the value ‘nil’ in violation of the type declaration.

See Also:
.........

*note progv::


File: ansicl,  Node: progv,  Next: setq,  Prev: let; let*,  Up: Data and Control Flow

progv (Special Operator)
========================

Syntax:
.......

 -- Special Form: progv SYMBOLS VALUES {form}* → {result}*

Arguments and Values:
.....................

SYMBOLS—a list of symbols; evaluated.

VALUES—a list of objects; evaluated.

FORMS—an implicit progn.

RESULTS—the values returned by the forms.

Description:
............

‘progv’ creates new dynamic variable bindings and executes each FORM
using those bindings.  Each FORM is evaluated in order.

‘progv’ allows binding one or more dynamic variables whose names may be
determined at run time.  Each FORM is evaluated in order with the
dynamic variables whose names are in SYMBOLS bound to corresponding
VALUES.  If too few VALUES are supplied, the remaining symbols are bound
and then made to have no value.  If too many VALUES are supplied, the
excess values are ignored.  The bindings of the dynamic variables are
undone on exit from ‘progv’.

Examples:
.........

      (setq *x* 1) → 1
      (progv '(*x*) '(2) *x*) → 2
      *x* → 1

     Assuming *x* is not globally special,

      (let ((*x* 3))
         (progv '(*x*) '(4)
           (list *x* (symbol-value '*x*)))) → (3 4)

See Also:
.........

*note let::, *note Section 3.1 (Evaluation): Evaluation.

Notes:
......

Among other things, ‘progv’ is useful when writing interpreters for
languages embedded in Lisp; it provides a handle on the mechanism for
binding dynamic variables.


File: ansicl,  Node: setq,  Next: psetq,  Prev: progv,  Up: Data and Control Flow

setq (Special Form)
===================

Syntax:
.......

 -- Special Form: setq {↓pair}* → result

PAIR::=
     var form

Pronunciation:
..............

[ˈsetˌkyü]

Arguments and Values:
.....................

VAR—a symbol naming a variable other than a constant variable.

FORM—a form.

RESULT—the primary value of the last FORM, or ‘nil’ if no PAIRS were
supplied.

Description:
............

Assigns values to variables.

‘(setq var1 form1 var2 form2 ...)’ is the simple variable assignment
statement of Lisp.  First FORM1 is evaluated and the result is stored in
the variable VAR1, then FORM2 is evaluated and the result stored in
VAR2, and so forth.  ‘setq’ may be used for assignment of both lexical
and dynamic variables.

If any VAR refers to a binding made by ‘symbol-macrolet’, then that VAR
is treated as if ‘setf’ (not ‘setq’) had been used.

Examples:
.........

      ;; A simple use of SETQ to establish values for variables.
      (setq a 1 b 2 c 3) → 3
      a → 1
      b → 2
      c → 3

      ;; Use of SETQ to update values by sequential assignment.
      (setq a (1+ b) b (1+ a) c (+ a b)) → 7
      a → 3
      b → 4
      c → 7

      ;; This illustrates the use of SETQ on a symbol macro.
      (let ((x (list 10 20 30)))
        (symbol-macrolet ((y (car x)) (z (cadr x)))
          (setq y (1+ z) z (1+ y))
          (list x y z)))
     → ((21 22 30) 21 22)

Side Effects:
.............

The primary value of each FORM is assigned to the corresponding VAR.

See Also:
.........

*note psetq::, *note set::, *note setf::


File: ansicl,  Node: psetq,  Next: block,  Prev: setq,  Up: Data and Control Flow

psetq (Macro)
=============

Syntax:
.......

 -- Macro: psetq {↓pair}* → ‘nil’

PAIR::=
     var form

Pronunciation:
..............

‘psetq’: [ːpēˈsetˌkyü]

Arguments and Values:
.....................

VAR—a symbol naming a variable other than a constant variable.

FORM—a form.

Description:
............

Assigns values to variables.

This is just like ‘setq’, except that the assignments happen “in
parallel.” That is, first all of the forms are evaluated, and only then
are the variables set to the resulting values.  In this way, the
assignment to one variable does not affect the value computation of
another in the way that would occur with ‘setq’’s sequential assignment.

If any VAR refers to a binding made by ‘symbol-macrolet’, then that VAR
is treated as if ‘psetf’ (not ‘psetq’) had been used.

Examples:
.........

      ;; A simple use of PSETQ to establish values for variables.
      ;; As a matter of style, many programmers would prefer SETQ
      ;; in a simple situation like this where parallel assignment
      ;; is not needed, but the two have equivalent effect.
      (psetq a 1 b 2 c 3) → NIL
      a → 1
      b → 2
      c → 3

      ;; Use of PSETQ to update values by parallel assignment.
      ;; The effect here is very different than if SETQ had been used.
      (psetq a (1+ b) b (1+ a) c (+ a b)) → NIL
      a → 3
      b → 2
      c → 3

      ;; Use of PSETQ on a symbol macro.
      (let ((x (list 10 20 30)))
        (symbol-macrolet ((y (car x)) (z (cadr x)))
          (psetq y (1+ z) z (1+ y))
          (list x y z)))
     → ((21 11 30) 21 11)

      ;; Use of parallel assignment to swap values of A and B.
      (let ((a 1) (b 2))
        (psetq a b  b a)
        (values a b))
     → 2, 1

Side Effects:
.............

The values of FORMS are assigned to VARS.

See Also:
.........

*note psetf::, *note setq::

