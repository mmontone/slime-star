This is ansicl, produced by makeinfo version 6.7 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: graphic-char-p,  Next: standard-char-p,  Prev: digit-char-p,  Up: Characters

graphic-char-p (Function)
=========================

Syntax:
.......

 -- Function: graphic-char-p char → generalized-boolean

Arguments and Values:
.....................

CHAR—a character.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if CHARACTER is a graphic character; otherwise, returns
false.

Examples:
.........

      (graphic-char-p #\G) → true
      (graphic-char-p #\#) → true
      (graphic-char-p #\Space) → true
      (graphic-char-p #\Newline) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note read::, *note Section 2.1 (Character Syntax): Character Syntax,
*note Section 13.1.10 (Documentation of Implementation-Defined Scripts):
Documentation of Implementation-Defined Scripts.


File: ansicl,  Node: standard-char-p,  Next: char-upcase; char-downcase,  Prev: graphic-char-p,  Up: Characters

standard-char-p (Function)
==========================

Syntax:
.......

 -- Function: standard-char-p character → generalized-boolean

Arguments and Values:
.....................

CHARACTER—a character.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if CHARACTER is of type ‘standard-char’; otherwise, returns
false.

Examples:
.........

      (standard-char-p #\Space) → true
      (standard-char-p #\~) → true
      ;; This next example presupposes an implementation
      ;; in which #\Bell is a defined character.
      (standard-char-p #\Bell) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.


File: ansicl,  Node: char-upcase; char-downcase,  Next: upper-case-p; lower-case-p; both-case-p,  Prev: standard-char-p,  Up: Characters

char-upcase, char-downcase (Function)
=====================================

Syntax:
.......

 -- Function: char-upcase character → corresponding-character
 -- Function: char-downcase character → corresponding-character

Arguments and Values:
.....................

CHARACTER, CORRESPONDING-CHARACTER—a character.

Description:
............

If CHARACTER is a lowercase character, ‘char-upcase’ returns the
corresponding uppercase character.  Otherwise, ‘char-upcase’ just
returns the given CHARACTER.

If CHARACTER is an uppercase character, ‘char-downcase’ returns the
corresponding lowercase character.  Otherwise, ‘char-downcase’ just
returns the given CHARACTER.

The result only ever differs from CHARACTER in its code attribute; all
implementation-defined attributes are preserved.

Examples:
.........

      (char-upcase #\a) → #\A
      (char-upcase #\A) → #\A
      (char-downcase #\a) → #\a
      (char-downcase #\A) → #\a
      (char-upcase #\9) → #\9
      (char-downcase #\9) → #\9
      (char-upcase #\@) → #\@
      (char-downcase #\@) → #\@
      ;; Note that this next example might run for a very long time in
      ;; some implementations if CHAR-CODE-LIMIT happens to be very large
      ;; for that implementation.
      (dotimes (code char-code-limit)
        (let ((char (code-char code)))
          (when char
            (unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))
                          ((lower-case-p char) (char= (char-downcase (char-upcase char)) char))
                          (t (and (char= (char-upcase (char-downcase char)) char)
                                  (char= (char-downcase (char-upcase char)) char))))
              (return char)))))
     → NIL

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note upper-case-p::, *note alpha-char-p::, *note Section 13.1.4.3
(Characters With Case): CharactersWithCase, *note Section 13.1.10
(Documentation of Implementation-Defined Scripts): Documentation of
Implementation-Defined Scripts.

Notes:
......

If the CORRESPONDING-CHAR is different than CHARACTER, then both the
CHARACTER and the CORRESPONDING-CHAR have case.

Since ‘char-equal’ ignores the case of the characters it compares, the
CORRESPONDING-CHARACTER is always the same as CHARACTER under
‘char-equal’.


File: ansicl,  Node: upper-case-p; lower-case-p; both-case-p,  Next: char-code,  Prev: char-upcase; char-downcase,  Up: Characters

upper-case-p, lower-case-p, both-case-p (Function)
==================================================

Syntax:
.......

 -- Function: upper-case-p character → generalized-boolean
 -- Function: lower-case-p character → generalized-boolean
 -- Function: both-case-p character → generalized-boolean

Arguments and Values:
.....................

CHARACTER—a character.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

These functions test the case of a given CHARACTER.

‘upper-case-p’ returns true if CHARACTER is an uppercase character;
otherwise, returns false.

‘lower-case-p’ returns true if CHARACTER is a lowercase character;
otherwise, returns false.

‘both-case-p’ returns true if CHARACTER is a character with case;
otherwise, returns false.

Examples:
.........

      (upper-case-p #\A) → true
      (upper-case-p #\a) → false
      (both-case-p #\a) → true
      (both-case-p #\5) → false
      (lower-case-p #\5) → false
      (upper-case-p #\5) → false
      ;; This next example presupposes an implementation
      ;; in which #\Bell is an implementation-defined character.
      (lower-case-p #\Bell) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note char-upcase::, *note char-downcase::, *note Section 13.1.4.3
(Characters With Case): CharactersWithCase, *note Section 13.1.10
(Documentation of Implementation-Defined Scripts): Documentation of
Implementation-Defined Scripts.


File: ansicl,  Node: char-code,  Next: char-int,  Prev: upper-case-p; lower-case-p; both-case-p,  Up: Characters

char-code (Function)
====================

Syntax:
.......

 -- Function: char-code character → code

Arguments and Values:
.....................

CHARACTER—a character.

CODE—a character code.

Description:
............

‘char-code’ returns the code attribute of CHARACTER.

Examples:
.........

     ;; An implementation using ASCII character encoding
     ;; might return these values:
     (char-code #\$) → 36
     (char-code #\a) → 97

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note char-code-limit::


File: ansicl,  Node: char-int,  Next: code-char,  Prev: char-code,  Up: Characters

char-int (Function)
===================

Syntax:
.......

 -- Function: char-int character → integer

Arguments and Values:
.....................

CHARACTER—a character.

INTEGER—a non-negative integer.

Description:
............

Returns a non-negative integer encoding the CHARACTER object.  The
manner in which the integer is computed is implementation-dependent.  In
contrast to ‘sxhash’, the result is not guaranteed to be independent of
the particular Lisp image.

If CHARACTER has no implementation-defined attributes, the results of
‘char-int’ and ‘char-code’ are the same.

      (char= c1 c2) ≡ (= (char-int c1) (char-int c2))

for characters c1 and c2.

Examples:
.........

      (char-int #\A) → 65       ; implementation A
      (char-int #\A) → 577      ; implementation B
      (char-int #\A) → 262145   ; implementation C

See Also:
.........

*note char-code::


File: ansicl,  Node: code-char,  Next: char-code-limit,  Prev: char-int,  Up: Characters

code-char (Function)
====================

Syntax:
.......

 -- Function: code-char code → char-p

Arguments and Values:
.....................

CODE—a character code.

CHAR-P—a character or ‘nil’.

Description:
............

Returns a character with the code attribute given by CODE.  If no such
character exists and one cannot be created, ‘nil’ is returned.

Examples:
.........

     (code-char 65.) → #\A  ;in an implementation using ASCII codes
     (code-char (char-code #\Space)) → #\Space  ;in any implementation

Affected By:
............

The implementation’s character encoding.

See Also:
.........

*note char-code::

Notes:
......


File: ansicl,  Node: char-code-limit,  Next: char-name,  Prev: code-char,  Up: Characters

char-code-limit (Constant Variable)
===================================

Constant Value:
...............

A non-negative integer, the exact magnitude of which is
implementation-dependent, but which is not less than ‘96’ (the number of
standard characters).

Description:
............

The upper exclusive bound on the value returned by the function
‘char-code’.

See Also:
.........

*note char-code::

Notes:
......

The value of ‘char-code-limit’ might be larger than the actual number of
characters supported by the implementation.


File: ansicl,  Node: char-name,  Next: name-char,  Prev: char-code-limit,  Up: Characters

char-name (Function)
====================

Syntax:
.......

 -- Function: char-name character → name

Arguments and Values:
.....................

CHARACTER—a character.

NAME—a string or ‘nil’.

Description:
............

Returns a string that is the name of the CHARACTER, or ‘nil’ if the
CHARACTER has no name.

All non-graphic characters are required to have names unless they have
some implementation-defined attribute which is not null.  Whether or not
other characters have names is implementation-dependent.

The standard characters <Newline> and <Space> have the respective names
‘"Newline"’ and ‘"Space"’.  The semi-standard characters <Tab>, <Page>,
<Rubout>, <Linefeed>, <Return>, and <Backspace>  (if they are supported
by the implementation) have the respective names ‘"Tab"’, ‘"Page"’,
‘"Rubout"’, ‘"Linefeed"’, ‘"Return"’, and ‘"Backspace"’ (in the
indicated case, even though name lookup by “‘#\’” and by the function
‘name-char’ is not case sensitive).

Examples:
.........

      (char-name #\ ) → "Space"
      (char-name #\Space) → "Space"
      (char-name #\Page) → "Page"

      (char-name #\a)
     → NIL
     or→ "LOWERCASE-a"
     or→ "Small-A"
     or→ "LA01"

      (char-name #\A)
     → NIL
     or→ "UPPERCASE-A"
     or→ "Capital-A"
     or→ "LA02"

      ;; Even though its CHAR-NAME can vary, #\A prints as #\A
      (prin1-to-string (read-from-string (format nil "#\\~A" (or (char-name #\A) "A"))))
     → "#\\A"

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note name-char::, *note Section 22.1.3.2 (Printing Characters):
PrintingCharacters.

Notes:
......

Non-graphic characters having names are written by the Lisp printer as
“‘#\’” followed by the their name; see *note Section 22.1.3.2 (Printing
Characters): PrintingCharacters.


File: ansicl,  Node: name-char,  Prev: char-name,  Up: Characters

name-char (Function)
====================

Syntax:
.......

 -- Function: name-char name → char-p

Arguments and Values:
.....................

NAME—a string designator.

CHAR-P—a character or ‘nil’.

Description:
............

Returns the character object whose name is NAME (as determined by
‘string-equal’—i.e., lookup is not case sensitive).  If such a character
does not exist, ‘nil’ is returned.

Examples:
.........

     (name-char 'space) → #\Space
     (name-char "space") → #\Space
     (name-char "Space") → #\Space
     (let ((x (char-name #\a)))
       (or (not x) (eql (name-char x) #\a))) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NAME is not a string
designator.

See Also:
.........

*note char-name::


File: ansicl,  Node: Conses,  Next: Arrays,  Prev: Characters,  Up: Top

14 Conses
*********

* Menu:

* Cons Concepts::

Dictionary

* list (System Class)::
* null (System Class)::
* cons (System Class)::
* atom (Type)::
* cons (Function)::
* consp::
* atom (Function)::
* rplaca; rplacd::
* car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+::
* copy-tree::
* sublis; nsublis::
* subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not::
* tree-equal::
* copy-list::
* list; list*::
* list-length::
* listp::
* make-list::
* push::
* pop::
* first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+::
* nth::
* endp::
* null (Function)::
* nconc::
* append::
* revappend; nreconc::
* butlast; nbutlast::
* last::
* ldiff; tailp::
* nthcdr::
* rest::
* member; member-if; member-if-not::
* mapc; mapcar; mapcan; mapl; maplist; mapcon::
* acons::
* assoc; assoc-if; assoc-if-not::
* copy-alist::
* pairlis::
* rassoc; rassoc-if; rassoc-if-not::
* get-properties::
* getf::
* remf::
* intersection; nintersection::
* adjoin::
* pushnew::
* set-difference; nset-difference::
* set-exclusive-or; nset-exclusive-or::
* subsetp::
* union; nunion::


File: ansicl,  Node: Cons Concepts,  Next: list (System Class),  Up: Conses

14.1 Cons Concepts
==================

A “cons” is a compound data object having two components called the car
and the cdr.

car   cons     rplacd
cdr   rplaca

Figure 14.1: Some defined names relating to conses.

Depending on context, a group of connected conses can be viewed in a
variety of different ways.  A variety of operations is provided to
support each of these various views.

* Menu:

* Conses as Trees::
* Conses as Lists::


File: ansicl,  Node: Conses as Trees,  Next: Conses as Lists,  Up: Cons Concepts

14.1.1 Conses as Trees
----------------------

A “tree” is a binary recursive data structure made up of conses and
atoms: the conses are themselves also trees (sometimes called “subtrees”
or “branches”), and the atoms are terminal nodes (sometimes called
“leaves”).  Typically, the leaves represent data while the branches
establish some relationship among that data.

caaaar   caddar   cdar        nsubst
caaadr   cadddr   cddaar      nsubst-if
caaar    caddr    cddadr      nsubst-if-not
caadar   cadr     cddar       nthcdr
caaddr   cdaaar   cdddar      sublis
caadr    cdaadr   cddddr      subst
caar     cdaar    cdddr       subst-if
cadaar   cdadar   cddr        subst-if-not
cadadr   cdaddr   copy-tree   tree-equal
cadar    cdadr    nsublis

Figure 14.2: Some defined names relating to trees.

14.1.1.1 General Restrictions on Parameters that must be Trees
..............................................................

Except as explicitly stated otherwise, for any standardized function
that takes a parameter that is required to be a tree, the consequences
are undefined if that tree is circular.


File: ansicl,  Node: Conses as Lists,  Prev: Conses as Trees,  Up: Cons Concepts

14.1.2 Conses as Lists
----------------------

A “list” is a chain of conses in which the car of each cons is an
element of the list, and the cdr of each cons is either the next link in
the chain or a terminating atom.

A “proper list” is a list terminated by the empty list.  The empty list
is a proper list, but is not a cons.

An “improper list” is a list that is not a proper list; that is, it is a
circular list or a dotted list.

A “dotted list” is a list that has a terminating atom that is not the
empty list.  A non-nil atom by itself is not considered to be a list of
any kind—not even a dotted list.

A “circular list” is a chain of conses that has no termination because
some cons in the chain is the cdr of a later cons.

append       last            nbutlast   rest
butlast      ldiff           nconc      revappend
copy-alist   list            ninth      second
copy-list    list*           nreconc    seventh
eighth       list-length     nth        sixth
endp         make-list       nthcdr     tailp
fifth        member          pop        tenth
first        member-if       push       third
fourth       member-if-not   pushnew

Figure 14.3: Some defined names relating to lists.

14.1.2.1 Lists as Association Lists
...................................

An “association list” is a list of conses representing an association of
keys with values, where the car of each cons is the key and the cdr is
the value associated with that key.

acons   assoc-if       pairlis   rassoc-if
assoc   assoc-if-not   rassoc    rassoc-if-not

Figure 14.4: Some defined names related to assocation lists.

14.1.2.2 Lists as Sets
......................

Lists are sometimes viewed as sets by considering their elements
unordered and by assuming there is no duplication of elements.

adjoin          nset-difference     set-difference     union
intersection    nset-exclusive-or   set-exclusive-or
nintersection   nunion              subsetp

Figure 14.5: Some defined names related to sets.

14.1.2.3 General Restrictions on Parameters that must be Lists
..............................................................

Except as explicitly specified otherwise, any standardized function that
takes a parameter that is required to be a list should be prepared to
signal an error of type ‘type-error’ if the value received is a dotted
list.

Except as explicitly specified otherwise, for any standardized function
that takes a parameter that is required to be a list, the consequences
are undefined if that list is circular.


File: ansicl,  Node: list (System Class),  Next: null (System Class),  Prev: Cons Concepts,  Up: Conses

list (System Class)
===================

Class Precedence List:
......................

‘list’, ‘sequence’, ‘t’

Description:
............

A “list” is a chain of conses in which the car of each cons is an
element of the list, and the cdr of each cons is either the next link in
the chain or a terminating atom.

A “proper list” is a chain of conses terminated by the “empty list”, (),
which is itself a proper list.  A “dotted list” is a list which has a
terminating atom that is not the empty list.  A “circular list” is a
chain of conses that has no termination because some cons in the chain
is the cdr of a later cons.

Dotted lists and circular lists are also lists, but usually the
unqualified term “list” within this specification means proper list.
Nevertheless, the type ‘list’ unambiguously includes dotted lists and
circular lists.

For each element of a list there is a cons.  The empty list has no
elements and is not a cons.

The types ‘cons’ and ‘null’ form an exhaustive partition of the type
‘list’.

See Also:
.........

*note Section 2.4.1 (Left-Parenthesis): Left-Parenthesis, *note Section
22.1.3.5 (Printing Lists and Conses): PrintingListsAndConses.


File: ansicl,  Node: null (System Class),  Next: cons (System Class),  Prev: list (System Class),  Up: Conses

null (System Class)
===================

Class Precedence List:
......................

‘null’, ‘symbol’, ‘list’, ‘sequence’, ‘t’

Description:
............

The only object of type ‘null’ is ‘nil’, which represents the empty list
and can also be notated ().

See Also:
.........

*note Section 2.3.4 (Symbols as Tokens): Symbols as Tokens, *note
Section 2.4.1 (Left-Parenthesis): Left-Parenthesis, *note Section
22.1.3.3 (Printing Symbols): PrintingSymbols.


File: ansicl,  Node: cons (System Class),  Next: atom (Type),  Prev: null (System Class),  Up: Conses

cons (System Class)
===================

Class Precedence List:
......................

‘cons’, ‘list’, ‘sequence’, ‘t’

Description:
............

A cons is a compound object having two components, called the car and
cdr.  These form a dotted pair.  Each component can be any object.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(cons [car-typespec [cdr-typespec]])

Compound Type Specifier Arguments:
..................................

CAR-TYPESPEC—a type specifier, or the symbol *.  The default is the
symbol *.

CDR-TYPESPEC—a type specifier, or the symbol *.  The default is the
symbol *.

Compound Type Specifier Description:
....................................

This denotes the set of conses whose car is constrained to be of type
CAR-TYPESPEC and whose cdr is constrained to be of type CDR-TYPESPEC.
(If either CAR-TYPESPEC or CDR-TYPESPEC is *, it is as if the type ‘t’
had been denoted.)

See Also:
.........

*note Section 2.4.1 (Left-Parenthesis): Left-Parenthesis, *note Section
22.1.3.5 (Printing Lists and Conses): PrintingListsAndConses.


File: ansicl,  Node: atom (Type),  Next: cons (Function),  Prev: cons (System Class),  Up: Conses

atom (Type)
===========

Supertypes:
...........

‘atom’, ‘t’

Description:
............

It is equivalent to ‘(not cons)’.


File: ansicl,  Node: cons (Function),  Next: consp,  Prev: atom (Type),  Up: Conses

cons (Function)
===============

Syntax:
.......

 -- Function: cons object-1 object-2 → cons

Arguments and Values:
.....................

OBJECT-1—an object.

OBJECT-2—an object.

CONS—a cons.

Description:
............

Creates a fresh cons, the car of which is OBJECT-1 and the cdr of which
is OBJECT-2.

Examples:
.........

      (cons 1 2) → (1 . 2)
      (cons 1 nil) → (1)
      (cons nil 2) → (NIL . 2)
      (cons nil nil) → (NIL)
      (cons 1 (cons 2 (cons 3 (cons 4 nil)))) → (1 2 3 4)
      (cons 'a 'b) → (A . B)
      (cons 'a (cons 'b (cons 'c '()))) → (A B C)
      (cons 'a '(b c d)) → (A B C D)

See Also:
.........

*note list::

Notes:
......

If OBJECT-2 is a list, ‘cons’ can be thought of as producing a new list
which is like it but has OBJECT-1 prepended.


File: ansicl,  Node: consp,  Next: atom (Function),  Prev: cons (Function),  Up: Conses

consp (Function)
================

Syntax:
.......

 -- Function: consp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘cons’; otherwise, returns false.

Examples:
.........

      (consp nil) → false
      (consp (cons 1 2)) → true

The empty list is not a cons, so

      (consp '()) ≡ (consp 'nil) → false

See Also:
.........

*note listp::

Notes:
......

      (consp OBJECT) ≡ (typep OBJECT 'cons) ≡ (not (typep OBJECT 'atom)) ≡ (typep OBJECT '(not atom))


File: ansicl,  Node: atom (Function),  Next: rplaca; rplacd,  Prev: consp,  Up: Conses

atom (Function)
===============

Syntax:
.......

 -- Function: atom object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘atom’; otherwise, returns false.

Examples:
.........

      (atom 'sss) → true
      (atom (cons 1 2)) → false
      (atom nil) → true
      (atom '()) → true
      (atom 3) → true

Notes:
......

      (atom OBJECT) ≡ (typep OBJECT 'atom) ≡ (not (consp OBJECT))
      ≡ (not (typep OBJECT 'cons)) ≡ (typep OBJECT '(not cons))


File: ansicl,  Node: rplaca; rplacd,  Next: car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+,  Prev: atom (Function),  Up: Conses

rplaca, rplacd (Function)
=========================

Syntax:
.......

 -- Function: rplaca cons object → cons
 -- Function: rplacd cons object → cons

Pronunciation:
..............

‘rplaca’: [ˌrēˈplakə] or [ˌrəˈplakə]

‘rplacd’: [ˌrēˈplakdə] or [ˌrəˈplakdə] or [ˌrēˈplakdē] or [ˌrəˈplakdē]

Arguments and Values:
.....................

CONS—a cons.

OBJECT—an object.

Description:
............

‘rplaca’ replaces the car of the CONS with OBJECT.

‘rplacd’ replaces the cdr of the CONS with OBJECT.

Examples:
.........

      (defparameter *some-list* (list* 'one 'two 'three 'four)) → *some-list*
      *some-list* → (ONE TWO THREE . FOUR)
      (rplaca *some-list* 'uno) → (UNO TWO THREE . FOUR)
      *some-list* → (UNO TWO THREE . FOUR)
      (rplacd (last *some-list*) (list 'IV)) → (THREE IV)
      *some-list* → (UNO TWO THREE IV)

Side Effects:
.............

The CONS is modified.

Should signal an error of type ‘type-error’ if CONS is not a cons.


File: ansicl,  Node: car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+,  Next: copy-tree,  Prev: rplaca; rplacd,  Up: Conses

car, cdr, caar, cadr, cdar, cddr, caaar, caadr, cadar, caddr, cdaar, cdadr, cddar, cdddr, caaaar, caaadr, caadar, caaddr, cadaar, cadadr, caddar, cadddr, cdaaar, cdaadr, cdadar, cdaddr, cddaar, cddadr, cdddar, cddddr (Accessor)
===================================================================================================================================================================================================================================

Syntax:
.......

car x → object | (setf (x object) new-object)
cdr x → object | (setf (x object) new-object)
caar x → object | (setf (x object) new-object)
cadr x → object | (setf (x object) new-object)
cdar x → object | (setf (x object) new-object)
cddr x → object | (setf (x object) new-object)
caaar x → object | (setf (x object) new-object)
caadr x → object | (setf (x object) new-object)
cadar x → object | (setf (x object) new-object)
caddr x → object | (setf (x object) new-object)
cdaar x → object | (setf (x object) new-object)
cdadr x → object | (setf (x object) new-object)
cddar x → object | (setf (x object) new-object)
cdddr x → object | (setf (x object) new-object)
caaaar x → object | (setf (x object) new-object)
caaadr x → object | (setf (x object) new-object)
caadar x → object | (setf (x object) new-object)
caaddr x → object | (setf (x object) new-object)
cadaar x → object | (setf (x object) new-object)
cadadr x → object | (setf (x object) new-object)
caddar x → object | (setf (x object) new-object)
cadddr x → object | (setf (x object) new-object)
cdaaar x → object | (setf (x object) new-object)
cdaadr x → object | (setf (x object) new-object)
cdadar x → object | (setf (x object) new-object)
cdaddr x → object | (setf (x object) new-object)
cddaar x → object | (setf (x object) new-object)
cddadr x → object | (setf (x object) new-object)
cdddar x → object | (setf (x object) new-object)
cddddr x → object | (setf (x object) new-object)


Pronunciation:
..............

‘cadr’: [ˈkaˌdə r]

‘caddr’: [ˈkadə ˌdə r] or [ˈkaˌd\.udə r]

‘cdr’: [ˈk\.uˌdə r]

‘cddr’: [ˈk\.udə ˌdə r] or [ˈkəˌd\.udə r]

Arguments and Values:
.....................

X—a list.

OBJECT—an object.

NEW-OBJECT—an object.

Description:
............

If X is a cons, ‘car’ returns the car of that cons.  If X is ‘nil’,
‘car’ returns ‘nil’.

If X is a cons, ‘cdr’ returns the cdr of that cons.  If X is ‘nil’,
‘cdr’ returns ‘nil’.

Functions are provided which perform compositions of up to four ‘car’
and ‘cdr’ operations.  Their names consist of a ‘C’, followed by two,
three, or four occurrences of ‘A’ or ‘D’, and finally an ‘R’.  The
series of ‘A’’s and ‘D’’s in each function’s name is chosen to identify
the series of ‘car’ and ‘cdr’ operations that is performed by the
function.  The order in which the ‘A’’s and ‘D’’s appear is the inverse
of the order in which the corresponding operations are performed.  The
next figure  defines the relationships precisely.

This place ...   Is equivalent to this place ...
---------------------------------------------------
‘(caar X)’       ‘(car (car X))’
‘(cadr X)’       ‘(car (cdr X))’
‘(cdar X)’       ‘(cdr (car X))’
‘(cddr X)’       ‘(cdr (cdr X))’
‘(caaar X)’      ‘(car (car (car X)))’
‘(caadr X)’      ‘(car (car (cdr X)))’
‘(cadar X)’      ‘(car (cdr (car X)))’
‘(caddr X)’      ‘(car (cdr (cdr X)))’
‘(cdaar X)’      ‘(cdr (car (car X)))’
‘(cdadr X)’      ‘(cdr (car (cdr X)))’
‘(cddar X)’      ‘(cdr (cdr (car X)))’
‘(cdddr X)’      ‘(cdr (cdr (cdr X)))’
‘(caaaar X)’     ‘(car (car (car (car X))))’
‘(caaadr X)’     ‘(car (car (car (cdr X))))’
‘(caadar X)’     ‘(car (car (cdr (car X))))’
‘(caaddr X)’     ‘(car (car (cdr (cdr X))))’
‘(cadaar X)’     ‘(car (cdr (car (car X))))’
‘(cadadr X)’     ‘(car (cdr (car (cdr X))))’
‘(caddar X)’     ‘(car (cdr (cdr (car X))))’
‘(cadddr X)’     ‘(car (cdr (cdr (cdr X))))’
‘(cdaaar X)’     ‘(cdr (car (car (car X))))’
‘(cdaadr X)’     ‘(cdr (car (car (cdr X))))’
‘(cdadar X)’     ‘(cdr (car (cdr (car X))))’
‘(cdaddr X)’     ‘(cdr (car (cdr (cdr X))))’
‘(cddaar X)’     ‘(cdr (cdr (car (car X))))’
‘(cddadr X)’     ‘(cdr (cdr (car (cdr X))))’
‘(cdddar X)’     ‘(cdr (cdr (cdr (car X))))’
‘(cddddr X)’     ‘(cdr (cdr (cdr (cdr X))))’

Figure 14.6: CAR and CDR variants

‘setf’ can also be used with any of these functions to change an
existing component of X, but ‘setf’ will not make new components.  So,
for example, the car of a cons can be assigned with ‘setf’ of ‘car’, but
the car of ‘nil’ cannot be assigned with ‘setf’ of ‘car’.  Similarly,
the car of the car of a cons whose car is a cons can be assigned with
‘setf’ of ‘caar’, but neither ‘nil’ nor a cons whose car is ‘nil’ can be
assigned with ‘setf’ of ‘caar’.

The argument X is permitted to be a dotted list or a circular list.

Examples:
.........

      (car nil) → NIL
      (cdr '(1 . 2)) → 2
      (cdr '(1 2)) → (2)
      (cadr '(1 2)) → 2
      (car '(a b c)) → A
      (cdr '(a b c)) → (B C)

Exceptional Situations:
.......................

The functions ‘car’ and ‘cdr’ should signal ‘type-error’ if they receive
an argument which is not a list.  The other functions (‘caar’, ‘cadr’,
... ‘cddddr’) should behave for the purpose of error checking as if
defined by appropriate calls to ‘car’ and ‘cdr’.

See Also:
.........

*note rplaca::, *note first::, *note rest::

Notes:
......

The car of a cons can also be altered by using ‘rplaca’, and the cdr of
a cons can be altered by using ‘rplacd’.

     (car x)    ≡ (first x)
     (cadr x)   ≡ (second x) ≡ (car (cdr x))
     (caddr x)  ≡ (third x)  ≡ (car (cdr (cdr x)))
     (cadddr x) ≡ (fourth x) ≡ (car (cdr (cdr (cdr x))))


File: ansicl,  Node: copy-tree,  Next: sublis; nsublis,  Prev: car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+,  Up: Conses

copy-tree (Function)
====================

Syntax:
.......

 -- Function: copy-tree tree → new-tree

Arguments and Values:
.....................

TREE—a tree.

NEW-TREE—a tree.

Description:
............

Creates a copy of a tree of conses.

If TREE is not a cons, it is returned; otherwise, the result is a new
cons of the results of calling ‘copy-tree’ on the car and cdr of TREE.
In other words, all conses in the tree represented by TREE are copied
recursively, stopping only when non-conses are encountered.

‘copy-tree’ does not preserve circularities and the sharing of
substructure.

Examples:
.........

      (setq object (list (cons 1 "one")
                         (cons 2 (list 'a 'b 'c))))
     → ((1 . "one") (2 A B C))
      (setq object-too object) → ((1 . "one") (2 A B C))
      (setq copy-as-list (copy-list object))
      (setq copy-as-alist (copy-alist object))
      (setq copy-as-tree (copy-tree object))
      (eq object object-too) → true
      (eq copy-as-tree object) → false
      (eql copy-as-tree object) → false
      (equal copy-as-tree object) → true
      (setf (first (cdr (second object))) "a"
            (car (second object)) "two"
            (car object) '(one . 1)) → (ONE . 1)
      object → ((ONE . 1) ("two" "a" B C))
      object-too → ((ONE . 1) ("two" "a" B C))
      copy-as-list → ((1 . "one") ("two" "a" B C))
      copy-as-alist → ((1 . "one") (2 "a" B C))
      copy-as-tree → ((1 . "one") (2 A B C))

See Also:
.........

*note tree-equal::


File: ansicl,  Node: sublis; nsublis,  Next: subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not,  Prev: copy-tree,  Up: Conses

sublis, nsublis (Function)
==========================

Syntax:
.......

 -- Function: sublis alist tree &key key test test-not → new-tree
 -- Function: nsublis alist tree &key key test test-not → new-tree

Arguments and Values:
.....................

ALIST—an association list.

TREE—a tree.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

NEW-TREE—a tree.

Description:
............

‘sublis’ makes substitutions for objects in TREE (a structure of
conses).  ‘nsublis’ is like ‘sublis’ but destructively modifies the
relevant parts of the TREE.

‘sublis’ looks at all subtrees and leaves of TREE; if a subtree or leaf
appears as a key in ALIST (that is, the key and the subtree or leaf
satisfy the test), it is replaced by the object with which that key is
associated.  This operation is non-destructive.  In effect, ‘sublis’ can
perform several ‘subst’ operations simultaneously.

If ‘sublis’ succeeds, a new copy of TREE is returned in which each
occurrence of such a subtree or leaf is replaced by the object with
which it is associated.  If no changes are made, the original tree is
returned.  The original TREE is left unchanged, but the result tree may
share cells with it.

‘nsublis’ is permitted to modify TREE but otherwise returns the same
values as ‘sublis’.

Examples:
.........

      (sublis '((x . 100) (z . zprime))
              '(plus x (minus g z x p) 4 . x))
     → (PLUS 100 (MINUS G ZPRIME 100 P) 4 . 100)
      (sublis '(((+ x y) . (- x y)) ((- x y) . (+ x y)))
              '(* (/ (+ x y) (+ x p)) (- x y))
              :test #'equal)
     → (* (/ (- X Y) (+ X P)) (+ X Y))
      (setq tree1 '(1 (1 2) ((1 2 3)) (((1 2 3 4)))))
     → (1 (1 2) ((1 2 3)) (((1 2 3 4))))
      (sublis '((3 . "three")) tree1)
     → (1 (1 2) ((1 2 "three")) (((1 2 "three" 4))))
      (sublis '((t . "string"))
               (sublis '((1 . "") (4 . 44)) tree1)
               :key #'stringp)
     → ("string" ("string" 2) (("string" 2 3)) ((("string" 2 3 44))))
      tree1 → (1 (1 2) ((1 2 3)) (((1 2 3 4))))
      (setq tree2 '("one" ("one" "two") (("one" "Two" "three"))))
     → ("one" ("one" "two") (("one" "Two" "three")))
      (sublis '(("two" . 2)) tree2)
     → ("one" ("one" "two") (("one" "Two" "three")))
      tree2 → ("one" ("one" "two") (("one" "Two" "three")))
      (sublis '(("two" . 2)) tree2 :test 'equal)
     → ("one" ("one" 2) (("one" "Two" "three")))

      (nsublis '((t . 'temp))
                tree1
                :key #'(lambda (x) (or (atom x) (< (list-length x) 3))))
     → ((QUOTE TEMP) (QUOTE TEMP) QUOTE TEMP)

Side Effects:
.............

‘nsublis’ modifies TREE.

See Also:
.........

*note subst::, *note Section 3.2.1 (Compiler Terminology): Compiler
Terminology, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Because the side-effecting variants (e.g., ‘nsublis’) potentially change
the path that is being traversed, their effects in the presence of
shared or circular structure structure may vary in surprising ways when
compared to their non-side-effecting alternatives.  To see this,
consider the following side-effect behavior, which might be exhibited by
some implementations:

      (defun test-it (fn)
        (let* ((shared-piece (list 'a 'b))
               (data (list shared-piece shared-piece)))
          (funcall fn '((a . b) (b . a)) data)))
      (test-it #'sublis) → ((B A) (B A))
      (test-it #'nsublis) → ((A B) (A B))


File: ansicl,  Node: subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not,  Next: tree-equal,  Prev: sublis; nsublis,  Up: Conses

subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not (Function)
==========================================================================

Syntax:
.......

 -- Function: subst new old tree &key key test test-not → new-tree
 -- Function: subst-if new predicate tree &key key → new-tree
 -- Function: subst-if-not new predicate tree &key key → new-tree

 -- Function: nsubst new old tree &key key test test-not → new-tree
 -- Function: nsubst-if new predicate tree &key key → new-tree
 -- Function: nsubst-if-not new predicate tree &key key → new-tree

Arguments and Values:
.....................

NEW—an object.

OLD—an object.

PREDICATE—a symbol that names a function, or a function of one argument
that returns a generalized boolean value.

TREE—a tree.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

NEW-TREE—a tree.

Description:
............

‘subst’, ‘subst-if’, and ‘subst-if-not’ perform substitution operations
on TREE.  Each function searches TREE for occurrences of a particular
OLD item of an element or subexpression that satisfies the test.

‘nsubst’, ‘nsubst-if’, and ‘nsubst-if-not’ are like ‘subst’, ‘subst-if’,
and ‘subst-if-not’ respectively, except that the original TREE is
modified.

‘subst’ makes a copy of TREE, substituting NEW for every subtree or leaf
of TREE (whether the subtree or leaf is a car or a cdr of its parent)
such that OLD and the subtree or leaf satisfy the test.

‘nsubst’ is a destructive version of ‘subst’.  The list structure of
TREE is altered by destructively replacing with NEW each leaf of the
TREE such that OLD and the leaf satisfy the test.

For ‘subst’, ‘subst-if’, and ‘subst-if-not’, if the functions succeed, a
new copy of the tree is returned in which each occurrence of such an
element is replaced by the NEW element or subexpression.  If no changes
are made, the original TREE may be returned.  The original TREE is left
unchanged, but the result tree may share storage with it.

For ‘nsubst’, ‘nsubst-if’, and ‘nsubst-if-not’ the original TREE is
modified and returned as the function result, but the result may not be
‘eq’ to TREE.

Examples:
.........

      (setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) → (1 (1 2) (1 2 3) (1 2 3 4))
      (subst "two" 2 tree1) → (1 (1 "two") (1 "two" 3) (1 "two" 3 4))
      (subst "five" 5 tree1) → (1 (1 2) (1 2 3) (1 2 3 4))
      (eq tree1 (subst "five" 5 tree1)) → implementation-dependent
      (subst 'tempest 'hurricane
             '(shakespeare wrote (the hurricane)))
     → (SHAKESPEARE WROTE (THE TEMPEST))
      (subst 'foo 'nil '(shakespeare wrote (twelfth night)))
     → (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)
      (subst '(a . cons) '(old . pair)
             '((old . spice) ((old . shoes) old . pair) (old . pair))
             :test #'equal)
     → ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))

      (subst-if 5 #'listp tree1) → 5
      (subst-if-not '(x) #'consp tree1)
     → (1 X)

      tree1 → (1 (1 2) (1 2 3) (1 2 3 4))
      (nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y))))
     → (1 (1 2) X X)
      tree1 → (1 (1 2) X X)

Side Effects:
.............

‘nsubst’, ‘nsubst-if’, and ‘nsubst-if-not’ might alter the tree
structure of TREE.

See Also:
.........

*note substitute::, *note nsubstitute::, *note Section 3.2.1 (Compiler
Terminology): Compiler Terminology, *note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The functions ‘subst-if-not’ and ‘nsubst-if-not’ are deprecated.

One possible definition of ‘subst’:

      (defun subst (old new tree &rest x &key test test-not key)
        (cond ((satisfies-the-test old tree :test test
                                   :test-not test-not :key key)
               new)
              ((atom tree) tree)
              (t (let ((a (apply #'subst old new (car tree) x))
                       (d (apply #'subst old new (cdr tree) x)))
                   (if (and (eql a (car tree))
                            (eql d (cdr tree)))
                       tree
                       (cons a d))))))


File: ansicl,  Node: tree-equal,  Next: copy-list,  Prev: subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not,  Up: Conses

tree-equal (Function)
=====================

Syntax:
.......

 -- Function: tree-equal tree-1 tree-2 &key test test-not →
          generalized-boolean

Arguments and Values:
.....................

TREE-1—a tree.

TREE-2—a tree.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘tree-equal’ tests whether two trees are of the same shape and have the
same leaves.  ‘tree-equal’ returns true if TREE-1 and TREE-2 are both
atoms and satisfy the test, or if they are both conses and the car of
TREE-1 is ‘tree-equal’ to the car of TREE-2 and the cdr of TREE-1 is
‘tree-equal’ to the cdr of TREE-2.  Otherwise, ‘tree-equal’ returns
false.

‘tree-equal’ recursively compares conses but not any other objects that
have components.

The first argument to the :test or :test-not function is TREE-1 or a car
or cdr of TREE-1; the second argument is TREE-2 or a car or cdr of
TREE-2.

Examples:
.........

      (setq tree1 '(1 (1 2))
            tree2 '(1 (1 2))) → (1 (1 2))
      (tree-equal tree1 tree2) → true
      (eql tree1 tree2) → false
      (setq tree1 '('a ('b 'c))
            tree2 '('a ('b 'c))) → ('a ('b 'c))
     → ((QUOTE A) ((QUOTE B) (QUOTE C)))
      (tree-equal tree1 tree2 :test 'eq) → true

Exceptional Situations:
.......................

The consequences are undefined if both TREE-1 and TREE-2 are circular.

See Also:
.........

*note equal::, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.


File: ansicl,  Node: copy-list,  Next: list; list*,  Prev: tree-equal,  Up: Conses

copy-list (Function)
====================

Syntax:
.......

 -- Function: copy-list list → copy

Arguments and Values:
.....................

LIST—a proper list or a dotted list.

COPY—a list.

Description:
............

Returns a copy of LIST.  If LIST is a dotted list, the resulting list
will also be a dotted list.

Only the list structure of LIST is copied; the elements of the resulting
list are the same as the corresponding elements of the given LIST.

Examples:
.........

      (setq lst (list 1 (list 2 3))) → (1 (2 3))
      (setq slst lst) → (1 (2 3))
      (setq clst (copy-list lst)) → (1 (2 3))
      (eq slst lst) → true
      (eq clst lst) → false
      (equal clst lst) → true
      (rplaca lst "one") → ("one" (2 3))
      slst → ("one" (2 3))
      clst → (1 (2 3))
      (setf (caadr lst) "two") → "two"
      lst → ("one" ("two" 3))
      slst → ("one" ("two" 3))
      clst → (1 ("two" 3))

Exceptional Situations:
.......................

The consequences are undefined if LIST is a circular list.

See Also:
.........

*note copy-alist::, *note copy-seq::, *note copy-tree::

Notes:
......

The copy created is ‘equal’ to LIST, but not ‘eq’.


File: ansicl,  Node: list; list*,  Next: list-length,  Prev: copy-list,  Up: Conses

list, list* (Function)
======================

Syntax:
.......

 -- Function: list &rest objects → list
 -- Function: list* &rest objects+ → result

Arguments and Values:
.....................

OBJECT—an object.

LIST—a list.

RESULT—an object.

Description:
............

‘list’ returns a list containing the supplied OBJECTS.

‘list*’ is like ‘list’ except that the last argument to ‘list’ becomes
the car of the last cons constructed, while the last argument to ‘list*’
becomes the cdr of the last cons constructed.  Hence, any given call to
‘list*’ always produces one fewer conses than a call to ‘list’ with the
same number of arguments.

If the last argument to ‘list*’ is a list, the effect is to construct a
new list which is similar, but which has additional elements added to
the front corresponding to the preceding arguments of ‘list*’.

If ‘list*’ receives only one OBJECT, that OBJECT is returned, regardless
of whether or not it is a list.

Examples:
.........

      (list 1) → (1)
      (list* 1) → 1
      (setq a 1) → 1
      (list a 2) → (1 2)
      '(a 2) → (A 2)
      (list 'a 2) → (A 2)
      (list* a 2) → (1 . 2)
      (list) → NIL ;i.e., ()
      (setq a '(1 2)) → (1 2)
      (eq a (list* a)) → true
      (list 3 4 'a (car '(b . c)) (+ 6 -2)) → (3 4 A B 4)
      (list* 'a 'b 'c 'd) ≡ (cons 'a (cons 'b (cons 'c 'd))) → (A B C . D)
      (list* 'a 'b 'c '(d e f)) → (A B C D E F)

See Also:
.........

*note cons (Function)::

Notes:
......

      (list* X) ≡ X


File: ansicl,  Node: list-length,  Next: listp,  Prev: list; list*,  Up: Conses

list-length (Function)
======================

Syntax:
.......

 -- Function: list-length list → length

Arguments and Values:
.....................

LIST—a proper list or a circular list.

LENGTH—a non-negative integer, or ‘nil’.

Description:
............

Returns the length of LIST if LIST is a proper list.  Returns ‘nil’ if
LIST is a circular list.

Examples:
.........

      (list-length '(a b c d)) → 4
      (list-length '(a (b c) d)) → 3
      (list-length '()) → 0
      (list-length nil) → 0
      (defun circular-list (&rest elements)
        (let ((cycle (copy-list elements)))
          (nconc cycle cycle)))
      (list-length (circular-list 'a 'b)) → NIL
      (list-length (circular-list 'a)) → NIL
      (list-length (circular-list)) → 0

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if LIST is not a proper list
or a circular list.

See Also:
.........

*note length::

Notes:
......

‘list-length’ could be implemented as follows:

      (defun list-length (x)
        (do ((n 0 (+ n 2))           ;Counter.
             (fast x (cddr fast))    ;Fast pointer: leaps by 2.
             (slow x (cdr slow)))    ;Slow pointer: leaps by 1.
            (nil)
          ;; If fast pointer hits the end, return the count.
          (when (endp fast) (return n))
          (when (endp (cdr fast)) (return (+ n 1)))
          ;; If fast pointer eventually equals slow pointer,
          ;;  then we must be stuck in a circular list.
          ;; (A deeper property is the converse: if we are
          ;;  stuck in a circular list, then eventually the
          ;;  fast pointer will equal the slow pointer.
          ;;  That fact justifies this implementation.)
          (when (and (eq fast slow) (> n 0)) (return nil))))



File: ansicl,  Node: listp,  Next: make-list,  Prev: list-length,  Up: Conses

listp (Function)
================

Syntax:
.......

 -- Function: listp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘list’; otherwise, returns false.

Examples:
.........

      (listp nil) → true
      (listp (cons 1 2)) → true
      (listp (make-array 6)) → false
      (listp t) → false

See Also:
.........

*note consp::

Notes:
......

If OBJECT is a cons, ‘listp’ does not check whether OBJECT is a proper
list; it returns true for any kind of list.

      (listp OBJECT) ≡ (typep OBJECT 'list) ≡ (typep OBJECT '(or cons null))


File: ansicl,  Node: make-list,  Next: push,  Prev: listp,  Up: Conses

make-list (Function)
====================

Syntax:
.......

 -- Function: make-list size &key initial-element → list

Arguments and Values:
.....................

SIZE—a non-negative integer.

INITIAL-ELEMENT—an object.  The default is ‘nil’.

LIST—a list.

Description:
............

Returns a list of LENGTH given by size, each of the elements of which is
INITIAL-ELEMENT.

Examples:
.........

      (make-list 5) → (NIL NIL NIL NIL NIL)
      (make-list 3 :initial-element 'rah) → (RAH RAH RAH)
      (make-list 2 :initial-element '(1 2 3)) → ((1 2 3) (1 2 3))
      (make-list 0) → NIL ;i.e., ()
      (make-list 0 :initial-element 'new-element) → NIL

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SIZE is not a
non-negative integer.

See Also:
.........

*note cons (Function)::, *note list::


File: ansicl,  Node: push,  Next: pop,  Prev: make-list,  Up: Conses

push (Macro)
============

Syntax:
.......

 -- Macro: push item place → new-place-value

Arguments and Values:
.....................

ITEM—an object.

PLACE—a place, the value of which may be any object.

NEW-PLACE-VALUE—a list (the new value of PLACE).

Description:
............

‘push’ prepends ITEM to the list that is stored in PLACE, stores the
resulting list in PLACE, and returns the list.

For information about the evaluation of subforms of PLACE, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

      (setq llst '(nil)) → (NIL)
      (push 1 (car llst)) → (1)
      llst → ((1))
      (push 1 (car llst)) → (1 1)
      llst → ((1 1))
      (setq x '(a (b c) d)) → (A (B C) D)
      (push 5 (cadr x)) → (5 B C)
      x → (A (5 B C) D)

Side Effects:
.............

The contents of PLACE are modified.

See Also:
.........

*note pop::, *note pushnew::, *note Section 5.1 (Generalized Reference):
Generalized Reference.

Notes:
......

The effect of ‘(push item place)’ is equivalent to

      (setf place (cons item place))

except that the subforms of PLACE are evaluated only once, and ITEM is
evaluated before PLACE.


File: ansicl,  Node: pop,  Next: first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+,  Prev: push,  Up: Conses

pop (Macro)
===========

Syntax:
.......

 -- Macro: pop place → element

Arguments and Values:
.....................

PLACE—a place, the value of which is a list (possibly, but necessarily,
a dotted list or circular list).

ELEMENT—an object (the car of the contents of PLACE).

Description:
............

‘pop’ reads the value of PLACE, remembers the car of the list which was
retrieved, writes the cdr of the list back into the PLACE, and finally
yields the car of the originally retrieved list.

For information about the evaluation of subforms of PLACE, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

      (setq stack '(a b c)) → (A B C)
      (pop stack) → A
      stack → (B C)
      (setq llst '((1 2 3 4))) → ((1 2 3 4))
      (pop (car llst)) → 1
      llst → ((2 3 4))

Side Effects:
.............

The contents of PLACE are modified.

See Also:
.........

*note push::, *note pushnew::, *note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of ‘(pop PLACE)’ is roughly equivalent to

      (prog1 (car PLACE) (setf PLACE (cdr PLACE)))

except that the latter would evaluate any subforms of PLACE three times,
while ‘pop’ evaluates them only once.


File: ansicl,  Node: first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+,  Next: nth,  Prev: pop,  Up: Conses

first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth (Accessor)
====================================================================================

Syntax:
.......

first list → object | (setf (list object) new-object)
second list → object | (setf (list object) new-object)
third list → object | (setf (list object) new-object)
fourth list → object | (setf (list object) new-object)
fifth list → object | (setf (list object) new-object)
sixth list → object | (setf (list object) new-object)
seventh list → object | (setf (list object) new-object)
eighth list → object | (setf (list object) new-object)
ninth list → object | (setf (list object) new-object)
tenth list → object | (setf (list object) new-object)


Arguments and Values:
.....................

LIST—a list, which might be a dotted list or a circular list.

OBJECT, NEW-OBJECT—an OBJECT.

Description:
............

The functions ‘first’, ‘second’, ‘third’, ‘fourth’, ‘fifth’, ‘sixth’,
‘seventh’, ‘eighth’, ‘ninth’, and ‘tenth’ ACCESS the first, second,
third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth elements
of LIST, respectively.  Specifically,

      (first LIST)    ≡  (car LIST)
      (second LIST)   ≡  (car (cdr LIST))
      (third LIST)    ≡  (car (cddr LIST))
      (fourth LIST)   ≡  (car (cdddr LIST))
      (fifth LIST)    ≡  (car (cddddr LIST))
      (sixth LIST)    ≡  (car (cdr (cddddr LIST)))
      (seventh LIST)  ≡  (car (cddr (cddddr LIST)))
      (eighth LIST)   ≡  (car (cdddr (cddddr LIST)))
      (ninth LIST)    ≡  (car (cddddr (cddddr LIST)))
      (tenth LIST)    ≡  (car (cdr (cddddr (cddddr LIST))))

‘setf’ can also be used with any of these functions to change an
existing component.  The same equivalences apply.  For example:

      (setf (fifth LIST) NEW-OBJECT) ≡ (setf (car (cddddr LIST)) NEW-OBJECT)

Examples:
.........

      (setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10))
     → (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)
      (first lst) → 1
      (tenth lst) → 10
      (fifth lst) → ((V))
      (second (fourth lst)) → 5
      (sixth '(1 2 3)) → NIL
      (setf (fourth lst) "four") → "four"
      lst → (1 2 3 "four" ((V)) VI 7 8 9 10)

See Also:
.........

*note car::, *note nth::

Notes:
......

‘first’ is functionally equivalent to ‘car’, ‘second’ is functionally
equivalent to ‘cadr’, ‘third’ is functionally equivalent to ‘caddr’, and
‘fourth’ is functionally equivalent to ‘cadddr’.

The ordinal numbering used here is one-origin, as opposed to the
zero-origin numbering used by ‘nth’:

      (fifth x) ≡ (nth 4 x)


File: ansicl,  Node: nth,  Next: endp,  Prev: first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+,  Up: Conses

nth (Accessor)
==============

Syntax:
.......

 -- Function: nth n list → object
(setf (nth n list) new-object)

Arguments and Values:
.....................

N—a non-negative integer.

LIST—a list, which might be a dotted list or a circular list.

OBJECT—an object.

NEW-OBJECT—an object.

Description:
............

‘nth’ locates the Nth element of LIST, where the car of the LIST is the
“zeroth” element.  Specifically,

      (nth N LIST) ≡ (car (nthcdr N LIST))

‘nth’ may be used to specify a PLACE to ‘setf’.  Specifically,

      (setf (nth N LIST) NEW-OBJECT) ≡ (setf (car (nthcdr N LIST)) NEW-OBJECT)

Examples:
.........

      (nth 0 '(foo bar baz)) → FOO
      (nth 1 '(foo bar baz)) → BAR
      (nth 3 '(foo bar baz)) → NIL
      (setq 0-to-3 (list 0 1 2 3)) → (0 1 2 3)
      (setf (nth 2 0-to-3) "two") → "two"
      0-to-3 → (0 1 "two" 3)

See Also:
.........

*note elt::, *note first::, *note nthcdr::


File: ansicl,  Node: endp,  Next: null (Function),  Prev: nth,  Up: Conses

endp (Function)
===============

Syntax:
.......

 -- Function: endp list → generalized-boolean

Arguments and Values:
.....................

LIST—a list, which might be a dotted list or a circular list.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if LIST is the empty list.  Returns false if LIST is a
cons.

Examples:
.........

      (endp nil) → true
      (endp '(1 2)) → false
      (endp (cddr '(1 2))) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if LIST is not a list.

Notes:
......

The purpose of ‘endp’ is to test for the end of PROPER LIST.  Since
‘endp’ does not descend into a cons, it is well-defined to pass it a
dotted list.  However, if shorter “lists” are iteratively produced by
calling ‘cdr’ on such a dotted list and those “lists” are tested with
‘endp’, a situation that has undefined consequences will eventually
result when the non-nil atom (which is not in fact a list) finally
becomes the argument to ‘endp’.  Since this is the usual way in which
‘endp’ is used, it is conservative programming style and consistent with
the intent of ‘endp’ to treat ‘endp’ as simply a function on proper
lists which happens not to enforce an argument type of proper list
except when the argument is atomic.


File: ansicl,  Node: null (Function),  Next: nconc,  Prev: endp,  Up: Conses

null (Function)
===============

Syntax:
.......

 -- Function: null object → boolean

Arguments and Values:
.....................

OBJECT—an object.

BOOLEAN—a boolean.

Description:
............

Returns ‘t’ if OBJECT is the empty list; otherwise, returns ‘nil’.

Examples:
.........

      (null '()) → T
      (null nil) → T
      (null t) → NIL
      (null 1) → NIL

See Also:
.........

*note not (Function)::

Notes:
......

‘null’ is intended to be used to test for the empty list whereas ‘not’
is intended to be used to invert a boolean (or generalized boolean).
Operationally, ‘null’ and ‘not’ compute the same result; which to use is
a matter of style.

      (null OBJECT) ≡ (typep OBJECT 'null) ≡ (eq OBJECT '())


File: ansicl,  Node: nconc,  Next: append,  Prev: null (Function),  Up: Conses

nconc (Function)
================

Syntax:
.......

 -- Function: nconc &rest lists → concatenated-list

Arguments and Values:
.....................

LIST—each but the last must be a list (which might be a DOTTED LIST but
must not be a circular list); the last LIST may be any object.

CONCATENATED-LIST—a list.

Description:
............

Returns a list that is the concatenation of LISTS.  If no LISTS are
supplied, ‘(nconc)’ returns ‘nil’.  ‘nconc’ is defined using the
following recursive relationship:

      (nconc) → ()
      (nconc nil . LISTS) ≡ (nconc . LISTS)
      (nconc LIST) → LIST
      (nconc LIST-1 LIST-2) ≡ (progn (rplacd (last LIST-1) LIST-2) LIST-1)
      (nconc LIST-1 LIST-2 . LISTS) ≡ (nconc (nconc LIST-1 LIST-2) . LISTS)

Examples:
.........

      (nconc) → NIL
      (setq x '(a b c)) → (A B C)
      (setq y '(d e f)) → (D E F)
      (nconc x y) → (A B C D E F)
      x → (A B C D E F)

Note, in the example, that the value of ‘x’ is now different, since its
last cons has been ‘rplacd’’d to the value of ‘y’.  If ‘(nconc x y)’
were evaluated again, it would yield a piece of a circular list, whose
printed representation would be ‘(A B C D E F D E F D E F ...)’,
repeating forever; if the ‘*print-circle*’ switch were non-nil, it would
be printed as ‘(A B C . #1=(D E F . #1#))’.

      (setq foo (list 'a 'b 'c 'd 'e)
            bar (list 'f 'g 'h 'i 'j)
            baz (list 'k 'l 'm)) → (K L M)
      (setq foo (nconc foo bar baz)) → (A B C D E F G H I J K L M)
      foo → (A B C D E F G H I J K L M)
      bar → (F G H I J K L M)
      baz → (K L M)

      (setq foo (list 'a 'b 'c 'd 'e)
            bar (list 'f 'g 'h 'i 'j)
            baz (list 'k 'l 'm)) → (K L M)
      (setq foo (nconc nil foo bar nil baz)) → (A B C D E F G H I J K L M)
      foo → (A B C D E F G H I J K L M)
      bar → (F G H I J K L M)
      baz → (K L M)

Side Effects:
.............

The LISTS are modified rather than copied.

See Also:
.........

*note append::, *note concatenate::


File: ansicl,  Node: append,  Next: revappend; nreconc,  Prev: nconc,  Up: Conses

append (Function)
=================

Syntax:
.......

 -- Function: append &rest lists → result

Arguments and Values:
.....................

LIST—each must be a proper list except the last, which may be any
object.

RESULT—an object.  This will be a list unless the last LIST was not a
list and all preceding LISTS were null.

Description:
............

‘append’ returns a new LIST that is the concatenation of the copies.
LISTS are left unchanged; the list structure of each of LISTS except the
last is copied.  The last argument is not copied; it becomes the cdr of
the final dotted pair of the concatenation of the preceding LISTS, or is
returned directly if there are no preceding non-empty LISTS.

Examples:
.........

      (append '(a b c) '(d e f) '() '(g)) → (A B C D E F G)
      (append '(a b c) 'd) → (A B C . D)
      (setq lst '(a b c)) → (A B C)
      (append lst '(d)) → (A B C D)
      lst → (A B C)
      (append) → NIL
      (append 'a) → A

See Also:
.........

*note nconc::, *note concatenate::


File: ansicl,  Node: revappend; nreconc,  Next: butlast; nbutlast,  Prev: append,  Up: Conses

revappend, nreconc (Function)
=============================

Syntax:
.......

 -- Function: revappend list tail → result-list
 -- Function: nreconc list tail → result-list

Arguments and Values:
.....................

LIST—a proper list.

TAIL—an object.

RESULT-LIST—an object.

Description:
............

‘revappend’ constructs a copybut with the elements in reverse order.  It
then appends (as if by ‘nconc’) the TAIL to that reversed list and
returns the result.

‘nreconc’ reverses the order of elements in LIST (as if by ‘nreverse’).
It then appends (as if by ‘nconc’) the TAIL to that reversed list and
returns the result.

The resulting list shares list structure with TAIL.

Examples:
.........

      (let ((list-1 (list 1 2 3))
            (list-2 (list 'a 'b 'c)))
        (print (revappend list-1 list-2))
        (print (equal list-1 '(1 2 3)))
        (print (equal list-2 '(a b c))))
     ▷ (3 2 1 A B C)
     ▷ T
     ▷ T
     → T

      (revappend '(1 2 3) '()) → (3 2 1)
      (revappend '(1 2 3) '(a . b)) → (3 2 1 A . B)
      (revappend '() '(a b c)) → (A B C)
      (revappend '(1 2 3) 'a) → (3 2 1 . A)
      (revappend '() 'a) → A   ;degenerate case

      (let ((list-1 '(1 2 3))
            (list-2 '(a b c)))
        (print (nreconc list-1 list-2))
        (print (equal list-1 '(1 2 3)))
        (print (equal list-2 '(a b c))))
     ▷ (3 2 1 A B C)
     ▷ NIL
     ▷ T
     → T


Side Effects:
.............

‘revappend’ does not modify either of its arguments.  ‘nreconc’ is
permitted to modify LIST but not TAIL.

Although it might be implemented differently, ‘nreconc’ is constrained
to have side-effect behavior equivalent to:

      (nconc (nreverse LIST) TAIL)

See Also:
.........

*note reverse::, *note nreverse::, *note nconc::

Notes:
......

The following functional equivalences are true, although good
implementations will typically use a faster algorithm for achieving the
same effect:

      (revappend LIST TAIL) ≡ (nconc (reverse LIST) TAIL)
      (nreconc LIST TAIL) ≡ (nconc (nreverse LIST) TAIL)


File: ansicl,  Node: butlast; nbutlast,  Next: last,  Prev: revappend; nreconc,  Up: Conses

butlast, nbutlast (Function)
============================

Syntax:
.......

 -- Function: butlast list &optional n → result-list
 -- Function: nbutlast list &optional n → result-list

Arguments and Values:
.....................

LIST—a list, which might be a dotted list but must not be a circular
list.

N—a non-negative integer.

RESULT-LIST—a list.

Description:
............

‘butlast’ returns a copy of LIST from which the last N conses have been
omitted.  If N is not supplied, its value is 1.  If there are fewer than
N conses in LIST, ‘nil’ is returned and, in the case of ‘nbutlast’, LIST
is not modified.

‘nbutlast’ is like ‘butlast’, but ‘nbutlast’ may modify LIST.  It
changes the cdr of the cons N+1 from the end of the LIST to ‘nil’.

Examples:
.........

      (setq lst '(1 2 3 4 5 6 7 8 9)) → (1 2 3 4 5 6 7 8 9)
      (butlast lst) → (1 2 3 4 5 6 7 8)
      (butlast lst 5) → (1 2 3 4)
      (butlast lst (+ 5 5)) → NIL
      lst → (1 2 3 4 5 6 7 8 9)
      (nbutlast lst 3) → (1 2 3 4 5 6)
      lst → (1 2 3 4 5 6)
      (nbutlast lst 99) → NIL
      lst → (1 2 3 4 5 6)
      (butlast '(a b c d)) → (A B C)
      (butlast '((a b) (c d))) → ((A B))
      (butlast '(a)) → NIL
      (butlast nil) → NIL
      (setq foo (list 'a 'b 'c 'd)) → (A B C D)
      (nbutlast foo) → (A B C)
      foo → (A B C)
      (nbutlast (list 'a)) → NIL
      (nbutlast '()) → NIL

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if LIST is not a proper list
or a dotted list.  Should signal an error of type ‘type-error’ if N is
not a non-negative integer.

Notes:
......

      (butlast LIST N) ≡ (ldiff LIST (last LIST N))


File: ansicl,  Node: last,  Next: ldiff; tailp,  Prev: butlast; nbutlast,  Up: Conses

last (Function)
===============

Syntax:
.......

 -- Function: last list &optional n → tail

Arguments and Values:
.....................

LIST—a list, which might be a dotted list but must not be a circular
list.

N—a non-negative integer.  The default is ‘1’.

TAIL—an object.

Description:
............

‘last’ returns the last N conses (not the last N elements) of LIST).  If
LIST is (), ‘last’ returns ().

If N is zero, the atom that terminates LIST is returned.  If N is
greater than or equal to the number of cons cells in LIST, the result is
LIST.

Examples:
.........

      (last nil) → NIL
      (last '(1 2 3)) → (3)
      (last '(1 2 . 3)) → (2 . 3)
      (setq x (list 'a 'b 'c 'd)) → (A B C D)
      (last x) → (D)
      (rplacd (last x) (list 'e 'f)) x → (A B C D E F)
      (last x) → (F)

      (last '(a b c))   → (C)

      (last '(a b c) 0) → ()
      (last '(a b c) 1) → (C)
      (last '(a b c) 2) → (B C)
      (last '(a b c) 3) → (A B C)
      (last '(a b c) 4) → (A B C)

      (last '(a . b) 0) → B
      (last '(a . b) 1) → (A . B)
      (last '(a . b) 2) → (A . B)

Exceptional Situations:
.......................

The consequences are undefined if LIST is a circular list.  Should
signal an error of type ‘type-error’ if N is not a non-negative integer.

See Also:
.........

*note butlast::, *note nth::

Notes:
......

The following code could be used to define ‘last’.

      (defun last (list &optional (n 1))
        (check-type n (integer 0))
        (do ((l list (cdr l))
             (r list)
             (i 0 (+ i 1)))
            ((atom l) r)
          (if (>= i n) (pop r))))


File: ansicl,  Node: ldiff; tailp,  Next: nthcdr,  Prev: last,  Up: Conses

ldiff, tailp (Function)
=======================

Syntax:
.......

 -- Function: ldiff list object → result-list
 -- Function: tailp object list → generalized-boolean

Arguments and Values:
.....................

LIST—a list, which might be a dotted list.

OBJECT—an object.

RESULT-LIST—a list.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

If OBJECT is the same as some tail of LIST, ‘tailp’ returns true;
otherwise, it returns false.

If OBJECT is the same as some tail of LIST, ‘ldiff’ returns a fresh list
of the elements of list that precede ‘object’ in the list structure of
LIST; otherwise, it returns a copy

Examples:
.........

      (let ((lists '#((a b c) (a b c . d))))
        (dotimes (i (length lists)) ()
          (let ((list (aref lists i)))
            (format t "~2&list=~S ~21T(tailp object list)~
                       ~44T(ldiff list object)~%" list)
              (let ((objects (vector list (cddr list) (copy-list (cddr list))
                                     '(f g h) '() 'd 'x)))
                (dotimes (j (length objects)) ()
                  (let ((object (aref objects j)))
                    (format t "~& object=~S ~21T~S ~44T~S"
                            object (tailp object list) (ldiff list object))))))))
     ▷
     ▷ list=(A B C)         (tailp object list)    (ldiff list object)
     ▷  object=(A B C)      T                      NIL
     ▷  object=(C)          T                      (A B)
     ▷  object=(C)          NIL                    (A B C)
     ▷  object=(F G H)      NIL                    (A B C)
     ▷  object=NIL          T                      (A B C)
     ▷  object=D            NIL                    (A B C)
     ▷  object=X            NIL                    (A B C)
     ▷
     ▷ list=(A B C . D)     (tailp object list)    (ldiff list object)
     ▷  object=(A B C . D)  T                      NIL
     ▷  object=(C . D)      T                      (A B)
     ▷  object=(C . D)      NIL                    (A B C . D)
     ▷  object=(F G H)      NIL                    (A B C . D)
     ▷  object=NIL          NIL                    (A B C . D)
     ▷  object=D            T                      (A B C)
     ▷  object=X            NIL                    (A B C . D)
     → NIL

Side Effects:
.............

Neither ‘ldiff’ nor ‘tailp’ modifies either of its arguments.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST is
not a proper list or a dotted list.

See Also:
.........

*note set-difference::

Notes:
......

If the LIST is a circular list, ‘tailp’ will reliably yield a value only
if the given OBJECT is in fact a tail of LIST.  Otherwise, the
consequences are unspecified: a given implementation which detects the
circularity must return false, but since an implementation is not
obliged to detect such a situation, ‘tailp’ might just loop indefinitely
without returning in that case.

‘tailp’ could be defined as follows:

      (defun tailp (object list)
        (do ((list list (cdr list)))
            ((atom list) (eql list object))
           (if (eql object list)
               (return t))))

and ‘ldiff’ could be defined by:

     (defun ldiff (list object)
       (do ((list list (cdr list))
            (r '() (cons (car list) r)))
           ((atom list)
            (if (eql list object) (nreverse r) (nreconc r list)))
         (when (eql object list)
           (return (nreverse r)))))


File: ansicl,  Node: nthcdr,  Next: rest,  Prev: ldiff; tailp,  Up: Conses

nthcdr (Function)
=================

Syntax:
.......

 -- Function: nthcdr n list → tail

Arguments and Values:
.....................

N—a non-negative integer.

LIST—a list, which might be a dotted list or a circular list.

TAIL—an object.

Description:
............

Returns the tail of LIST that would be obtained by calling ‘cdr’ N times
in succession.

Examples:
.........

      (nthcdr 0 '()) → NIL
      (nthcdr 3 '()) → NIL
      (nthcdr 0 '(a b c)) → (A B C)
      (nthcdr 2 '(a b c)) → (C)
      (nthcdr 4 '(a b c)) → ()
      (nthcdr 1 '(0 . 1)) → 1

      (locally (declare (optimize (safety 3)))
        (nthcdr 3 '(0 . 1)))
      Error: Attempted to take CDR of 1.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if N is not a non-negative
integer.

For N being an integer greater than ‘1’, the error checking done by
‘(nthcdr N LIST)’ is the same as for ‘(nthcdr (- N 1) (cdr LIST))’; see
the function *note cdr::.

See Also:
.........

*note cdr::, *note nth::, *note rest::


File: ansicl,  Node: rest,  Next: member; member-if; member-if-not,  Prev: nthcdr,  Up: Conses

rest (Accessor)
===============

Syntax:
.......

 -- Function: rest list → tail
(setf (rest list) new-tail)

Arguments and Values:
.....................

LIST—a list, which might be a dotted list or a circular list.

TAIL—an object.

Description:
............

‘rest’ performs the same operation as ‘cdr’, but mnemonically
complements ‘first’.  Specifically,

      (rest LIST) ≡ (cdr LIST)
      (setf (rest LIST) NEW-TAIL) ≡ (setf (cdr LIST) NEW-TAIL)

Examples:
.........

      (rest '(1 2)) → (2)
      (rest '(1 . 2)) → 2
      (rest '(1)) → NIL
      (setq *cons* '(1 . 2)) → (1 . 2)
      (setf (rest *cons*) "two") → "two"
      *cons* → (1 . "two")

See Also:
.........

*note cdr::, *note nthcdr::

Notes:
......

‘rest’ is often preferred stylistically over ‘cdr’ when the argument is
to being subjectively viewed as a list rather than as a cons.


File: ansicl,  Node: member; member-if; member-if-not,  Next: mapc; mapcar; mapcan; mapl; maplist; mapcon,  Prev: rest,  Up: Conses

member, member-if, member-if-not (Function)
===========================================

Syntax:
.......

 -- Function: member item list &key key test test-not → tail
 -- Function: member-if predicate list &key key → tail
 -- Function: member-if-not predicate list &key key → tail

Arguments and Values:
.....................

ITEM—an object.

LIST—a proper list.

PREDICATE—a designator for a function of one argument that returns a
generalized boolean.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

TAIL—a list.

Description:
............

‘member’, ‘member-if’, and ‘member-if-not’ each search LIST for ITEM or
for a top-level element that satisfies the test.  The argument to the
PREDICATE function is an element of LIST.

If some element satisfies the test, the tail of LIST beginning with this
element is returned; otherwise ‘nil’ is returned.

LIST is searched on the top level only.

Examples:
.........

      (member 2 '(1 2 3)) → (2 3)
      (member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) → ((3 . 4))
      (member 'e '(a b c d)) → NIL

      (member-if #'listp '(a b nil c d)) → (NIL C D)
      (member-if #'numberp '(a #\Space 5/3 foo)) → (5/3 FOO)
      (member-if-not #'zerop
                      '(3 6 9 11 . 12)
                      :key #'(lambda (x) (mod x 3))) → (11 . 12)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST is
not a proper list.

See Also:
.........

*note find::, *note position::, *note Section 3.6 (Traversal Rules and
Side Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The function ‘member-if-not’ is deprecated.

In the following

      (member 'a '(g (a y) c a d e a f)) → (A D E A F)

the value returned by ‘member’ is identical to the portion of the list
beginning with ‘a’.  Thus ‘rplaca’ on the result of ‘member’ can be used
to alter the part of the list where ‘a’ was found (assuming a check has
been made that ‘member’ did not return ‘nil’).


File: ansicl,  Node: mapc; mapcar; mapcan; mapl; maplist; mapcon,  Next: acons,  Prev: member; member-if; member-if-not,  Up: Conses

mapc, mapcar, mapcan, mapl, maplist, mapcon (Function)
======================================================

Syntax:
.......

 -- Function: mapc function &rest lists+ → list-1
 -- Function: mapcar function &rest lists+ → result-list
 -- Function: mapcan function &rest lists+ → concatenated-results
 -- Function: mapl function &rest lists+ → list-1
 -- Function: maplist function &rest lists+ → result-list
 -- Function: mapcon function &rest lists+ → concatenated-results

Arguments and Values:
.....................

FUNCTION—a designator for a function that must take as many arguments as
there are LISTS.

LIST—a proper list.

LIST-1—the first LIST (which must be a proper list).

RESULT-LIST—a list.

CONCATENATED-RESULTS—a list.

Description:
............

The mapping operation involves applying FUNCTION to successive sets of
arguments in which one argument is obtained from each sequence.  Except
for ‘mapc’ and ‘mapl’, the result contains the results returned by
FUNCTION.  In the cases of ‘mapc’ and ‘mapl’, the resulting sequence is
LIST.

FUNCTION is called first on all the elements with index ‘0’, then on all
those with index ‘1’, and so on.  RESULT-TYPE specifies the type of the
resulting sequence.  If FUNCTION is a symbol, it is ‘coerce’d to a
function as if by ‘symbol-function’.

‘mapcar’ operates on successive elements of the LISTS.  FUNCTION is
applied to the first element of each LIST, then to the second element of
each LIST, and so on.  The iteration terminates when the shortest LIST
runs out, and excess elements in other lists are ignored.  The value
returned by ‘mapcar’ is a list of the results of successive calls to
FUNCTION.

‘mapc’ is like ‘mapcar’ except that the results of applying FUNCTION are
not accumulated.  The LIST argument is returned.

‘maplist’ is like ‘mapcar’ except that FUNCTION is applied to successive
sublists of the LISTS.  FUNCTION is first applied to the LISTS
themselves, and then to the cdr of each LIST, and then to the cdr of the
cdr of each LIST, and so on.

‘mapl’ is like ‘maplist’ except that the results of applying FUNCTION
are not accumulated; LIST-1 is returned.

‘mapcan’ and ‘mapcon’ are like ‘mapcar’ and ‘maplist’ respectively,
except that the results of applying FUNCTION are combined into a list by
the use of ‘nconc’ rather than ‘list’.  That is,

      (mapcon f x1 ... xn)
        ≡ (apply #'nconc (maplist f x1 ... xn))

and similarly for the relationship between ‘mapcan’ and ‘mapcar’.

Examples:
.........

      (mapcar #'car '((1 a) (2 b) (3 c))) → (1 2 3)
      (mapcar #'abs '(3 -4 2 -5 -6)) → (3 4 2 5 6)
      (mapcar #'cons '(a b c) '(1 2 3)) → ((A . 1) (B . 2) (C . 3))

      (maplist #'append '(1 2 3 4) '(1 2) '(1 2 3))
     → ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3))
      (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))
     → ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))
      (maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))
     → (0 0 1 0 1 1 1)
     ;An entry is 1 if the corresponding element of the input
     ;  list was the last instance of that element in the input list.

      (setq dummy nil) → NIL
      (mapc #'(lambda (&rest x) (setq dummy (append dummy x)))
             '(1 2 3 4)
             '(a b c d e)
             '(x y z)) → (1 2 3 4)
      dummy → (1 A X 2 B Y 3 C Z)

      (setq dummy nil) → NIL
      (mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) → (1 2 3 4)
      dummy → ((4) (3 4) (2 3 4) (1 2 3 4))

      (mapcan #'(lambda (x y) (if (null x) nil (list x y)))
               '(nil nil nil d e)
               '(1 2 3 4 5 6)) → (D 4 E 5)
      (mapcan #'(lambda (x) (and (numberp x) (list x)))
               '(a 1 b c 3 4 d 5))
     → (1 3 4 5)

In this case the function serves as a filter; this is a standard
Lisp idiom using ‘mapcan’.

      (mapcon #'list '(1 2 3 4)) → ((1 2 3 4) (2 3 4) (3 4) (4))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if any LIST
is not a proper list.

See Also:
.........

*note dolist::, *note map::, *note Section 3.6 (Traversal Rules and Side
Effects): Traversal Rules and Side Effects.


File: ansicl,  Node: acons,  Next: assoc; assoc-if; assoc-if-not,  Prev: mapc; mapcar; mapcan; mapl; maplist; mapcon,  Up: Conses

acons (Function)
================

Syntax:
.......

 -- Function: acons key datum alist → new-alist

Arguments and Values:
.....................

KEY—an object.

DATUM—an object.

ALIST—an association list.

NEW-ALIST—an association list.

Description:
............

Creates a fresh cons, the cdr of which is ALIST and the car of which is
another fresh cons, the car of which is KEY and the cdr of which is
DATUM.

Examples:
.........

      (setq alist '()) → NIL
      (acons 1 "one" alist) → ((1 . "one"))
      alist → NIL
      (setq alist (acons 1 "one" (acons 2 "two" alist))) → ((1 . "one") (2 . "two"))
      (assoc 1 alist) → (1 . "one")
      (setq alist (acons 1 "uno" alist)) → ((1 . "uno") (1 . "one") (2 . "two"))
      (assoc 1 alist) → (1 . "uno")

See Also:
.........

*note assoc::, *note pairlis::

Notes:
......

     (acons KEY DATUM ALIST) ≡ (cons (cons KEY DATUM) ALIST)


File: ansicl,  Node: assoc; assoc-if; assoc-if-not,  Next: copy-alist,  Prev: acons,  Up: Conses

assoc, assoc-if, assoc-if-not (Function)
========================================

Syntax:
.......

 -- Function: assoc item alist &key key test test-not → entry

 -- Function: assoc-if predicate alist &key key → entry
 -- Function: assoc-if-not predicate alist &key key → entry

Arguments and Values:
.....................

ITEM—an object.

ALIST—an association list.

PREDICATE—a designator for a function of one argument that returns a
generalized boolean.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

ENTRY—a cons that is an element of ALIST, or ‘nil’.

Description:
............

‘assoc’, ‘assoc-if’, and ‘assoc-if-not’ return the first cons in ALIST
whose car satisfies the test, or ‘nil’ if no such cons is found.

For ‘assoc’, ‘assoc-if’, and ‘assoc-if-not’, if ‘nil’ appears in ALIST
in place of a pair, it is ignored.

Examples:
.........

      (setq values '((x . 100) (y . 200) (z . 50))) → ((X . 100) (Y . 200) (Z . 50))
      (assoc 'y values) → (Y . 200)
      (rplacd (assoc 'y values) 201) → (Y . 201)
      (assoc 'y values) → (Y . 201)
      (setq alist '((1 . "one")(2 . "two")(3 . "three")))
     → ((1 . "one") (2 . "two") (3 . "three"))
      (assoc 2 alist) → (2 . "two")
      (assoc-if #'evenp alist) → (2 . "two")
      (assoc-if-not #'(lambda(x) (< x 3)) alist) → (3 . "three")
      (setq alist '(("one" . 1)("two" . 2))) → (("one" . 1) ("two" . 2))
      (assoc "one" alist) → NIL
      (assoc "one" alist :test #'equalp) → ("one" . 1)
      (assoc "two" alist :key #'(lambda(x) (char x 2))) → NIL
      (assoc #\o alist :key #'(lambda(x) (char x 2))) → ("two" . 2)
      (assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z))) →  (R . X)
      (assoc 'goo '((foo . bar) (zoo . goo))) → NIL
      (assoc '2 '((1 a b c) (2 b c d) (-7 x y z))) → (2 B C D)
      (setq alist '(("one" . 1) ("2" . 2) ("three" . 3)))
     → (("one" . 1) ("2" . 2) ("three" . 3))
      (assoc-if-not #'alpha-char-p alist
                    :key #'(lambda (x) (char x 0))) → ("2" . 2)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if ALIST is
not an association list.

See Also:
.........

*note rassoc::, *note find::, *note member::, *note position::, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and Side
Effects.

Notes:
......

The :test-not parameter is deprecated.

The function ‘assoc-if-not’ is deprecated.

It is possible to ‘rplacd’ the result of ‘assoc’, provided that it is
not ‘nil’, in order to “update” ALIST.

The two expressions

      (assoc item list :test fn)

and

      (find item list :test fn :key #'car)

are equivalent in meaning with one exception: if ‘nil’ appears in ALIST
in place of a pair, and ITEM is ‘nil’, ‘find’ will compute the car of
the ‘nil’ in ALIST, find that it is equal to ITEM, and return ‘nil’,
whereas ‘assoc’ will ignore the ‘nil’ in ALIST and continue to search
for an actual cons whose car is ‘nil’.


File: ansicl,  Node: copy-alist,  Next: pairlis,  Prev: assoc; assoc-if; assoc-if-not,  Up: Conses

copy-alist (Function)
=====================

Syntax:
.......

 -- Function: copy-alist alist → new-alist

Arguments and Values:
.....................

ALIST—an association list.

NEW-ALIST—an association list.

Description:
............

‘copy-alist’ returns a copy of ALIST.

The list structure of ALIST is copied, and the elements of ALIST which
are conses are also copied (as conses only).  Any other objects which
are referred to, whether directly or indirectly, by the ALIST continue
to be shared.

Examples:
.........

     (defparameter *alist* (acons 1 "one" (acons 2 "two" '())))
     *alist* → ((1 . "one") (2 . "two"))
     (defparameter *list-copy* (copy-list *alist*))
     *list-copy* → ((1 . "one") (2 . "two"))
     (defparameter *alist-copy* (copy-alist *alist*))
     *alist-copy* → ((1 . "one") (2 . "two"))
     (setf (cdr (assoc 2 *alist-copy*)) "deux") → "deux"
     *alist-copy* → ((1 . "one") (2 . "deux"))
     *alist* → ((1 . "one") (2 . "two"))
     (setf (cdr (assoc 1 *list-copy*)) "uno") → "uno"
     *list-copy* → ((1 . "uno") (2 . "two"))
     *alist* → ((1 . "uno") (2 . "two"))

See Also:
.........

*note copy-list::


File: ansicl,  Node: pairlis,  Next: rassoc; rassoc-if; rassoc-if-not,  Prev: copy-alist,  Up: Conses

pairlis (Function)
==================

Syntax:
.......

 -- Function: pairlis keys data &optional alist → new-alist

Arguments and Values:
.....................

KEYS—a proper list.

DATA—a proper list.

ALIST—an association list.  The default is the empty list.

NEW-ALIST—an association list.

Description:
............

Returns an association list that associates elements of KEYS to
corresponding elements of DATA.  The consequences are undefined if KEYS
and DATA are not of the same length.

If ALIST is supplied, ‘pairlis’ returns a modified ALIST with the new
pairs prepended to it.  The new pairs may appear in the resulting
association list in either forward or backward order.  The result of

      (pairlis '(one two) '(1 2) '((three . 3) (four . 19)))

might be

      ((one . 1) (two . 2) (three . 3) (four . 19))

or

      ((two . 2) (one . 1) (three . 3) (four . 19))

Examples:
.........

      (setq keys '(1 2 3)
             data '("one" "two" "three")
             alist '((4 . "four"))) → ((4 . "four"))
      (pairlis keys data) → ((3 . "three") (2 . "two") (1 . "one"))
      (pairlis keys data alist)
     → ((3 . "three") (2 . "two") (1 . "one") (4 . "four"))
      alist → ((4 . "four"))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if KEYS AND
DATA are not proper lists.

See Also:
.........

*note acons::


File: ansicl,  Node: rassoc; rassoc-if; rassoc-if-not,  Next: get-properties,  Prev: pairlis,  Up: Conses

rassoc, rassoc-if, rassoc-if-not (Function)
===========================================

Syntax:
.......

 -- Function: rassoc item alist &key key test test-not → entry

 -- Function: rassoc-if predicate alist &key key → entry
 -- Function: rassoc-if-not predicate alist &key key → entry

Arguments and Values:
.....................

ITEM—an object.

ALIST—an association list.

PREDICATE—a designator for a function of one argument that returns a
generalized boolean.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

ENTRY—a cons that is an element of the ALIST, or ‘nil’.

Description:
............

‘rassoc’, ‘rassoc-if’, and ‘rassoc-if-not’ return the first cons whose
cdr satisfies the test.  If no such cons is found, ‘nil’ is returned.

If ‘nil’ appears in ALIST in place of a pair, it is ignored.

Examples:
.........

      (setq alist '((1 . "one") (2 . "two") (3 . 3)))
     → ((1 . "one") (2 . "two") (3 . 3))
      (rassoc 3 alist) → (3 . 3)
      (rassoc "two" alist) → NIL
      (rassoc "two" alist :test 'equal) → (2 . "two")
      (rassoc 1 alist :key #'(lambda (x) (if (numberp x) (/ x 3)))) → (3 . 3)
      (rassoc 'a '((a . b) (b . c) (c . a) (z . a))) → (C . A)
      (rassoc-if #'stringp alist) → (1 . "one")
      (rassoc-if-not #'vectorp alist) → (3 . 3)

See Also:
.........

*note assoc::, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The function ‘rassoc-if-not’ is deprecated.

It is possible to ‘rplaca’ the result of ‘rassoc’, provided that it is
not ‘nil’, in order to “update” ALIST.

The expressions

      (rassoc item list :test fn)

and

      (find item list :test fn :key #'cdr)

are equivalent in meaning, except when the ‘item’ is ‘nil’ and
‘nil’ appears in place of a pair in the ALIST.  See the function *note
assoc::.


File: ansicl,  Node: get-properties,  Next: getf,  Prev: rassoc; rassoc-if; rassoc-if-not,  Up: Conses

get-properties (Function)
=========================

Syntax:
.......

 -- Function: get-properties plist indicator-list → indicator, value,
          tail

Arguments and Values:
.....................

PLIST—a property list.

INDICATOR-LIST—a proper list (of indicators).

INDICATOR—an object that is an element of INDICATOR-LIST.

VALUE—an object.

TAIL—a list.

Description:
............

‘get-properties’ is used to look up any of several property list entries
all at once.

It searches the PLIST for the first entry whose indicator is identical
to one of the objects in INDICATOR-LIST.  If such an entry is found, the
INDICATOR and VALUE returned are the property indicator and its
associated property value, and the TAIL returned is the tail of the
PLIST that begins with the found entry (i.e., whose car is the
INDICATOR).  If no such entry is found, the INDICATOR, VALUE, and TAIL
are all ‘nil’.

Examples:
.........

      (setq x '()) → NIL
      (setq *indicator-list* '(prop1 prop2)) → (PROP1 PROP2)
      (getf x 'prop1) → NIL
      (setf (getf x 'prop1) 'val1) → VAL1
      (eq (getf x 'prop1) 'val1) → true
      (get-properties x *indicator-list*) → PROP1, VAL1, (PROP1 VAL1)
      x → (PROP1 VAL1)

See Also:
.........

*note get::, *note getf::


File: ansicl,  Node: getf,  Next: remf,  Prev: get-properties,  Up: Conses

getf (Accessor)
===============

Syntax:
.......

 -- Function: getf plist indicator &optional default → value
(setf (getf place indicator &optional default) new-value)

Arguments and Values:
.....................

PLIST—a property list.

PLACE—a place, the value of which is a property list.

INDICATOR—an object.

DEFAULT—an object.  The default is ‘nil’.

VALUE—an object.

NEW-VALUE—an object.

Description:
............

‘getf’ finds a property on the PLIST whose property indicator is
identical to INDICATOR, and returns its corresponding property value.
If there are multiple properties‘getf’ uses the first such property.  If
there is no property with that property indicator, DEFAULT is returned.

‘setf’ of ‘getf’ may be used to associate a new object with an existing
indicator in the property list held by PLACE, or to create a new
assocation if none exists.  If there are multiple properties‘setf’ of
‘getf’ associates the NEW-VALUE with the first such property.  When a
‘getf’ form is used as a ‘setf’ PLACE, any DEFAULT which is supplied is
evaluated according to normal left-to-right evaluation rules, but its
value is ignored.

‘setf’ of ‘getf’ is permitted to either write the value of PLACE itself,
or modify of any part, car or cdr, of the list structure held by PLACE.

Examples:
.........

      (setq x '()) → NIL
      (getf x 'prop1) → NIL
      (getf x 'prop1 7) → 7
      (getf x 'prop1) → NIL
      (setf (getf x 'prop1) 'val1) → VAL1
      (eq (getf x 'prop1) 'val1) → true
      (getf x 'prop1) → VAL1
      (getf x 'prop1 7) → VAL1
      x → (PROP1 VAL1)

     ;; Examples of implementation variation permitted.
      (setq foo (list 'a 'b 'c 'd 'e 'f)) → (A B C D E F)
      (setq bar (cddr foo)) → (C D E F)
      (remf foo 'c) → true
      foo → (A B E F)
      bar
     → (C D E F)
     or→ (C)
     or→ (NIL)
     or→ (C NIL)
     or→ (C D)

See Also:
.........

*note get::, *note get-properties::, *note setf::, *note Section 5.1.2.2
(Function Call Forms as Places): FnFormsAsGenRefs.

Notes:
......

There is no way (using ‘getf’) to distinguish an absent property from
one whose value is DEFAULT; but see ‘get-properties’.

Note that while supplying a default argument to ‘getf’ in a ‘setf’
situation is sometimes not very interesting, it is still important
because some macros, such as ‘push’ and ‘incf’, require a PLACE argument
which data is both read from and written to.  In such a context, if a
default argument is to be supplied for the read situation, it must be
syntactically valid for the write situation as well.  For example,

      (let ((plist '()))
        (incf (getf plist 'count 0))
        plist) → (COUNT 1)


File: ansicl,  Node: remf,  Next: intersection; nintersection,  Prev: getf,  Up: Conses

remf (Macro)
============

Syntax:
.......

 -- Macro: remf place indicator → generalized-boolean

Arguments and Values:
.....................

PLACE—a place.

INDICATOR—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘remf’ removes from the property list stored in PLACE a
propertyidentical to INDICATOR.  If there are multiple properties‘remf’
only removes the first such property.  ‘remf’ returns false if no such
property was found, or true if a property was found.

The property indicator and the corresponding property value are removed
in an undefined order by destructively splicing the property list.
‘remf’ is permitted to either ‘setf’ PLACE or to ‘setf’ any part, ‘car’
or ‘cdr’, of the list structure held by that PLACE.

For information about the evaluation of subforms of PLACE, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

      (setq x (cons () ())) → (NIL)
      (setf (getf (car x) 'prop1) 'val1) → VAL1
      (remf (car x) 'prop1) → true
      (remf (car x) 'prop1) → false

Side Effects:
.............

The property list stored in PLACE is modified.

See Also:
.........

*note remprop::, *note getf::


File: ansicl,  Node: intersection; nintersection,  Next: adjoin,  Prev: remf,  Up: Conses

intersection, nintersection (Function)
======================================

Syntax:
.......

 -- Function: intersection list-1 list-2 &key key test test-not →
          result-list
 -- Function: nintersection list-1 list-2 &key key test test-not →
          result-list

Arguments and Values:
.....................

LIST-1—a proper list.

LIST-2—a proper list.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

RESULT-LIST—a list.

Description:
............

‘intersection’ and ‘nintersection’ return a list that contains every
element that occurs in both LIST-1 and LIST-2.

‘nintersection’ is the destructive version of ‘intersection’.  It
performs the same operation, but may destroy LIST-1 using its cells to
construct the result.  LIST-2 is not destroyed.

The intersection operation is described as follows.  For all possible
ordered pairs consisting of one element from LIST-1 and one element from
LIST-2, :test or :test-not are used to determine whether they satisfy
the test.  The first argument to the :test or :test-not function is an
element of LIST-1; the second argument is an element of LIST-2.  If
:test or :test-not is not supplied, ‘eql’ is used.  It is an error if
:test and :test-not are supplied in the same function call.

If :key is supplied (and not ‘nil’), it is used to extract the part to
be tested from the LIST element.  The argument to the :key function is
an element of either LIST-1 or LIST-2; the :key function typically
returns part of the supplied element.  If :key is not supplied or ‘nil’,
the LIST-1 and LIST-2 elements are used.

For every pair that satifies the test, exactly one of the two elements
of the pair will be put in the result.  No element from either list
appears in the result that does not satisfy the test for an element from
the other list.  If one of the lists contains duplicate elements, there
may be duplication in the result.

There is no guarantee that the order of elements in the result will
reflect the ordering of the arguments in any particular way.  The result
list may share cells with, or be ‘eq’ to, either LIST-1 or LIST-2 if
appropriate.

Examples:
.........

      (setq list1 (list 1 1 2 3 4 a b c "A" "B" "C" "d")
            list2 (list 1 4 5 b c d "a" "B" "c" "D"))
       → (1 4 5 B C D "a" "B" "c" "D")
      (intersection list1 list2) → (C B 4 1 1)
      (intersection list1 list2 :test 'equal) → ("B" C B 4 1 1)
      (intersection list1 list2 :test #'equalp) → ("d" "C" "B" "A" C B 4 1 1)
      (nintersection list1 list2) → (1 1 4 B C)
      list1 → implementation-dependent ;e.g., (1 1 4 B C)
      list2 → implementation-dependent ;e.g., (1 4 5 B C D "a" "B" "c" "D")
      (setq list1 (copy-list '((1 . 2) (2 . 3) (3 . 4) (4 . 5))))
     → ((1 . 2) (2 . 3) (3 . 4) (4 . 5))
      (setq list2 (copy-list '((1 . 3) (2 . 4) (3 . 6) (4 . 8))))
     → ((1 . 3) (2 . 4) (3 . 6) (4 . 8))
      (nintersection list1 list2 :key #'cdr) → ((2 . 3) (3 . 4))
      list1 → implementation-dependent ;e.g., ((1 . 2) (2 . 3) (3 . 4))
      list2 → implementation-dependent ;e.g., ((1 . 3) (2 . 4) (3 . 6) (4 . 8))

Side Effects:
.............

‘nintersection’ can modify LIST-1, but not LIST-2.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST-1 AND
LIST-2 are not proper lists.

See Also:
.........

*note union::, *note Section 3.2.1 (Compiler Terminology): Compiler
Terminology, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Since the ‘nintersection’ side effect is not required, it should not be
used in for-effect-only positions in portable code.


File: ansicl,  Node: adjoin,  Next: pushnew,  Prev: intersection; nintersection,  Up: Conses

adjoin (Function)
=================

Syntax:
.......

 -- Function: adjoin item list &key key test test-not → new-list

Arguments and Values:
.....................

ITEM—an object.

LIST—a proper list.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

NEW-LIST—a list.

Description:
............

Tests whether ITEM is the same as an existing element of LIST.  If the
ITEM is not an existing element, ‘adjoin’ adds it to LIST (as if by
‘cons’) and returns the resulting list; otherwise, nothing is added and
the original LIST is returned.

The TEST, TEST-NOT, and KEY affect how it is determined whether ITEM is
the same as an element of LIST.  For details, *note Satisfying a
Two-Argument Test: SatisfyingTheTwoArgTest.

Examples:
.........

      (setq slist '()) → NIL
      (adjoin 'a slist) → (A)
      slist → NIL
      (setq slist (adjoin '(test-item 1) slist)) → ((TEST-ITEM 1))
      (adjoin '(test-item 1) slist) → ((TEST-ITEM 1) (TEST-ITEM 1))
      (adjoin '(test-item 1) slist :test 'equal) → ((TEST-ITEM 1))
      (adjoin '(new-test-item 1) slist :key #'cadr) → ((TEST-ITEM 1))
      (adjoin '(new-test-item 1) slist) → ((NEW-TEST-ITEM 1) (TEST-ITEM 1))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST is
not a proper list.

See Also:
.........

*note pushnew::, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

      (adjoin item list :key fn)
        ≡ (if (member (fn item) list :key fn) list (cons item list))


File: ansicl,  Node: pushnew,  Next: set-difference; nset-difference,  Prev: adjoin,  Up: Conses

pushnew (Macro)
===============

Syntax:
.......

 -- Macro: pushnew item place &key key test test-not → new-place-value

Arguments and Values:
.....................

ITEM—an object.

PLACE—a place, the value of which is a proper list.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

NEW-PLACE-VALUE—a list (the new value of PLACE).

Description:
............

‘pushnew’ tests whether ITEM is the same as any existing element of the
list stored in PLACE.  If ITEM is not, it is prepended to the list, and
the new list is stored in PLACE.

‘pushnew’ returns the new list that is stored in PLACE.

Whether or not ITEM is already a member of the list that is in PLACE is
determined by comparisons using :test or :test-not.  The first argument
to the :test or :test-not function is ITEM; the second argument is an
element of the list in PLACE as returned by the :key function (if
supplied).

If :key is supplied, it is used to extract the part to be tested from
both ITEM and the list element, as for ‘adjoin’.

The argument to the :key function is an element of the list stored in
PLACE.  The :key function typically returns part part of the element of
the list.  If :key is not supplied or ‘nil’, the list element is used.

For information about the evaluation of subforms of PLACE, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

It is implementation-dependent whether or not ‘pushnew’ actually
executes the storing form for its PLACE in the situation where the ITEM
is already a member of the list held by PLACE.

Examples:
.........

      (setq x '(a (b c) d)) → (A (B C) D)
      (pushnew 5 (cadr x)) → (5 B C)
      x → (A (5 B C) D)
      (pushnew 'b (cadr x)) → (5 B C)
      x → (A (5 B C) D)
      (setq lst '((1) (1 2) (1 2 3))) → ((1) (1 2) (1 2 3))
      (pushnew '(2) lst) → ((2) (1) (1 2) (1 2 3))
      (pushnew '(1) lst) → ((1) (2) (1) (1 2) (1 2 3))
      (pushnew '(1) lst :test 'equal) → ((1) (2) (1) (1 2) (1 2 3))
      (pushnew '(1) lst :key #'car) → ((1) (2) (1) (1 2) (1 2 3))

Side Effects:
.............

The contents of PLACE may be modified.

See Also:
.........

*note push::, *note adjoin::, *note Section 5.1 (Generalized Reference):
Generalized Reference.

Notes:
......

The effect of
      (pushnew item place :test p)

is roughly equivalent to
      (setf place (adjoin item place :test p))

except that the subforms of ‘place’ are evaluated only once, and ‘item’
is evaluated before ‘place’.


File: ansicl,  Node: set-difference; nset-difference,  Next: set-exclusive-or; nset-exclusive-or,  Prev: pushnew,  Up: Conses

set-difference, nset-difference (Function)
==========================================

Syntax:
.......

 -- Function: set-difference list-1 list-2 &key key test test-not →
          result-list
 -- Function: nset-difference list-1 list-2 &key key test test-not →
          result-list

Arguments and Values:
.....................

LIST-1—a proper list.

LIST-2—a proper list.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

RESULT-LIST—a list.

Description:
............

‘set-difference’ returns a list of elements of LIST-1 that do not appear
in LIST-2.

‘nset-difference’ is the destructive version of ‘set-difference’.  It
may destroy LIST-1.

For all possible ordered pairs consisting of one element from LIST-1 and
one element from LIST-2, the :test or :test-not function is used to
determine whether they satisfy the test.  The first argument to the
:test or :test-not function is the part of an element of LIST-1 that is
returned by the :key function (if supplied); the second argument is the
part of an element of LIST-2 that is returned by the :key function (if
supplied).

If :key is supplied, its argument is a LIST-1 or LIST-2 element.  The
:key function typically returns part of the supplied element.  If :key
is not supplied, the LIST-1 or LIST-2 element is used.

An element of LIST-1 appears in the result if and only if it does not
match any element of LIST-2.

There is no guarantee that the order of elements in the result will
reflect the ordering of the arguments in any particular way.  The result
list may share cells with, or be ‘eq’ to, either of LIST-1 or LIST-2, if
appropriate.

Examples:
.........

      (setq lst1 (list "A" "b" "C" "d")
            lst2 (list "a" "B" "C" "d")) → ("a" "B" "C" "d")
      (set-difference lst1 lst2) → ("d" "C" "b" "A")
      (set-difference lst1 lst2 :test 'equal) → ("b" "A")
      (set-difference lst1 lst2 :test #'equalp) → NIL
      (nset-difference lst1 lst2 :test #'string=) → ("A" "b")
      (setq lst1 '(("a" . "b") ("c" . "d") ("e" . "f")))
     → (("a" . "b") ("c" . "d") ("e" . "f"))
      (setq lst2 '(("c" . "a") ("e" . "b") ("d" . "a")))
     → (("c" . "a") ("e" . "b") ("d" . "a"))
      (nset-difference lst1 lst2 :test #'string= :key #'cdr)
     → (("c" . "d") ("e" . "f"))
      lst1 → (("a" . "b") ("c" . "d") ("e" . "f"))
      lst2 → (("c" . "a") ("e" . "b") ("d" . "a"))

     ;; Remove all flavor names that contain "c" or "w".
      (set-difference '("strawberry" "chocolate" "banana"
                       "lemon" "pistachio" "rhubarb")
               '(#\c #\w)
               :test #'(lambda (s c) (find c s)))
     → ("banana" "rhubarb" "lemon")    ;One possible ordering.

Side Effects:
.............

‘nset-difference’ may destroy LIST-1.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST-1 AND
LIST-2 are not proper lists.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and Side
Effects.

Notes:
......

The :test-not parameter is deprecated.


File: ansicl,  Node: set-exclusive-or; nset-exclusive-or,  Next: subsetp,  Prev: set-difference; nset-difference,  Up: Conses

set-exclusive-or, nset-exclusive-or (Function)
==============================================

Syntax:
.......

 -- Function: set-exclusive-or list-1 list-2 &key key test test-not →
          result-list
 -- Function: nset-exclusive-or list-1 list-2 &key key test test-not →
          result-list

Arguments and Values:
.....................

LIST-1—a proper list.

LIST-2—a proper list.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

RESULT-LIST—a list.

Description:
............

‘set-exclusive-or’ returns a list of elements that appear in exactly one
of LIST-1 and LIST-2.

‘nset-exclusive-or’ is the destructive version of ‘set-exclusive-or’.

For all possible ordered pairs consisting of one element from LIST-1 and
one element from LIST-2, the :test or :test-not function is used to
determine whether they satisfy the test.

If :key is supplied, it is used to extract the part to be tested from
the LIST-1 or LIST-2 element.  The first argument to the :test or
:test-not function is the part of an element of LIST-1 extracted by the
:key function (if supplied); the second argument is the part of an
element of LIST-2 extracted by the :key function (if supplied).  If :key
is not supplied or ‘nil’, the LIST-1 or LIST-2 element is used.

The result contains precisely those elements of LIST-1 and LIST-2 that
appear in no matching pair.

The result list of ‘set-exclusive-or’ might share storage with one of
LIST-1 or LIST-2.

Examples:
.........

      (setq lst1 (list 1 "a" "b")
            lst2 (list 1 "A" "b")) → (1 "A" "b")
      (set-exclusive-or lst1 lst2) → ("b" "A" "b" "a")
      (set-exclusive-or lst1 lst2 :test #'equal) → ("A" "a")
      (set-exclusive-or lst1 lst2 :test 'equalp) → NIL
      (nset-exclusive-or lst1 lst2) → ("a" "b" "A" "b")
      (setq lst1 (list (("a" . "b") ("c" . "d") ("e" . "f"))))
     → (("a" . "b") ("c" . "d") ("e" . "f"))
      (setq lst2 (list (("c" . "a") ("e" . "b") ("d" . "a"))))
     → (("c" . "a") ("e" . "b") ("d" . "a"))
      (nset-exclusive-or lst1 lst2 :test #'string= :key #'cdr)
     → (("c" . "d") ("e" . "f") ("c" . "a") ("d" . "a"))
      lst1 → (("a" . "b") ("c" . "d") ("e" . "f"))
      lst2 → (("c" . "a") ("d" . "a"))

Side Effects:
.............

‘nset-exclusive-or’ is permitted to modify any part, car or cdr, of the
list structure of LIST-1 or LIST-2.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST-1 AND
LIST-2 are not proper lists.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and Side
Effects.

Notes:
......

The :test-not parameter is deprecated.

Since the ‘nset-exclusive-or’ side effect is not required, it should not
be used in for-effect-only positions in portable code.


File: ansicl,  Node: subsetp,  Next: union; nunion,  Prev: set-exclusive-or; nset-exclusive-or,  Up: Conses

subsetp (Function)
==================

Syntax:
.......

 -- Function: subsetp list-1 list-2 &key key test test-not →
          generalized-boolean

Arguments and Values:
.....................

LIST-1—a proper list.

LIST-2—a proper list.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘subsetp’ returns true if every element of LIST-1 matches some element
of LIST-2, and false otherwise.

Whether a list element is the same as another list element is determined
by the functions specified by the keyword arguments.  The first argument
to the :test or :test-not function is typically part of an element of
LIST-1 extracted by the :key function; the second argument is typically
part of an element of LIST-2 extracted by the :key function.

The argument to the :key function is an element of either LIST-1 or
LIST-2; the return value is part of the element of the supplied list
element.  If :key is not supplied or ‘nil’, the LIST-1 or LIST-2 element
itself is supplied to the :test or :test-not function.

Examples:
.........

      (setq cosmos '(1 "a" (1 2))) → (1 "a" (1 2))
      (subsetp '(1) cosmos) → true
      (subsetp '((1 2)) cosmos) → false
      (subsetp '((1 2)) cosmos :test 'equal) → true
      (subsetp '(1 "A") cosmos :test #'equalp) → true
      (subsetp '((1) (2)) '((1) (2))) → false
      (subsetp '((1) (2)) '((1) (2)) :key #'car) → true

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST-1 AND
LIST-2 are not proper lists.

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.

Notes:
......

The :test-not parameter is deprecated.


File: ansicl,  Node: union; nunion,  Prev: subsetp,  Up: Conses

union, nunion (Function)
========================

Syntax:
.......

 -- Function: union list-1 list-2 &key key test test-not → result-list
 -- Function: nunion list-1 list-2 &key key test test-not → result-list

Arguments and Values:
.....................

LIST-1—a proper list.

LIST-2—a proper list.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

RESULT-LIST—a list.

Description:
............

‘union’ and ‘nunion’ return a list that contains every element that
occurs in either LIST-1 or LIST-2.

For all possible ordered pairs consisting of one element from LIST-1 and
one element from LIST-2, :test or :test-not is used to determine whether
they satisfy the test.  The first argument to the :test or :test-not
function is the part of the element of LIST-1 extracted by the :key
function (if supplied); the second argument is the part of the element
of LIST-2 extracted by the :key function (if supplied).

The argument to the :key function is an element of LIST-1 or LIST-2; the
return value is part of the supplied element.  If :key is not supplied
or ‘nil’, the element of LIST-1 or LIST-2 itself is supplied to the
:test or :test-not function.

For every matching pair, one of the two elements of the pair will be in
the result.  Any element from either LIST-1 or LIST-2 that matches no
element of the other will appear in the result.

If there is a duplication between LIST-1 and LIST-2, only one of the
duplicate instances will be in the result.  If either LIST-1 or LIST-2
has duplicate entries within it, the redundant entries might or might
not appear in the result.

The order of elements in the result do not have to reflect the ordering
of LIST-1 or LIST-2 in any way.  The result list may be ‘eq’ to either
LIST-1 or LIST-2 if appropriate.

Examples:
.........

      (union '(a b c) '(f a d))
     → (A B C F D)
     or→ (B C F A D)
     or→ (D F A B C)
      (union '((x 5) (y 6)) '((z 2) (x 4)) :key #'car)
     → ((X 5) (Y 6) (Z 2))
     or→ ((X 4) (Y 6) (Z 2))

      (setq lst1 (list 1 2 '(1 2) "a" "b")
            lst2 (list 2 3 '(2 3) "B" "C"))
     → (2 3 (2 3) "B" "C")
      (nunion lst1 lst2)
     → (1 (1 2) "a" "b" 2 3 (2 3) "B" "C")
     or→ (1 2 (1 2) "a" "b" "C" "B" (2 3) 3)

Side Effects:
.............

‘nunion’ is permitted to modify any part, car or cdr, of the list
structure of LIST-1 or LIST-2.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST-1 AND
LIST-2 are not proper lists.

See Also:
.........

*note intersection::, *note Section 3.2.1 (Compiler Terminology):
Compiler Terminology, *note Section 3.6 (Traversal Rules and Side
Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Since the ‘nunion’ side effect is not required, it should not be used in
for-effect-only positions in portable code.


File: ansicl,  Node: Arrays,  Next: Strings,  Prev: Conses,  Up: Top

15 Arrays
*********

* Menu:

* Array Concepts::

Dictionary

* array::
* simple-array::
* vector (System Class)::
* simple-vector::
* bit-vector::
* simple-bit-vector::
* make-array::
* adjust-array::
* adjustable-array-p::
* aref::
* array-dimension::
* array-dimensions::
* array-element-type::
* array-has-fill-pointer-p::
* array-displacement::
* array-in-bounds-p::
* array-rank::
* array-row-major-index::
* array-total-size::
* arrayp::
* fill-pointer::
* row-major-aref::
* upgraded-array-element-type::
* array-dimension-limit::
* array-rank-limit::
* array-total-size-limit::
* simple-vector-p::
* svref::
* vector (Function)::
* vector-pop::
* vector-push; vector-push-extend::
* vectorp::
* bit; sbit::
* bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+::
* bit-vector-p::
* simple-bit-vector-p::


File: ansicl,  Node: Array Concepts,  Next: array,  Up: Arrays

15.1 Array Concepts
===================

* Menu:

* Array Elements::
* Specialized Arrays::


File: ansicl,  Node: Array Elements,  Next: Specialized Arrays,  Up: Array Concepts

15.1.1 Array Elements
---------------------

An array contains a set of objects called elements that can be
referenced individually according to a rectilinear coordinate system.

15.1.1.1 Array Indices
......................

An array element is referred to by a (possibly empty) series of indices.
The length of the series must equal the rank of the array.  Each index
must be a non-negative fixnum less than the corresponding array
dimension.  Array indexing is zero-origin.

15.1.1.2 Array Dimensions
.........................

An axis of an array is called a “dimension”.

Each dimension is a non-negative fixnum; if any dimension of an array is
zero, the array has no elements.  It is permissible for a dimension to
be zero, in which case the array has no elements, and any attempt to
access an element is an error.  However, other properties of the array,
such as the dimensions themselves, may be used.

15.1.1.2.1 Implementation Limits on Individual Array Dimensions
...............................................................

An implementation may impose a limit on dimensions of an array, but
there is a minimum requirement on that limit.  See the variable *note
array-dimension-limit::.

15.1.1.3 Array Rank
...................

An array can have any number of dimensions (including zero).  The number
of dimensions is called the “rank”.

If the rank of an array is zero then the array is said to have no
dimensions, and the product of the dimensions (see ‘array-total-size’)
is then 1; a zero-rank array therefore has a single element.

15.1.1.3.1 Vectors
..................

An array of rank one (i.e., a one-dimensional array) is called a
“vector”.

15.1.1.3.1.1 Fill Pointers
..........................

A “fill pointer” is a non-negative integer no larger than the total
number of elements in a vector.  Not all vectors have fill pointers.
See the functions *note make-array:: and ‘adjust-array’.

An element of a vector is said to be “active” if it has an index that is
greater than or equal to zero, but less than the fill pointer (if any).
For an array that has no fill pointer, all elements are considered
active.

Only vectors may have fill pointers; multidimensional arrays may not.  A
multidimensional array that is displaced to a vector that has a fill
pointer can be created.

15.1.1.3.2 Multidimensional Arrays
..................................

15.1.1.3.2.1 Storage Layout for Multidimensional Arrays
.......................................................

Multidimensional arrays store their components in row-major order; that
is, internally a multidimensional array is stored as a one-dimensional
array, with the multidimensional index sets ordered lexicographically,
last index varying fastest.

15.1.1.3.2.2 Implementation Limits on Array Rank
................................................

An implementation may impose a limit on the rank of an array, but there
is a minimum requirement on that limit.  See the variable *note
array-rank-limit::.


File: ansicl,  Node: Specialized Arrays,  Prev: Array Elements,  Up: Array Concepts

15.1.2 Specialized Arrays
-------------------------

An array can be a general array, meaning each element may be any object,
or it may be a specialized array, meaning that each element must be of a
restricted type.

The phrasing “an array specialized to type «type»” is sometimes used to
emphasize the element type of an array.  This phrasing is tolerated even
when the «type» is ‘t’, even though an array specialized to type t is a
general array, not a specialized array.

The next figure lists some defined names that are applicable to array
creation, access, and information operations.

adjust-array            array-has-fill-pointer-p   make-array
adjustable-array-p      array-in-bounds-p          svref
aref                    array-rank                 upgraded-array-element-type
array-dimension         array-rank-limit           upgraded-complex-part-type
array-dimension-limit   array-row-major-index      vector
array-dimensions        array-total-size           vector-pop
array-displacement      array-total-size-limit     vector-push
array-element-type      fill-pointer               vector-push-extend

Figure 15.1: General Purpose Array-Related Defined Names

15.1.2.1 Array Upgrading
........................

The “upgraded array element type” of a type Tis a type Tand that is used
instead of Tis used as an array element type for object creation or type
discrimination.

During creation of an array, the element type that was requested is
called the “expressed array element type”.  The upgraded array element
type of the expressed array element type becomes the “actual array
element type” of the array that is created.

Type upgrading implies a movement upwards in the type hierarchy lattice.
A type is always a subtype of its upgraded array element type.  Also, if
a type Tthen the upgraded array element type of Tmust be a subtype of
the upgraded array element type of TTwo disjoint types can be upgraded
to the same type.

The upgraded array element type Tis a function only of Tthat is, it is
independent of any other property of the array for which Tsuch as rank,
adjustability, fill pointers, or displacement.  The function
‘upgraded-array-element-type’ can be used by conforming programs to
predict how the implementation will upgrade a given type.

15.1.2.2 Required Kinds of Specialized Arrays
.............................................

Vectors whose elements are restricted to type ‘character’ or a subtype
of ‘character’ are called “strings”.  Strings are of type ‘string’.  The
next figure lists some defined names related to strings.

Strings are specialized arrays and might logically have been included in
this chapter.  However, for purposes of readability most information
about strings does not appear in this chapter; see instead *note Chapter
16 (Strings): Strings.

char                 string-equal          string-upcase
make-string          string-greaterp       string‘/=’
nstring-capitalize   string-left-trim      string‘<’
nstring-downcase     string-lessp          string‘<=’
nstring-upcase       string-not-equal      string‘=’
schar                string-not-greaterp   string‘>’
string               string-not-lessp      string‘>=’
string-capitalize    string-right-trim
string-downcase      string-trim

Figure 15.2: Operators that Manipulate Strings

Vectors whose elements are restricted to type ‘bit’ are called “bit
vectors”.  Bit vectors are of type ‘bit-vector’.  The next figure lists
some defined names for operations on bit arrays.

bit         bit-ior    bit-orc2
bit-and     bit-nand   bit-xor
bit-andc1   bit-nor    sbit
bit-andc2   bit-not
bit-eqv     bit-orc1

Figure 15.3: Operators that Manipulate Bit Arrays


File: ansicl,  Node: array,  Next: simple-array,  Prev: Array Concepts,  Up: Arrays

array (System Class)
====================

Class Precedence List:
......................

‘array’, ‘t’

Description:
............

An array contains objects arranged according to a Cartesian coordinate
system.  An array provides mappings from a set of fixnums {iof the
array, where 0 ≤ ir is the rank of the array, and dthe array.

When an array is created, the program requesting its creation may
declare that all elements are of a particular type, called the expressed
array element type.  The implementation is permitted to upgrade this
type in order to produce the actual array element type, which is the
element type for the array is actually specialized.  See the function
*note upgraded-array-element-type::.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(array [{element-type | *} [dimension-spec]])

DIMENSION-SPEC::=
     rank | * | ({dimension | *}*)

Compound Type Specifier Arguments:
..................................

DIMENSION—a valid array dimension.

ELEMENT-TYPE—a type specifier.

RANK—a non-negative fixnum.

Compound Type Specifier Description:
....................................

This denotes the set of arrays whose element type, rank, and dimensions
match any given ELEMENT-TYPE, RANK, and DIMENSIONS.  Specifically:

If ELEMENT-TYPE is the symbol *, arrays are not excluded on the basis of
their element type.  Otherwise, only those ARRAYS are included whose
actual array element type is the result of upgrading ELEMENT-TYPE; see
*note Section 15.1.2.1 (Array Upgrading): ArrayUpgrading.

If the DIMENSION-SPEC is a RANK, the set includes only those ARRAYS
having that rank.  If the DIMENSION-SPEC is a list of DIMENSIONS, the
set includes only those ARRAYS having a rank given by the length of the
DIMENSIONS, and having the indicated DIMENSIONS; in this case, * matches
any value for the corresponding dimension.  If the DIMENSION-SPEC is the
symbol *, the set is not restricted on the basis of rank or dimension.

See Also:
.........

*note *print-array*::, *note aref::, *note make-array::, *note vector
(System Class)::, *note Section 2.4.8.12 (Sharpsign A): SharpsignA,
*note Section 22.1.3.8 (Printing Other Arrays): PrintingOtherArrays.

Notes:
......

Note that the type ‘(array t)’ is a proper subtype of the type ‘(array
*)’.  The reason is that the type ‘(array t)’ is the set of arrays that
can hold any object (the elements are of type ‘t’, which includes all
objects).  On the other hand, the type ‘(array *)’ is the set of all
arrays whatsoever, including for example arrays that can hold only
characters.  The type ‘(array character)’ is not a subtype of the type
‘(array t)’; the two sets are disjoint because the type ‘(array
character)’ is not the set of all arrays that can hold characters, but
rather the set of arrays that are specialized to hold precisely
characters and no other objects.


File: ansicl,  Node: simple-array,  Next: vector (System Class),  Prev: array,  Up: Arrays

simple-array (Type)
===================

Supertypes:
...........

‘simple-array’, ‘array’, ‘t’

Description:
............

The type of an array that is not displaced to another array, has no fill
pointer, and is not expressly adjustable is a subtype of type
‘simple-array’.  The concept of a simple array exists to allow the
implementation to use a specialized representation and to allow the user
to declare that certain values will always be simple arrays.

The types ‘simple-vector’, ‘simple-string’, and ‘simple-bit-vector’ are
disjoint subtypes of type ‘simple-array’, for they respectively mean
‘(simple-array t (*))’, the union of all ‘(simple-array c (*))’ for any
c being a subtype of type ‘character’, and ‘(simple-array bit (*))’.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(simple-array [{element-type | *} [dimension-spec]])

DIMENSION-SPEC::=
     rank | * | ({dimension | *}*)

Compound Type Specifier Arguments:
..................................

DIMENSION—a valid array dimension.

ELEMENT-TYPE—a type specifier.

RANK—a non-negative fixnum.

Compound Type Specifier Description:
....................................

This compound type specifier is treated exactly as the corresponding
compound type specifier for type ‘array’ would be treated, except that
the set is further constrained to include only simple arrays.

Notes:
......

It is implementation-dependent whether displaced arrays, vectors with
fill pointers, or arrays that are actually adjustable are simple arrays.

‘(simple-array *)’ refers to all simple arrays regardless of element
type, ‘(simple-array TYPE-SPECIFIER)’ refers only to those simple arrays
that can result from giving TYPE-SPECIFIER as the :element-type argument
to ‘make-array’.


File: ansicl,  Node: vector (System Class),  Next: simple-vector,  Prev: simple-array,  Up: Arrays

vector (System Class)
=====================

Class Precedence List:
......................

‘vector’, ‘array’, ‘sequence’, ‘t’

Description:
............

Any one-dimensional array is a vector.

The type ‘vector’ is a subtype of type ‘array’; for all types ‘x’,
‘(vector x)’ is the same as ‘(array x (*))’.

The type ‘(vector t)’, the type ‘string’, and the type ‘bit-vector’ are
disjoint subtypes of type ‘vector’.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(vector [{element-type | *} [{size | *}]])

Compound Type Specifier Arguments:
..................................

SIZE—a non-negative fixnum.

ELEMENT-TYPE—a type specifier.

Compound Type Specifier Description:
....................................

This denotes the set of specialized vectors whose element type and
DIMENSION match the specified values.  Specifically:

If ELEMENT-TYPE is the symbol *, vectors are not excluded on the basis
of their element type.  Otherwise, only those VECTORS are included whose
actual array element type is the result of upgrading ELEMENT-TYPE; see
*note Section 15.1.2.1 (Array Upgrading): ArrayUpgrading.

If a SIZE is specified, the set includes only those VECTORS whose only
dimension is SIZE.  If the symbol * is specified instead of a SIZE, the
set is not restricted on the basis of dimension.

See Also:
.........

*note Section 15.1.2.2 (Required Kinds of Specialized Arrays):
RequiredSpecializedArrays, *note Section 2.4.8.3 (Sharpsign
Left-Parenthesis): SharpsignLeftParen, *note Section 22.1.3.7 (Printing
Other Vectors): PrintingOtherVectors, *note Section 2.4.8.12 (Sharpsign
A): SharpsignA.

Notes:
......

The type ‘(vector E S)’ is equivalent to the type ‘(array E (S))’.

The type ‘(vector bit)’ has the name ‘bit-vector’.

The union of all types ‘(vector C)’, where C is any subtype of
‘character’, has the name ‘string’.

‘(vector *)’ refers to all vectors regardless of element type, ‘(vector
TYPE-SPECIFIER)’ refers only to those vectors that can result from
giving TYPE-SPECIFIER as the :element-type argument to ‘make-array’.


File: ansicl,  Node: simple-vector,  Next: bit-vector,  Prev: vector (System Class),  Up: Arrays

simple-vector (Type)
====================

Supertypes:
...........

‘simple-vector’, ‘vector’, ‘simple-array’, ‘array’, ‘sequence’, ‘t’

Description:
............

The type of a vector that is not displaced to another array, has no fill
pointer, is not expressly adjustable and is able to hold elements of any
type is a subtype of type ‘simple-vector’.

The type ‘simple-vector’ is a subtype of type ‘vector’, and is a subtype
of type ‘(vector t)’.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(simple-vector [size])

Compound Type Specifier Arguments:
..................................

SIZE—a non-negative fixnum, or the symbol *.  The default is the symbol
*.

Compound Type Specifier Description:
....................................

This is the same as ‘(simple-array t (SIZE))’.


File: ansicl,  Node: bit-vector,  Next: simple-bit-vector,  Prev: simple-vector,  Up: Arrays

bit-vector (System Class)
=========================

Class Precedence List:
......................

‘bit-vector’, ‘vector’, ‘array’, ‘sequence’, ‘t’

Description:
............

A bit vector is a vector the element type of which is bit.

The type ‘bit-vector’ is a subtype of type ‘vector’, for ‘bit-vector’
means ‘(vector bit)’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(bit-vector [size])

Compound Type Specifier Arguments:
..................................

SIZE—a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This denotes the same type as the type ‘(array bit (SIZE))’; that is,
the set of bit vectors of size SIZE.

See Also:
.........

*note Section 2.4.8.4 (Sharpsign Asterisk): SharpsignStar, *note Section
22.1.3.6 (Printing Bit Vectors): PrintingBitVectors, *note Section
15.1.2.2 (Required Kinds of Specialized Arrays):
RequiredSpecializedArrays.


File: ansicl,  Node: simple-bit-vector,  Next: make-array,  Prev: bit-vector,  Up: Arrays

simple-bit-vector (Type)
========================

Supertypes:
...........

‘simple-bit-vector’, ‘bit-vector’, ‘vector’, ‘simple-array’, ‘array’,
‘sequence’, ‘t’

Description:
............

The type of a bit vector that is not displaced to another array, has no
fill pointer, and is not expressly adjustable is a subtype of type
‘simple-bit-vector’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(simple-bit-vector [size])

Compound Type Specifier Arguments:
..................................

SIZE—a non-negative fixnum, or the symbol *.  The default is the symbol
*.

Compound Type Specifier Description:
....................................

This denotes the same type as the type ‘(simple-array bit (SIZE))’; that
is, the set of simple bit vectors of size SIZE.


File: ansicl,  Node: make-array,  Next: adjust-array,  Prev: simple-bit-vector,  Up: Arrays

make-array (Function)
=====================

Syntax:
.......

 -- Function: make-array dimensions &key element-type initial-element
          initial-contents adjustable fill-pointer displaced-to
          displaced-index-offset → new-array

Arguments and Values:
.....................

DIMENSIONS—a designator for a list of valid array dimensions.

ELEMENT-TYPE—a type specifier.  The default is ‘t’.

INITIAL-ELEMENT—an object.

INITIAL-CONTENTS—an object.

ADJUSTABLE—a generalized boolean.  The default is ‘nil’.

FILL-POINTER—a valid fill pointer for the array to be created, or ‘t’ or
‘nil’.  The default is ‘nil’.

DISPLACED-TO—an array or ‘nil’.  The default is ‘nil’.  This option must
not be supplied if either INITIAL-ELEMENT or INITIAL-CONTENTS is
supplied.

DISPLACED-INDEX-OFFSET—a valid array row-major index for DISPLACED-TO.
The default is ‘0’.  This option must not be supplied unless a non-nil
DISPLACED-TO is supplied.

NEW-ARRAY—an array.

Description:
............

Creates and returns an array constructed of the most specialized type
that can accommodate elements of type given by ELEMENT-TYPE.  If
DIMENSIONS is ‘nil’ then a zero-dimensional array is created.

DIMENSIONS represents the dimensionality of the new array.

ELEMENT-TYPE indicates the type of the elements intended to be stored in
the NEW-ARRAY.  The NEW-ARRAY can actually store any objects of the type
which results from upgrading ELEMENT-TYPE; see *note Section 15.1.2.1
(Array Upgrading): ArrayUpgrading.

If INITIAL-ELEMENT is supplied, it is used to initialize each element of
NEW-ARRAY.  If INITIAL-ELEMENT is supplied, it must be of the type given
by ELEMENT-TYPE.  INITIAL-ELEMENT cannot be supplied if either the
:initial-contents option is supplied or DISPLACED-TO is non-nil.  If
INITIAL-ELEMENT is not supplied, the consequences of later reading an
uninitialized element of NEW-ARRAY are undefined unless either
INITIAL-CONTENTS is supplied or DISPLACED-TO is non-nil.

INITIAL-CONTENTS is used to initialize the contents of array.  For
example:

      (make-array '(4 2 3) :initial-contents
                  '(((a b c) (1 2 3))
                   ((d e f) (3 1 2))
                   ((g h i) (2 3 1))
                   ((j k l) (0 0 0))))

INITIAL-CONTENTS is composed of a nested structure of sequences.  The
numbers of levels in the structure must equal the rank of array.  Each
leaf of the nested structure must be of the type given by ELEMENT-TYPE.
If array is zero-dimensional, then INITIAL-CONTENTS specifies the single
element.  Otherwise, INITIAL-CONTENTS must be a sequence whose length is
equal to the first dimension; each element must be a nested structure
for an array whose dimensions are the remaining dimensions, and so on.
INITIAL-CONTENTS cannot be supplied if either INITIAL-ELEMENT is
supplied or DISPLACED-TO is non-nil.  If INITIAL-CONTENTS is not
supplied, the consequences of later reading an uninitialized element of
NEW-ARRAY are undefined unless either INITIAL-ELEMENT is supplied or
DISPLACED-TO is non-nil.

If ADJUSTABLE is non-nil, the array is expressly adjustable (and so
actually adjustable); otherwise, the array is not expressly adjustable
(and it is implementation-dependent whether the array is actually
adjustable).

If FILL-POINTER is non-nil, the array must be one-dimensional; that is,
the array must be a vector.  If FILL-POINTER is ‘t’, the length of the
vector is used to initialize the fill pointer.  If FILL-POINTER is an
integer, it becomes the initial fill pointer for the vector.

If DISPLACED-TO is non-nil, ‘make-array’ will create a displaced array
and DISPLACED-TO is the target of that displaced array.  In that case,
the consequences are undefined if the actual array element type of
DISPLACED-TO is not type equivalent to the actual array element type of
the array being created.  If DISPLACED-TO is ‘nil’, the array is not a
displaced array.

The DISPLACED-INDEX-OFFSET is made to be the index offset of the array.
When an array A is given as the :displaced-to argument to ‘make-array’
when creating array B, then array B is said to be displaced to array A.
The total number of elements in an array, called the total size of the
array, is calculated as the product of all the dimensions.  It is
required that the total size of A be no smaller than the sum of the
total size of B plus the offset ‘n’ supplied by the
DISPLACED-INDEX-OFFSET.  The effect of displacing is that array B does
not have any elements of its own, but instead maps accesses to itself
into accesses to array A. The mapping treats both arrays as if they were
one-dimensional by taking the elements in row-major order, and then maps
an access to element ‘k’ of array B to an access to element ‘k’+‘n’ of
array A.

If ‘make-array’ is called with ADJUSTABLE, FILL-POINTER, and
DISPLACED-TO each ‘nil’, then the result is a simple array.  If
‘make-array’ is called with one or more of ADJUSTABLE, FILL-POINTER, or
DISPLACED-TO being true, whether the resulting array is a simple array
is implementation-dependent.

When an array A is given as the :displaced-to argument to ‘make-array’
when creating array B, then array B is said to be displaced to array A.
The total number of elements in an array, called the total size of the
array, is calculated as the product of all the dimensions.  The
consequences are unspecified if the total size of A is smaller than the
sum of the total size of B plus the offset ‘n’ supplied by the
DISPLACED-INDEX-OFFSET.  The effect of displacing is that array B does
not have any elements of its own, but instead maps accesses to itself
into accesses to array A. The mapping treats both arrays as if they were
one-dimensional by taking the elements in row-major order, and then maps
an access to element ‘k’ of array B to an access to element ‘k’+‘n’ of
array A.

Examples:
.........


      (make-array 5) ;; Creates a one-dimensional array of five elements.
      (make-array '(3 4) :element-type '(mod 16)) ;; Creates a
                     ;;two-dimensional array, 3 by 4, with four-bit elements.
      (make-array 5 :element-type 'single-float) ;; Creates an array of single-floats.

      (make-array nil :initial-element nil) → #0ANIL
      (make-array 4 :initial-element nil) → #(NIL NIL NIL NIL)
      (make-array '(2 4)
                   :element-type '(unsigned-byte 2)
                   :initial-contents '((0 1 2 3) (3 2 1 0)))
     → #2A((0 1 2 3) (3 2 1 0))
      (make-array 6
                   :element-type 'character
                   :initial-element #\a
                   :fill-pointer 3) → "aaa"

The following is an example of making a displaced array.

      (setq a (make-array '(4 3)))
     → #<ARRAY 4x3 simple 32546632>
      (dotimes (i 4)
        (dotimes (j 3)
          (setf (aref a i j) (list i 'x j '= (* i j)))))
     → NIL
      (setq b (make-array 8 :displaced-to a
                            :displaced-index-offset 2))
     → #<ARRAY 8 indirect 32550757>
      (dotimes (i 8)
        (print (list i (aref b i))))
     ▷ (0 (0 X 2 = 0))
     ▷ (1 (1 X 0 = 0))
     ▷ (2 (1 X 1 = 1))
     ▷ (3 (1 X 2 = 2))
     ▷ (4 (2 X 0 = 0))
     ▷ (5 (2 X 1 = 2))
     ▷ (6 (2 X 2 = 4))
     ▷ (7 (3 X 0 = 0))
     → NIL

The last example depends on the fact that arrays are, in effect, stored
in row-major order.

      (setq a1 (make-array 50))
     → #<ARRAY 50 simple 32562043>
      (setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))
     → #<ARRAY 20 indirect 32563346>
      (length b1) → 20

      (setq a2 (make-array 50 :fill-pointer 10))
     → #<ARRAY 50 fill-pointer 10 46100216>
      (setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))
     → #<ARRAY 20 indirect 46104010>
      (length a2) → 10
      (length b2) → 20

      (setq a3 (make-array 50 :fill-pointer 10))
     → #<ARRAY 50 fill-pointer 10 46105663>
      (setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10
                              :fill-pointer 5))
     → #<ARRAY 20 indirect, fill-pointer 5 46107432>
      (length a3) → 10
      (length b3) → 5

See Also:
.........

*note adjustable-array-p::, *note aref::, *note arrayp::, *note
array-element-type::, *note array-rank-limit::, *note
array-dimension-limit::, *note fill-pointer::, *note
upgraded-array-element-type::

Notes:
......

There is no specified way to create an array for which
‘adjustable-array-p’ definitely returns false.  There is no specified
way to create an array that is not a simple array.


File: ansicl,  Node: adjust-array,  Next: adjustable-array-p,  Prev: make-array,  Up: Arrays

adjust-array (Function)
=======================

Syntax:
.......

 -- Function: adjust-array array new-dimensions &key element-type
          initial-element initial-contents fill-pointer displaced-to
          displaced-index-offset → adjusted-array

Arguments and Values:
.....................

ARRAY—an array.

NEW-DIMENSIONS—a valid array dimension or a list of valid array
dimensions.

ELEMENT-TYPE—a type specifier.

INITIAL-ELEMENT—an object.  INITIAL-ELEMENT must not be supplied if
either INITIAL-CONTENTS or DISPLACED-TO is supplied.

INITIAL-CONTENTS—an object.  If array has rank greater than zero, then
INITIAL-CONTENTS is composed of nested sequences, the depth of which
must equal the rank of ARRAY.  Otherwise, array is zero-dimensional and
INITIAL-CONTENTS supplies the single element.  INITIAL-CONTENTS must not
be supplied if either INITIAL-ELEMENT or DISPLACED-TO is given.

FILL-POINTER—a valid fill pointer for the array to be created, or ‘t’,
or ‘nil’.  The default is ‘nil’.

DISPLACED-TO—an array or ‘nil’.  INITIAL-ELEMENTS and INITIAL-CONTENTS
must not be supplied if DISPLACED-TO is supplied.

DISPLACED-INDEX-OFFSET—an object of type ‘(fixnum 0 n)’ where n is
‘(array-total-size DISPLACED-TO)’.  DISPLACED-INDEX-OFFSET may be
supplied only if DISPLACED-TO is supplied.

ADJUSTED-ARRAY—an array.

Description:
............

‘adjust-array’ changes the dimensions or elements of ARRAY.  The result
is an array of the same type and rank as ARRAY, that is either the
modified ARRAY, or a newly created array to which ARRAY can be
displaced, and that has the given NEW-DIMENSIONS.

NEW-DIMENSIONS specify the size of each dimension of ARRAY.

ELEMENT-TYPE specifies the type of the elements of the resulting array.
If ELEMENT-TYPE is supplied, the consequences are unspecified if the
upgraded array element type of ELEMENT-TYPE is not the same as the
actual array element type of ARRAY.

If INITIAL-CONTENTS is supplied, it is treated as for ‘make-array’.  In
this case none of the original contents of ARRAY appears in the
resulting array.

If FILL-POINTER is an integer, it becomes the fill pointer for the
resulting array.  If FILL-POINTER is the symbol ‘t’, it indicates that
the size of the resulting array should be used as the fill pointer.  If
FILL-POINTER is ‘nil’, it indicates that the fill pointer should be left
as it is.

If DISPLACED-TO non-nil, a displaced array is created.  The resulting
array shares its contents with the array given by DISPLACED-TO.  The
resulting array cannot contain more elements than the array it is
displaced to.  If DISPLACED-TO is not supplied or ‘nil’, the resulting
array is not a displaced array.  If array A is created displaced to
array B and subsequently array B is given to ‘adjust-array’, array A
will still be displaced to array B. Although ARRAY might be a displaced
array, the resulting array is not a displaced array unless DISPLACED-TO
is supplied and not ‘nil’.  The interaction between ‘adjust-array’ and
displaced arrays is as follows given three arrays, ‘A’, ‘B’, and ‘C’:

‘A’ is not displaced before or after the call

           (adjust-array A ...)

     The dimensions of ‘A’ are altered, and the contents rearranged as
     appropriate.  Additional elements of ‘A’ are taken from
     INITIAL-ELEMENT.  The use of INITIAL-CONTENTS causes all old
     contents to be discarded.

‘A’ is not displaced before, but is displaced to ‘C’ after the call

           (adjust-array A ... :displaced-to C)

     None of the original contents of ‘A’ appears in ‘A’ afterwards; ‘A’
     now contains the contents of ‘C’, without any rearrangement of ‘C’.

‘A’ is displaced to ‘B’ before the call, and is displaced to ‘C’ after the call

           (adjust-array A ... :displaced-to B)
           (adjust-array A ... :displaced-to C)

     ‘B’ and ‘C’ might be the same.  The contents of ‘B’ do not appear
     in ‘A’ afterward unless such contents also happen to be in ‘C’ If
     DISPLACED-INDEX-OFFSET is not supplied in the ‘adjust-array’ call,
     it defaults to zero; the old offset into ‘B’ is not retained.

‘A’ is displaced to ‘B’ before the call, but not displaced afterward.

           (adjust-array A ... :displaced-to B)
           (adjust-array A ... :displaced-to nil)

     ‘A’ gets a new “data region,” and contents of ‘B’ are copied into
     it as appropriate to maintain the existing old contents; additional
     elements of ‘A’ are taken from INITIAL-ELEMENT if supplied.
     However, the use of INITIAL-CONTENTS causes all old contents to be
     discarded.

If DISPLACED-INDEX-OFFSET is supplied, it specifies the offset of the
resulting array from the beginning of the array that it is displaced to.
If DISPLACED-INDEX-OFFSET is not supplied, the offset is 0.  The size of
the resulting array plus the offset value cannot exceed the size of the
array that it is displaced to.

If only NEW-DIMENSIONS and an INITIAL-ELEMENT argument are supplied,
those elements of ARRAY that are still in bounds appear in the resulting
array.  The elements of the resulting array that are not in the bounds
of array are initialized to INITIAL-ELEMENT; if INITIAL-ELEMENT is not
provided, the consequences of later reading any such new element of
NEW-ARRAY before it has been initialized are undefined.

If INITIAL-CONTENTS or DISPLACED-TO is supplied, then none of the
original contents of ARRAY appears in the new array.

The consequences are unspecified if ARRAY is adjusted to a size smaller
than its fill pointer without supplying the FILL-POINTER argument so
that its fill-pointer is properly adjusted in the process.

If ‘A’ is displaced to ‘B’, the consequences are unspecified if ‘B’ is
adjusted in such a way that it no longer has enough elements to satisfy
‘A’.

If ‘adjust-array’ is applied to an array that is actually adjustable,
the array returned is identical to ARRAY.  If the array returned by
‘adjust-array’ is distinct from ARRAY, then the argument ARRAY is
unchanged.

Note that if an array A is displaced to another array B, and B is
displaced to another array C, and B is altered by ‘adjust-array’, A must
now refer to the adjust contents of B. This means that an implementation
cannot collapse the chain to make A refer to C directly and forget that
the chain of reference passes through B. However, caching techniques are
permitted as long as they preserve the semantics specified here.

Examples:
.........

      (adjustable-array-p
       (setq ada (adjust-array
                   (make-array '(2 3)
                               :adjustable t
                               :initial-contents '((a b c) (1 2 3)))
                   '(4 6)))) → T
      (array-dimensions ada) → (4 6)
      (aref ada 1 1) → 2
      (setq beta (make-array '(2 3) :adjustable t))
     → #2A((NIL NIL NIL) (NIL NIL NIL))
      (adjust-array beta '(4 6) :displaced-to ada)
     → #2A((A B C NIL NIL NIL)
            (1 2 3 NIL NIL NIL)
            (NIL NIL NIL NIL NIL NIL)
            (NIL NIL NIL NIL NIL NIL))
      (array-dimensions beta) → (4 6)
      (aref beta 1 1) → 2

Suppose that the 4-by-4 array in ‘m’ looks like this:

     #2A(( alpha     beta      gamma     delta )
         ( epsilon   zeta      eta       theta )
         ( iota      kappa     lambda    mu    )
         ( nu        xi        omicron   pi    ))

Then the result of

      (adjust-array m '(3 5) :initial-element 'baz)

is a 3-by-5 array with contents

     #2A(( alpha     beta      gamma     delta     baz )
         ( epsilon   zeta      eta       theta     baz )
         ( iota      kappa     lambda    mu        baz ))

Exceptional Situations:
.......................

An error of type ‘error’ is signaled if FILL-POINTER is supplied and
non-nil but ARRAY has no fill pointer.

See Also:
.........

*note adjustable-array-p::, *note make-array::, *note
array-dimension-limit::, *note array-total-size-limit::, *note array::


File: ansicl,  Node: adjustable-array-p,  Next: aref,  Prev: adjust-array,  Up: Arrays

adjustable-array-p (Function)
=============================

Syntax:
.......

 -- Function: adjustable-array-p array → generalized-boolean

Arguments and Values:
.....................

ARRAY—an array.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if and only if ‘adjust-array’ could return a value which is
identical to ARRAY when given that array as its first argument.

Examples:
.........

      (adjustable-array-p
        (make-array 5
                    :element-type 'character
                    :adjustable t
                    :fill-pointer 3)) → true
      (adjustable-array-p (make-array 4)) → implementation-dependent

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note adjust-array::, *note make-array::


File: ansicl,  Node: aref,  Next: array-dimension,  Prev: adjustable-array-p,  Up: Arrays

aref (Accessor)
===============

Syntax:
.......

 -- Function: aref array &rest subscripts → element
(setf (aref array &rest subscripts) new-element)

Arguments and Values:
.....................

ARRAY—an array.

SUBSCRIPTS—a list of valid array indices for the ARRAY.

ELEMENT, NEW-ELEMENT—an object.

Description:
............

Accesses the ARRAY element specified by the SUBSCRIPTS.  If no
SUBSCRIPTS are supplied and ARRAY is zero rank, ‘aref’ accesses the sole
element of ARRAY.

‘aref’ ignores fill pointers.  It is permissible to use ‘aref’ to access
any ARRAY element, whether active or not.

Examples:
.........

If the variable ‘foo’ names a 3-by-5 array, then the first index could
be 0, 1, or 2, and then second index could be 0, 1, 2, 3, or 4.  The
array elements can be referred to by using the function ‘aref’; for
example, ‘(aref foo 2 1)’ refers to element (2, 1) of the array.

      (aref (setq alpha (make-array 4)) 3) → implementation-dependent
      (setf (aref alpha 3) 'sirens) → SIRENS
      (aref alpha 3) → SIRENS
      (aref (setq beta (make-array '(2 4)
                         :element-type '(unsigned-byte 2)
                         :initial-contents '((0 1 2 3) (3 2 1 0))))
             1 2) → 1
      (setq gamma '(0 2))
      (apply #'aref beta gamma) → 2
      (setf (apply #'aref beta gamma) 3) → 3
      (apply #'aref beta gamma) → 3
      (aref beta 0 2) → 3

See Also:
.........

*note bit::, *note char::, *note elt::, *note row-major-aref::, *note
svref::, *note Section 3.2.1 (Compiler Terminology): Compiler
Terminology.


File: ansicl,  Node: array-dimension,  Next: array-dimensions,  Prev: aref,  Up: Arrays

array-dimension (Function)
==========================

Syntax:
.......

 -- Function: array-dimension array axis-number → dimension

Arguments and Values:
.....................

ARRAY—an array.

AXIS-NUMBER—an integer greater than or equal to zero and less than the
rank of the ARRAY.

DIMENSION—a non-negative integer.

Description:
............

‘array-dimension’ returns the AXIS-NUMBER dimension(Any fill pointer is
ignored.)

Examples:
.........

      (array-dimension (make-array 4) 0) → 4
      (array-dimension (make-array '(2 3)) 1) → 3

Affected By:
............

None.

See Also:
.........

*note array-dimensions::, *note length::

Notes:
......

      (array-dimension array n) ≡ (nth n (array-dimensions array))


File: ansicl,  Node: array-dimensions,  Next: array-element-type,  Prev: array-dimension,  Up: Arrays

array-dimensions (Function)
===========================

Syntax:
.......

 -- Function: array-dimensions array → dimensions

Arguments and Values:
.....................

ARRAY—an array.

DIMENSIONS—a list of integers.

Description:
............

Returns a list of the dimensions of ARRAY.  (If ARRAY is a vector with a
fill pointer, that fill pointer is ignored.)

Examples:
.........

      (array-dimensions (make-array 4)) → (4)
      (array-dimensions (make-array '(2 3))) → (2 3)
      (array-dimensions (make-array 4 :fill-pointer 2)) → (4)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note array-dimension::


File: ansicl,  Node: array-element-type,  Next: array-has-fill-pointer-p,  Prev: array-dimensions,  Up: Arrays

array-element-type (Function)
=============================

Syntax:
.......

 -- Function: array-element-type array → typespec

Arguments and Values:
.....................

ARRAY—an array.

TYPESPEC—a type specifier.

Description:
............

Returns a type specifier which represents the actual array element type
of the array, which is the set of objects that such an ARRAY can hold.
(Because of array upgrading, this type specifier can in some cases
denote a supertype of the expressed array element type of the ARRAY.)

Examples:
.........

      (array-element-type (make-array 4)) → T
      (array-element-type (make-array 12 :element-type '(unsigned-byte 8)))
     → implementation-dependent
      (array-element-type (make-array 12 :element-type '(unsigned-byte 5)))
     → implementation-dependent

      (array-element-type (make-array 5 :element-type '(mod 5)))

could be ‘(mod 5)’, ‘(mod 8)’, ‘fixnum’, ‘t’, or any other type of which
‘(mod 5)’ is a subtype.

Affected By:
............

The implementation.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note array::, *note make-array::, *note subtypep::, *note
upgraded-array-element-type::


File: ansicl,  Node: array-has-fill-pointer-p,  Next: array-displacement,  Prev: array-element-type,  Up: Arrays

array-has-fill-pointer-p (Function)
===================================

Syntax:
.......

 -- Function: array-has-fill-pointer-p array → generalized-boolean

Arguments and Values:
.....................

ARRAY—an array.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if ARRAY has a fill pointer; otherwise returns false.

Examples:
.........

      (array-has-fill-pointer-p (make-array 4)) → implementation-dependent
      (array-has-fill-pointer-p (make-array '(2 3))) → false
      (array-has-fill-pointer-p
        (make-array 8
                    :fill-pointer 2
                    :initial-element 'filler)) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note make-array::, *note fill-pointer::

Notes:
......

Since arrays of rank other than one cannot have a fill pointer,
‘array-has-fill-pointer-p’ always returns ‘nil’ when its argument is
such an array.


File: ansicl,  Node: array-displacement,  Next: array-in-bounds-p,  Prev: array-has-fill-pointer-p,  Up: Arrays

array-displacement (Function)
=============================

Syntax:
.......

 -- Function: array-displacement array → displaced-to,
          displaced-index-offset

Arguments and Values:
.....................

ARRAY—an array.

DISPLACED-TO—an ARRAY or ‘nil’.

DISPLACED-INDEX-OFFSET—a non-negative fixnum.

Description:
............

If the ARRAY is a displaced array, returns the values of the
:displaced-to and :displaced-index-offset options for the array (see the
functions *note make-array:: and ‘adjust-array’).  If the ARRAY is not a
displaced array, ‘nil’ and ‘0’ are returned.

If ‘array-displacement’ is called on an ARRAY for which a non-nil object
was provided as the :displaced-to argument to ‘make-array’ or
‘adjust-array’, it must return that object as its first value.  It is
implementation-dependent whether ‘array-displacement’ returns a non-nil
primary value for any other ARRAY.

Examples:
.........

      (setq a1 (make-array 5)) → #<ARRAY 5 simple 46115576>
      (setq a2 (make-array 4 :displaced-to a1
                             :displaced-index-offset 1))
     → #<ARRAY 4 indirect 46117134>
      (array-displacement a2)
     → #<ARRAY 5 simple 46115576>, 1
      (setq a3 (make-array 2 :displaced-to a2
                             :displaced-index-offset 2))
     → #<ARRAY 2 indirect 46122527>
      (array-displacement a3)
     → #<ARRAY 4 indirect 46117134>, 2

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if ARRAY is not an array.

See Also:
.........

*note make-array::


File: ansicl,  Node: array-in-bounds-p,  Next: array-rank,  Prev: array-displacement,  Up: Arrays

array-in-bounds-p (Function)
============================

Syntax:
.......

 -- Function: array-in-bounds-p array &rest subscripts →
          generalized-boolean

Arguments and Values:
.....................

ARRAY—an array.

SUBSCRIPTS—a list of integers of length equal to the rank of the array.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if the SUBSCRIPTS are all in bounds for ARRAY; otherwise
returns false.  (If ARRAY is a vector with a fill pointer, that fill
pointer is ignored.)

Examples:
.........

      (setq a (make-array '(7 11) :element-type 'string-char))
      (array-in-bounds-p a 0  0) → true
      (array-in-bounds-p a 6 10) → true
      (array-in-bounds-p a 0 -1) → false
      (array-in-bounds-p a 0 11) → false
      (array-in-bounds-p a 7  0) → false

See Also:
.........

*note array-dimensions::

Notes:
......

      (array-in-bounds-p array subscripts)
      ≡ (and (not (some #'minusp (list subscripts)))
              (every #'< (list subscripts) (array-dimensions array)))


File: ansicl,  Node: array-rank,  Next: array-row-major-index,  Prev: array-in-bounds-p,  Up: Arrays

array-rank (Function)
=====================

Syntax:
.......

 -- Function: array-rank array → rank

Arguments and Values:
.....................

ARRAY—an array.

RANK—a non-negative integer.

Description:
............

Returns the number of dimensions of ARRAY.

Examples:
.........

      (array-rank (make-array '())) → 0
      (array-rank (make-array 4)) → 1
      (array-rank (make-array '(4))) → 1
      (array-rank (make-array '(2 3))) → 2

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note array-rank-limit::, *note make-array::


File: ansicl,  Node: array-row-major-index,  Next: array-total-size,  Prev: array-rank,  Up: Arrays

array-row-major-index (Function)
================================

Syntax:
.......

 -- Function: array-row-major-index array &rest subscripts → index

Arguments and Values:
.....................

ARRAY—an array.

SUBSCRIPTS—a list of valid array indices for the ARRAY.

INDEX—a valid array row-major index for the ARRAY.

Description:
............

Computes the position according to the row-major ordering of ARRAY for
the element that is specified by SUBSCRIPTS, and returns the offset of
the element in the computed position from the beginning of ARRAY.

For a one-dimensional ARRAY, the result of ‘array-row-major-index’
equals SUBSCRIPT.

‘array-row-major-index’ ignores fill pointers.

Examples:
.........

      (setq a (make-array '(4 7) :element-type '(unsigned-byte 8)))
      (array-row-major-index a 1 2) → 9
      (array-row-major-index
         (make-array '(2 3 4)
                     :element-type '(unsigned-byte 8)
                     :displaced-to a
                     :displaced-index-offset 4)
         0 2 1) → 9

Notes:
......

A possible definition of ‘array-row-major-index’, with no
error-checking, is

      (defun array-row-major-index (a &rest subscripts)
        (apply #'+ (maplist #'(lambda (x y)
                                 (* (car x) (apply #'* (cdr y))))
                            subscripts
                            (array-dimensions a))))


File: ansicl,  Node: array-total-size,  Next: arrayp,  Prev: array-row-major-index,  Up: Arrays

array-total-size (Function)
===========================

Syntax:
.......

 -- Function: array-total-size array → size

Arguments and Values:
.....................

ARRAY—an array.

SIZE—a non-negative integer.

Description:
............

Returns the array total size of the ARRAY.

Examples:
.........

      (array-total-size (make-array 4)) → 4
      (array-total-size (make-array 4 :fill-pointer 2)) → 4
      (array-total-size (make-array 0)) → 0
      (array-total-size (make-array '(4 2))) → 8
      (array-total-size (make-array '(4 0))) → 0
      (array-total-size (make-array '())) → 1

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note make-array::, *note array-dimensions::

Notes:
......

If the ARRAY is a vector with a fill pointer, the fill pointer is
ignored when calculating the array total size.

Since the product of no arguments is one, the array total size of a
zero-dimensional array is one.

      (array-total-size x)
         ≡ (apply #'* (array-dimensions x))
         ≡ (reduce #'* (array-dimensions x))


File: ansicl,  Node: arrayp,  Next: fill-pointer,  Prev: array-total-size,  Up: Arrays

arrayp (Function)
=================

Syntax:
.......

 -- Function: arrayp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘array’; otherwise, returns false.

Examples:
.........

      (arrayp (make-array '(2 3 4) :adjustable t)) → true
      (arrayp (make-array 6)) → true
      (arrayp #*1011) → true
      (arrayp "hi") → true
      (arrayp 'hi) → false
      (arrayp 12) → false

See Also:
.........

*note typep::

Notes:
......

      (arrayp OBJECT) ≡ (typep OBJECT 'array)


File: ansicl,  Node: fill-pointer,  Next: row-major-aref,  Prev: arrayp,  Up: Arrays

fill-pointer (Accessor)
=======================

Syntax:
.......

 -- Function: fill-pointer vector → fill-pointer
(setf (fill-pointer vector) new-fill-pointer)

Arguments and Values:
.....................

VECTOR—a vector with a fill pointer.

FILL-POINTER, NEW-FILL-POINTER—a valid fill pointer for the VECTOR.

Description:
............

Accesses the fill pointer of VECTOR.

Examples:
.........

      (setq a (make-array 8 :fill-pointer 4)) → #(NIL NIL NIL NIL)
      (fill-pointer a) → 4
      (dotimes (i (length a)) (setf (aref a i) (* i i))) → NIL
      a → #(0 1 4 9)
      (setf (fill-pointer a) 3) → 3
      (fill-pointer a) → 3
      a → #(0 1 4)
      (setf (fill-pointer a) 8) → 8
      a → #(0 1 4 9 NIL NIL NIL NIL)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if VECTOR is not a vector
with a fill pointer.

See Also:
.........

*note make-array::, *note length::

Notes:
......

There is no operator that will remove a vector’s fill pointer.


File: ansicl,  Node: row-major-aref,  Next: upgraded-array-element-type,  Prev: fill-pointer,  Up: Arrays

row-major-aref (Accessor)
=========================

Syntax:
.......

 -- Function: row-major-aref array index → element
(setf (row-major-aref array index) new-element)

Arguments and Values:
.....................

ARRAY—an array.

INDEX—a valid array row-major index for the ARRAY.

ELEMENT, NEW-ELEMENT—an object.

Description:
............

Considers array as a vector by viewing its elements in row-major order,
and returns the element of that vector which is referred to by the given
INDEX.

‘row-major-aref’ is valid for use with ‘setf’.

See Also:
.........

*note aref::, *note array-row-major-index::

Notes:
......

      (row-major-aref array index) ≡
        (aref (make-array (array-total-size array)
                          :displaced-to array
                          :element-type (array-element-type array))
              index)

      (aref array i1 i2 ...) ≡
          (row-major-aref array (array-row-major-index array i1 i2))


File: ansicl,  Node: upgraded-array-element-type,  Next: array-dimension-limit,  Prev: row-major-aref,  Up: Arrays

upgraded-array-element-type (Function)
======================================

Syntax:
.......

 -- Function: upgraded-array-element-type typespec &optional environment
          → upgraded-typespec

Arguments and Values:
.....................

TYPESPEC—a type specifier.

ENVIRONMENT—an environment object.  The default is ‘nil’, denoting the
null lexical environment and the current global environment.

UPGRADED-TYPESPEC—a type specifier.

Description:
............

Returns the element type of the most specialized array representation
capable of holding items of the type denoted by TYPESPEC.

The TYPESPEC is a subtype of (and possibly type equivalent to) the
UPGRADED-TYPESPEC.

If TYPESPEC is ‘bit’, the result is type equivalent to ‘bit’.  If
TYPESPEC is ‘base-char’, the result is type equivalent to ‘base-char’.
If TYPESPEC is ‘character’, the result is type equivalent to
‘character’.

The purpose of ‘upgraded-array-element-type’ is to reveal how an
implementation does its upgrading.

The ENVIRONMENT is used to expand any derived type specifiers that are
mentioned in the TYPESPEC.

See Also:
.........

*note array-element-type::, *note make-array::

Notes:
......

Except for storage allocation consequences and dealing correctly with
the optional ENVIRONMENT argument, ‘upgraded-array-element-type’ could
be defined as:

      (defun upgraded-array-element-type (type &optional environment)
        (array-element-type (make-array 0 :element-type type)))


File: ansicl,  Node: array-dimension-limit,  Next: array-rank-limit,  Prev: upgraded-array-element-type,  Up: Arrays

array-dimension-limit (Constant Variable)
=========================================

Constant Value:
...............

A positive fixnum, the exact magnitude of which is
implementation-dependent, but which is not less than ‘1024’.

Description:
............

The upper exclusive bound on each individual dimension of an array.

See Also:
.........

*note make-array::


File: ansicl,  Node: array-rank-limit,  Next: array-total-size-limit,  Prev: array-dimension-limit,  Up: Arrays

array-rank-limit (Constant Variable)
====================================

Constant Value:
...............

A positive fixnum, the exact magnitude of which is
implementation-dependent, but which is not less than ‘8’.

Description:
............

The upper exclusive bound on the rank of an array.

See Also:
.........

*note make-array::


File: ansicl,  Node: array-total-size-limit,  Next: simple-vector-p,  Prev: array-rank-limit,  Up: Arrays

array-total-size-limit (Constant Variable)
==========================================

Constant Value:
...............

A positive fixnum, the exact magnitude of which is
implementation-dependent, but which is not less than ‘1024’.

Description:
............

The upper exclusive bound on the array total size of an array.

The actual limit on the array total size imposed by the implementation
might vary according the element type of the array; in this case, the
value of ‘array-total-size-limit’ will be the smallest of these possible
limits.

See Also:
.........

*note make-array::, *note array-element-type::


File: ansicl,  Node: simple-vector-p,  Next: svref,  Prev: array-total-size-limit,  Up: Arrays

simple-vector-p (Function)
==========================

Syntax:
.......

 -- Function: simple-vector-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘simple-vector’; otherwise, returns
false..

Examples:
.........

      (simple-vector-p (make-array 6)) → true
      (simple-vector-p "aaaaaa") → false
      (simple-vector-p (make-array 6 :fill-pointer t)) → false

See Also:
.........

*note simple-vector::

Notes:
......

      (simple-vector-p OBJECT) ≡ (typep OBJECT 'simple-vector)


File: ansicl,  Node: svref,  Next: vector (Function),  Prev: simple-vector-p,  Up: Arrays

svref (Accessor)
================

Syntax:
.......

 -- Function: svref simple-vector index → element
(setf (svref simple-vector index) new-element)

Arguments and Values:
.....................

SIMPLE-VECTOR—a simple vector.

INDEX—a valid array index for the SIMPLE-VECTOR.

ELEMENT, NEW-ELEMENT—an object (whose type is a subtype of the array
element type of the SIMPLE-VECTOR).

Description:
............

Accesses the element of SIMPLE-VECTOR specified by INDEX.

Examples:
.........

      (simple-vector-p (setq v (vector 1 2 'sirens))) → true
      (svref v 0) → 1
      (svref v 2) → SIRENS
      (setf (svref v 1) 'newcomer) → NEWCOMER
      v → #(1 NEWCOMER SIRENS)

See Also:
.........

*note aref::, *note sbit::, *note schar::, *note vector (Function)::,
*note Section 3.2.1 (Compiler Terminology): Compiler Terminology.

Notes:
......

‘svref’ is identical to ‘aref’ except that it requires its first
argument to be a simple vector.

      (svref V I) ≡ (aref (the simple-vector V) I)


File: ansicl,  Node: vector (Function),  Next: vector-pop,  Prev: svref,  Up: Arrays

vector (Function)
=================

Syntax:
.......

 -- Function: vector &rest objects → vector

Arguments and Values:
.....................

OBJECT—an object.

VECTOR—a vector of type ‘(vector t *)’.

Description:
............

Creates a fresh simple general vector whose size corresponds to the
number of OBJECTS.

The vector is initialized to contain the OBJECTS.

Examples:
.........

      (arrayp (setq v (vector 1 2 'sirens))) → true
      (vectorp v) → true
      (simple-vector-p v) → true
      (length v) → 3

See Also:
.........

*note make-array::

Notes:
......

‘vector’ is analogous to ‘list’.

      (vector a  ≡ (make-array (list n) :element-type t
                               :initial-contents
                                 (list a


File: ansicl,  Node: vector-pop,  Next: vector-push; vector-push-extend,  Prev: vector (Function),  Up: Arrays

vector-pop (Function)
=====================

Syntax:
.......

 -- Function: vector-pop vector → element

Arguments and Values:
.....................

VECTOR—a vector with a fill pointer.

ELEMENT—an object.

Description:
............

Decreases the fill pointer of VECTOR by one, and retrieves the element
of VECTOR that is designated by the new fill pointer.

Examples:
.........

      (vector-push (setq fable (list 'fable))
                   (setq fa (make-array 8
                                        :fill-pointer 2
                                        :initial-element 'sisyphus))) → 2
      (fill-pointer fa) → 3
      (eq (vector-pop fa) fable) → true
      (vector-pop fa) → SISYPHUS
      (fill-pointer fa) → 1

Side Effects:
.............

The fill pointer is decreased by one.

Affected By:
............

The value of the fill pointer.

Exceptional Situations:
.......................

An error of type ‘type-error’ is signaled if VECTOR does not have a fill
pointer.

If the fill pointer is zero, ‘vector-pop’ signals an error of type
‘error’.

See Also:
.........

*note vector-push::, *note vector-push-extend::, *note fill-pointer::


File: ansicl,  Node: vector-push; vector-push-extend,  Next: vectorp,  Prev: vector-pop,  Up: Arrays

vector-push, vector-push-extend (Function)
==========================================

Syntax:
.......

 -- Function: vector-push new-element vector → new-index-p

 -- Function: vector-push-extend new-element vector &optional extension
          → new-index

Arguments and Values:
.....................

NEW-ELEMENT—an object.

VECTOR—a vector with a fill pointer.

EXTENSION—a positive integer.  The default is implementation-dependent.

NEW-INDEX-P—a valid array index for VECTOR, or ‘nil’.

NEW-INDEX—a valid array index for VECTOR.

Description:
............

‘vector-push’ and ‘vector-push-extend’ store NEW-ELEMENT in VECTOR.
‘vector-push’ attempts to store NEW-ELEMENT in the element of VECTOR
designated by the fill pointer, and to increase the fill pointer by one.
If the ‘(>= (fill-pointer VECTOR) (array-dimension VECTOR 0))’, neither
VECTOR nor its fill pointer are affected.  Otherwise, the store and
increment take place and ‘vector-push’ returns the former value of the
fill pointer which is one less than the one it leaves in VECTOR.

‘vector-push-extend’ is just like ‘vector-push’ except that if the fill
pointer gets too large, VECTOR is extended using ‘adjust-array’ so that
it can contain more elements.  EXTENSION is the minimum number of
elements to be added to VECTOR if it must be extended.

‘vector-push’ and ‘vector-push-extend’ return the index of NEW-ELEMENT
in VECTOR.  If ‘(>= (fill-pointer VECTOR) (array-dimension VECTOR 0))’,
‘vector-push’ returns ‘nil’.

Examples:
.........

      (vector-push (setq fable (list 'fable))
                   (setq fa (make-array 8
                                        :fill-pointer 2
                                        :initial-element 'first-one))) → 2
      (fill-pointer fa) → 3
      (eq (aref fa 2) fable) → true
      (vector-push-extend #\X
                         (setq aa
                               (make-array 5
                                           :element-type 'character
                                           :adjustable t
                                           :fill-pointer 3))) → 3
      (fill-pointer aa) → 4
      (vector-push-extend #\Y aa 4) → 4
      (array-total-size aa) → at least 5
      (vector-push-extend #\Z aa 4) → 5
      (array-total-size aa) → 9 ;(or more)

Affected By:
............

The value of the fill pointer.

How VECTOR was created.

Exceptional Situations:
.......................

An error of type ‘error’ is signaled by ‘vector-push-extend’ if it tries
to extend VECTOR and VECTOR is not actually adjustable.

An error of type ‘error’ is signaled if VECTOR does not have a fill
pointer.

See Also:
.........

*note adjustable-array-p::, *note fill-pointer::, *note vector-pop::


File: ansicl,  Node: vectorp,  Next: bit; sbit,  Prev: vector-push; vector-push-extend,  Up: Arrays

vectorp (Function)
==================

Syntax:
.......

 -- Function: vectorp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘vector’; otherwise, returns false.

Examples:
.........

      (vectorp "aaaaaa") → true
      (vectorp (make-array 6 :fill-pointer t)) → true
      (vectorp (make-array '(2 3 4))) → false
      (vectorp #*11) → true
      (vectorp #b11) → false

Notes:
......

      (vectorp OBJECT) ≡ (typep OBJECT 'vector)


File: ansicl,  Node: bit; sbit,  Next: bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+,  Prev: vectorp,  Up: Arrays

bit, sbit (Accessor)
====================

Syntax:
.......

 -- Function: bit bit-array &rest subscripts → bit
 -- Function: sbit bit-array &rest subscripts → bit

Arguments and Values:
.....................

BIT-ARRAY—for ‘bit’, a bit array; for ‘sbit’, a simple bit array.

SUBSCRIPTS—a list of valid array indices for the BIT-ARRAY.

BIT—a bit.

Description:
............

‘bit’ and ‘sbit’ access the BIT-ARRAY element specified by SUBSCRIPTS.

These functions ignore the fill pointer when accessing elements.

Examples:
.........

      (bit (setq ba (make-array 8
                                 :element-type 'bit
                                 :initial-element 1))
            3) → 1
      (setf (bit ba 3) 0) → 0
      (bit ba 3) → 0
      (sbit ba 5) → 1
      (setf (sbit ba 5) 1) → 1
      (sbit ba 5) → 1

See Also:
.........

*note aref::, *note Section 3.2.1 (Compiler Terminology): Compiler
Terminology.

Notes:
......

‘bit’ and ‘sbit’ are like ‘aref’ except that they require ARRAYS to be a
bit array and a simple bit array, respectively.

‘bit’ and ‘sbit’, unlike ‘char’ and ‘schar’, allow the first argument to
be an array of any rank.


File: ansicl,  Node: bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+,  Next: bit-vector-p,  Prev: bit; sbit,  Up: Arrays

bit-and, bit-andc1, bit-andc2, bit-eqv, bit-ior, bit-nand, bit-nor, bit-not, bit-orc1, bit-orc2, bit-xor (Function)
===================================================================================================================

Syntax:
.......

 -- Function: bit-and bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array
 -- Function: bit-andc1 bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array
 -- Function: bit-andc2 bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array
 -- Function: bit-eqv bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array
 -- Function: bit-ior bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array
 -- Function: bit-nand bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array
 -- Function: bit-nor bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array
 -- Function: bit-orc1 bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array
 -- Function: bit-orc2 bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array
 -- Function: bit-xor bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-not bit-array &optional opt-arg → resulting-bit-array

Arguments and Values:
.....................

BIT-ARRAY, BIT-ARRAY1, BIT-ARRAY2—a bit array.

OPT-ARG—a bit array, or ‘t’, or ‘nil’.  The default is ‘nil’.

BIT-ARRAY, BIT-ARRAY1, BIT-ARRAY2, and OPT-ARG (if an array) must all be
of the same rank and dimensions.

RESULTING-BIT-ARRAY—a bit array.

Description:
............

These functions perform bit-wise logical operations on BIT-ARRAY1 and
BIT-ARRAY2 and return an array of matching rank and dimensions, such
that any given bit of the result is produced by operating on
corresponding bits from each of the arguments.

In the case of ‘bit-not’, an array of rank and dimensions matching
BIT-ARRAY is returned that contains a copy of BIT-ARRAY with all the
bits inverted.

If OPT-ARG is of type ‘(array bit)’ the contents of the result are
destructively placed into OPT-ARG.  If OPT-ARG is the symbol ‘t’,
BIT-ARRAY or BIT-ARRAY1 is replaced with the result; if OPT-ARG is
‘nil’ or omitted, a new array is created to contain the result.

The next figure indicates the logical operation performed by each of the
functions.

Function      Operation
-------------------------------------------------------------
‘bit-nor’     complement of BIT-ARRAY1 or BIT-ARRAY2
‘bit-andc1’   and complement of BIT-ARRAY1 with BIT-ARRAY2
‘bit-andc2’   and BIT-ARRAY1 with complement of BIT-ARRAY2
‘bit-orc1’    or complement of BIT-ARRAY1 with BIT-ARRAY2
‘bit-orc2’    or BIT-ARRAY1 with complement of BIT-ARRAY2

Figure 15.4: Bit-wise Logical Operations on Bit Arrays

Examples:
.........

      (bit-and (setq ba #*11101010) #*01101011) → #*01101010
      (bit-and #*1100 #*1010) → #*1000
      (bit-andc1 #*1100 #*1010) → #*0010
      (setq rba (bit-andc2 ba #*00110011 t)) → #*11001000
      (eq rba ba) → true
      (bit-not (setq ba #*11101010)) → #*00010101
      (setq rba (bit-not ba
                          (setq tba (make-array 8
                                                :element-type 'bit))))
     → #*00010101
      (equal rba tba) → true
      (bit-xor #*1100 #*1010) → #*0110

See Also:
.........

*note lognot::, *note logand::


File: ansicl,  Node: bit-vector-p,  Next: simple-bit-vector-p,  Prev: bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+,  Up: Arrays

bit-vector-p (Function)
=======================

Syntax:
.......

 -- Function: bit-vector-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘bit-vector’; otherwise, returns
false.

Examples:
.........

      (bit-vector-p (make-array 6
                                :element-type 'bit
                                :fill-pointer t)) → true
      (bit-vector-p #*) → true
      (bit-vector-p (make-array 6)) → false

See Also:
.........

*note typep::

Notes:
......

      (bit-vector-p OBJECT) ≡ (typep OBJECT 'bit-vector)


File: ansicl,  Node: simple-bit-vector-p,  Prev: bit-vector-p,  Up: Arrays

simple-bit-vector-p (Function)
==============================

Syntax:
.......

 -- Function: simple-bit-vector-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘simple-bit-vector’; otherwise,
returns false.

Examples:
.........

      (simple-bit-vector-p (make-array 6)) → false
      (simple-bit-vector-p #*) → true

See Also:
.........

*note simple-vector-p::

Notes:
......

      (simple-bit-vector-p OBJECT) ≡ (typep OBJECT 'simple-bit-vector)


File: ansicl,  Node: Strings,  Next: Sequences,  Prev: Arrays,  Up: Top

16 Strings
**********

* Menu:

* String Concepts::

Dictionary

* string (System Class)::
* base-string::
* simple-string::
* simple-base-string::
* simple-string-p::
* char; schar::
* string (Function)::
* string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+::
* string-trim; string-left-trim; string-right-trim::
* string=; string/=; string<; string>; string<=; string>=; string-equal; +::
* stringp::
* make-string::


File: ansicl,  Node: String Concepts,  Next: string (System Class),  Up: Strings

16.1 String Concepts
====================

* Menu:

* Implications of Strings Being Arrays::
* Subtypes of STRING::


File: ansicl,  Node: Implications of Strings Being Arrays,  Next: Subtypes of STRING,  Up: String Concepts

16.1.1 Implications of Strings Being Arrays
-------------------------------------------

Since all strings are arrays, all rules which apply generally to arrays
also apply to strings.  See *note Section 15.1 (Array Concepts): Array
Concepts.

For example, strings can have fill pointers, and strings are also
subject to the rules of element type upgrading that apply to arrays.


File: ansicl,  Node: Subtypes of STRING,  Prev: Implications of Strings Being Arrays,  Up: String Concepts

16.1.2 Subtypes of STRING
-------------------------

All functions that operate on strings will operate on subtypes of string
as well.

However, the consequences are undefined if a character is inserted into
a string for which the element type of the string does not include that
character.


File: ansicl,  Node: string (System Class),  Next: base-string,  Prev: String Concepts,  Up: Strings

string (System Class)
=====================

Class Precedence List:
......................

‘string’, ‘vector’, ‘array’, ‘sequence’, ‘t’

Description:
............

A string is a specialized vector whose elements are of type ‘character’
or a suptype of type ‘character’.  When used as a type specifier for
object creation, ‘string’ means ‘(vector character)’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(string [size])

Compound Type Specifier Arguments:
..................................

SIZE—a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This denotes the union of all types ‘(array c (SIZE))’ for all subtypes
c of ‘character’; that is, the set of strings of size SIZE.

See Also:
.........

*note Section 16.1 (String Concepts): String Concepts, *note Section
2.4.5 (Double-Quote): Double-Quote, *note Section 22.1.3.4 (Printing
Strings): PrintingStrings.


File: ansicl,  Node: base-string,  Next: simple-string,  Prev: string (System Class),  Up: Strings

base-string (Type)
==================

Supertypes:
...........

‘base-string’, ‘string’, ‘vector’, ‘array’, ‘sequence’, ‘t’

Description:
............

The type ‘base-string’ is equivalent to ‘(vector base-char)’.  The base
string representation is the most efficient string representation that
can hold an arbitrary sequence of standard characters.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(base-string [size])

Compound Type Specifier Arguments:
..................................

SIZE—a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This is equivalent to the type ‘(vector base-char SIZE)’; that is, the
set of base strings of size SIZE.


File: ansicl,  Node: simple-string,  Next: simple-base-string,  Prev: base-string,  Up: Strings

simple-string (Type)
====================

Supertypes:
...........

‘simple-string’, ‘string’, ‘vector’, ‘simple-array’, ‘array’,
‘sequence’, ‘t’

Description:
............

A simple string is a specialized one-dimensional simple array whose
elements are of type ‘character’ or a suptype of type ‘character’.  When
used as a type specifier for object creation, ‘simple-string’ means
‘(simple-array character (size))’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(simple-string [size])

Compound Type Specifier Arguments:
..................................

SIZE—a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This denotes the union of all types ‘(simple-array c (SIZE))’ for all
subtypes c of ‘character’; that is, the set of simple strings of size
SIZE.


File: ansicl,  Node: simple-base-string,  Next: simple-string-p,  Prev: simple-string,  Up: Strings

simple-base-string (Type)
=========================

Supertypes:
...........

‘simple-base-string’, ‘base-string’, ‘simple-string’, ‘string’,
‘vector’, ‘simple-array’, ‘array’, ‘sequence’, ‘t’

Description:
............

The type ‘simple-base-string’ is equivalent to ‘(simple-array base-char
(*))’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(simple-base-string [size])

Compound Type Specifier Arguments:
..................................

SIZE—a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This is equivalent to the type ‘(simple-array base-char (SIZE))’; that
is, the set of simple base strings of size SIZE.


File: ansicl,  Node: simple-string-p,  Next: char; schar,  Prev: simple-base-string,  Up: Strings

simple-string-p (Function)
==========================

Syntax:
.......

 -- Function: simple-string-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘simple-string’; otherwise, returns
false.

Examples:
.........

      (simple-string-p "aaaaaa") → true
      (simple-string-p (make-array 6
                                   :element-type 'character
                                   :fill-pointer t)) → false

Notes:
......

      (simple-string-p OBJECT) ≡ (typep OBJECT 'simple-string)


File: ansicl,  Node: char; schar,  Next: string (Function),  Prev: simple-string-p,  Up: Strings

char, schar (Accessor)
======================

Syntax:
.......

 -- Function: char string index → character
 -- Function: schar string index → character

Arguments and Values:
.....................

STRING—for ‘char’, a string; for ‘schar’, a simple string.

INDEX—a valid array index for the STRING.

CHARACTER, NEW-CHARACTER—a character.

Description:
............

‘char’ and ‘schar’ access the element of STRING specified by INDEX.

‘char’ ignores fill pointers when accessing elements.

Examples:
.........

      (setq my-simple-string (make-string 6 :initial-element #\A)) → "AAAAAA"
      (schar my-simple-string 4) → #\A
      (setf (schar my-simple-string 4) #\B) → #\B
      my-simple-string → "AAAABA"
      (setq my-filled-string
            (make-array 6 :element-type 'character
                          :fill-pointer 5
                          :initial-contents my-simple-string))
     → "AAAAB"
      (char my-filled-string 4) → #\B
      (char my-filled-string 5) → #\A
      (setf (char my-filled-string 3) #\C) → #\C
      (setf (char my-filled-string 5) #\D) → #\D
      (setf (fill-pointer my-filled-string) 6) → 6
      my-filled-string → "AAACBD"

See Also:
.........

*note aref::, *note elt::, *note Section 3.2.1 (Compiler Terminology):
Compiler Terminology.

Notes:
......

      (char s j) ≡ (aref (the string s) j)


File: ansicl,  Node: string (Function),  Next: string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+,  Prev: char; schar,  Up: Strings

string (Function)
=================

Syntax:
.......

 -- Function: string x → string

Arguments and Values:
.....................

X—a string, a symbol, or a character.

STRING—a string.

Description:
............

Returns a string described by X; specifically:

   • If X is a string, it is returned.
   • If X is a symbol, its name is returned.
   • If X is a character, then a string containing that one character is
     returned.
   • ‘string’ might perform additional, implementation-defined
     conversions.

Examples:
.........

      (string "already a string") → "already a string"
      (string 'elm) → "ELM"
      (string #\c) → "c"

Exceptional Situations:
.......................

In the case where a conversion is defined neither by this specification
nor by the implementation, an error of type ‘type-error’ is signaled.

See Also:
.........

*note coerce::, *note string (System Class):: (type).

Notes:
......

‘coerce’ can be used to convert a sequence of characters to a string.

‘prin1-to-string’, ‘princ-to-string’, ‘write-to-string’, or ‘format’
(with a first argument of ‘nil’) can be used to get a string
representation of a number or any other object.


File: ansicl,  Node: string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+,  Next: string-trim; string-left-trim; string-right-trim,  Prev: string (Function),  Up: Strings

string-upcase, string-downcase, string-capitalize, nstring-upcase, nstring-downcase, nstring-capitalize (Function)
==================================================================================================================

Syntax:
.......

 -- Function: string-upcase string &key start end → cased-string
 -- Function: string-downcase string &key start end → cased-string
 -- Function: string-capitalize string &key start end → cased-string

 -- Function: nstring-upcase string &key start end → string
 -- Function: nstring-downcase string &key start end → string
 -- Function: nstring-capitalize string &key start end → string

Arguments and Values:
.....................

STRING—a string designator.  For ‘nstring-upcase’, ‘nstring-downcase’,
and ‘nstring-capitalize’, the STRING designator must be a string.

START, END—bounding index designators of STRING.  The defaults for START
and END are ‘0’ and ‘nil’, respectively.

CASED-STRING—a string.

Description:
............

‘string-upcase’, ‘string-downcase’, ‘string-capitalize’,
‘nstring-upcase’, ‘nstring-downcase’, ‘nstring-capitalize’ change the
case of the subsequence of STRING bounded by START and END as follows:

string-upcase

     ‘string-upcase’ returns a string just like STRING with all
     lowercase characters replaced by the corresponding uppercase
     characters.  More precisely, each character of the result string is
     produced by applying the function ‘char-upcase’ to the
     corresponding character of STRING.

string-downcase

     ‘string-downcase’ is like ‘string-upcase’ except that all uppercase
     characters are replaced by the corresponding lowercase characters
     (using ‘char-downcase’).

string-capitalize

     ‘string-capitalize’ produces a copy of STRING such that, for every
     word in the copy, the first character of the “word,” if it has
     case, is uppercase and any other characters with case in the word
     are lowercase.  For the purposes of ‘string-capitalize’, a “word”
     is defined to be a consecutive subsequence consisting of
     alphanumeric characters, delimited at each end either by a
     non-alphanumeric character or by an end of the string.

nstring-upcase, nstring-downcase, nstring-capitalize 

     ‘nstring-upcase’, ‘nstring-downcase’, and ‘nstring-capitalize’ are
     identical to ‘string-upcase’, ‘string-downcase’, and
     ‘string-capitalize’ respectively except that they modify STRING.

For ‘string-upcase’, ‘string-downcase’, and ‘string-capitalize’, STRING
is not modified.  However, if no characters in STRING require
conversion, the result may be either STRING or a copy of it, at the
implementation’s discretion.

Examples:
.........

      (string-upcase "abcde") → "ABCDE"
      (string-upcase "Dr. Livingston, I presume?")
     → "DR. LIVINGSTON, I PRESUME?"
      (string-upcase "Dr. Livingston, I presume?" :start 6 :end 10)
     → "Dr. LiVINGston, I presume?"
      (string-downcase "Dr. Livingston, I presume?")
     → "dr. livingston, i presume?"

      (string-capitalize "elm 13c arthur;fig don't") → "Elm 13c Arthur;Fig Don'T"
      (string-capitalize " hello ") → " Hello "
      (string-capitalize "occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION")
     →  "Occluded Casements Forestall Inadvertent Defenestration"
      (string-capitalize 'kludgy-hash-search) → "Kludgy-Hash-Search"
      (string-capitalize "DON'T!") → "Don'T!"    ;not "Don't!"
      (string-capitalize "pipe 13a, foo16c") → "Pipe 13a, Foo16c"

      (setq str (copy-seq "0123ABCD890a")) → "0123ABCD890a"
      (nstring-downcase str :start 5 :end 7) → "0123AbcD890a"
      str → "0123AbcD890a"

Side Effects:
.............

‘nstring-upcase’, ‘nstring-downcase’, and ‘nstring-capitalize’ modify
STRING as appropriate rather than constructing a new string.

See Also:
.........

*note char-upcase::, *note char-downcase::

Notes:
......

The result is always of the same length as STRING.


File: ansicl,  Node: string-trim; string-left-trim; string-right-trim,  Next: string=; string/=; string<; string>; string<=; string>=; string-equal; +,  Prev: string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+,  Up: Strings

string-trim, string-left-trim, string-right-trim (Function)
===========================================================

Syntax:
.......

 -- Function: string-trim character-bag string → trimmed-string
 -- Function: string-left-trim character-bag string → trimmed-string
 -- Function: string-right-trim character-bag string → trimmed-string

Arguments and Values:
.....................

CHARACTER-BAG—a sequence containing characters.

STRING—a string designator.

TRIMMED-STRING—a string.

Description:
............

‘string-trim’ returns a substring of STRING, with all characters in
CHARACTER-BAG stripped off the beginning and end.  ‘string-left-trim’ is
similar but strips characters off only the beginning;
‘string-right-trim’ strips off only the end.

If no characters need to be trimmed from the STRING, then either STRING
itself or a copy of it may be returned, at the discretion of the
implementation.

All of these functions observe the fill pointer.

Examples:
.........

      (string-trim "abc" "abcaakaaakabcaaa") → "kaaak"
      (string-trim '(#\Space #\Tab #\Newline) " garbanzo beans
             ") → "garbanzo beans"
      (string-trim " (*)" " ( *three (silly) words* ) ")
     → "three (silly) words"

      (string-left-trim "abc" "labcabcabc") → "labcabcabc"
      (string-left-trim " (*)" " ( *three (silly) words* ) ")
     → "three (silly) words* ) "

      (string-right-trim " (*)" " ( *three (silly) words* ) ")
     → " ( *three (silly) words"

Affected By:
............

The implementation.


File: ansicl,  Node: string=; string/=; string<; string>; string<=; string>=; string-equal; +,  Next: stringp,  Prev: string-trim; string-left-trim; string-right-trim,  Up: Strings

string=, string/=, string<, string>, string<=, string>=, string-equal, string-not-equal, string-lessp, string-greaterp, string-not-greaterp, string-not-lessp (Function)
========================================================================================================================================================================

Syntax:
.......

 -- Function: string= string1 string2 &key start1 end1 start2 end2 →
          generalized-boolean

 -- Function: string/= string1 string2 &key start1 end1 start2 end2 →
          mismatch-index
 -- Function: string< string1 string2 &key start1 end1 start2 end2 →
          mismatch-index
 -- Function: string> string1 string2 &key start1 end1 start2 end2 →
          mismatch-index
 -- Function: string<= string1 string2 &key start1 end1 start2 end2 →
          mismatch-index
 -- Function: string>= string1 string2 &key start1 end1 start2 end2 →
          mismatch-index

 -- Function: string-equal string1 string2 &key start1 end1 start2 end2
          → generalized-boolean

 -- Function: string-not-equal string1 string2 &key start1 end1 start2
          end2 → mismatch-index
 -- Function: string-lessp string1 string2 &key start1 end1 start2 end2
          → mismatch-index
 -- Function: string-greaterp string1 string2 &key start1 end1 start2
          end2 → mismatch-index
 -- Function: string-not-greaterp string1 string2 &key start1 end1
          start2 end2 → mismatch-index
 -- Function: string-not-lessp string1 string2 &key start1 end1 start2
          end2 → mismatch-index

Arguments and Values:
.....................

STRING1—a string designator.

STRING2—a string designator.

START1, END1—bounding index designators of STRING1.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

START2, END2—bounding index designators of STRING2.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

GENERALIZED-BOOLEAN—a generalized boolean.

MISMATCH-INDEX—a bounding index of STRING1, or ‘nil’.

Description:
............

These functions perform lexicographic comparisons on STRING1 and
STRING2.  ‘string=’ and ‘string-equal’ are called equality functions;
the others are called inequality functions.  The comparison operations
these functions perform are restricted to the subsequence of STRING1
bounded by start1 and END1 and to the subsequence of STRING2 bounded by
start2 and END2.

A string a is equal to a string b if it contains the same number of
characters, and the corresponding characters are the same under ‘char=’
or ‘char-equal’, as appropriate.

A string a is less than a string b if in the first position in which
they differ the character of a is less than the corresponding character
of b according to ‘char<’ or ‘char-lessp’ as appropriate, or if string a
is a proper prefix of string b (of shorter length and matching in all
the characters of a).

The equality functions return a GENERALIZED BOOLEAN that is true if the
strings are equal, or false otherwise.

The inequality functions return a MISMATCH-INDEX that is true if the
strings are not equal, or false otherwise.  When the MISMATCH-INDEX is
true, it is an integer representing the first character position at
which the two substrings differ, as an offset from the beginning of
STRING1.

The comparison has one of the following results:

‘string=’

     ‘string=’ is true if the supplied substrings are of the same length
     and contain the same characters in corresponding positions;
     otherwise it is false.

‘string/=’

     ‘string/=’ is true if the supplied substrings are different;
     otherwise it is false.

‘string-equal’

     ‘string-equal’ is just like ‘string=’ except that differences in
     case are ignored; two characters are considered to be the same if
     ‘char-equal’ is true of them.

‘string<’

     ‘string<’ is true if substring1 is less than substring2; otherwise
     it is false.

‘string>’

     ‘string>’ is true if substring1 is greater than substring2;
     otherwise it is false.

‘string-lessp’, ‘string-greaterp’

     ‘string-lessp’ and ‘string-greaterp’ are exactly like ‘string<’ and
     ‘string>’, respectively, except that distinctions between uppercase
     and lowercase letters are ignored.  It is as if ‘char-lessp’ were
     used instead of ‘char<’ for comparing characters.

‘string<=’

     ‘string<=’ is true if substring1 is less than or equal to
     substring2; otherwise it is false.

‘string>=’

     ‘string>=’ is true if substring1 is greater than or equal to
     substring2; otherwise it is false.

‘string-not-greaterp’, ‘string-not-lessp’

     ‘string-not-greaterp’ and ‘string-not-lessp’ are exactly like
     ‘string<=’ and ‘string>=’, respectively, except that distinctions
     between uppercase and lowercase letters are ignored.  It is as if
     ‘char-lessp’ were used instead of ‘char<’ for comparing characters.

Examples:
.........

      (string= "foo" "foo") → true
      (string= "foo" "Foo") → false
      (string= "foo" "bar") → false
      (string= "together" "frog" :start1 1 :end1 3 :start2 2) → true
      (string-equal "foo" "Foo") → true
      (string= "abcd" "01234abcd9012" :start2 5 :end2 9) → true
      (string< "aaaa" "aaab") → 3
      (string>= "aaaaa" "aaaa") → 4
      (string-not-greaterp "Abcde" "abcdE") → 5
      (string-lessp "012AAAA789" "01aaab6" :start1 3 :end1 7
                                           :start2 2 :end2 6) → 6
      (string-not-equal "AAAA" "aaaA") → false

See Also:
.........

*note char=::

Notes:
......

‘equal’ calls ‘string=’ if applied to two strings.


File: ansicl,  Node: stringp,  Next: make-string,  Prev: string=; string/=; string<; string>; string<=; string>=; string-equal; +,  Up: Strings

stringp (Function)
==================

Syntax:
.......

 -- Function: stringp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘string’; otherwise, returns false.

Examples:
.........

      (stringp "aaaaaa") → true
      (stringp #\a) → false

See Also:
.........

*note typep::, *note string (System Class):: (type)

Notes:
......

      (stringp OBJECT) ≡ (typep OBJECT 'string)


File: ansicl,  Node: make-string,  Prev: stringp,  Up: Strings

make-string (Function)
======================

Syntax:
.......

 -- Function: make-string size &key initial-element element-type →
          string

Arguments and Values:
.....................

SIZE—a valid array dimension.

INITIAL-ELEMENT—a character.  The default is implementation-dependent.

ELEMENT-TYPE—a type specifier.  The default is ‘character’.

STRING—a simple string.

Description:
............

‘make-string’ returns a simple string of length SIZE whose elements have
been initialized to INITIAL-ELEMENT.

The ELEMENT-TYPE names the type of the elements of the string; a string
is constructed of the most specialized type that can accommodate
elements of the given type.

Examples:
.........

      (make-string 10 :initial-element #\5) → "5555555555"
      (length (make-string 10)) → 10

Affected By:
............

The implementation.


File: ansicl,  Node: Sequences,  Next: Hash Tables,  Prev: Strings,  Up: Top

17 Sequences
************

* Menu:

* Sequence Concepts::
* Rules about Test Functions::

Dictionary

* sequence::
* copy-seq::
* elt::
* fill::
* make-sequence::
* subseq::
* map::
* map-into::
* reduce::
* count; count-if; count-if-not::
* length::
* reverse; nreverse::
* sort; stable-sort::
* find; find-if; find-if-not::
* position; position-if; position-if-not::
* search::
* mismatch::
* replace::
* substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+::
* concatenate::
* merge::
* remove; remove-if; remove-if-not; delete; delete-if; delete-if-not::
* remove-duplicates; delete-duplicates::


File: ansicl,  Node: Sequence Concepts,  Next: Rules about Test Functions,  Up: Sequences

17.1 Sequence Concepts
======================

A “sequence” is an ordered collection of elements, implemented as either
a vector or a list.

Sequences can be created by the function ‘make-sequence’, as well as
other functions that create objects of types that are subtypes of
‘sequence’ (e.g., ‘list’, ‘make-list’, ‘mapcar’, and ‘vector’).

A “sequence function” is a function defined by this specification or
added as an extension by the implementation that operates on one or more
sequences.  Whenever a sequence function must construct and return a new
vector, it always returns a simple vector.  Similarly, any strings
constructed will be simple strings.

concatenate         length               remove
copy-seq            map                  remove-duplicates
count               map-into             remove-if
count-if            merge                remove-if-not
count-if-not        mismatch             replace
delete              notany               reverse
delete-duplicates   notevery             search
delete-if           nreverse             some
delete-if-not       nsubstitute          sort
elt                 nsubstitute-if       stable-sort
every               nsubstitute-if-not   subseq
fill                position             substitute
find                position-if          substitute-if
find-if             position-if-not      substitute-if-not
find-if-not         reduce

Figure 17.1: Standardized Sequence Functions

* Menu:

* General Restrictions on Parameters that must be Sequences::


File: ansicl,  Node: General Restrictions on Parameters that must be Sequences,  Up: Sequence Concepts

17.1.1 General Restrictions on Parameters that must be Sequences
----------------------------------------------------------------

In general, lists (including association lists and property lists) that
are treated as sequences must be proper lists.


File: ansicl,  Node: Rules about Test Functions,  Next: sequence,  Prev: Sequence Concepts,  Up: Sequences

17.2 Rules about Test Functions
===============================

* Menu:

* Satisfying a Two-Argument Test::
* Satisfying a One-Argument Test::


File: ansicl,  Node: Satisfying a Two-Argument Test,  Next: Satisfying a One-Argument Test,  Up: Rules about Test Functions

17.2.1 Satisfying a Two-Argument Test
-------------------------------------

When an object O is being considered iteratively against each element
Eof a sequence S by an operator F listed in the next figure, it is
sometimes useful to control the way in which the presence of O is tested
in S is tested by F. This control is offered on the basis of a function
designated with either a :test or :test-not argument.

adjoin            nset-exclusive-or   search
assoc             nsublis             set-difference
count             nsubst              set-exclusive-or
delete            nsubstitute         sublis
find              nunion              subsetp
intersection      position            subst
member            pushnew             substitute
mismatch          rassoc              tree-equal
nintersection     remove              union
nset-difference   remove-duplicates

Figure 17.2: Operators that have Two-Argument Tests to be Satisfied

The object O might not be compared directly to EIf a :key argument is
provided, it is a designator for a function of one argument to be called
with each Eand yielding an object Z(If there is no :key argument, Z

The function designated by the :key argument is never called on O
itself.  However, if the function operates on multiple sequences (e.g.,
as happens in ‘set-difference’), O will be the result of calling the
:key function on an element of the other sequence.

A :test argument, if supplied to F, is a designator for a function of
two arguments, O and ZAn Eto “satisfy the test” if this :test function
returns a generalized boolean representing true.

A :test-not argument, if supplied to F, is designator for a function of
two arguments, O and ZAn Eto “satisfy the test” if this :test-not
function returns a generalized boolean representing false.

If neither a :test nor a :test-not argument is supplied, it is as if a
:test argument of ‘#'eql’ was supplied.

The consequences are unspecified if both a :test and a :test-not
argument are supplied in the same call to F.

17.2.1.1 Examples of Satisfying a Two-Argument Test
...................................................

      (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'equal)
     → (foo bar "BAR" "foo" "bar")
      (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'equalp)
     → (foo bar "BAR" "bar")
      (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'string-equal)
     → (bar "BAR" "bar")
      (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'string=)
     → (BAR "BAR" "foo" "bar")

      (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #'eql)
     → (1)
      (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #'=)
     → (1 1.0 #C(1.0 0.0))
      (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test (complement #'=))
     → (1 1.0 #C(1.0 0.0))

      (count 1 '((one 1) (uno 1) (two 2) (dos 2)) :key #'cadr) → 2

      (count 2.0 '(1 2 3) :test #'eql :key #'float) → 1

      (count "FOO" (list (make-pathname :name "FOO" :type "X")
                         (make-pathname :name "FOO" :type "Y"))
             :key #'pathname-name
             :test #'equal)
     → 2


File: ansicl,  Node: Satisfying a One-Argument Test,  Prev: Satisfying a Two-Argument Test,  Up: Rules about Test Functions

17.2.2 Satisfying a One-Argument Test
-------------------------------------

When using one of the functions in the next figure, the elements E of a
sequence S are filtered not on the basis of the presence or absence of
an object O under a two argument predicate, as with the functions
described in *note Section 17.2.1 (Satisfying a Two-Argument Test):
Satisfying a Two-Argument Test, but rather on the basis of a one
argument predicate.

assoc-if        member-if            rassoc-if
assoc-if-not    member-if-not        rassoc-if-not
count-if        nsubst-if            remove-if
count-if-not    nsubst-if-not        remove-if-not
delete-if       nsubstitute-if       subst-if
delete-if-not   nsubstitute-if-not   subst-if-not
find-if         position-if          substitute-if
find-if-not     position-if-not      substitute-if-not

Figure 17.3: Operators that have One-Argument Tests to be Satisfied

The element EIf a :key argument is provided, it is a designator for a
function of one argument to be called with each Eand yielding an object
Z(If there is no :key argument, Z

Functions defined in this specification and having a name that ends in
“‘-if’” accept a first argument that is a designator for a function of
one argument, ZAn E“satisfy the test” if this :test function returns a
generalized boolean representing true.

Functions defined in this specification and having a name that ends in
“‘-if-not’” accept a first argument that is a designator for a function
of one argument, ZAn E“satisfy the test” if this :test function returns
a generalized boolean representing false.

17.2.2.1 Examples of Satisfying a One-Argument Test
...................................................

      (count-if #'zerop '(1 #C(0.0 0.0) 0 0.0d0 0.0s0 3)) → 4

      (remove-if-not #'symbolp '(0 1 2 3 4 5 6 7 8 9 A B C D E F))
     → (A B C D E F)
      (remove-if (complement #'symbolp) '(0 1 2 3 4 5 6 7 8 9 A B C D E F))
     → (A B C D E F)

      (count-if #'zerop '("foo" "" "bar" "" "" "baz" "quux") :key #'length)
     → 3


File: ansicl,  Node: sequence,  Next: copy-seq,  Prev: Rules about Test Functions,  Up: Sequences

sequence (System Class)
=======================

Class Precedence List:
......................

‘sequence’, ‘t’

Description:
............

Sequences are ordered collections of objects, called the elements of the
sequence.

The types ‘vector’ and the type ‘list’ are disjoint subtypes of type
‘sequence’, but are not necessarily an exhaustive partition of sequence.

When viewing a vector as a sequence, only the active elements of that
vector are considered elements of the sequence; that is, sequence
operations respect the fill pointer when given sequences represented as
vectors.


File: ansicl,  Node: copy-seq,  Next: elt,  Prev: sequence,  Up: Sequences

copy-seq (Function)
===================

Syntax:
.......

 -- Function: copy-seq sequence → copied-sequence

Arguments and Values:
.....................

SEQUENCE—a proper sequence.

COPIED-SEQUENCE—a proper sequence.

Description:
............

Creates a copy of SEQUENCE.  The elements of the new sequence are the
same as the corresponding elements of the given SEQUENCE.

If SEQUENCE is a vector, the result is a fresh simple array of rank one
that has the same actual array element type as SEQUENCE.  If SEQUENCE is
a list, the result is a fresh list.

Examples:
.........

      (setq str "a string") → "a string"
      (equalp str (copy-seq str)) → true
      (eql str (copy-seq str)) → false

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note copy-list::

Notes:
......

From a functional standpoint,
      (copy-seq x) ≡ (subseq x 0)

However, the programmer intent is typically very different in these two
cases.


File: ansicl,  Node: elt,  Next: fill,  Prev: copy-seq,  Up: Sequences

elt (Accessor)
==============

Syntax:
.......

 -- Function: elt sequence index → object
(setf (elt sequence index) new-object)

Arguments and Values:
.....................

SEQUENCE—a proper sequence.

INDEX—a valid sequence index for SEQUENCE.

OBJECT—an object.

NEW-OBJECT—an object.

Description:
............

Accesses the element of SEQUENCE specified by INDEX.

Examples:
.........

      (setq str (copy-seq "0123456789")) → "0123456789"
      (elt str 6) → #\6
      (setf (elt str 0) #\#) → #\#
      str → "#123456789"

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.  Should signal an error of type ‘type-error’
if INDEX is not a valid sequence index for SEQUENCE.

See Also:
.........

*note aref::, *note nth::, *note Section 3.2.1 (Compiler Terminology):
Compiler Terminology.

Notes:
......

‘aref’ may be used to access vector elements that are beyond the
vector’s fill pointer.


File: ansicl,  Node: fill,  Next: make-sequence,  Prev: elt,  Up: Sequences

fill (Function)
===============

Syntax:
.......

 -- Function: fill sequence item &key start end → sequence

Arguments and Values:
.....................

SEQUENCE—a proper sequence.

ITEM—a sequence.

START, END—bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

Description:
............

Replaces the elements of SEQUENCE bounded by START and END with ITEM.

Examples:
.........

      (fill (list 0 1 2 3 4 5) '(444)) → ((444) (444) (444) (444) (444) (444))
      (fill (copy-seq "01234") #\e :start 3) → "012ee"
      (setq x (vector 'a 'b 'c 'd 'e)) → #(A B C D E)
      (fill x 'z :start 1 :end 3) → #(A Z Z D E)
      x → #(A Z Z D E)
      (fill x 'p) → #(P P P P P)
      x → #(P P P P P)

Side Effects:
.............

SEQUENCE is destructively modified.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.  Should signal an error of type ‘type-error’
if START is not a non-negative integer.  Should signal an error of type
‘type-error’ if END is not a non-negative integer or ‘nil’.

See Also:
.........

*note replace::, *note nsubstitute::

Notes:
......

‘(fill SEQUENCE ITEM) ≡ (nsubstitute-if ITEM (constantly t) SEQUENCE)’


File: ansicl,  Node: make-sequence,  Next: subseq,  Prev: fill,  Up: Sequences

make-sequence (Function)
========================

Syntax:
.......

 -- Function: make-sequence result-type size &key initial-element →
          sequence

Arguments and Values:
.....................

RESULT-TYPE—a ‘sequence’ type specifier.

SIZE—a non-negative integer.

INITIAL-ELEMENT—an object.  The default is implementation-dependent.

SEQUENCE—a proper sequence.

Description:
............

Returns a sequence of the type RESULT-TYPE and of length SIZE, each of
the elements of which has been initialized to INITIAL-ELEMENT.

If the RESULT-TYPE is a subtype of ‘list’, the result will be a list.

If the RESULT-TYPE is a subtype of ‘vector’, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ‘*’), the element type of the resulting array is
‘t’; otherwise, an error is signaled.

Examples:
.........

      (make-sequence 'list 0) → ()
      (make-sequence 'string 26 :initial-element #\.)
     → ".........................."
      (make-sequence '(vector double-float) 2
                     :initial-element 1d0)
     → #(1.0d0 1.0d0)

      (make-sequence '(vector * 2) 3) should signal an error
      (make-sequence '(vector * 4) 3) should signal an error

Affected By:
............

The implementation.

Exceptional Situations:
.......................

The consequences are unspecified if INITIAL-ELEMENT is not an object
which can be stored in the resulting sequence.

An error of type ‘type-error’ must be signaled if the RESULT-TYPE is
neither a recognizable subtype of ‘list’, nor a recognizable subtype of
‘vector’.

An error of type ‘type-error’ should be signaled if RESULT-TYPE
specifies the number of elements and SIZE is different from that number.

See Also:
.........

*note make-array::, *note make-list::

Notes:
......

      (make-sequence 'string 5) ≡ (make-string 5)


File: ansicl,  Node: subseq,  Next: map,  Prev: make-sequence,  Up: Sequences

subseq (Accessor)
=================

Syntax:
.......

 -- Function: subseq sequence start &optional end → subsequence
(setf (subseq sequence start &optional end) new-subsequence)

Arguments and Values:
.....................

SEQUENCE—a proper sequence.

START, END—bounding index designators of SEQUENCE.  The default for END
is ‘nil’.

SUBSEQUENCE—a proper sequence.

NEW-SUBSEQUENCE—a proper sequence.

Description:
............

‘subseq’ creates a sequence that is a copy of the subsequence of
SEQUENCE BOUNDED by START and END.

START specifies an offset into the original SEQUENCE and marks the
beginning position of the subsequence.  END marks the position following
the last element of the subsequence.

‘subseq’ always allocates a new sequence for a result; it never shares
storage with an old sequence.  The result subsequence is always of the
same type as SEQUENCE.

If SEQUENCE is a vector, the result is a fresh simple array of rank one
that has the same actual array element type as SEQUENCE.  If SEQUENCE is
a list, the result is a fresh list.

‘setf’ may be used with ‘subseq’ to destructively replace elements of a
subsequence with elements taken from a sequence of new values.  If the
subsequence and the new sequence are not of equal length, the shorter
length determines the number of elements that are replaced.  The
remaining elements at the end of the longer sequence are not modified in
the operation.

Examples:
.........

      (setq str "012345") → "012345"
      (subseq str 2) → "2345"
      (subseq str 3 5) → "34"
      (setf (subseq str 4) "abc") → "abc"
      str → "0123ab"
      (setf (subseq str 0 2) "A") → "A"
      str → "A123ab"

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.  Should be prepared to signal an error of type
‘type-error’ if NEW-SUBSEQUENCE is not a proper sequence.

See Also:
.........

*note replace::


File: ansicl,  Node: map,  Next: map-into,  Prev: subseq,  Up: Sequences

map (Function)
==============

Syntax:
.......

 -- Function: map result-type function &rest sequences+ → result

Arguments and Values:
.....................

RESULT-TYPE—a ‘sequence’ type specifier, or ‘nil’.

FUNCTION—a function designator.  FUNCTION must take as many arguments as
there are SEQUENCES.

SEQUENCE—a proper sequence.

RESULT—if RESULT-TYPE is a type specifier other than ‘nil’, then a
sequence of the type it denotes; otherwise (if the RESULT-TYPE is
‘nil’), ‘nil’.

Description:
............

Applies FUNCTION to successive sets of arguments in which one argument
is obtained from each sequence.  The FUNCTION is called first on all the
elements with index ‘0’, then on all those with index ‘1’, and so on.
The RESULT-TYPE specifies the type of the resulting sequence.

‘map’ returns ‘nil’ if RESULT-TYPE is ‘nil’.  Otherwise, ‘map’ returns a
sequence such that element ‘j’ is the result of applying FUNCTION to
element ‘j’ of each of the SEQUENCES.  The result sequence is as long as
the shortest of the SEQUENCES.  The consequences are undefined if the
result of applying FUNCTION to the successive elements of the SEQUENCES
cannot be contained in a sequence of the type given by RESULT-TYPE.

If the RESULT-TYPE is a subtype of ‘list’, the result will be a list.

If the RESULT-TYPE is a subtype of ‘vector’, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ‘*’), the element type of the resulting array is
‘t’; otherwise, an error is signaled.

Examples:
.........

      (map 'string #'(lambda (x y)
                       (char "01234567890ABCDEF" (mod (+ x y) 16)))
            '(1 2 3 4)
            '(10 9 8 7)) → "AAAA"
      (setq seq '("lower" "UPPER" "" "123")) → ("lower" "UPPER" "" "123")
      (map nil #'nstring-upcase seq) → NIL
      seq → ("LOWER" "UPPER" "" "123")
      (map 'list #'- '(1 2 3 4)) → (-1 -2 -3 -4)
      (map 'string
           #'(lambda (x) (if (oddp x) #\1 #\0))
           '(1 2 3 4)) → "1010"

      (map '(vector * 4) #'cons "abc" "de") should signal an error

Exceptional Situations:
.......................

An error of type ‘type-error’ must be signaled if the RESULT-TYPE is not
a recognizable subtype of ‘list’, not a recognizable subtype of
‘vector’, and not ‘nil’.

Should be prepared to signal an error of type ‘type-error’ if any
SEQUENCE is not a proper sequence.

An error of type ‘type-error’ should be signaled if RESULT-TYPE
specifies the number of elements and the minimum length of the SEQUENCES
is different from that number.

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: ansicl,  Node: map-into,  Next: reduce,  Prev: map,  Up: Sequences

map-into (Function)
===================

Syntax:
.......

 -- Function: map-into result-sequence function &rest sequences →
          result-sequence

Arguments and Values:
.....................

RESULT-SEQUENCE—a proper sequence.

FUNCTION—a designator for a function of as many arguments as there are
SEQUENCES.

SEQUENCE—a proper sequence.

Description:
............

Destructively modifies RESULT-SEQUENCE to contain the results of
applying FUNCTION to each element in the argument SEQUENCES in turn.

RESULT-SEQUENCE and each element of SEQUENCES can each be either a list
or a vector.  If RESULT-SEQUENCE and each element of SEQUENCES are not
all the same length, the iteration terminates when the shortest sequence
(of any of the SEQUENCES or the RESULT-SEQUENCE) is exhausted.  If
RESULT-SEQUENCE is a vector with a fill pointer, the fill pointer is
ignored when deciding how many iterations to perform, and afterwards the
fill pointer is set to the number of times FUNCTION was applied.  If
RESULT-SEQUENCE is longer than the shortest element of SEQUENCES, extra
elements at the end of RESULT-SEQUENCE are left unchanged.  If
RESULT-SEQUENCE is ‘nil’, ‘map-into’ immediately returns ‘nil’, since
‘nil’ is a sequence of length zero.

If FUNCTION has side effects, it can count on being called first on all
of the elements with index 0, then on all of those numbered 1, and so
on.

Examples:
.........

      (setq a (list 1 2 3 4) b (list 10 10 10 10)) → (10 10 10 10)
      (map-into a #'+ a b) → (11 12 13 14)
      a → (11 12 13 14)
      b → (10 10 10 10)
      (setq k '(one two three)) → (ONE TWO THREE)
      (map-into a #'cons k a) → ((ONE . 11) (TWO . 12) (THREE . 13) 14)
      (map-into a #'gensym) → (#:G9090 #:G9091 #:G9092 #:G9093)
      a → (#:G9090 #:G9091 #:G9092 #:G9093)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if
RESULT-SEQUENCE is not a proper sequence.  Should be prepared to signal
an error of type ‘type-error’ if SEQUENCE is not a proper sequence.

Notes:
......

‘map-into’ differs from ‘map’ in that it modifies an existing sequence
rather than creating a new one.  In addition, ‘map-into’ can be called
with only two arguments, while ‘map’ requires at least three arguments.

‘map-into’ could be defined by:

      (defun map-into (result-sequence function &rest sequences)
        (loop for index below (apply #'min
                                     (length result-sequence)
                                     (mapcar #'length sequences))
              do (setf (elt result-sequence index)
                       (apply function
                              (mapcar #'(lambda (seq) (elt seq index))
                                      sequences))))
        result-sequence)


File: ansicl,  Node: reduce,  Next: count; count-if; count-if-not,  Prev: map-into,  Up: Sequences

reduce (Function)
=================

Syntax:
.......

 -- Function: reduce function sequence &key key from-end start end
          initial-value → result

Arguments and Values:
.....................

FUNCTION—a designator for a function that might be called with either
zero or two arguments.

SEQUENCE—a proper sequence.

KEY—a designator for a function of one argument, or ‘nil’.

FROM-END—a generalized boolean.  The default is false.

START, END—bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

INITIAL-VALUE—an object.

RESULT—an object.

Description:
............

‘reduce’ uses a binary operation, FUNCTION, to combine the elements of
SEQUENCE bounded by START and END.

The FUNCTION must accept as arguments two elements of SEQUENCE or the
results from combining those elements.  The FUNCTION must also be able
to accept no arguments.

If KEY is supplied, it is used is used to extract the values to reduce.
The KEY function is applied exactly once to each element of SEQUENCE in
the order implied by the reduction order but not to the value of
INITIAL-VALUE, if supplied.  The KEY function typically returns part of
the element of SEQUENCE.  If KEY is not supplied or is ‘nil’, the
SEQUENCE element itself is used.

The reduction is left-associative, unless FROM-END is true in which case
it is right-associative.

If INITIAL-VALUE is supplied, it is logically placed before the
subsequence (or after it if FROM-END is true) and included in the
reduction operation.

In the normal case, the result of ‘reduce’ is the combined result of
FUNCTION’s being applied to successive pairs of elements of SEQUENCE.
If the subsequence contains exactly one element and no INITIAL-VALUE is
given, then that element is returned and FUNCTION is not called.  If the
subsequence is empty and an INITIAL-VALUE is given, then the
INITIAL-VALUE is returned and FUNCTION is not called.  If the
subsequence is empty and no INITIAL-VALUE is given, then the FUNCTION is
called with zero arguments, and ‘reduce’ returns whatever FUNCTION does.
This is the only case where the FUNCTION is called with other than two
arguments.

Examples:
.........

      (reduce #'* '(1 2 3 4 5)) → 120
      (reduce #'append '((1) (2)) :initial-value '(i n i t)) → (I N I T 1 2)
      (reduce #'append '((1) (2)) :from-end t
                                  :initial-value '(i n i t)) → (1 2 I N I T)
      (reduce #'- '(1 2 3 4)) ≡ (- (- (- 1 2) 3) 4) → -8
      (reduce #'- '(1 2 3 4) :from-end t)    ;Alternating sum.
     ≡ (- 1 (- 2 (- 3 4))) → -2
      (reduce #'+ '()) → 0
      (reduce #'+ '(3)) → 3
      (reduce #'+ '(foo)) → FOO
      (reduce #'list '(1 2 3 4)) → (((1 2) 3) 4)
      (reduce #'list '(1 2 3 4) :from-end t) → (1 (2 (3 4)))
      (reduce #'list '(1 2 3 4) :initial-value 'foo) → ((((foo 1) 2) 3) 4)
      (reduce #'list '(1 2 3 4)
             :from-end t :initial-value 'foo) → (1 (2 (3 (4 foo))))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: ansicl,  Node: count; count-if; count-if-not,  Next: length,  Prev: reduce,  Up: Sequences

count, count-if, count-if-not (Function)
========================================

Syntax:
.......

 -- Function: count item sequence &key from-end start end key test
          test-not → n
 -- Function: count-if predicate sequence &key from-end start end key →
          n
 -- Function: count-if-not predicate sequence &key from-end start end
          key → n

Arguments and Values:
.....................

ITEM—an object.

SEQUENCE—a proper sequence.

PREDICATE—a designator for a function of one argument that returns a
generalized boolean.

FROM-END—a generalized boolean.  The default is false.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

START, END—bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

KEY—a designator for a function of one argument, or ‘nil’.

N—a non-negative integer less than or equal to the length of SEQUENCE.

Description:
............

‘count’, ‘count-if’, and ‘count-if-not’ count and return the number of
elements in the SEQUENCE bounded by START and END that satisfy the test.

The FROM-END has no direct effect on the result.  However, if FROM-END
is true, the elements of SEQUENCE will be supplied as arguments to the
TEST, TEST-NOT, and KEY in reverse order, which may change the
side-effects, if any, of those functions.

Examples:
.........

      (count #\a "how many A's are there in here?") → 2
      (count-if-not #'oddp '((1) (2) (3) (4)) :key #'car) → 2
      (count-if #'upper-case-p "The Crying of Lot 49" :start 4) → 2

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note Section 17.2 (Rules about Test Functions): Rules about Test
Functions, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not argument is deprecated.

The function ‘count-if-not’ is deprecated.


File: ansicl,  Node: length,  Next: reverse; nreverse,  Prev: count; count-if; count-if-not,  Up: Sequences

length (Function)
=================

Syntax:
.......

 -- Function: length sequence → n

Arguments and Values:
.....................

SEQUENCE—a proper sequence.

N—a non-negative integer.

Description:
............

Returns the number of elements in SEQUENCE.

If SEQUENCE is a vector with a fill pointer, the active length as
specified by the fill pointer is returned.

Examples:
.........

      (length "abc") → 3
      (setq str (make-array '(3) :element-type 'character
                                 :initial-contents "abc"
                                 :fill-pointer t)) → "abc"
      (length str) → 3
      (setf (fill-pointer str) 2) → 2
      (length str) → 2

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note list-length::, *note sequence::


File: ansicl,  Node: reverse; nreverse,  Next: sort; stable-sort,  Prev: length,  Up: Sequences

reverse, nreverse (Function)
============================

Syntax:
.......

 -- Function: reverse sequence → reversed-sequence

 -- Function: nreverse sequence → reversed-sequence

Arguments and Values:
.....................

SEQUENCE—a proper sequence.

REVERSED-SEQUENCE—a sequence.

Description:
............

‘reverse’ and ‘nreverse’ return a new sequence of the same kind as
SEQUENCE, containing the same elements, but in reverse order.

‘reverse’ and ‘nreverse’ differ in that ‘reverse’ always creates and
returns a new sequence, whereas ‘nreverse’ might modify and return the
given SEQUENCE.  ‘reverse’ never modifies the given SEQUENCE.

For ‘reverse’, if SEQUENCE is a vector, the result is a fresh simple
array of rank one that has the same actual array element type as
SEQUENCE.  If SEQUENCE is a list, the result is a fresh list.

For ‘nreverse’, if SEQUENCE is a vector, the result is a vector that has
the same actual array element type as SEQUENCE.  If SEQUENCE is a list,
the result is a list.

For ‘nreverse’, SEQUENCE might be destroyed and re-used to produce the
result.  The result might or might not be identical to SEQUENCE.
Specifically, when SEQUENCE is a list, ‘nreverse’ is permitted to ‘setf’
any part, ‘car’ or ‘cdr’, of any cons that is part of the list structure
of SEQUENCE.  When SEQUENCE is a vector, ‘nreverse’ is permitted to
re-order the elements of SEQUENCE in order to produce the resulting
vector.

Examples:
.........

      (setq str "abc") → "abc"
      (reverse str) → "cba"
      str → "abc"
      (setq str (copy-seq str)) → "abc"
      (nreverse str) → "cba"
      str → implementation-dependent
      (setq l (list 1 2 3)) → (1 2 3)
      (nreverse l) → (3 2 1)
      l → implementation-dependent

Side Effects:
.............

‘nreverse’ might either create a new sequence, modify the argument
SEQUENCE, or both.  (‘reverse’ does not modify SEQUENCE.)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.


File: ansicl,  Node: sort; stable-sort,  Next: find; find-if; find-if-not,  Prev: reverse; nreverse,  Up: Sequences

sort, stable-sort (Function)
============================

Syntax:
.......

 -- Function: sort sequence predicate &key key → sorted-sequence
 -- Function: stable-sort sequence predicate &key key → sorted-sequence

Arguments and Values:
.....................

SEQUENCE—a proper sequence.

PREDICATE—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

SORTED-SEQUENCE—a sequence.

Description:
............

‘sort’ and ‘stable-sort’ destructively sort SEQUENCES according to the
order determined by the PREDICATE function.

If SEQUENCE is a vector, the result is a vector that has the same actual
array element type as SEQUENCE.  If SEQUENCE is a list, the result is a
list.

‘sort’ determines the relationship between two elements by giving keys
extracted from the elements to the PREDICATE.  The first argument to the
PREDICATE function is the part of one element of SEQUENCE extracted by
the KEY function (if supplied); the second argument is the part of
another element of SEQUENCE extracted by the KEY function (if supplied).
PREDICATE should return true if and only if the first argument is
strictly less than the second (in some appropriate sense).  If the first
argument is greater than or equal to the second (in the appropriate
sense), then the PREDICATE should return false.

The argument to the KEY function is the SEQUENCE element.  The return
value of the KEY function becomes an argument to PREDICATE.  If KEY is
not supplied or ‘nil’, the SEQUENCE element itself is used.  There is no
guarantee on the number of times the KEY will be called.

If the KEY and PREDICATE always return, then the sorting operation will
always terminate, producing a sequence containing the same elements as
SEQUENCE (that is, the result is a permutation of SEQUENCE).  This is
guaranteed even if the PREDICATE does not really consistently represent
a total order (in which case the elements will be scrambled in some
unpredictable way, but no element will be lost).  If the KEY
consistently returns meaningful keys, and the PREDICATE does reflect
some total ordering criterion on those keys, then the elements of the
SORTED-SEQUENCE will be properly sorted according to that ordering.

The sorting operation performed by ‘sort’ is not guaranteed stable.
Elements considered equal by the PREDICATE might or might not stay in
their original order.  The PREDICATE is assumed to consider two elements
‘x’ and ‘y’ to be equal if ‘(funcall predicate x y)’ and ‘(funcall
predicate y x)’ are both false.  ‘stable-sort’ guarantees stability.

The sorting operation can be destructive in all cases.  In the case of a
vector argument, this is accomplished by permuting the elements in
place.  In the case of a list, the list is destructively reordered in
the same manner as for ‘nreverse’.

Examples:
.........

      (setq tester (copy-seq "lkjashd")) → "lkjashd"
      (sort tester #'char-lessp) → "adhjkls"
      (setq tester (list '(1 2 3) '(4 5 6) '(7 8 9))) → ((1 2 3) (4 5 6) (7 8 9))
      (sort tester #'> :key #'car)  → ((7 8 9) (4 5 6) (1 2 3))
      (setq tester (list 1 2 3 4 5 6 7 8 9 0)) → (1 2 3 4 5 6 7 8 9 0)
      (stable-sort tester #'(lambda (x y) (and (oddp x) (evenp y))))
     → (1 3 5 7 9 2 4 6 8 0)
      (sort (setq committee-data
                  (vector (list (list "JonL" "White") "Iteration")
                          (list (list "Dick" "Waters") "Iteration")
                          (list (list "Dick" "Gabriel") "Objects")
                          (list (list "Kent" "Pitman") "Conditions")
                          (list (list "Gregor" "Kiczales") "Objects")
                          (list (list "David" "Moon") "Objects")
                          (list (list "Kathy" "Chapman") "Editorial")
                          (list (list "Larry" "Masinter") "Cleanup")
                          (list (list "Sandra" "Loosemore") "Compiler")))
            #'string-lessp :key #'cadar)
     → #((("Kathy" "Chapman") "Editorial")
          (("Dick" "Gabriel") "Objects")
          (("Gregor" "Kiczales") "Objects")
          (("Sandra" "Loosemore") "Compiler")
          (("Larry" "Masinter") "Cleanup")
          (("David" "Moon") "Objects")
          (("Kent" "Pitman") "Conditions")
          (("Dick" "Waters") "Iteration")
          (("JonL" "White") "Iteration"))
      ;; Note that individual alphabetical order within `committees'
      ;; is preserved.
      (setq committee-data
            (stable-sort committee-data #'string-lessp :key #'cadr))
     → #((("Larry" "Masinter") "Cleanup")
          (("Sandra" "Loosemore") "Compiler")
          (("Kent" "Pitman") "Conditions")
          (("Kathy" "Chapman") "Editorial")
          (("Dick" "Waters") "Iteration")
          (("JonL" "White") "Iteration")
          (("Dick" "Gabriel") "Objects")
          (("Gregor" "Kiczales") "Objects")
          (("David" "Moon") "Objects"))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note merge::, *note Section 3.2.1 (Compiler Terminology): Compiler
Terminology, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects, *note Section 3.7 (Destructive
Operations): Destructive Operations.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.


File: ansicl,  Node: find; find-if; find-if-not,  Next: position; position-if; position-if-not,  Prev: sort; stable-sort,  Up: Sequences

find, find-if, find-if-not (Function)
=====================================

Syntax:
.......

 -- Function: find item sequence &key from-end test test-not start end
          key → element
 -- Function: find-if predicate sequence &key from-end start end key →
          element
 -- Function: find-if-not predicate sequence &key from-end start end key
          → element

Arguments and Values:
.....................

ITEM—an object.

SEQUENCE—a proper sequence.

PREDICATE—a designator for a function of one argument that returns a
generalized boolean.

FROM-END—a generalized boolean.  The default is false.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

START, END—bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

KEY—a designator for a function of one argument, or ‘nil’.

ELEMENT—an element of the SEQUENCE, or ‘nil’.

Description:
............

‘find’, ‘find-if’, and ‘find-if-not’ each search for an element of the
SEQUENCE bounded by START and end that satisfies the predicate PREDICATE
or that satisfies the test TEST or TEST-NOT, as appropriate.

If FROM-END is true, then the result is the rightmost element that
satisfies the test.

If the SEQUENCE contains an element that satisfies the test, then the
leftmost or rightmost SEQUENCE element, depending on FROM-END, is
returned; otherwise ‘nil’ is returned.

Examples:
.........

      (find #\d "here are some letters that can be looked at" :test #'char>)
     → #\Space
      (find-if #'oddp '(1 2 3 4 5) :end 3 :from-end t) → 3
      (find-if-not #'complexp
                  '#(3.5 2 #C(1.0 0.0) #C(0.0 1.0))
                  :start 2) → NIL

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note position::, *note Section 17.2 (Rules about Test Functions): Rules
about Test Functions, *note Section 3.6 (Traversal Rules and Side
Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not argument is deprecated.

The function ‘find-if-not’ is deprecated.


File: ansicl,  Node: position; position-if; position-if-not,  Next: search,  Prev: find; find-if; find-if-not,  Up: Sequences

position, position-if, position-if-not (Function)
=================================================

Syntax:
.......

 -- Function: position item sequence &key from-end test test-not start
          end key → position

 -- Function: position-if predicate sequence &key from-end start end key
          → position
 -- Function: position-if-not predicate sequence &key from-end start end
          key → position

Arguments and Values:
.....................

ITEM—an object.

SEQUENCE—a proper sequence.

PREDICATE—a designator for a function of one argument that returns a
generalized boolean.

FROM-END—a generalized boolean.  The default is false.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

START, END—bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

KEY—a designator for a function of one argument, or ‘nil’.

POSITION—a bounding index of SEQUENCE, or ‘nil’.

Description:
............

‘position’, ‘position-if’, and ‘position-if-not’ each search SEQUENCE
for an element that satisfies the test.

The POSITION returned is the index within SEQUENCE of the leftmost (if
FROM-END is true) or of the rightmost (if FROM-END is false) element
that satisfies the test; otherwise ‘nil’ is returned.  The index
returned is relative to the left-hand end of the entire SEQUENCE,
regardless of the value of start, end, or from-end.

Examples:
.........

      (position #\a "baobab" :from-end t) → 4
      (position-if #'oddp '((1) (2) (3) (4)) :start 1 :key #'car) → 2
      (position 595 '()) → NIL
      (position-if-not #'integerp '(1 2 3 4 5.0)) → 4

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note find::, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not argument is deprecated.

The function ‘position-if-not’ is deprecated.


File: ansicl,  Node: search,  Next: mismatch,  Prev: position; position-if; position-if-not,  Up: Sequences

search (Function)
=================

Syntax:
.......

 -- Function: search sequence-1 sequence-2 &key from-end test test-not
          key start1 start2 end1 end2 → position

Arguments and Values:
.....................

SEQUENCE-1—a sequence.

SEQUENCE-2—a sequence.

FROM-END—a generalized boolean.  The default is false.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

START1, END1—bounding index designators of SEQUENCE-1.  The defaults for
START1 and END1 are ‘0’ and ‘nil’, respectively.

START2, END2—bounding index designators of SEQUENCE-2.  The defaults for
START2 and END2 are ‘0’ and ‘nil’, respectively.

POSITION—a bounding index of SEQUENCE-2, or ‘nil’.

Description:
............

Searches SEQUENCE-2 for a subsequence that matches SEQUENCE-1.

The implementation may choose to search SEQUENCE-2 in any order; there
is no guarantee on the number of times the test is made.  For example,
when START-END is true, the SEQUENCE might actually be searched from
left to right instead of from right to left (but in either case would
return the rightmost matching subsequence).  If the search succeeds,
‘search’ returns the offset into SEQUENCE-2 of the first element of the
leftmost or rightmost matching subsequence, depending on FROM-END;
otherwise ‘search’ returns ‘nil’.

If FROM-END is true, the index of the leftmost element of the rightmost
matching subsequence is returned.

Examples:
.........

      (search "dog" "it's a dog's life") → 7
      (search '(0 1) '(2 4 6 1 3 5) :key #'oddp) → 2

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.

Notes:
......

The :test-not argument is deprecated.


File: ansicl,  Node: mismatch,  Next: replace,  Prev: search,  Up: Sequences

mismatch (Function)
===================

Syntax:
.......

 -- Function: mismatch sequence-1 sequence-2 &key from-end test test-not
          key start1 start2 end1 end2 → position

Arguments and Values:
.....................

SEQUENCE-1—a sequence.

SEQUENCE-2—a sequence.

FROM-END—a generalized boolean.  The default is false.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

START1, END1—bounding index designators of SEQUENCE-1.  The defaults for
START1 and END1 are ‘0’ and ‘nil’, respectively.

START2, END2—bounding index designators of SEQUENCE-2.  The defaults for
START2 and END2 are ‘0’ and ‘nil’, respectively.

KEY—a designator for a function of one argument, or ‘nil’.

POSITION—a bounding index of SEQUENCE-1, or ‘nil’.

Description:
............

The specified subsequences of SEQUENCE-1 and SEQUENCE-2 are compared
element-wise.

The KEY argument is used for both the SEQUENCE-1 and the SEQUENCE-2.

If SEQUENCE-1 and SEQUENCE-2 are of equal length and match in every
element, the result is false.  Otherwise, the result is a non-negative
integer, the index within SEQUENCE-1 of the leftmost or rightmost
position, depending on FROM-END, at which the two subsequences fail to
match.  If one subsequence is shorter than and a matching prefix of the
other, the result is the index relative to SEQUENCE-1 beyond the last
position tested.

If FROM-END is true, then one plus the index of the rightmost position
in which the SEQUENCES differ is returned.  In effect, the subsequences
are aligned at their right-hand ends; then, the last elements are
compared, the penultimate elements, and so on.  The index returned is an
index relative to SEQUENCE-1.

Examples:
.........

      (mismatch "abcd" "ABCDE" :test #'char-equal) → 4
      (mismatch '(3 2 1 1 2 3) '(1 2 3) :from-end t) → 3
      (mismatch '(1 2 3) '(2 3 4) :test-not #'eq :key #'oddp) → NIL
      (mismatch '(1 2 3 4 5 6) '(3 4 5 6 7) :start1 2 :end2 4) → NIL

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.

Notes:
......

The :test-not argument is deprecated.


File: ansicl,  Node: replace,  Next: substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+,  Prev: mismatch,  Up: Sequences

replace (Function)
==================

Syntax:
.......

 -- Function: replace sequence-1 sequence-2 &key start1 end1 start2 end2
          → sequence-1

Arguments and Values:
.....................

SEQUENCE-1—a sequence.

SEQUENCE-2—a sequence.

START1, END1—bounding index designators of SEQUENCE-1.  The defaults for
START1 and END1 are ‘0’ and ‘nil’, respectively.

START2, END2—bounding index designators of SEQUENCE-2.  The defaults for
START2 and END2 are ‘0’ and ‘nil’, respectively.

Description:
............

Destructively modifies SEQUENCE-1 by replacing the elements of
SUBSEQUENCE-1 bounded by START1 and END1 with the elements of
SUBSEQUENCE-2 bounded by START2 and END2.

SEQUENCE-1 is destructively modified by copying successive elements into
it from SEQUENCE-2.  Elements of the subsequence of SEQUENCE-2 bounded
by START2 and END2 are copied into the subsequence of SEQUENCE-1 bounded
by START1 and END1.  If these subsequences are not of the same length,
then the shorter length determines how many elements are copied; the
extra elements near the end of the longer subsequence are not involved
in the operation.  The number of elements copied can be expressed as:

      (min (- end1 start1) (- end2 start2))

If SEQUENCE-1 and SEQUENCE-2 are the same object and the region being
modified overlaps the region being copied from, then it is as if the
entire source region were copied to another place and only then copied
back into the target region.  However, if SEQUENCE-1 and SEQUENCE-2 are
not the same, but the region being modified overlaps the region being
copied from (perhaps because of shared list structure or displaced
arrays), then after the ‘replace’ operation the subsequence of
SEQUENCE-1 being modified will have unpredictable contents.  It is an
error if the elements of SEQUENCE-2 are not of a type that can be stored
into SEQUENCE-1.

Examples:
.........

      (replace "abcdefghij" "0123456789" :start1 4 :end1 7 :start2 4)
     → "abcd456hij"
      (setq lst "012345678") → "012345678"
      (replace lst lst :start1 2 :start2 0) → "010123456"
      lst → "010123456"

Side Effects:
.............

The SEQUENCE-1 is modified.

See Also:
.........

*note fill::


File: ansicl,  Node: substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+,  Next: concatenate,  Prev: replace,  Up: Sequences

substitute, substitute-if, substitute-if-not, nsubstitute, nsubstitute-if, nsubstitute-if-not (Function)
========================================================================================================

Syntax:
.......

 -- Function: substitute newitem olditem sequence &key from-end test
          test-not start end count key → result-sequence

 -- Function: substitute-if newitem predicate sequence &key from-end
          start end count key → result-sequence

 -- Function: substitute-if-not newitem predicate sequence &key from-end
          start end count key → result-sequence

 -- Function: nsubstitute newitem olditem sequence &key from-end test
          test-not start end count key → sequence

 -- Function: nsubstitute-if newitem predicate sequence &key from-end
          start end count key → sequence

 -- Function: nsubstitute-if-not newitem predicate sequence &key
          from-end start end count key → sequence

Arguments and Values:
.....................

NEWITEM—an object.

OLDITEM—an object.

SEQUENCE—a proper sequence.

PREDICATE—a designator for a function of one argument that returns a
generalized boolean.

FROM-END—a generalized boolean.  The default is false.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

START, END—bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

COUNT—an integer or ‘nil’.  The default is ‘nil’.

KEY—a designator for a function of one argument, or ‘nil’.

RESULT-SEQUENCE—a sequence.

Description:
............

‘substitute’, ‘substitute-if’, and ‘substitute-if-not’ return a copy of
SEQUENCE in which each element that satisfies the test has been replaced
with NEWITEM.

‘nsubstitute’, ‘nsubstitute-if’, and ‘nsubstitute-if-not’ are like
‘substitute’, ‘substitute-if’, and ‘substitute-if-not’ respectively, but
they may modify SEQUENCE.

If SEQUENCE is a vector, the result is a vector that has the same actual
array element type as SEQUENCE.  If SEQUENCE is a list, the result is a
list.

COUNT, if supplied, limits the number of elements altered; if more than
COUNT elements satisfy the test, then of these elements only the
leftmost or rightmost, depending on FROM-END, are replaced, as many as
specified by COUNT.  If COUNT is supplied and negative, the behavior is
as if zero had been supplied instead.  If COUNT is ‘nil’, all matching
items are affected.

Supplying a FROM-END of true matters only when the COUNT is provided
(and non-nil); in that case, only the rightmost COUNT elements
satisfying the test are removed (instead of the leftmost).

PREDICATE, TEST, and TEST-NOT might be called more than once for each
sequence element, and their side effects can happen in any order.

The result of all these functions is a sequence of the same type as
SEQUENCE that has the same elements except that those in the subsequence
bounded by START and END and satisfying the test have been replaced by
NEWITEM.

‘substitute’, ‘substitute-if’, and ‘substitute-if-not’ return a SEQUENCE
which can share with SEQUENCE or may be identical to the input SEQUENCE
if no elements need to be changed.

‘nsubstitute’ and ‘nsubstitute-if’ are required to ‘setf’ any ‘car’ (if
SEQUENCE is a list) or ‘aref’ (if SEQUENCE is a vector) of SEQUENCE that
is required to be replaced with NEWITEM.  If SEQUENCE is a list, none of
the cdrs of the top-level list can be modified.

Examples:
.........

      (substitute #\. #\SPACE "0 2 4 6") → "0.2.4.6"
      (substitute 9 4 '(1 2 4 1 3 4 5)) → (1 2 9 1 3 9 5)
      (substitute 9 4 '(1 2 4 1 3 4 5) :count 1) → (1 2 9 1 3 4 5)
      (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)
     → (1 2 4 1 3 9 5)
      (substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) → (9 9 4 9 3 4 5)

      (substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)
     → ((1) (2) (3) 0)
      (substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) → (9 2 4 9 9 4 9)
      (substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)
     → (1 2 4 1 3 9 5)

      (setq some-things (list 'a 'car 'b 'cdr 'c)) → (A CAR B CDR C)
      (nsubstitute-if "function was here" #'fboundp some-things
                      :count 1 :from-end t) → (A CAR B "function was here" C)
      some-things → (A CAR B "function was here" C)
      (setq alpha-tester (copy-seq "ab ")) → "ab "
      (nsubstitute-if-not #\z #'alpha-char-p alpha-tester) → "abz"
      alpha-tester → "abz"

Side Effects:
.............

‘nsubstitute’, ‘nsubstitute-if’, and ‘nsubstitute-if-not’ modify
SEQUENCE.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note subst::, *note nsubst::, *note Section 3.2.1 (Compiler
Terminology): Compiler Terminology, *note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.

The :test-not argument is deprecated.

The functions ‘substitute-if-not’ and ‘nsubstitute-if-not’ are
deprecated.

‘nsubstitute’ and ‘nsubstitute-if’ can be used in for-effect-only
positions in code.

Because the side-effecting variants (e.g., ‘nsubstitute’) potentially
change the path that is being traversed, their effects in the presence
of shared or circular structure may vary in surprising ways when
compared to their non-side-effecting alternatives.  To see this,
consider the following side-effect behavior, which might be exhibited by
some implementations:

      (defun test-it (fn)
        (let ((x (cons 'b nil)))
          (rplacd x x)
          (funcall fn 'a 'b x :count 1)))
      (test-it #'substitute) → (A . #1=(B . #1#))
      (test-it #'nsubstitute) → (A . #1#)


File: ansicl,  Node: concatenate,  Next: merge,  Prev: substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+,  Up: Sequences

concatenate (Function)
======================

Syntax:
.......

 -- Function: concatenate result-type &rest sequences → result-sequence

Arguments and Values:
.....................

RESULT-TYPE—a ‘sequence’ type specifier.

SEQUENCES—a sequence.

RESULT-SEQUENCE—a proper sequence of type RESULT-TYPE.

Description:
............

‘concatenate’ returns a sequence that contains all the individual
elements of all the SEQUENCES in the order that they are supplied.  The
sequence is of type RESULT-TYPE, which must be a subtype of type
‘sequence’.

All of the SEQUENCES are copied from; the result does not share any
structure with any of the SEQUENCES.  Therefore, if only one SEQUENCE is
provided and it is of type RESULT-TYPE, ‘concatenate’ is required to
copy SEQUENCE rather than simply returning it.

It is an error if any element of the SEQUENCES cannot be an element of
the sequence result.

If the RESULT-TYPE is a subtype of ‘list’, the result will be a list.

If the RESULT-TYPE is a subtype of ‘vector’, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ‘*’), the element type of the resulting array is
‘t’; otherwise, an error is signaled.

Examples:
.........

     (concatenate 'string "all" " " "together" " " "now") → "all together now"
     (concatenate 'list "ABC" '(d e f) #(1 2 3) #*1011)
     → (#\A #\B #\C D E F 1 2 3 1 0 1 1)
     (concatenate 'list) → NIL

       (concatenate '(vector * 2) "a" "bc") should signal an error

Exceptional Situations:
.......................

An error is signaled if the RESULT-TYPE is neither a recognizable
subtype of ‘list’, nor a recognizable subtype of ‘vector’.

An error of type ‘type-error’ should be signaled if RESULT-TYPE
specifies the number of elements and the sum of SEQUENCES is different
from that number.

See Also:
.........

*note append::


File: ansicl,  Node: merge,  Next: remove; remove-if; remove-if-not; delete; delete-if; delete-if-not,  Prev: concatenate,  Up: Sequences

merge (Function)
================

Syntax:
.......

 -- Function: merge result-type sequence-1 sequence-2 predicate &key key
          → result-sequence

Arguments and Values:
.....................

RESULT-TYPE—a ‘sequence’ type specifier.

SEQUENCE-1—a sequence.

SEQUENCE-2—a sequence.

PREDICATE—a designator for a function of two arguments that returns a
generalized boolean.

KEY—a designator for a function of one argument, or ‘nil’.

RESULT-SEQUENCE—a proper sequence of type RESULT-TYPE.

Description:
............

Destructively merges SEQUENCE-1 with SEQUENCE-2 according to an order
determined by the PREDICATE.  ‘merge’ determines the relationship
between two elements by giving keys extracted from the sequence elements
to the PREDICATE.

The first argument to the PREDICATE function is an element of SEQUENCE-1
as returned by the KEY (if supplied); the second argument is an element
of SEQUENCE-2 as returned by the KEY (if supplied).  PREDICATE should
return true if and only if its first argument is strictly less than the
second (in some appropriate sense).  If the first argument is greater
than or equal to the second (in the appropriate sense), then PREDICATE
should return false.  ‘merge’ considers two elements ‘x’ and ‘y’ to be
equal if ‘(funcall predicate x y)’ and ‘(funcall predicate y x)’ both
yield false.

The argument to the KEY is the SEQUENCE element.  Typically, the return
value of the KEY becomes the argument to PREDICATE.  If KEY is not
supplied or ‘nil’, the sequence element itself is used.  The KEY may be
executed more than once for each sequence element, and its side effects
may occur in any order.

If KEY and PREDICATE return, then the merging operation will terminate.
The result of merging two sequences ‘x’ and ‘y’ is a new sequence of
type RESULT-TYPE ‘z’, such that the length of ‘z’ is the sum of the
lengths of ‘x’ and ‘y’, and ‘z’ contains all the elements of ‘x’ and
‘y’.  If ‘x1’ and ‘x2’ are two elements of ‘x’, and ‘x1’ precedes ‘x2’
in ‘x’, then ‘x1’ precedes ‘x2’ in ‘z’, and similarly for elements of
‘y’.  In short, ‘z’ is an interleaving of ‘x’ and ‘y’.

If ‘x’ and ‘y’ were correctly sorted according to the PREDICATE, then
‘z’ will also be correctly sorted.  If ‘x’ or ‘y’ is not so sorted, then
‘z’ will not be sorted, but will nevertheless be an interleaving of ‘x’
and ‘y’.

The merging operation is guaranteed stable; if two or more elements are
considered equal by the PREDICATE, then the elements from SEQUENCE-1
will precede those from SEQUENCE-2 in the result.

SEQUENCE-1 and/or SEQUENCE-2 may be destroyed.

If the RESULT-TYPE is a subtype of ‘list’, the result will be a list.

If the RESULT-TYPE is a subtype of ‘vector’, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ‘*’), the element type of the resulting array is
‘t’; otherwise, an error is signaled.

Examples:
.........

      (setq test1 (list 1 3 4 6 7))
      (setq test2 (list 2 5 8))
      (merge 'list test1 test2 #'<) → (1 2 3 4 5 6 7 8)
      (setq test1 (copy-seq "BOY"))
      (setq test2 (copy-seq :nosy"))
      (merge 'string test1 test2 #'char-lessp) → "BnOosYy"
      (setq test1 (vector ((red . 1) (blue . 4))))
      (setq test2 (vector ((yellow . 2) (green . 7))))
      (merge 'vector test1 test2 #'< :key #'cdr)
     → #((RED . 1) (YELLOW . 2) (BLUE . 4) (GREEN . 7))

      (merge '(vector * 4) '(1 5) '(2 4 6) #'<) should signal an error

Exceptional Situations:
.......................

An error must be signaled if the RESULT-TYPE is neither a recognizable
subtype of ‘list’, nor a recognizable subtype of ‘vector’.

An error of type ‘type-error’ should be signaled if RESULT-TYPE
specifies the number of elements and the sum of the lengths of
SEQUENCE-1 and SEQUENCE-2 is different from that number.

See Also:
.........

*note sort::, *note stable-sort::, *note Section 3.2.1 (Compiler
Terminology): Compiler Terminology, *note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.


File: ansicl,  Node: remove; remove-if; remove-if-not; delete; delete-if; delete-if-not,  Next: remove-duplicates; delete-duplicates,  Prev: merge,  Up: Sequences

remove, remove-if, remove-if-not, delete, delete-if, delete-if-not (Function)
=============================================================================

Syntax:
.......

 -- Function: remove item sequence &key from-end test test-not start end
          count key → result-sequence

 -- Function: remove-if test sequence &key from-end start end count key
          → result-sequence

 -- Function: remove-if-not test sequence &key from-end start end count
          key → result-sequence

 -- Function: delete item sequence &key from-end test test-not start end
          count key → result-sequence

 -- Function: delete-if test sequence &key from-end start end count key
          → result-sequence

 -- Function: delete-if-not test sequence &key from-end start end count
          key → result-sequence

Arguments and Values:
.....................

ITEM—an object.

SEQUENCE—a proper sequence.

TEST—a designator for a function of one argument that returns a
generalized boolean.

FROM-END—a generalized boolean.  The default is false.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

START, END—bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

COUNT—an integer or ‘nil’.  The default is ‘nil’.

KEY—a designator for a function of one argument, or ‘nil’.

RESULT-SEQUENCE—a sequence.

Description:
............

‘remove’, ‘remove-if’, and ‘remove-if-not’ return a SEQUENCE from which
the elements that satisfy the test have been removed.

‘delete’, ‘delete-if’, and ‘delete-if-not’ are like ‘remove’,
‘remove-if’, and ‘remove-if-not’ respectively, but they may modify
SEQUENCE.

If SEQUENCE is a vector, the result is a vector that has the same actual
array element type as SEQUENCE.  If SEQUENCE is a list, the result is a
list.

Supplying a FROM-END of true matters only when the COUNT is provided; in
that case only the rightmost COUNT elements satisfying the test are
deleted.

COUNT, if supplied, limits the number of elements removed or deleted; if
more than COUNT elements satisfy the test, then of these elements only
the leftmost or rightmost, depending on FROM-END, are deleted or
removed, as many as specified by COUNT.  If COUNT is supplied and
negative, the behavior is as if zero had been supplied instead.  If
COUNT is ‘nil’, all matching items are affected.

For all these functions, elements not removed or deleted occur in the
same order in the result as they did in SEQUENCE.

‘remove’, ‘remove-if’, ‘remove-if-not’ return a sequence of the same
type as SEQUENCE that has the same elements except that those in the
subsequence bounded by START and END and satisfying the test have been
removed.  This is a non-destructive operation.  If any elements need to
be removed, the result will be a copy.  The result of ‘remove’ may share
with SEQUENCE; the result may be identical to the input SEQUENCE if no
elements need to be removed.

‘delete’, ‘delete-if’, and ‘delete-if-not’ return a sequence of the same
type as SEQUENCE that has the same elements except that those in the
subsequence bounded by START and END and satisfying the test have been
deleted.  SEQUENCE may be destroyed and used to construct the result;
however, the result might or might not be identical to SEQUENCE.

‘delete’, when SEQUENCE is a list, is permitted to ‘setf’ any part,
‘car’ or ‘cdr’, of the top-level list structure in that SEQUENCE.  When
SEQUENCE is a vector, ‘delete’ is permitted to change the dimensions of
the vector and to slide its elements into new positions without
permuting them to produce the resulting vector.

‘delete-if’ is constrained to behave exactly as follows:

      (delete nil sequence
                  :test #'(lambda (ignore item) (funcall test item))
                  ...)

Examples:
.........

      (remove 4 '(1 3 4 5 9)) → (1 3 5 9)
      (remove 4 '(1 2 4 1 3 4 5)) → (1 2 1 3 5)
      (remove 4 '(1 2 4 1 3 4 5) :count 1) → (1 2 1 3 4 5)
      (remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) → (1 2 4 1 3 5)
      (remove 3 '(1 2 4 1 3 4 5) :test #'>) → (4 3 4 5)
      (setq lst '(list of four elements)) → (LIST OF FOUR ELEMENTS)
      (setq lst2 (copy-seq lst)) → (LIST OF FOUR ELEMENTS)
      (setq lst3 (delete 'four lst)) → (LIST OF ELEMENTS)
      (equal lst lst2) → false
      (remove-if #'oddp '(1 2 4 1 3 4 5)) → (2 4 4)
      (remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)
     → (1 2 4 1 3 5)
      (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)
     → (1 2 3 4 5 6 8)
      (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
      (delete 4 tester) → (1 2 1 3 5)
      (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
      (delete 4 tester :count 1) → (1 2 1 3 4 5)
      (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
      (delete 4 tester :count 1 :from-end t) → (1 2 4 1 3 5)
      (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
      (delete 3 tester :test #'>) → (4 3 4 5)
      (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
      (delete-if #'oddp tester) → (2 4 4)
      (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
      (delete-if #'evenp tester :count 1 :from-end t) → (1 2 4 1 3 5)
      (setq tester (list 1 2 3 4 5 6)) → (1 2 3 4 5 6)
      (delete-if #'evenp tester) → (1 3 5)
      tester → implementation-dependent

      (setq foo (list 'a 'b 'c)) → (A B C)
      (setq bar (cdr foo)) → (B C)
      (setq foo (delete 'b foo)) → (A C)
      bar → ((C)) or ...
      (eq (cdr foo) (car bar)) → T or ...

Side Effects:
.............

For ‘delete’, ‘delete-if’, and ‘delete-if-not’, SEQUENCE may be
destroyed and used to construct the result.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and Side
Effects.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.

The :test-not argument is deprecated.

The functions ‘delete-if-not’ and ‘remove-if-not’ are deprecated.


File: ansicl,  Node: remove-duplicates; delete-duplicates,  Prev: remove; remove-if; remove-if-not; delete; delete-if; delete-if-not,  Up: Sequences

remove-duplicates, delete-duplicates (Function)
===============================================

Syntax:
.......

 -- Function: remove-duplicates sequence &key from-end test test-not
          start end key → result-sequence

 -- Function: delete-duplicates sequence &key from-end test test-not
          start end key → result-sequence

Arguments and Values:
.....................

SEQUENCE—a proper sequence.

FROM-END—a generalized boolean.  The default is false.

TEST—a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT—a designator for a function of two arguments that returns a
generalized boolean.

START, END—bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

KEY—a designator for a function of one argument, or ‘nil’.

RESULT-SEQUENCE—a sequence.

Description:
............

‘remove-duplicates’ returns a modified copy of SEQUENCE from which any
element that matches another element occurring in SEQUENCE has been
removed.

If SEQUENCE is a vector, the result is a vector that has the same actual
array element type as SEQUENCE.  If SEQUENCE is a list, the result is a
list.

‘delete-duplicates’ is like ‘remove-duplicates’, but ‘delete-duplicates’
may modify SEQUENCE.

The elements of SEQUENCE are compared pairwise, and if any two match,
then the one occurring earlier in SEQUENCE is discarded, unless FROM-END
is true, in which case the one later in SEQUENCE is discarded.

‘remove-duplicates’ and ‘delete-duplicates’ return a sequence of the
same type as SEQUENCE with enough elements removed so that no two of the
remaining elements match.  The order of the elements remaining in the
result is the same as the order in which they appear in SEQUENCE.

‘remove-duplicates’ returns a sequence that may share with SEQUENCE or
may be identical to SEQUENCE if no elements need to be removed.

‘delete-duplicates’, when SEQUENCE is a list, is permitted to ‘setf’ any
part, ‘car’ or ‘cdr’, of the top-level list structure in that SEQUENCE.
When SEQUENCE is a vector, ‘delete-duplicates’ is permitted to change
the dimensions of the vector and to slide its elements into new
positions without permuting them to produce the resulting vector.

Examples:
.........

      (remove-duplicates "aBcDAbCd" :test #'char-equal :from-end t) → "aBcD"
      (remove-duplicates '(a b c b d d e)) → (A C B D E)
      (remove-duplicates '(a b c b d d e) :from-end t) → (A B C D E)
      (remove-duplicates '((foo #\a) (bar #\%) (baz #\A))
          :test #'char-equal :key #'cadr) → ((BAR #\%) (BAZ #\A))
      (remove-duplicates '((foo #\a) (bar #\%) (baz #\A))
          :test #'char-equal :key #'cadr :from-end t) → ((FOO #\a) (BAR #\%))
      (setq tester (list 0 1 2 3 4 5 6))
      (delete-duplicates tester :key #'oddp :start 1 :end 6) → (0 4 5 6)

Side Effects:
.............

‘delete-duplicates’ might destructively modify SEQUENCE.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SEQUENCE is not a proper
sequence.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and Side
Effects.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.

The :test-not argument is deprecated.

These functions are useful for converting SEQUENCE into a canonical form
suitable for representing a set.


File: ansicl,  Node: Hash Tables,  Next: Filenames,  Prev: Sequences,  Up: Top

18 Hash Tables
**************

* Menu:

* Hash Table Concepts::

Dictionary

* hash-table::
* make-hash-table::
* hash-table-p::
* hash-table-count::
* hash-table-rehash-size::
* hash-table-rehash-threshold::
* hash-table-size::
* hash-table-test::
* gethash::
* remhash::
* maphash::
* with-hash-table-iterator::
* clrhash::
* sxhash::


File: ansicl,  Node: Hash Table Concepts,  Next: hash-table,  Up: Hash Tables

18.1 Hash Table Concepts
========================

* Menu:

* Hash-Table Operations::
* Modifying Hash Table Keys::


File: ansicl,  Node: Hash-Table Operations,  Next: Modifying Hash Table Keys,  Up: Hash Table Concepts

18.1.1 Hash-Table Operations
----------------------------

The next figure lists some defined names that are applicable to hash
tables.  The following rules apply to hash tables.

   – A hash table can only associate one value with a given key.  If an
     attempt is made to add a second value for a given key, the second
     value will replace the first.  Thus, adding a value to a hash table
     is a destructive operation; the hash table is modified.

   – There are four kinds of hash tables: those whose keys are compared
     with ‘eq’, those whose keys are compared with ‘eql’, those whose
     keys are compared with ‘equal’, and those whose keys are compared
     with ‘equalp’.

   – Hash tables are created by ‘make-hash-table’.  ‘gethash’ is used to
     look up a key and find the associated value.  New entries are added
     to hash tables using ‘setf’ with ‘gethash’.  ‘remhash’ is used to
     remove an entry.  For example:

           (setq a (make-hash-table)) → #<HASH-TABLE EQL 0/120 32536573>
           (setf (gethash 'color a) 'brown) → BROWN
           (setf (gethash 'name a) 'fred) → FRED
           (gethash 'color a) → BROWN, true
           (gethash 'name a) → FRED, true
           (gethash 'pointy a) → NIL, false

     In this example, the symbols ‘color’ and ‘name’ are being used as
     keys, and the symbols ‘brown’ and ‘fred’ are being used as the
     associated values.  The hash table has two items in it, one of
     which associates from ‘color’ to ‘brown’, and the other of which
     associates from ‘name’ to ‘fred’.

   – A key or a value may be any object.

   – The existence of an entry in the hash table can be determined from
     the secondary value returned by ‘gethash’.

clrhash            hash-table-p      remhash
gethash            make-hash-table   sxhash
hash-table-count   maphash

Figure 18.1: Hash-table defined names


File: ansicl,  Node: Modifying Hash Table Keys,  Prev: Hash-Table Operations,  Up: Hash Table Concepts

18.1.2 Modifying Hash Table Keys
--------------------------------

The function supplied as the :test argument to ‘make-hash-table’
specifies the ‘equivalence test’ for the hash table it creates.

An object is ‘visibly modified’ with regard to an equivalence test if
there exists some set of objects (or potential objects) which are
equivalent to the object before the modification but are no longer
equivalent afterwards.

If an object Oand is then visibly modified with regard to the
equivalence test of H, then the consequences are unspecified if OOor
after the modification), is used as a key in further operations on H.
The consequences of using Oeven if Oand then later modified again in
such a way as to undo the visible modification.

Following are specifications of the modifications which are visible to
the equivalence tests which must be supported by hash tables.  The
modifications are described in terms of modification of components, and
are defined recursively.  Visible modifications of components of the
object are visible modifications of the object.

18.1.2.1 Visible Modification of Objects with respect to EQ and EQL
...................................................................

No standardized function is provided that is capable of visibly
modifying an object with regard to ‘eq’ or ‘eql’.

18.1.2.2 Visible Modification of Objects with respect to EQUAL
..............................................................

As a consequence of the behavior for ‘equal’, the rules for visible
modification of objects not explicitly mentioned in this section are
inherited from those in *note Section 18.1.2.1 (Visible Modification of
Objects with respect to EQ and EQL): VisModEQL.

18.1.2.2.1 Visible Modification of Conses with respect to EQUAL
...............................................................

Any visible change to the car or the cdr of a cons is considered a
visible modification with regard to ‘equal’.

18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL
................................................................................

For a vector of type ‘bit-vector’ or of type ‘string’, any visible
change to an active element of the vector, or to the length of the
vector (if it is actually adjustable or has a fill pointer) is
considered a visible modification with regard to ‘equal’.

18.1.2.3 Visible Modification of Objects with respect to EQUALP
...............................................................

As a consequence of the behavior for ‘equalp’, the rules for visible
modification of objects not explicitly mentioned in this section are
inherited from those in *note Section 18.1.2.2 (Visible Modification of
Objects with respect to EQUAL): VisModEQUAL.

18.1.2.3.1 Visible Modification of Structures with respect to EQUALP
....................................................................

Any visible change to a slot of a structure is considered a visible
modification with regard to ‘equalp’.

18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP
................................................................

In an array, any visible change to an active element, to the fill
pointer (if the array can and does have one), or to the dimensions (if
the array is actually adjustable) is considered a visible modification
with regard to ‘equalp’.

18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP
.....................................................................

In a hash table, any visible change to the count of entries in the hash
table, to the keys, or to the values associated with the keys is
considered a visible modification with regard to ‘equalp’.

Note that the visibility of modifications to the keys depends on the
equivalence test of the hash table, not on the specification of
‘equalp’.

18.1.2.4 Visible Modifications by Language Extensions
.....................................................

Implementations that extend the language by providing additional mutator
functions (or additional behavior for existing mutator functions) must
document how the use of these extensions interacts with equivalence
tests and hash table searches.

Implementations that extend the language by defining additional
acceptable equivalence tests for hash tables (allowing additional values
for the :test argument to ‘make-hash-table’) must document the visible
components of these tests.


File: ansicl,  Node: hash-table,  Next: make-hash-table,  Prev: Hash Table Concepts,  Up: Hash Tables

hash-table (System Class)
=========================

Class Precedence List:
......................

‘hash-table’, ‘t’

Description:
............

Hash tables provide a way of mapping any object (a key) to an associated
object (a value).

See Also:
.........

*note Section 18.1 (Hash Table Concepts): Hash Table Concepts, *note
Section 22.1.3.13 (Printing Other Objects): PrintingOtherObjects.

Notes:
......

The intent is that this mapping be implemented by a hashing mechanism,
such as that described in Section 6.4 “Hashing” of ‘The Art of Computer
Programming, Volume 3’ (pp506-549).  In spite of this intent, no
conforming implementation is required to use any particular technique to
implement the mapping.


File: ansicl,  Node: make-hash-table,  Next: hash-table-p,  Prev: hash-table,  Up: Hash Tables

make-hash-table (Function)
==========================

Syntax:
.......

 -- Function: make-hash-table &key test size rehash-size
          rehash-threshold → hash-table

Arguments and Values:
.....................

TEST—a designator for one of the functions ‘eq’, ‘eql’, ‘equal’, or
‘equalp’.  The default is ‘eql’.

SIZE—a non-negative integer.  The default is implementation-dependent.

REHASH-SIZE—a real of type ‘(or (integer 1 *) (float (1.0) *))’.  The
default is implementation-dependent.

REHASH-THRESHOLD—a real of type ‘(real 0 1)’.  The default is
implementation-dependent.

HASH-TABLE—a hash table.

Description:
............

Creates and returns a new hash table.

TEST determines how keys are compared.  An object is said to be present
in the HASH-TABLE if that object is the same under the test as the key
for some entry in the HASH-TABLE.

SIZE is a hint to the implementation about how much initial space to
allocate in the HASH-TABLE.  This information, taken together with the
REHASH-THRESHOLD, controls the approximate number of entries which it
should be possible to insert before the table has to grow.  The actual
size might be rounded up from SIZE to the next ‘good’ size; for example,
some implementations might round to the next prime number.

REHASH-SIZE specifies a minimum amount to increase the size of the
HASH-TABLE when it becomes full enough to require rehashing; see
REHASH-THESHOLD below.  If REHASH-SIZE is an integer, the expected
growth rate for the table is additive and the integer is the number of
entries to add; if it is a float, the expected growth rate for the table
is multiplicative and the float is the ratio of the new size to the old
size.  As with SIZE, the actual size of the increase might be rounded
up.

REHASH-THRESHOLD specifies how full the HASH-TABLE can get before it
must grow.  It specifies the maximum desired hash-table occupancy level.

The values of REHASH-SIZE and REHASH-THRESHOLD do not constrain the
implementation to use any particular method for computing when and by
how much the size of HASH-TABLE should be enlarged.  Such decisions are
implementation-dependent, and these values only hints from the
programmer to the implementation, and the implementation is permitted to
ignore them.

Examples:
.........

      (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 46142754>
      (setf (gethash "one" table) 1) → 1
      (gethash "one" table) → NIL, false
      (setq table (make-hash-table :test 'equal)) → #<HASH-TABLE EQUAL 0/139 46145547>
      (setf (gethash "one" table) 1) → 1
      (gethash "one" table) → 1, T
      (make-hash-table :rehash-size 1.5 :rehash-threshold 0.7)
     → #<HASH-TABLE EQL 0/120 46156620>

See Also:
.........

*note gethash::, *note hash-table::


File: ansicl,  Node: hash-table-p,  Next: hash-table-count,  Prev: make-hash-table,  Up: Hash Tables

hash-table-p (Function)
=======================

Syntax:
.......

 -- Function: hash-table-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘hash-table’; otherwise, returns
false.

Examples:
.........

      (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32511220>
      (hash-table-p table) → true
      (hash-table-p 37) → false
      (hash-table-p '((a . 1) (b . 2))) → false

Notes:
......

      (hash-table-p OBJECT) ≡ (typep OBJECT 'hash-table)


File: ansicl,  Node: hash-table-count,  Next: hash-table-rehash-size,  Prev: hash-table-p,  Up: Hash Tables

hash-table-count (Function)
===========================

Syntax:
.......

 -- Function: hash-table-count hash-table → count

Arguments and Values:
.....................

HASH-TABLE—a hash table.

COUNT—a non-negative integer.

Description:
............

Returns the number of entries in the HASH-TABLE.  If HASH-TABLE has just
been created or newly cleared (see ‘clrhash’) the entry count is ‘0’.

Examples:
.........

      (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32115135>
      (hash-table-count table) → 0
      (setf (gethash 57 table) "fifty-seven") → "fifty-seven"
      (hash-table-count table) → 1
      (dotimes (i 100) (setf (gethash i table) i)) → NIL
      (hash-table-count table) → 100

Affected By:
............

‘clrhash’, ‘remhash’, ‘setf’ of ‘gethash’

See Also:
.........

*note hash-table-size::

Notes:
......

The following relationships are functionally correct, although in
practice using ‘hash-table-count’ is probably much faster:

      (hash-table-count TABLE) ≡
      (loop for value being the hash-values of TABLE count t) ≡
      (let ((total 0))
        (maphash #'(lambda (key value)
                     (declare (ignore key value))
                     (incf total))
                 TABLE)
        total)


File: ansicl,  Node: hash-table-rehash-size,  Next: hash-table-rehash-threshold,  Prev: hash-table-count,  Up: Hash Tables

hash-table-rehash-size (Function)
=================================

Syntax:
.......

 -- Function: hash-table-rehash-size hash-table → rehash-size

Arguments and Values:
.....................

HASH-TABLE—a hash table.

REHASH-SIZE—a real of type ‘(or (integer 1 *) (float (1.0) *))’.

Description:
............

Returns the current rehash size of HASH-TABLE, suitable for use in a
call to ‘make-hash-table’ in order to produce a hash table with state
corresponding to the current state of the HASH-TABLE.

Examples:
.........

      (setq table (make-hash-table :size 100 :rehash-size 1.4))
     → #<HASH-TABLE EQL 0/100 2556371>
      (hash-table-rehash-size table) → 1.4

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if HASH-TABLE is not a hash
table.

See Also:
.........

*note make-hash-table::, *note hash-table-rehash-threshold::

Notes:
......

If the hash table was created with an integer rehash size, the result is
an integer, indicating that the rate of growth of the HASH-TABLE when
rehashed is intended to be additive; otherwise, the result is a float,
indicating that the rate of growth of the HASH-TABLE when rehashed is
intended to be multiplicative.  However, this value is only advice to
the implementation; the actual amount by which the HASH-TABLE will grow
upon rehash is implementation-dependent.


File: ansicl,  Node: hash-table-rehash-threshold,  Next: hash-table-size,  Prev: hash-table-rehash-size,  Up: Hash Tables

hash-table-rehash-threshold (Function)
======================================

Syntax:
.......

 -- Function: hash-table-rehash-threshold hash-table → rehash-threshold

Arguments and Values:
.....................

HASH-TABLE—a hash table.

REHASH-THRESHOLD—a real of type ‘(real 0 1)’.

Description:
............

Returns the current rehash threshold of HASH-TABLE, which is suitable
for use in a call to ‘make-hash-table’ in order to produce a hash table
with state corresponding to the current state of the HASH-TABLE.

Examples:
.........

      (setq table (make-hash-table :size 100 :rehash-threshold 0.5))
     → #<HASH-TABLE EQL 0/100 2562446>
      (hash-table-rehash-threshold table) → 0.5

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if HASH-TABLE is not a hash
table.

See Also:
.........

*note make-hash-table::, *note hash-table-rehash-size::


File: ansicl,  Node: hash-table-size,  Next: hash-table-test,  Prev: hash-table-rehash-threshold,  Up: Hash Tables

hash-table-size (Function)
==========================

Syntax:
.......

 -- Function: hash-table-size hash-table → size

Arguments and Values:
.....................

HASH-TABLE—a hash table.

SIZE—a non-negative integer.

Description:
............

Returns the current size of HASH-TABLE, which is suitable for use in a
call to ‘make-hash-table’ in order to produce a hash table with state
corresponding to the current state of the HASH-TABLE.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if HASH-TABLE is not a hash
table.

See Also:
.........

*note hash-table-count::, *note make-hash-table::


File: ansicl,  Node: hash-table-test,  Next: gethash,  Prev: hash-table-size,  Up: Hash Tables

hash-table-test (Function)
==========================

Syntax:
.......

 -- Function: hash-table-test hash-table → test

Arguments and Values:
.....................

HASH-TABLE—a hash table.

TEST—a function designator.  For the four standardized hash table test
functions (see ‘make-hash-table’), the TEST value returned is always a
symbol.  If an implementation permits additional tests, it is
implementation-dependent whether such tests are returned as function
objects or function names.

Description:
............

Returns the test used for comparing keys in HASH-TABLE.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if HASH-TABLE is not a hash
table.

See Also:
.........

*note make-hash-table::


File: ansicl,  Node: gethash,  Next: remhash,  Prev: hash-table-test,  Up: Hash Tables

gethash (Accessor)
==================

Syntax:
.......

 -- Function: gethash key hash-table &optional default → value,
          present-p
(setf (gethash key hash-table &optional default) new-value)

Arguments and Values:
.....................

KEY—an object.

HASH-TABLE—a hash table.

DEFAULT—an object.  The default is ‘nil’.

VALUE—an object.

PRESENT-P—a generalized boolean.

Description:
............

VALUE is the object in HASH-TABLE whose key is the same as KEY under the
HASH-TABLE’s equivalence test.  If there is no such entry, VALUE is the
DEFAULT.

PRESENT-P is true if an entry is found; otherwise, it is false.

‘setf’ may be used with ‘gethash’ to modify the value associated with a
given key, or to add a new entry.  When a ‘gethash’ form is used as a
‘setf’ PLACE, any DEFAULT which is supplied is evaluated according to
normal left-to-right evaluation rules, but its value is ignored.

Examples:
.........

      (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32206334>
      (gethash 1 table) → NIL, false
      (gethash 1 table 2) → 2, false
      (setf (gethash 1 table) "one") → "one"
      (setf (gethash 2 table "two") "two") → "two"
      (gethash 1 table) → "one", true
      (gethash 2 table) → "two", true
      (gethash nil table) → NIL, false
      (setf (gethash nil table) nil) → NIL
      (gethash nil table) → NIL, true
      (defvar *counters* (make-hash-table)) → *COUNTERS*
      (gethash 'foo *counters*) → NIL, false
      (gethash 'foo *counters* 0) → 0, false
      (defmacro how-many (obj) `(values (gethash ,obj *counters* 0))) → HOW-MANY
      (defun count-it (obj) (incf (how-many obj))) → COUNT-IT
      (dolist (x '(bar foo foo bar bar baz)) (count-it x))
      (how-many 'foo) → 2
      (how-many 'bar) → 3
      (how-many 'quux) → 0

See Also:
.........

*note remhash::

Notes:
......

The secondary value, PRESENT-P, can be used to distinguish the absence
of an entry from the presence of an entry that has a value of DEFAULT.

