This is ansicl, produced by makeinfo version 6.7 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: keyword,  Next: symbolp,  Prev: symbol,  Up: Symbols

keyword (Type)
==============

Supertypes:
...........

‘keyword’, ‘symbol’, ‘t’

Description:
............

The type ‘keyword’ includes all symbols interned the ‘KEYWORD’ package.

Interning a symbol in the ‘KEYWORD’ package has three automatic effects:

  1. It causes the symbol to become bound to itself.
  2. It causes the symbol to become an external symbol of the ‘KEYWORD’
     package.
  3. It causes the symbol to become a constant variable.

See Also:
.........

*note keywordp::


File: ansicl,  Node: symbolp,  Next: keywordp,  Prev: keyword,  Up: Symbols

symbolp (Function)
==================

Syntax:
.......

 -- Function: symbolp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘symbol’; otherwise, returns false.

Examples:
.........

      (symbolp 'elephant) → true
      (symbolp 12) → false
      (symbolp nil) → true
      (symbolp '()) → true
      (symbolp :test) → true
      (symbolp "hello") → false

See Also:
.........

*note keywordp::, *note symbol::, *note typep::

Notes:
......

      (symbolp OBJECT) ≡ (typep OBJECT 'symbol)


File: ansicl,  Node: keywordp,  Next: make-symbol,  Prev: symbolp,  Up: Symbols

keywordp (Function)
===================

Syntax:
.......

 -- Function: keywordp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is a keyword

Examples:
.........

      (keywordp 'elephant) → false
      (keywordp 12) → false
      (keywordp :test) → true
      (keywordp ':test) → true
      (keywordp nil) → false
      (keywordp :nil) → true
      (keywordp '(:test)) → false
      (keywordp "hello") → false
      (keywordp ":hello") → false
      (keywordp '&optional) → false

See Also:
.........

*note constantp::, *note keyword::, *note symbolp::, *note
symbol-package::


File: ansicl,  Node: make-symbol,  Next: copy-symbol,  Prev: keywordp,  Up: Symbols

make-symbol (Function)
======================

Syntax:
.......

 -- Function: make-symbol name → new-symbol

Arguments and Values:
.....................

NAME—a string.

NEW-SYMBOL—a fresh, uninterned symbol.

Description:
............

‘make-symbol’ creates and returns a fresh, uninterned symbol whose name
is the given NAME.  The NEW-SYMBOL is neither bound nor fbound and has a
null property list.

It is implementation-dependent whether the string that becomes the
NEW-SYMBOL’s name is the given NAME or a copy of it.  Once a string has
been given as the NAME argument to make-symbol, the consequences are
undefined if a subsequent attempt is made to alter that string.

Examples:
.........

      (setq temp-string "temp") → "temp"
      (setq temp-symbol (make-symbol temp-string)) → #:|temp|
      (symbol-name temp-symbol) → "temp"
      (eq (symbol-name temp-symbol) temp-string) → implementation-dependent
      (find-symbol "temp") → NIL, NIL
      (eq (make-symbol temp-string) (make-symbol temp-string)) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NAME is not a string.

See Also:
.........

*note copy-symbol::

Notes:
......

No attempt is made by ‘make-symbol’ to convert the case of the name to
uppercase.  The only case conversion which ever occurs for symbols is
done by the Lisp reader.  The program interface to symbol creation
retains case, and the program interface to interning symbols is
case-sensitive.


File: ansicl,  Node: copy-symbol,  Next: gensym,  Prev: make-symbol,  Up: Symbols

copy-symbol (Function)
======================

Syntax:
.......

 -- Function: copy-symbol symbol &optional copy-properties → new-symbol

Arguments and Values:
.....................

SYMBOL—a symbol.

COPY-PROPERTIES—a generalized boolean.  The default is false.

NEW-SYMBOL—a fresh, uninterned symbol.

Description:
............

‘copy-symbol’ returns a fresh, uninterned symbol, the name of which is
‘string=’ to and possibly the same as the name of the given SYMBOL.

If COPY-PROPERTIES is false, the NEW-SYMBOL is neither bound nor fbound
and has a null property list.  If COPY-PROPERTIES is true, then the
initial value of NEW-SYMBOL is the value of SYMBOL, the initial function
definition of NEW-SYMBOL is the functional value of SYMBOL, and the
property list of NEW-SYMBOL is a copy

Examples:
.........

      (setq fred 'fred-smith) → FRED-SMITH
      (setf (symbol-value fred) 3) → 3
      (setq fred-clone-1a (copy-symbol fred nil)) → #:FRED-SMITH
      (setq fred-clone-1b (copy-symbol fred nil)) → #:FRED-SMITH
      (setq fred-clone-2a (copy-symbol fred t))   → #:FRED-SMITH
      (setq fred-clone-2b (copy-symbol fred t))   → #:FRED-SMITH
      (eq fred fred-clone-1a) → false
      (eq fred-clone-1a fred-clone-1b) → false
      (eq fred-clone-2a fred-clone-2b) → false
      (eq fred-clone-1a fred-clone-2a) → false
      (symbol-value fred) → 3
      (boundp fred-clone-1a) → false
      (symbol-value fred-clone-2a) → 3
      (setf (symbol-value fred-clone-2a) 4) → 4
      (symbol-value fred) → 3
      (symbol-value fred-clone-2a) → 4
      (symbol-value fred-clone-2b) → 3
      (boundp fred-clone-1a) → false
      (setf (symbol-function fred) #'(lambda (x) x)) → #<FUNCTION anonymous>
      (fboundp fred) → true
      (fboundp fred-clone-1a) → false
      (fboundp fred-clone-2a) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note make-symbol::

Notes:
......

Implementors are encouraged not to copy the string which is the symbol’s
name unnecessarily.  Unless there is a good reason to do so, the normal
implementation strategy is for the NEW-SYMBOL’s name to be identical to
the given SYMBOL’s name.


File: ansicl,  Node: gensym,  Next: *gensym-counter*,  Prev: copy-symbol,  Up: Symbols

gensym (Function)
=================

Syntax:
.......

 -- Function: gensym &optional x → new-symbol

Arguments and Values:
.....................

X—a string or a non-negative integer.  Complicated defaulting behavior;
see below.

NEW-SYMBOL—a fresh, uninterned symbol.

Description:
............

Creates and returns a fresh, uninterned symbol, as if by calling
‘make-symbol’.  (The only difference between ‘gensym’ and ‘make-symbol’
is in how the NEW-SYMBOL’s name is determined.)

The name of the NEW-SYMBOL is the concatenation of a prefix, which
defaults to ‘"G"’, and a suffix, which is the decimal representation of
a number that defaults to the value of ‘*gensym-counter*’.

If X is supplied, and is a string, then that string is used as a prefix
instead of ‘"G"’ for this call to ‘gensym’ only.

If X is supplied, and is an integer, then that integer, instead of the
value of ‘*gensym-counter*’, is used as the suffix for this call to
‘gensym’ only.

If and only if no explicit suffix is supplied, ‘*gensym-counter*’ is
incremented after it is used.

Examples:
.........

      (setq sym1 (gensym)) → #:G3142
      (symbol-package sym1) → NIL
      (setq sym2 (gensym 100)) → #:G100
      (setq sym3 (gensym 100)) → #:G100
      (eq sym2 sym3) → false
      (find-symbol "G100") → NIL, NIL
      (gensym "T") → #:T3143
      (gensym) → #:G3144

Side Effects:
.............

Might increment ‘*gensym-counter*’.

Affected By:
............

‘*gensym-counter*’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if X is not a string or a
non-negative integer.

See Also:
.........

*note gentemp::, *note *gensym-counter*::

Notes:
......

The ability to pass a numeric argument to ‘gensym’ has been deprecated;
explicitly binding ‘*gensym-counter*’ is now stylistically preferred.
(The somewhat baroque conventions for the optional argument are
historical in nature, and supported primarily for compatibility with
older dialects of Lisp.  In modern code, it is recommended that the only
kind of argument used be a string prefix.  In general, though, to obtain
more flexible control of the NEW-SYMBOL’s name, consider using
‘make-symbol’ instead.)


File: ansicl,  Node: *gensym-counter*,  Next: gentemp,  Prev: gensym,  Up: Symbols

*gensym-counter* (Variable)
===========================

Value Type:
...........

a non-negative integer.

Initial Value:
..............

implementation-dependent.

Description:
............

A number which will be used in constructing the name of the next symbol
generated by the function ‘gensym’.

‘*gensym-counter*’ can be either assigned or bound at any time, but its
value must always be a non-negative integer.

Affected By:
............

‘gensym’.

See Also:
.........

*note gensym::

Notes:
......

The ability to pass a numeric argument to ‘gensym’ has been deprecated;
explicitly binding ‘*gensym-counter*’ is now stylistically preferred.


File: ansicl,  Node: gentemp,  Next: symbol-function,  Prev: *gensym-counter*,  Up: Symbols

gentemp (Function)
==================

Syntax:
.......

 -- Function: gentemp &optional prefix package → new-symbol

Arguments and Values:
.....................

PREFIX—a string.  The default is ‘"T"’.

PACKAGE—a package designator.  The default is the current package.

NEW-SYMBOL—a fresh, interned symbol.

Description:
............

‘gentemp’ creates and returns a fresh symbol, interned in the indicated
PACKAGE.  The symbol is guaranteed to be one that was not previously
accessible in PACKAGE.  It is neither bound nor fbound, and has a null
property list.

The name of the NEW-SYMBOL is the concatenation of the PREFIX and a
suffix, which is taken from an internal counter used only by ‘gentemp’.
(If a symbol by that name is already accessible in PACKAGE, the counter
is incremented as many times as is necessary to produce a name that is
not already the name of a symbol accessible in PACKAGE.)

Examples:
.........

      (gentemp) → T1298
      (gentemp "FOO") → FOO1299
      (find-symbol "FOO1300") → NIL, NIL
      (gentemp "FOO") → FOO1300
      (find-symbol "FOO1300") → FOO1300, :INTERNAL
      (intern "FOO1301") → FOO1301, :INTERNAL
      (gentemp "FOO") → FOO1302
      (gentemp) → T1303

Side Effects:
.............

Its internal counter is incremented one or more times.

Interns the NEW-SYMBOL in PACKAGE.

Affected By:
............

The current state of its internal counter, and the current state of the
PACKAGE.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PREFIX is not a string.
Should signal an error of type ‘type-error’ if PACKAGE is not a package
designator.

See Also:
.........

*note gensym::

Notes:
......

The function ‘gentemp’ is deprecated.

If PACKAGE is the ‘KEYWORD’ package, the result is an external symbol of
PACKAGE.  Otherwise, the result is an internal symbol of PACKAGE.

The ‘gentemp’ internal counter is independent of ‘*gensym-counter*’, the
counter used by ‘gensym’.  There is no provision for accessing the
‘gentemp’ internal counter.

Just because ‘gentemp’ creates a symbol which did not previously exist
does not mean that such a symbol might not be seen in the future (e.g.,
in a data file—perhaps even created by the same program in another
session).  As such, this symbol is not truly unique in the same sense as
a gensym would be.  In particular, programs which do automatic code
generation should be careful not to attach global attributes to such
generated symbols (e.g., ‘special’ declarations) and then write them
into a file because such global attributes might, in a different
session, end up applying to other symbols that were automatically
generated on another day for some other purpose.


File: ansicl,  Node: symbol-function,  Next: symbol-name,  Prev: gentemp,  Up: Symbols

symbol-function (Accessor)
==========================

Syntax:
.......

 -- Function: symbol-function symbol → contents
(setf (symbol-function symbol) new-contents)

Arguments and Values:
.....................

SYMBOL—a symbol.

CONTENTS— If the SYMBOL is globally defined as a macro or a special
operator, an object of implementation-dependent nature and identity is
returned.  If the SYMBOL is not globally defined as either a macro or a
special operator, and if the SYMBOL is fbound, a function object is
returned.

NEW-CONTENTS—a function.

Description:
............

Accesses the symbol’s function cell.

Examples:
.........

      (symbol-function 'car) → #<FUNCTION CAR>
      (symbol-function 'twice) is an error   ;because TWICE isn't defined.
      (defun twice (n) (* n 2)) → TWICE
      (symbol-function 'twice) → #<FUNCTION TWICE>
      (list (twice 3)
            (funcall (function twice) 3)
            (funcall (symbol-function 'twice) 3))
     → (6 6 6)
      (flet ((twice (x) (list x x)))
        (list (twice 3)
              (funcall (function twice) 3)
              (funcall (symbol-function 'twice) 3)))
     → ((3 3) (3 3) 6)
      (setf (symbol-function 'twice) #'(lambda (x) (list x x)))
     → #<FUNCTION anonymous>
      (list (twice 3)
            (funcall (function twice) 3)
            (funcall (symbol-function 'twice) 3))
     → ((3 3) (3 3) (3 3))
      (fboundp 'defun) → true
      (symbol-function 'defun)
     → implementation-dependent
      (functionp (symbol-function 'defun))
     → implementation-dependent
      (defun symbol-function-or-nil (symbol)
        (if (and (fboundp symbol)
                 (not (macro-function symbol))
                 (not (special-operator-p symbol)))
            (symbol-function symbol)
            nil)) → SYMBOL-FUNCTION-OR-NIL
      (symbol-function-or-nil 'car) → #<FUNCTION CAR>
      (symbol-function-or-nil 'defun) → NIL

Affected By:
............

‘defun’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

Should signal ‘undefined-function’ if SYMBOL is not fbound and an
attempt is made to read its definition.  (No such error is signaled on
an attempt to write its definition.)

See Also:
.........

*note fboundp::, *note fmakunbound::, *note macro-function::, *note
special-operator-p::

Notes:
......

‘symbol-function’ cannot access the value of a lexical function name
produced by ‘flet’ or ‘labels’; it can access only the global function
value.

‘setf’ may be used with ‘symbol-function’ to replace a global function
definition when the symbol’s function definition does not represent a
special operator.

     (symbol-function SYMBOL) ≡ (fdefinition SYMBOL)

However, ‘fdefinition’ accepts arguments other than just symbols.


File: ansicl,  Node: symbol-name,  Next: symbol-package,  Prev: symbol-function,  Up: Symbols

symbol-name (Function)
======================

Syntax:
.......

 -- Function: symbol-name symbol → name

Arguments and Values:
.....................

SYMBOL—a symbol.

NAME—a string.

Description:
............

‘symbol-name’ returns the name of SYMBOL.  The consequences are
undefined if NAME is ever modified.

Examples:
.........

      (symbol-name 'temp) → "TEMP"
      (symbol-name :start) → "START"
      (symbol-name (gensym)) → "G1234" ;for example

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.


File: ansicl,  Node: symbol-package,  Next: symbol-plist,  Prev: symbol-name,  Up: Symbols

symbol-package (Function)
=========================

Syntax:
.......

 -- Function: symbol-package symbol → contents

Arguments and Values:
.....................

SYMBOL—a symbol.

CONTENTS—a package object or ‘nil’.

Description:
............

Returns the home package of SYMBOL.

Examples:
.........

      (in-package "CL-USER") → #<PACKAGE "COMMON-LISP-USER">
      (symbol-package 'car) → #<PACKAGE "COMMON-LISP">
      (symbol-package 'bus) → #<PACKAGE "COMMON-LISP-USER">
      (symbol-package :optional) → #<PACKAGE "KEYWORD">
      ;; Gensyms are uninterned, so have no home package.
      (symbol-package (gensym)) → NIL
      (make-package 'pk1) → #<PACKAGE "PK1">
      (intern "SAMPLE1" "PK1") → PK1::SAMPLE1, NIL
      (export (find-symbol "SAMPLE1" "PK1") "PK1") → T
      (make-package 'pk2 :use '(pk1)) → #<PACKAGE "PK2">
      (find-symbol "SAMPLE1" "PK2") → PK1:SAMPLE1, :INHERITED
      (symbol-package 'pk1::sample1) → #<PACKAGE "PK1">
      (symbol-package 'pk2::sample1) → #<PACKAGE "PK1">
      (symbol-package 'pk1::sample2) → #<PACKAGE "PK1">
      (symbol-package 'pk2::sample2) → #<PACKAGE "PK2">
      ;; The next several forms create a scenario in which a symbol
      ;; is not really uninterned, but is "apparently uninterned",
      ;; and so SYMBOL-PACKAGE still returns NIL.
      (setq s3 'pk1::sample3) → PK1::SAMPLE3
      (import s3 'pk2) → T
      (unintern s3 'pk1) → T
      (symbol-package s3) → NIL
      (eq s3 'pk2::sample3) → T

Affected By:
............

‘import’, ‘intern’, ‘unintern’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note intern::


File: ansicl,  Node: symbol-plist,  Next: symbol-value,  Prev: symbol-package,  Up: Symbols

symbol-plist (Accessor)
=======================

Syntax:
.......

 -- Function: symbol-plist symbol → plist
(setf (symbol-plist symbol) new-plist)

Arguments and Values:
.....................

SYMBOL—a symbol.

PLIST, NEW-PLIST—a property list.

Description:
............

Accesses the property list of SYMBOL.

Examples:
.........

      (setq sym (gensym)) → #:G9723
      (symbol-plist sym) → ()
      (setf (get sym 'prop1) 'val1) → VAL1
      (symbol-plist sym) → (PROP1 VAL1)
      (setf (get sym 'prop2) 'val2) → VAL2
      (symbol-plist sym) → (PROP2 VAL2 PROP1 VAL1)
      (setf (symbol-plist sym) (list 'prop3 'val3)) → (PROP3 VAL3)
      (symbol-plist sym) → (PROP3 VAL3)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note get::, *note remprop::

Notes:
......

The use of ‘setf’ should be avoided, since a symbol’s property list is a
global resource that can contain information established and depended
upon by unrelated programs in the same Lisp image.


File: ansicl,  Node: symbol-value,  Next: get,  Prev: symbol-plist,  Up: Symbols

symbol-value (Accessor)
=======================

Syntax:
.......

 -- Function: symbol-value symbol → value
(setf (symbol-value symbol) new-value)

Arguments and Values:
.....................

SYMBOL—a symbol that must have a value.

VALUE, NEW-VALUE—an object.

Description:
............

Accesses the symbol’s value cell.

Examples:
.........

      (setf (symbol-value 'a) 1) → 1
      (symbol-value 'a) → 1
      ;; SYMBOL-VALUE cannot see lexical variables.
      (let ((a 2)) (symbol-value 'a)) → 1
      (let ((a 2)) (setq a 3) (symbol-value 'a)) → 1
      ;; SYMBOL-VALUE can see dynamic variables.
      (let ((a 2))
        (declare (special a))
        (symbol-value 'a)) → 2
      (let ((a 2))
        (declare (special a))
        (setq a 3)
        (symbol-value 'a)) → 3
      (let ((a 2))
        (setf (symbol-value 'a) 3)
        a) → 2
      a → 3
      (symbol-value 'a) → 3
      (let ((a 4))
        (declare (special a))
        (let ((b (symbol-value 'a)))
          (setf (symbol-value 'a) 5)
          (values a b))) → 5, 4
      a → 3
      (symbol-value :any-keyword) → :ANY-KEYWORD
      (symbol-value 'nil) → NIL
      (symbol-value '()) → NIL
      ;; The precision of this next one is implementation-dependent.
      (symbol-value 'pi) → 3.141592653589793d0

Affected By:
............

‘makunbound’, ‘set’, ‘setq’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

Should signal ‘unbound-variable’ if SYMBOL is unbound and an attempt is
made to read its value.  (No such error is signaled on an attempt to
write its value.)

See Also:
.........

*note boundp::, *note makunbound::, *note set::, *note setq::

Notes:
......

‘symbol-value’ can be used to get the value of a constant variable.
‘symbol-value’ cannot access the value of a lexical variable.


File: ansicl,  Node: get,  Next: remprop,  Prev: symbol-value,  Up: Symbols

get (Accessor)
==============

Syntax:
.......

 -- Function: get symbol indicator &optional default → value
(setf (get symbol indicator &optional default) new-value)

Arguments and Values:
.....................

SYMBOL—a symbol.

INDICATOR—an object.

DEFAULT—an object.  The default is ‘nil’.

VALUE—if the indicated property exists, the object that is its value;
otherwise, the specified DEFAULT.

NEW-VALUE—an object.

Description:
............

‘get’ finds a property on the property listwhose property indicator is
identical to INDICATOR, and returns its corresponding property value.
If there are multiple properties‘get’ uses the first such property.  If
there is no property with that property indicator, DEFAULT is returned.

‘setf’ of ‘get’ may be used to associate a new object with an existing
indicator already on the SYMBOL’s property list, or to create a new
assocation if none exists.  If there are multiple properties‘setf’ of
‘get’ associates the NEW-VALUE with the first such property.  When a
‘get’ form is used as a ‘setf’ PLACE, any DEFAULT which is supplied is
evaluated according to normal left-to-right evaluation rules, but its
value is ignored.

Examples:
.........

      (defun make-person (first-name last-name)
        (let ((person (gensym "PERSON")))
          (setf (get person 'first-name) first-name)
          (setf (get person 'last-name) last-name)
          person)) → MAKE-PERSON
      (defvar *john* (make-person "John" "Dow")) → *JOHN*
      *john* → #:PERSON4603
      (defvar *sally* (make-person "Sally" "Jones")) → *SALLY*
      (get *john* 'first-name) → "John"
      (get *sally* 'last-name) → "Jones"
      (defun marry (man woman married-name)
        (setf (get man 'wife) woman)
        (setf (get woman 'husband) man)
        (setf (get man 'last-name) married-name)
        (setf (get woman 'last-name) married-name)
        married-name) → MARRY
      (marry *john* *sally* "Dow-Jones") → "Dow-Jones"
      (get *john* 'last-name) → "Dow-Jones"
      (get (get *john* 'wife) 'first-name) → "Sally"
      (symbol-plist *john*)
     → (WIFE #:PERSON4604 LAST-NAME "Dow-Jones" FIRST-NAME "John")
      (defmacro age (person &optional (default ''thirty-something))
        `(get ,person 'age ,default)) → AGE
      (age *john*) → THIRTY-SOMETHING
      (age *john* 20) → 20
      (setf (age *john*) 25) → 25
      (age *john*) → 25
      (age *john* 20) → 25

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note getf::, *note symbol-plist::, *note remprop::

Notes:
......

      (get x y) ≡ (getf (symbol-plist x) y)

Numbers and characters are not recommended for use as INDICATORS in
portable code since ‘get’ tests with ‘eq’ rather than ‘eql’, and
consequently the effect of using such INDICATORS is
implementation-dependent.

There is no way using ‘get’ to distinguish an absent property from one
whose value is DEFAULT.  However, see ‘get-properties’.


File: ansicl,  Node: remprop,  Next: boundp,  Prev: get,  Up: Symbols

remprop (Function)
==================

Syntax:
.......

 -- Function: remprop symbol indicator → generalized-boolean

Arguments and Values:
.....................

SYMBOL—a symbol.

INDICATOR—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘remprop’ removes from the property lista propertyidentical to
INDICATOR.  If there are multiple properties‘remprop’ only removes the
first such property.  ‘remprop’ returns false if no such property was
found, or true if a property was found.

The property indicator and the corresponding property value are removed
in an undefined order by destructively splicing the property list.  The
permissible side-effects correspond to those permitted for ‘remf’, such
that:

      (remprop x y) ≡ (remf (symbol-plist x) y)

Examples:
.........

      (setq test (make-symbol "PSEUDO-PI")) → #:PSEUDO-PI
      (symbol-plist test) → ()
      (setf (get test 'constant) t) → T
      (setf (get test 'approximation) 3.14) → 3.14
      (setf (get test 'error-range) 'noticeable) → NOTICEABLE
      (symbol-plist test)
     → (ERROR-RANGE NOTICEABLE APPROXIMATION 3.14 CONSTANT T)
      (setf (get test 'approximation) nil) → NIL
      (symbol-plist test)
     → (ERROR-RANGE NOTICEABLE APPROXIMATION NIL CONSTANT T)
      (get test 'approximation) → NIL
      (remprop test 'approximation) → true
      (get test 'approximation) → NIL
      (symbol-plist test)
     → (ERROR-RANGE NOTICEABLE CONSTANT T)
      (remprop test 'approximation) → NIL
      (symbol-plist test)
     → (ERROR-RANGE NOTICEABLE CONSTANT T)
      (remprop test 'error-range) → true
      (setf (get test 'approximation) 3) → 3
      (symbol-plist test)
     → (APPROXIMATION 3 CONSTANT T)

Side Effects:
.............

The property list of SYMBOL is modified.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note remf::, *note symbol-plist::

Notes:
......

Numbers and characters are not recommended for use as INDICATORS in
portable code since ‘remprop’ tests with ‘eq’ rather than ‘eql’, and
consequently the effect of using such INDICATORS is
implementation-dependent.  Of course, if you’ve gotten as far as needing
to remove such a property, you don’t have much choice—the time to have
been thinking about this was when you used ‘setf’ of ‘get’ to establish
the property.


File: ansicl,  Node: boundp,  Next: makunbound,  Prev: remprop,  Up: Symbols

boundp (Function)
=================

Syntax:
.......

 -- Function: boundp symbol → generalized-boolean

Arguments and Values:
.....................

SYMBOL—a symbol.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if SYMBOL is bound; otherwise, returns false.

Examples:
.........

      (setq x 1) → 1
      (boundp 'x) → true
      (makunbound 'x) → X
      (boundp 'x) → false
      (let ((x 2)) (boundp 'x)) → false
      (let ((x 2)) (declare (special x)) (boundp 'x)) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note set::, *note setq::, *note symbol-value::, *note makunbound::

Notes:
......

The function ‘bound’ determines only whether a symbol has a value in the
global environment; any lexical bindings are ignored.


File: ansicl,  Node: makunbound,  Next: set,  Prev: boundp,  Up: Symbols

makunbound (Function)
=====================

Syntax:
.......

 -- Function: makunbound symbol → symbol

Arguments and Values:
.....................

SYMBOL—a symbol

Description:
............

Makes the SYMBOL be unbound, regardless of whether it was previously
bound.

Examples:
.........

      (setf (symbol-value 'a) 1)
      (boundp 'a) → true
      a → 1
      (makunbound 'a) → A
      (boundp 'a) → false

Side Effects:
.............

The value cell of SYMBOL is modified.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note boundp::, *note fmakunbound::


File: ansicl,  Node: set,  Next: unbound-variable,  Prev: makunbound,  Up: Symbols

set (Function)
==============

Syntax:
.......

 -- Function: set symbol value → value

Arguments and Values:
.....................

SYMBOL—a symbol.

VALUE—an object.

Description:
............

‘set’ changes the contents of the value cell of symbol to the given
value.

     (set SYMBOL VALUE) ≡ (setf (symbol-value SYMBOL) VALUE)

Examples:
.........

      (setf (symbol-value 'n) 1) → 1
      (set 'n 2) → 2
      (symbol-value 'n) → 2
      (let ((n 3))
        (declare (special n))
        (setq n (+ n 1))
        (setf (symbol-value 'n) (* n 10))
        (set 'n (+ (symbol-value 'n) n))
        n) → 80
      n → 2
      (let ((n 3))
        (setq n (+ n 1))
        (setf (symbol-value 'n) (* n 10))
        (set 'n (+ (symbol-value 'n) n))
        n) → 4
      n → 44
      (defvar *n* 2)
      (let ((*n* 3))
        (setq *n* (+ *n* 1))
        (setf (symbol-value '*n*) (* *n* 10))
        (set '*n* (+ (symbol-value '*n*) *n*))
        *n*) → 80
       *n* → 2
      (defvar *even-count* 0) → *EVEN-COUNT*
      (defvar *odd-count* 0) → *ODD-COUNT*
      (defun tally-list (list)
        (dolist (element list)
          (set (if (evenp element) '*even-count* '*odd-count*)
               (+ element (if (evenp element) *even-count* *odd-count*)))))
      (tally-list '(1 9 4 3 2 7)) → NIL
      *even-count* → 6
      *odd-count* → 20

Side Effects:
.............

The value of SYMBOL is changed.

See Also:
.........

*note setq::, *note progv::, *note symbol-value::

Notes:
......

The function ‘set’ is deprecated.

‘set’ cannot change the value of a lexical variable.


File: ansicl,  Node: unbound-variable,  Prev: set,  Up: Symbols

unbound-variable (Condition Type)
=================================

Class Precedence List:
......................

‘unbound-variable’, ‘cell-error’, ‘error’, ‘serious-condition’,
‘condition’, ‘t’

Description:
............

The type ‘unbound-variable’ consists of error conditions that represent
attempts to read the value of an unbound variable.

The name of the cell (see ‘cell-error’) is the name of the variable that
was unbound.

See Also:
.........

*note cell-error-name::


File: ansicl,  Node: Packages,  Next: Numbers,  Prev: Symbols,  Up: Top

11 Packages
***********

* Menu:

* Package Concepts::

Dictionary

* package::
* export::
* find-symbol::
* find-package::
* find-all-symbols::
* import::
* list-all-packages::
* rename-package::
* shadow::
* shadowing-import::
* delete-package::
* make-package::
* with-package-iterator::
* unexport::
* unintern::
* in-package::
* unuse-package::
* use-package::
* defpackage::
* do-symbols; do-external-symbols; do-all-symbols::
* intern::
* package-name::
* package-nicknames::
* package-shadowing-symbols::
* package-use-list::
* package-used-by-list::
* packagep::
* *package*::
* package-error::
* package-error-package::


File: ansicl,  Node: Package Concepts,  Next: package,  Up: Packages

11.1 Package Concepts
=====================

* Menu:

* Introduction to Packages::
* Standardized Packages::


File: ansicl,  Node: Introduction to Packages,  Next: Standardized Packages,  Up: Package Concepts

11.1.1 Introduction to Packages
-------------------------------

A “package” establishes a mapping from names to symbols.  At any given
time, one package is current.  The “current package” is the one that is
the value of ‘*package*’.  When using the Lisp reader, it is possible to
refer to symbols in packages other than the current one through the use
of package prefixes in the printed representation of the symbol.

The next figure lists some defined names that are applicable to
packages.  Where an operator takes an argument that is either a symbol
or a list of symbols, an argument of ‘nil’ is treated as an empty list
of symbols.  Any PACKAGE argument may be either a string, a symbol, or a
package.  If a symbol is supplied, its name will be used as the package
name.

*modules*             import                      provide
*package*             in-package                  rename-package
defpackage            intern                      require
do-all-symbols        list-all-packages           shadow
do-external-symbols   make-package                shadowing-import
do-symbols            package-name                unexport
export                package-nicknames           unintern
find-all-symbols      package-shadowing-symbols   unuse-package
find-package          package-use-list            use-package
find-symbol           package-used-by-list

Figure 11.1: Some Defined Names related to Packages

11.1.1.1 Package Names and Nicknames
....................................

Each package has a name (a string) and perhaps some nicknames (also
strings).  These are assigned when the package is created and can be
changed later.

There is a single namespace for packages.  The function ‘find-package’
translates a package name or nickname into the associated package.  The
function ‘package-name’ returns the name of a package.  The function
‘package-nicknames’ returns a list of all nicknames for a package.
‘rename-package’ removes a package’s current name and nicknames and
replaces them with new ones specified by the caller.

11.1.1.2 Symbols in a Package
.............................

11.1.1.2.1 Internal and External Symbols
........................................

The mappings in a package are divided into two classes, external and
internal.  The symbols targeted by these different mappings are called
external symbols and internal symbols of the package.  Within a package,
a name refers to one symbol or to none; if it does refer to a symbol,
then it is either external or internal in that package, but not both.
“External symbols” are part of the package’s public interface to other
packages.  Symbols become external symbols of a given package if they
have been exported from that package.

A symbol has the same name no matter what package it is present in, but
it might be an external symbol of some packages and an internal symbol
of others.

11.1.1.2.2 Package Inheritance
..............................

Packages can be built up in layers.  From one point of view, a package
is a single collection of mappings from strings into internal symbols
and external symbols.  However, some of these mappings might be
established within the package itself, while other mappings are
inherited from other packages via ‘use-package’.  A symbol is said to be
“present” in a package if the mapping is in the package itself and is
not inherited from somewhere else.

There is no way to inherit the internal symbols of another package; to
refer to an internal symbol using the Lisp reader, a package containing
the symbol must be made to be the current package, a package prefix must
be used, or the symbol must be imported into the current package.

11.1.1.2.3 Accessibility of Symbols in a Package
................................................

A symbol becomes “accessible” in a package if that is its home package
when it is created, or if it is imported into that package, or by
inheritance via ‘use-package’.

If a symbol is accessible in a package, it can be referred to when using
the Lisp reader without a package prefix when that package is the
current package, regardless of whether it is present or inherited.

Symbols from one package can be made accessible in another package in
two ways.

   – Any individual symbol can be added to a package by use of ‘import’.
     After the call to ‘import’ the symbol is present in the importing
     package.  The status of the symbol in the package it came from (if
     any) is unchanged, and the home package for this symbol is
     unchanged.  Once imported, a symbol is present in the importing
     package and can be removed only by calling ‘unintern’.

     A symbol is shadowedin some package if the first symbol would be
     accessible by inheritance if not for the presence of the second
     symbol.  See ‘shadowing-import’.

   – The second mechanism for making symbols from one package accessible
     in another is provided by ‘use-package’.  All of the external
     symbols of the used package are inherited by the using package.
     The function ‘unuse-package’ undoes the effects of a previous
     ‘use-package’.

11.1.1.2.4 Locating a Symbol in a Package
.........................................

When a symbol is to be located in a given package the following occurs:

   – The external symbols and internal symbols of the package are
     searched for the symbol.
   – The external symbols of the used packages are searched in some
     unspecified order.  The order does not matter; see the rules for
     handling name conflicts listed below.

11.1.1.2.5 Prevention of Name Conflicts in Packages
...................................................

Within one package, any particular name can refer to at most one symbol.
A name conflict is said to occur when there would be more than one
candidate symbol.  Any time a name conflict is about to occur, a
correctable error is signaled.

The following rules apply to name conflicts:

   – Name conflicts are detected when they become possible, that is,
     when the package structure is altered.  Name conflicts are not
     checked during every name lookup.

   – If the same symbol is accessible to a package through more than one
     path, there is no name conflict.  A symbol cannot conflict with
     itself.  Name conflicts occur only between distinct symbols with
     the same name (under ‘string=’).

   – Every package has a list of shadowing symbols.  A shadowing symbol
     takes precedence over any other symbol of the same name that would
     otherwise be accessible in the package.  A name conflict involving
     a shadowing symbol is always resolved in favor of the shadowing
     symbol, without signaling an error (except for one exception
     involving ‘import’).  See ‘shadow’ and ‘shadowing-import’.

   – The functions ‘use-package’, ‘import’, and ‘export’ check for name
     conflicts.

   – ‘shadow’ and ‘shadowing-import’ never signal a name-conflict error.

   – ‘unuse-package’ and ‘unexport’ do not need to do any name-conflict
     checking.  ‘unintern’ does name-conflict checking only when a
     symbol being uninterned is a shadowing symbol .

   – Giving a shadowing symbol to ‘unintern’ can uncover a name conflict
     that had previously been resolved by the shadowing.

   – Package functions signal name-conflict errors of type
     ‘package-error’ before making any change to the package structure.
     When multiple changes are to be made, it is permissible for the
     implementation to process each change separately.  For example,
     when ‘export’ is given a list of symbols, aborting from a name
     conflict caused by the second symbol in the list might still export
     the first symbol in the list.  However, a name-conflict error
     caused by ‘export’ of a single symbol will be signaled before that
     symbol’s accessibility in any package is changed.

   – Continuing from a name-conflict error must offer the user a chance
     to resolve the name conflict in favor of either of the candidates.
     The package structure should be altered to reflect the resolution
     of the name conflict, via ‘shadowing-import’, ‘unintern’, or
     ‘unexport’.

   – A name conflict in ‘use-package’ between a symbol present in the
     using package and an external symbol of the used package is
     resolved in favor of the first symbol by making it a shadowing
     symbol, or in favor of the second symbol by uninterning the first
     symbol from the using package.

   – A name conflict in ‘export’ or ‘unintern’ due to a package’s
     inheriting two distinct symbols with the same name (under
     ‘string=’) from two other packages can be resolved in favor of
     either symbol by importing it into the using package and making it
     a shadowing symbol , just as with ‘use-package’.


File: ansicl,  Node: Standardized Packages,  Prev: Introduction to Packages,  Up: Package Concepts

11.1.2 Standardized Packages
----------------------------

This section describes the packages that are available in every
conforming implementation.  A summary of the names and nicknames of
those standardized packages is given in the next figure.

Name                 Nicknames
---------------------------------
‘COMMON-LISP’        ‘CL’
‘COMMON-LISP-USER’   ‘CL-USER’
‘KEYWORD’            none

Figure 11.2: Standardized Package Names

11.1.2.1 The COMMON-LISP Package
................................

The ‘COMMON-LISP’ package contains the primitives of the Common
Lisp system as defined by this specification.  Its external symbols
include all of the defined names (except for defined names in the
‘KEYWORD’ package) that are present in the Common Lisp system, such as
‘car’, ‘cdr’, ‘*package*’, etc.  The ‘COMMON-LISP’ package has the
nickname ‘CL’.

The ‘COMMON-LISP’ package has as external symbols those symbols
enumerated in the figures in *note Section 1.9 (Symbols in the
COMMON-LISP Package): Symbols in the COMMON-LISP Package, and no others.
These external symbols are present in the ‘COMMON-LISP’ package but
their home package need not be the ‘COMMON-LISP’ package.

For example, the symbol ‘HELP’ cannot be an external symbol of the
‘COMMON-LISP’ package because it is not mentioned in *note Section 1.9
(Symbols in the COMMON-LISP Package): Symbols in the COMMON-LISP
Package.  In contrast, the symbol variable must be an external symbol of
the ‘COMMON-LISP’ package even though it has no definition because it is
listed in that section (to support its use as a valid second argument to
the function ‘documentation’).

The ‘COMMON-LISP’ package can have additional internal symbols.

11.1.2.1.1 Constraints on the COMMON-LISP Package for Conforming Implementations
................................................................................

In a conforming implementation, an external symbol of the ‘COMMON-LISP’
package can have a function, macro, or special operator definition, a
global variable definition (or other status as a dynamic variable due to
a ‘special’ proclamation), or a type definition only if explicitly
permitted in this standard.  For example, ‘fboundp’ yields false for any
external symbol of the ‘COMMON-LISP’ package that is not the name of a
standardized function, macro or special operator, and ‘boundp’ returns
false for any external symbol of the ‘COMMON-LISP’ package that is not
the name of a standardized global variable.  It also follows that
conforming programs can use external symbols of the ‘COMMON-LISP’
package as the names of local lexical variables with confidence that
those names have not been proclaimed ‘special’ by the implementation
unless those symbols are names of standardized global variables.

A conforming implementation must not place any property on an external
symbol of the ‘COMMON-LISP’ package using a property indicator that is
either an external symbol of any standardized package or a symbol that
is otherwise accessible in the ‘COMMON-LISP-USER’ package.

11.1.2.1.2 Constraints on the COMMON-LISP Package for Conforming Programs
.........................................................................

Except where explicitly allowed, the consequences are undefined if any
of the following actions are performed on an external symbol of the
‘COMMON-LISP’ package:

  1. Binding or altering its value (lexically or dynamically).  (Some
     exceptions are noted below.)

  2. Defining, undefining, or binding it as a function.  (Some
     exceptions are noted below.)

  3. Defining, undefining, or binding it as a macro or compiler macro.
     (Some exceptions are noted below.)

  4. Defining it as a type specifier (via ‘defstruct’, ‘defclass’,
     ‘deftype’, ‘define-condition’).

  5. Defining it as a structure (via ‘defstruct’).

  6. Defining it as a declaration with a ‘declaration’ proclamation.

  7. Defining it as a symbol macro.

  8. Altering its home package.

  9. Tracing it (via ‘trace’).

  10. Declaring or proclaiming it ‘special’ (via declare, ‘declaim’, or
     ‘proclaim’).

  11. Declaring or proclaiming its ‘type’ or ‘ftype’ (via declare,
     ‘declaim’, or ‘proclaim’).  (Some exceptions are noted below.)

  12. Removing it from the ‘COMMON-LISP’ package.

  13. Defining a setf expander for it (via ‘defsetf’ or
     ‘define-setf-method’).

  14. Defining, undefining, or binding its setf function name.

  15. Defining it as a method combination type (via
     ‘define-method-combination’).

  16. Using it as the class-name argument to ‘setf’ of ‘find-class’.

  17. Binding it as a catch tag.

  18. Binding it as a restart name.

  19. Defining a method for a standardized generic function which is
     applicable when all of the arguments are direct instances of
     standardized classes.

11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs
..............................................................................................

If an external symbol of the ‘COMMON-LISP’ package is not globally
defined as a standardized dynamic variable or constant variable, it is
allowed to lexically bind it and to declare the ‘type’ of that binding,
and it is allowed to locally establish it as a symbol macro (e.g., with
‘symbol-macrolet’).

Unless explicitly specified otherwise, if an external symbol of the
‘COMMON-LISP’ package is globally defined as a standardized dynamic
variable, it is permitted to bind or assign that dynamic variable
provided that the “Value Type” constraints on the dynamic variable are
maintained, and that the new value of the variable is consistent with
the stated purpose of the variable.

If an external symbol of the ‘COMMON-LISP’ package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind it as a function (e.g., with ‘flet’), to declare the
‘ftype’ of that binding, and (in implementations which provide the
ability to do so) to ‘trace’ that binding.

If an external symbol of the ‘COMMON-LISP’ package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind it as a macro (e.g., with ‘macrolet’).

If an external symbol of the ‘COMMON-LISP’ package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind its setf function name as a function, and to declare the
‘ftype’ of that binding.

11.1.2.2 The COMMON-LISP-USER Package
.....................................

The ‘COMMON-LISP-USER’ package is the current package when a Common
Lisp system starts up.  This package uses the ‘COMMON-LISP’ package.
The ‘COMMON-LISP-USER’ package has the nickname ‘CL-USER’.  The
‘COMMON-LISP-USER’ package can have additional symbols interned within
it; it can use other implementation-defined packages.

11.1.2.3 The KEYWORD Package
............................

The ‘KEYWORD’ package contains symbols, called keywordsthat are
typically used as special markers in programs and their associated data
expressions

Symbol tokens that start with a package marker are parsed by the Lisp
reader as symbols in the ‘KEYWORD’ package; see *note Section 2.3.4
(Symbols as Tokens): Symbols as Tokens.  This makes it notationally
convenient to use keywords when communicating between programs in
different packages.  For example, the mechanism for passing keyword
parameters in a call uses keywordssee *note Section 3.4.1 (Ordinary
Lambda Lists): Ordinary Lambda Lists.

Symbols in the ‘KEYWORD’ package are, by definition, of type ‘keyword’.

11.1.2.3.1 Interning a Symbol in the KEYWORD Package
....................................................

The ‘KEYWORD’ package is treated differently than other packages in that
special actions are taken when a symbol is interned in it.  In
particular, when a symbol is interned in the ‘KEYWORD’ package, it is
automatically made to be an external symbol and is automatically made to
be a constant variable with itself as a value.

11.1.2.3.2 Notes about The KEYWORD Package
..........................................

It is generally best to confine the use of keywords to situations in
which there are a finitely enumerable set of names to be selected
between.  For example, if there were two states of a light switch, they
might be called :on and :off.

In situations where the set of names is not finitely enumerable (i.e.,
where name conflicts might arise) it is frequently best to use symbols
in some package other than ‘KEYWORD’ so that conflicts will be naturally
avoided.  For example, it is generally not wise for a program to use a
keywordas a property indicator, since if there were ever another program
that did the same thing, each would clobber the other’s data.

11.1.2.4 Implementation-Defined Packages
........................................

Other, implementation-defined packages might be present in the initial
Common Lisp environment.

It is recommended, but not required, that the documentation for a
conforming implementation contain a full list of all package names
initially present in that implementation but not specified in this
specification.  (See also the function ‘list-all-packages’.)


File: ansicl,  Node: package,  Next: export,  Prev: Package Concepts,  Up: Packages

package (System Class)
======================

Class Precedence List:
......................

‘package’, ‘t’

Description:
............

A package is a namespace that maps symbol names to symbols; see *note
Section 11.1 (Package Concepts): Package Concepts.

See Also:
.........

*note Section 11.1 (Package Concepts): Package Concepts, *note Section
22.1.3.13 (Printing Other Objects): PrintingOtherObjects, *note Section
2.3.4 (Symbols as Tokens): Symbols as Tokens.


File: ansicl,  Node: export,  Next: find-symbol,  Prev: package,  Up: Packages

export (Function)
=================

Syntax:
.......

 -- Function: export symbols &optional package → ‘t’

Arguments and Values:
.....................

SYMBOLS—a designator for a list of symbols.

PACKAGE—a package designator.  The default is the current package.

Description:
............

‘export’ makes one or more SYMBOLS that are accessible in PACKAGE
(whether directly or by inheritance) be external symbols of that
PACKAGE.

If any of the SYMBOLS is already accessible as an external symbol of
PACKAGE, ‘export’ has no effect on that symbol.  If the SYMBOL is
present in PACKAGE as an internal symbol, it is simply changed to
external status.  If it is accessible as an internal symbol via
‘use-package’, it is first imported into PACKAGE, then exported.  (The
SYMBOL is then present in the PACKAGE whether or not PACKAGE continues
to use the package through which the symbol was originally inherited.)

‘export’ makes each SYMBOL accessible to all the packages that use
PACKAGE.  All of these packages are checked for name conflicts: ‘(export
s p)’ does ‘(find-symbol (symbol-name s) q)’ for each package q in
‘(package-used-by-list p)’.  Note that in the usual case of an ‘export’
during the initial definition of a package, the result of
‘package-used-by-list’ is ‘nil’ and the name-conflict checking takes
negligible time.  When multiple changes are to be made, for example when
‘export’ is given a LIST of SYMBOLS, it is permissible for the
implementation to process each change separately, so that aborting from
a name conflict caused by any but the first SYMBOL in the list does not
unexport the first SYMBOL in the LIST.  However, aborting from a
name-conflict error caused by ‘export’ of one of SYMBOLS does not leave
that symbol accessible to some packages and inaccessible to others; with
respect to each of SYMBOLS processed, ‘export’ behaves as if it were as
an atomic operation.

A name conflict in ‘export’ between one of SYMBOLS being exported and a
symbol already present in a package that would inherit the
newly-exported symbol may be resolved in favor of the exported symbol by
uninterning the other one, or in favor of the already-present symbol by
making it a shadowing symbol.

Examples:
.........

      (make-package 'temp :use nil) → #<PACKAGE "TEMP">
      (use-package 'temp) → T
      (intern "TEMP-SYM" 'temp) → TEMP::TEMP-SYM, NIL
      (find-symbol "TEMP-SYM") → NIL, NIL
      (export (find-symbol "TEMP-SYM" 'temp) 'temp) → T
      (find-symbol "TEMP-SYM") → TEMP-SYM, :INHERITED

Side Effects:
.............

The package system is modified.

Affected By:
............

Accessible symbols.

Exceptional Situations:
.......................

If any of the SYMBOLS is not accessible at all in PACKAGE, an error of
type ‘package-error’ is signaled that is correctable by permitting the
user to interactively specify whether that symbol should be imported.

See Also:
.........

*note import::, *note unexport::, *note Section 11.1 (Package Concepts):
Package Concepts.


File: ansicl,  Node: find-symbol,  Next: find-package,  Prev: export,  Up: Packages

find-symbol (Function)
======================

Syntax:
.......

 -- Function: find-symbol string &optional package → symbol, status

Arguments and Values:
.....................

STRING—a string.

PACKAGE—a package designator.  The default is the current package.

SYMBOL—a symbol accessible in the PACKAGE, or ‘nil’.

STATUS—one of :inherited, :external, :internal, or ‘nil’.

Description:
............

‘find-symbol’ locates a symbol whose name is STRING in a package.  If a
symbol named STRING is found in PACKAGE, directly or by inheritance, the
symbol found is returned as the first value; the second value is as
follows:

:internal

     If the symbol is present in PACKAGE as an internal symbol.

:external

     If the symbol is present in PACKAGE as an external symbol.

:inherited

     If the symbol is inherited by PACKAGE through ‘use-package’, but is
     not present in PACKAGE.

If no such symbol is accessible in PACKAGE, both values are ‘nil’.

Examples:
.........

      (find-symbol "NEVER-BEFORE-USED") → NIL, NIL
      (find-symbol "NEVER-BEFORE-USED") → NIL, NIL
      (intern "NEVER-BEFORE-USED") → NEVER-BEFORE-USED, NIL
      (intern "NEVER-BEFORE-USED") → NEVER-BEFORE-USED, :INTERNAL
      (find-symbol "NEVER-BEFORE-USED") → NEVER-BEFORE-USED, :INTERNAL
      (find-symbol "never-before-used") → NIL, NIL
      (find-symbol "CAR" 'common-lisp-user) → CAR, :INHERITED
      (find-symbol "CAR" 'common-lisp) → CAR, :EXTERNAL
      (find-symbol "NIL" 'common-lisp-user) → NIL, :INHERITED
      (find-symbol "NIL" 'common-lisp) → NIL, :EXTERNAL
      (find-symbol "NIL" (prog1 (make-package "JUST-TESTING" :use '())
                                (intern "NIL" "JUST-TESTING")))
     → JUST-TESTING::NIL, :INTERNAL
      (export 'just-testing::nil 'just-testing)
      (find-symbol "NIL" 'just-testing) → JUST-TESTING:NIL, :EXTERNAL
      (find-symbol "NIL" "KEYWORD")
     → NIL, NIL
     or→ :NIL, :EXTERNAL
      (find-symbol (symbol-name :nil) "KEYWORD") → :NIL, :EXTERNAL

Affected By:
............

‘intern’, ‘import’, ‘export’, ‘use-package’, ‘unintern’, ‘unexport’,
‘unuse-package’

See Also:
.........

*note intern::, *note find-all-symbols::

Notes:
......

‘find-symbol’ is operationally equivalent to ‘intern’, except that it
never creates a new symbol.


File: ansicl,  Node: find-package,  Next: find-all-symbols,  Prev: find-symbol,  Up: Packages

find-package (Function)
=======================

Syntax:
.......

 -- Function: find-package name → package

Arguments and Values:
.....................

NAME—a string designator or a package object.

PACKAGE—a package object or ‘nil’.

Description:
............

If NAME is a string designator, ‘find-package’ locates and returns the
package whose name or nickname is NAME.  This search is case sensitive.
If there is no such package, ‘find-package’ returns ‘nil’.

If NAME is a package object, that package object is returned.

Examples:
.........

      (find-package 'common-lisp) → #<PACKAGE "COMMON-LISP">
      (find-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
      (find-package 'not-there) → NIL

Affected By:
............

The set of packages created by the implementation.

‘defpackage’, ‘delete-package’, ‘make-package’, ‘rename-package’

See Also:
.........

*note make-package::


File: ansicl,  Node: find-all-symbols,  Next: import,  Prev: find-package,  Up: Packages

find-all-symbols (Function)
===========================

Syntax:
.......

 -- Function: find-all-symbols string → symbols

Arguments and Values:
.....................

STRING—a string designator.

SYMBOLS—a list of symbols.

Description:
............

‘find-all-symbols’ searches name that is the same (under ‘string=’) as
STRING.  A list of all such symbols is returned.  Whether or how the
list is ordered is implementation-dependent.

Examples:
.........

      (find-all-symbols 'car)
     → (CAR)
     or→ (CAR VEHICLES:CAR)
     or→ (VEHICLES:CAR CAR)
      (intern "CAR" (make-package 'temp :use nil)) → TEMP::CAR, NIL
      (find-all-symbols 'car)
     → (TEMP::CAR CAR)
     or→ (CAR TEMP::CAR)
     or→ (TEMP::CAR CAR VEHICLES:CAR)
     or→ (CAR TEMP::CAR VEHICLES:CAR)

See Also:
.........

*note find-symbol::


File: ansicl,  Node: import,  Next: list-all-packages,  Prev: find-all-symbols,  Up: Packages

import (Function)
=================

Syntax:
.......

 -- Function: import symbols &optional package → ‘t’

Arguments and Values:
.....................

SYMBOLS—a designator for a list of symbols.

PACKAGE—a package designator.  The default is the current package.

Description:
............

‘import’ adds SYMBOL or SYMBOLS to the internals of PACKAGE, checking
for name conflicts with existing symbols either present in PACKAGE or
accessible to it.  Once the SYMBOLS have been imported, they may be
referenced in the importing PACKAGE without the use of a package prefix
when using the Lisp reader.

A name conflict in ‘import’ between the SYMBOL being imported and a
symbol inherited from some other package can be resolved in favor of the
SYMBOL being imported by making it a shadowing symbol, or in favor of
the symbol already accessible by not doing the ‘import’.  A name
conflict in ‘import’ with a symbol already present in the PACKAGE may be
resolved by uninterning that symbol, or by not doing the ‘import’.

The imported symbol is not automatically exported from the current
package, but if it is already present and external, then the fact that
it is external is not changed.  If any symbol to be imported has no home
package (i.e., ‘(symbol-package SYMBOL) → nil’), ‘import’ sets the home
package of the SYMBOL to PACKAGE.

If the SYMBOL is already present in the importing PACKAGE, ‘import’ has
no effect.

Examples:
.........

      (import 'common-lisp::car (make-package 'temp :use nil)) → T
      (find-symbol "CAR" 'temp) → CAR, :INTERNAL
      (find-symbol "CDR" 'temp) → NIL, NIL

The form ‘(import 'editor:buffer)’ takes the external symbol named
‘buffer’ in the ‘EDITOR’ package (this symbol was located when the form
was read by the Lisp reader) and adds it to the current package as an
internal symbol.  The symbol ‘buffer’ is then present in the current
package.

Side Effects:
.............

The package system is modified.

Affected By:
............

Current state of the package system.

Exceptional Situations:
.......................

‘import’ signals a correctable error of type ‘package-error’ if any of
the SYMBOLS to be imported has the same name (under ‘string=’) as some
distinct symbol (under ‘eql’) already accessible in the PACKAGE, even if
the conflict is with a shadowing symbol of the PACKAGE.

See Also:
.........

*note shadow::, *note export::


File: ansicl,  Node: list-all-packages,  Next: rename-package,  Prev: import,  Up: Packages

list-all-packages (Function)
============================

Syntax:
.......

 -- Function: list-all-packages <no arguments> → packages

Arguments and Values:
.....................

PACKAGES—a list of package objects.

Description:
............

‘list-all-packages’ returns a fresh list of all registered packages.

Examples:
.........

      (let ((before (list-all-packages)))
         (make-package 'temp)
         (set-difference (list-all-packages) before)) → (#<PACKAGE "TEMP">)

Affected By:
............

‘defpackage’, ‘delete-package’, ‘make-package’


File: ansicl,  Node: rename-package,  Next: shadow,  Prev: list-all-packages,  Up: Packages

rename-package (Function)
=========================

Syntax:
.......

 -- Function: rename-package package new-name &optional new-nicknames →
          package-object

Arguments and Values:
.....................

PACKAGE—a package designator.

NEW-NAME—a package designator.

NEW-NICKNAMES—a list of string designators.  The default is the empty
list.

PACKAGE-OBJECT—the renamed PACKAGE object.

Description:
............

Replaces the name and nicknames of PACKAGE.  The old name and all of the
old nicknames of PACKAGE are eliminated and are replaced by NEW-NAME and
NEW-NICKNAMES.

The consequences are undefined if NEW-NAME or any NEW-NICKNAME conflicts
with any existing package names.

Examples:
.........

      (make-package 'temporary :nicknames '("TEMP")) → #<PACKAGE "TEMPORARY">
      (rename-package 'temp 'ephemeral) → #<PACKAGE "EPHEMERAL">
      (package-nicknames (find-package 'ephemeral)) → ()
      (find-package 'temporary) → NIL
      (rename-package 'ephemeral 'temporary '(temp fleeting))
     → #<PACKAGE "TEMPORARY">
      (package-nicknames (find-package 'temp)) → ("TEMP" "FLEETING")

See Also:
.........

*note make-package::


File: ansicl,  Node: shadow,  Next: shadowing-import,  Prev: rename-package,  Up: Packages

shadow (Function)
=================

Syntax:
.......

 -- Function: shadow symbol-names &optional package → ‘t’

Arguments and Values:
.....................

SYMBOL-NAMES—a designator for a list of string designators.

PACKAGE—a package designator.  The default is the current package.

Description:
............

‘shadow’ assures that symbols with names given by SYMBOL-NAMES are
present in the PACKAGE.

Specifically, PACKAGE is searched for symbols with the names supplied by
SYMBOL-NAMES.  For each such name, if a corresponding symbol is not
present in PACKAGE (directly, not by inheritance), then a corresponding
symbol is created with that name, and inserted into PACKAGE as an
internal symbol.  The corresponding symbol, whether pre-existing or
newly created, is then added, if not already present, to the shadowing
symbols list of PACKAGE.

Examples:
.........

      (package-shadowing-symbols (make-package 'temp)) → NIL
      (find-symbol 'car 'temp) → CAR, :INHERITED
      (shadow 'car 'temp) → T
      (find-symbol 'car 'temp) → TEMP::CAR, :INTERNAL
      (package-shadowing-symbols 'temp) → (TEMP::CAR)

      (make-package 'test-1) → #<PACKAGE "TEST-1">
      (intern "TEST" (find-package 'test-1)) → TEST-1::TEST, NIL
      (shadow 'test-1::test (find-package 'test-1)) → T
      (shadow 'TEST (find-package 'test-1)) → T
      (assert (not (null (member 'test-1::test (package-shadowing-symbols
                                                 (find-package 'test-1))))))

      (make-package 'test-2) → #<PACKAGE "TEST-2">
      (intern "TEST" (find-package 'test-2)) → TEST-2::TEST, NIL
      (export 'test-2::test (find-package 'test-2)) → T
      (use-package 'test-2 (find-package 'test-1))    ;should not error


Side Effects:
.............

‘shadow’ changes the state of the package system in such a way that the
package consistency rules do not hold across the change.

Affected By:
............

Current state of the package system.

See Also:
.........

*note package-shadowing-symbols::, *note Section 11.1 (Package
Concepts): Package Concepts.

Notes:
......

If a symbol with a name in SYMBOL-NAMES already exists in PACKAGE, but
by inheritance, the inherited symbol becomes shadowed


File: ansicl,  Node: shadowing-import,  Next: delete-package,  Prev: shadow,  Up: Packages

shadowing-import (Function)
===========================

Syntax:
.......

 -- Function: shadowing-import symbols &optional package → ‘t’

Arguments and Values:
.....................

SYMBOLS—a designator for a list of symbols.

PACKAGE —a package designator.  The default is the current package.

Description:
............

‘shadowing-import’ is like ‘import’, but it does not signal an error
even if the importation of a symbol would shadow some symbol already
accessible in PACKAGE.

‘shadowing-import’ inserts each of SYMBOLS into PACKAGE as an internal
symbol, regardless of whether another symbol of the same name is
shadowed by this action.  If a different symbol of the same name is
already present in PACKAGE, that symbol is first uninterned from
PACKAGE.  The new symbol is added to PACKAGE’s shadowing-symbols list.

‘shadowing-import’ does name-conflict checking to the extent that it
checks whether a distinct existing symbol with the same name is
accessible; if so, it is shadowed by the new symbol, which implies that
it must be uninterned if it was present in PACKAGE.

Examples:
.........

      (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
      (setq sym (intern "CONFLICT")) → CONFLICT
      (intern "CONFLICT" (make-package 'temp)) → TEMP::CONFLICT, NIL
      (package-shadowing-symbols 'temp) → NIL
      (shadowing-import sym 'temp) → T
      (package-shadowing-symbols 'temp) → (CONFLICT)

Side Effects:
.............

‘shadowing-import’ changes the state of the package system in such a way
that the consistency rules do not hold across the change.

PACKAGE’s shadowing-symbols list is modified.

Affected By:
............

Current state of the package system.

See Also:
.........

*note import::, *note unintern::, *note package-shadowing-symbols::


File: ansicl,  Node: delete-package,  Next: make-package,  Prev: shadowing-import,  Up: Packages

delete-package (Function)
=========================

Syntax:
.......

 -- Function: delete-package package → generalized-boolean

Arguments and Values:
.....................

PACKAGE—a package designator.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘delete-package’ deletes PACKAGE from all package system data
structures.  If the operation is successful, ‘delete-package’ returns
true, otherwise ‘nil’.  The effect of ‘delete-package’ is that the name
and nicknames of PACKAGE cease to be recognized package names.  The
package object is still a package (i.e., ‘packagep’ is true of it) but
‘package-name’ returns ‘nil’.  The consequences of deleting the
‘COMMON-LISP’ package or the ‘KEYWORD’ package are undefined.  The
consequences of invoking any other package operation on PACKAGE once it
has been deleted are unspecified.  In particular, the consequences of
invoking ‘find-symbol’, ‘intern’ and other functions that look for a
symbol name in a package are unspecified if they are called with
‘*package*’ bound to the deleted PACKAGE or with the deleted PACKAGE as
an argument.

If PACKAGE is a package object that has already been deleted,
‘delete-package’ immediately returns ‘nil’.

After this operation completes, the home package of any symbol whose
home package had previously been PACKAGE is implementation-dependent.
Except for this, symbols accessible in PACKAGE are not modified in any
other way; symbols whose home package is not PACKAGE remain unchanged.

Examples:
.........

      (setq *foo-package* (make-package "FOO" :use nil))
      (setq *foo-symbol*  (intern "FOO" *foo-package*))
      (export *foo-symbol* *foo-package*)

      (setq *bar-package* (make-package "BAR" :use '("FOO")))
      (setq *bar-symbol*  (intern "BAR" *bar-package*))
      (export *foo-symbol* *bar-package*)
      (export *bar-symbol* *bar-package*)

      (setq *baz-package* (make-package "BAZ" :use '("BAR")))

      (symbol-package *foo-symbol*) → #<PACKAGE "FOO">
      (symbol-package *bar-symbol*) → #<PACKAGE "BAR">

      (prin1-to-string *foo-symbol*) → "FOO:FOO"
      (prin1-to-string *bar-symbol*) → "BAR:BAR"

      (find-symbol "FOO" *bar-package*) → FOO:FOO, :EXTERNAL

      (find-symbol "FOO" *baz-package*) → FOO:FOO, :INHERITED
      (find-symbol "BAR" *baz-package*) → BAR:BAR, :INHERITED

      (packagep *foo-package*) → true
      (packagep *bar-package*) → true
      (packagep *baz-package*) → true

      (package-name *foo-package*) → "FOO"
      (package-name *bar-package*) → "BAR"
      (package-name *baz-package*) → "BAZ"

      (package-use-list *foo-package*) → ()
      (package-use-list *bar-package*) → (#<PACKAGE "FOO">)
      (package-use-list *baz-package*) → (#<PACKAGE "BAR">)

      (package-used-by-list *foo-package*) → (#<PACKAGE "BAR">)
      (package-used-by-list *bar-package*) → (#<PACKAGE "BAZ">)
      (package-used-by-list *baz-package*) → ()

      (delete-package *bar-package*)
     ▷ Error: Package BAZ uses package BAR.
     ▷ If continued, BAZ will be made to unuse-package BAR,
     ▷ and then BAR will be deleted.
     ▷ Type :CONTINUE to continue.
     ▷ Debug> :CONTINUE
     → T

      (symbol-package *foo-symbol*) → #<PACKAGE "FOO">
      (symbol-package *bar-symbol*) is unspecified

      (prin1-to-string *foo-symbol*) → "FOO:FOO"
      (prin1-to-string *bar-symbol*) is unspecified

      (find-symbol "FOO" *bar-package*) is unspecified

      (find-symbol "FOO" *baz-package*) → NIL, NIL
      (find-symbol "BAR" *baz-package*) → NIL, NIL

      (packagep *foo-package*) → T
      (packagep *bar-package*) → T
      (packagep *baz-package*) → T

      (package-name *foo-package*) → "FOO"
      (package-name *bar-package*) → NIL
      (package-name *baz-package*) → "BAZ"

      (package-use-list *foo-package*) → ()
      (package-use-list *bar-package*) is unspecified
      (package-use-list *baz-package*) → ()

      (package-used-by-list *foo-package*) → ()
      (package-used-by-list *bar-package*) is unspecified
      (package-used-by-list *baz-package*) → ()

Exceptional Situations:
.......................

If the PACKAGE designator is a name that does not currently name a
package, a correctable error of type ‘package-error’ is signaled.  If
correction is attempted, no deletion action is attempted; instead,
‘delete-package’ immediately returns ‘nil’.

If PACKAGE is used by other packages, a correctable error of type
‘package-error’ is signaled.  If correction is attempted,
‘unuse-package’ is effectively called to remove any dependencies,
causing PACKAGE’s external symbols to cease being accessible to those
packages that use PACKAGE.  ‘delete-package’ then deletes PACKAGE just
as it would have had there been no packages that used it.

See Also:
.........

*note unuse-package::


File: ansicl,  Node: make-package,  Next: with-package-iterator,  Prev: delete-package,  Up: Packages

make-package (Function)
=======================

Syntax:
.......

 -- Function: make-package package-name &key nicknames use → package

Arguments and Values:
.....................

PACKAGE-NAME—a string designator.

NICKNAMES—a list of string designators.  The default is the empty list.

USE— a list of package designators.  The default is
implementation-defined.

PACKAGE—a package.

Description:
............

Creates a new package with the name PACKAGE-NAME.

NICKNAMES are additional names which may be used to refer to the new
package.

USE specifies zero or more packages the external symbols of which are to
be inherited by the new package.  See the function *note use-package::.

Examples:
.........

      (make-package 'temporary :nicknames '("TEMP" "temp")) → #<PACKAGE "TEMPORARY">
      (make-package "OWNER" :use '("temp")) → #<PACKAGE "OWNER">
      (package-used-by-list 'temp) → (#<PACKAGE "OWNER">)
      (package-use-list 'owner) → (#<PACKAGE "TEMPORARY">)

Affected By:
............

The existence of other packages in the system.

Exceptional Situations:
.......................

The consequences are unspecified if packages denoted by USE do not
exist.

A correctable error is signaled if the PACKAGE-NAME or any of the
NICKNAMES is already the name or nickname of an existing package.

See Also:
.........

*note defpackage::, *note use-package::

Notes:
......

In situations where the packages to be used contain symbols which would
conflict, it is necessary to first create the package with ‘:use '()’,
then to use ‘shadow’ or ‘shadowing-import’ to address the conflicts, and
then after that to use ‘use-package’ once the conflicts have been
addressed.

When packages are being created as part of the static definition of a
program rather than dynamically by the program, it is generally
considered more stylistically appropriate to use ‘defpackage’ rather
than ‘make-package’.


File: ansicl,  Node: with-package-iterator,  Next: unexport,  Prev: make-package,  Up: Packages

with-package-iterator (Macro)
=============================

Syntax:
.......

 -- Macro: with-package-iterator (name package-list-form &rest
          symbol-types) {declaration}* {form}* → {result}*

Arguments and Values:
.....................

NAME—a symbol.

PACKAGE-LIST-FORM—a form; evaluated once to produce a PACKAGE-LIST.

PACKAGE-LIST—a designator for a list of package designators.

SYMBOL-TYPE—one of the symbols :internal, :external, or :inherited.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—the values of the FORMS.

Description:
............

Within the lexical scope of the body FORMS, the NAME is defined via
‘macrolet’ such that successive invocations of ‘(NAME)’ will return the
symbols, one by one, from the packages in PACKAGE-LIST.

It is unspecified whether symbols inherited from multiple packages are
returned more than once.  The order of symbols returned does not
necessarily reflect the order of packages in PACKAGE-LIST.  When
PACKAGE-LIST has more than one element, it is unspecified whether
duplicate symbols are returned once or more than once.

SYMBOL-TYPES controls which symbols that are accessible in a package are
returned as follows:

:internal

     The symbols that are present in the package, but that are not
     exported.

:external

     The symbols that are present in the package and are exported.

:inherited

     The symbols that are exported by used packages and that are not
     shadowed.

When more than one argument is supplied for SYMBOL-TYPES, a symbol is
returned if its accessibility matches any one of the SYMBOL-TYPES
supplied.  Implementations may extend this syntax by recognizing
additional symbol accessibility types.

An invocation of ‘(NAME)’ returns four values as follows:

  1. A flag that indicates whether a symbol is returned (true means that
     a symbol is returned).
  2. A symbol that is accessible in one the indicated packages.
  3. The accessibility type for that symbol; i.e., one of the symbols
     :internal, :external, or :inherited.
  4. The package from which the symbol was obtained.  The package is one
     of the packages present or named in PACKAGE-LIST.

After all symbols have been returned by successive invocations of
‘(NAME)’, then only one value is returned, namely ‘nil’.

The meaning of the second, third, and fourth values is that the returned
symbol is accessible in the returned package in the way indicated by the
second return value as follows:

:internal

     Means present and not exported.

:external

     Means present and exported.

:inherited

     Means not present (thus not shadowed) but inherited from some used
     package.

It is unspecified what happens if any of the implicit interior state of
an iteration is returned outside the dynamic extent of the
‘with-package-iterator’ form such as by returning some closure over the
invocation form.

Any number of invocations of ‘with-package-iterator’ can be nested, and
the body of the innermost one can invoke all of the locally established
macros, provided all those macros have distinct names.

Examples:
.........

The following function should return ‘t’ on any package, and signal an
error if the usage of ‘with-package-iterator’ does not agree with the
corresponding usage of ‘do-symbols’.

      (defun test-package-iterator (package)
        (unless (packagep package)
          (setq package (find-package package)))
        (let ((all-entries '())
              (generated-entries '()))
          (do-symbols (x package)
            (multiple-value-bind (symbol accessibility)
                (find-symbol (symbol-name x) package)
              (push (list symbol accessibility) all-entries)))
          (with-package-iterator (generator-fn package
                                  :internal :external :inherited)
            (loop
              (multiple-value-bind (more? symbol accessibility pkg)
                  (generator-fn)
                (unless more? (return))
                (let ((l (multiple-value-list (find-symbol (symbol-name symbol)
                                                           package))))
                  (unless (equal l (list symbol accessibility))
                    (error "Symbol ~S not found as ~S in package ~A [~S]"
                           symbol accessibility (package-name package) l))
                  (push l generated-entries)))))
          (unless (and (subsetp all-entries generated-entries :test #'equal)
                       (subsetp generated-entries all-entries :test #'equal))
           (error "Generated entries and Do-Symbols entries don't correspond"))
          t))

The following function prints out every present symbol (possibly more
than once):

      (defun print-all-symbols ()
        (with-package-iterator (next-symbol (list-all-packages)
                                :internal :external)
          (loop
            (multiple-value-bind (more? symbol) (next-symbol)
              (if more?
                 (print symbol)
                 (return))))))

Exceptional Situations:
.......................

‘with-package-iterator’ signals an error of type ‘program-error’ if no
SYMBOL-TYPES are supplied or if a SYMBOL-TYPE is not recognized by the
implementation is supplied.

The consequences are undefined if the local function named NAME
established by ‘with-package-iterator’ is called after it has returned
false as its primary value.

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: ansicl,  Node: unexport,  Next: unintern,  Prev: with-package-iterator,  Up: Packages

unexport (Function)
===================

Syntax:
.......

 -- Function: unexport symbols &optional package → ‘t’

Arguments and Values:
.....................

SYMBOLS—a designator for a list of symbols.

PACKAGE—a package designator.  The default is the current package.

Description:
............

‘unexport’ reverts external SYMBOLS in PACKAGE to internal status; it
undoes the effect of ‘export’.

‘unexport’ works only on symbols present in PACKAGE, switching them back
to internal status.  If ‘unexport’ is given a symbol that is already
accessible as an internal symbol in PACKAGE, it does nothing.

Examples:
.........

      (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
      (export (intern "CONTRABAND" (make-package 'temp)) 'temp) → T
      (find-symbol "CONTRABAND") → NIL, NIL
      (use-package 'temp) → T
      (find-symbol "CONTRABAND") → CONTRABAND, :INHERITED
      (unexport 'contraband 'temp) → T
      (find-symbol "CONTRABAND") → NIL, NIL

Side Effects:
.............

Package system is modified.

Affected By:
............

Current state of the package system.

Exceptional Situations:
.......................

If ‘unexport’ is given a symbol not accessible in PACKAGE at all, an
error of type ‘package-error’ is signaled.

The consequences are undefined if PACKAGE is the ‘KEYWORD’ package or
the ‘COMMON-LISP’ package.

See Also:
.........

*note export::, *note Section 11.1 (Package Concepts): Package Concepts.


File: ansicl,  Node: unintern,  Next: in-package,  Prev: unexport,  Up: Packages

unintern (Function)
===================

Syntax:
.......

 -- Function: unintern symbol &optional package → generalized-boolean

Arguments and Values:
.....................

SYMBOL—a symbol.

PACKAGE—a package designator.  The default is the current package.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘unintern’ removes SYMBOL from PACKAGE.  If SYMBOL is present in
PACKAGE, it is removed from PACKAGE and also from PACKAGE’s shadowing
symbols list if it is present there.  If PACKAGE is the home package for
SYMBOL, SYMBOL is made to have no home package.  SYMBOL may continue to
be accessible in PACKAGE by inheritance.

Use of ‘unintern’ can result in a symbol that has no recorded home
package, but that in fact is accessible in some package.  Common
Lisp does not check for this pathological case, and such symbols are
always printed preceded by ‘#:’.

‘unintern’ returns true if it removes SYMBOL, and ‘nil’ otherwise.

Examples:
.........

      (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
      (setq temps-unpack (intern "UNPACK" (make-package 'temp))) → TEMP::UNPACK
      (unintern temps-unpack 'temp) → T
      (find-symbol "UNPACK" 'temp) → NIL, NIL
      temps-unpack → #:UNPACK

Side Effects:
.............

‘unintern’ changes the state of the package system in such a way that
the consistency rules do not hold across the change.

Affected By:
............

Current state of the package system.

Exceptional Situations:
.......................

Giving a shadowing symbol to ‘unintern’ can uncover a name conflict that
had previously been resolved by the shadowing.  If package A uses
packages B and C, A contains a shadowing symbol ‘x’, and B and C each
contain external symbols named ‘x’, then removing the shadowing symbol
‘x’ from A will reveal a name conflict between ‘b:x’ and ‘c:x’ if those
two symbols are distinct.  In this case ‘unintern’ will signal an error.

See Also:
.........

*note Section 11.1 (Package Concepts): Package Concepts.


File: ansicl,  Node: in-package,  Next: unuse-package,  Prev: unintern,  Up: Packages

in-package (Macro)
==================

Syntax:
.......

 -- Macro: in-package name → package

Arguments and Values:
.....................

NAME—a string designator; not evaluated.

PACKAGE—the package named by NAME.

Description:
............

Causes the the package named by NAME to become the current package—that
is, the value of ‘*package*’.  If no such package already exists, an
error of type ‘package-error’ is signaled.

Everything ‘in-package’ does is also performed at compile time if the
call appears as a top level form.

Side Effects:
.............

The variable ‘*package*’ is assigned.  If the ‘in-package’ form is a top
level form, this assignment also occurs at compile time.

Exceptional Situations:
.......................

An error of type ‘package-error’ is signaled if the specified package
does not exist.

See Also:
.........

*note *package*::


File: ansicl,  Node: unuse-package,  Next: use-package,  Prev: in-package,  Up: Packages

unuse-package (Function)
========================

Syntax:
.......

 -- Function: unuse-package packages-to-unuse &optional package → ‘t’

Arguments and Values:
.....................

PACKAGES-TO-UNUSE—a designator for a list of package designators.

PACKAGE—a package designator.  The default is the current package.

Description:
............

‘unuse-package’ causes PACKAGE to cease inheriting all the external
symbols of PACKAGES-TO-UNUSE; ‘unuse-package’ undoes the effects of
‘use-package’.  The PACKAGES-TO-UNUSE are removed from the use list of
PACKAGE.

Any symbols that have been imported into PACKAGE continue to be present
in PACKAGE.

Examples:
.........

      (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
      (export (intern "SHOES" (make-package 'temp)) 'temp) → T
      (find-symbol "SHOES") → NIL, NIL
      (use-package 'temp) → T
      (find-symbol "SHOES") → SHOES, :INHERITED
      (find (find-package 'temp) (package-use-list 'common-lisp-user)) → #<PACKAGE "TEMP">
      (unuse-package 'temp) → T
      (find-symbol "SHOES") → NIL, NIL

Side Effects:
.............

The use list of PACKAGE is modified.

Affected By:
............

Current state of the package system.

See Also:
.........

*note use-package::, *note package-use-list::


File: ansicl,  Node: use-package,  Next: defpackage,  Prev: unuse-package,  Up: Packages

use-package (Function)
======================

Syntax:
.......

 -- Function: use-package packages-to-use &optional package → ‘t’

Arguments and Values:
.....................

PACKAGES-TO-USE—a designator for a list of package designators.  The
‘KEYWORD’ package may not be supplied.

PACKAGE—a package designator.  The default is the current package.  The
PACKAGE cannot be the ‘KEYWORD’ package.

Description:
............

‘use-package’ causes PACKAGE to inherit all the external symbols of
PACKAGES-TO-USE.  The inherited symbols become accessible as internal
symbols of PACKAGE.

PACKAGES-TO-USE are added to the use list of PACKAGE if they are not
there already.  All external symbols in PACKAGES-TO-USE become
accessible in PACKAGE as internal symbols.  ‘use-package’ does not cause
any new symbols to be present in PACKAGE but only makes them accessible
by inheritance.

‘use-package’ checks for name conflicts between the newly imported
symbols and those already accessible in PACKAGE.  A name conflict in
‘use-package’ between two external symbols inherited by PACKAGE from
PACKAGES-TO-USE may be resolved in favor of either symbol by importing
one of them into PACKAGE and making it a shadowing symbol.

Examples:
.........

      (export (intern "LAND-FILL" (make-package 'trash)) 'trash) → T
      (find-symbol "LAND-FILL" (make-package 'temp)) → NIL, NIL
      (package-use-list 'temp) → (#<PACKAGE "TEMP">)
      (use-package 'trash 'temp) → T
      (package-use-list 'temp) → (#<PACKAGE "TEMP"> #<PACKAGE "TRASH">)
      (find-symbol "LAND-FILL" 'temp) → TRASH:LAND-FILL, :INHERITED

Side Effects:
.............

The use list of PACKAGE may be modified.

See Also:
.........

*note unuse-package::, *note package-use-list::, *note Section 11.1
(Package Concepts): Package Concepts.

Notes:
......

It is permissible for a package Pto use a package Peven if PThe using of
packages is not transitive, so no problem results from the apparent
circularity.


File: ansicl,  Node: defpackage,  Next: do-symbols; do-external-symbols; do-all-symbols,  Prev: use-package,  Up: Packages

defpackage (Macro)
==================

Syntax:
.......

 -- Macro: defpackage defined-package-name 〚↓option〛 → package

OPTION::=
     {(:nicknames {nickname}*)}* |
     (:documentation string) |
     {(:use {package-name}*)}* |
     {(:shadow {↓symbol-name}*)}* |
     {(:shadowing-import-from PACKAGE-NAME {↓symbol-name}*)}* |
     {(:import-from PACKAGE-NAME {↓symbol-name}*)}* |
     {(:export {↓symbol-name}*)}* |
     {(:intern {↓symbol-name}*)}* |
     (:size integer)

Arguments and Values:
.....................

DEFINED-PACKAGE-NAME—a string designator.

PACKAGE-NAME—a package designator.

NICKNAME—a string designator.

SYMBOL-NAME—a string designator.

PACKAGE—the package named PACKAGE-NAME.

Description:
............

‘defpackage’ creates a package as specified and returns the package.

If DEFINED-PACKAGE-NAME already refers to an existing package, the
name-to-package mapping for that name is not changed.  If the new
definition is at variance with the current state of that package, the
consequences are undefined; an implementation might choose to modify the
existing package to reflect the new definition.  If DEFINED-PACKAGE-NAME
is a symbol, its name is used.

The standard options are described below.

:nicknames

     The arguments to :nicknames set the package’s nicknames to the
     supplied names.

:documentation

     The argument to :documentation specifies a documentation string; it
     is attached as a documentation string to the package.  At most one
     :documentation option can appear in a single ‘defpackage’ form.

:use

     The arguments to :use set the packages that the package named by
     PACKAGE-NAME will inherit from.  If :use is not supplied, it
     defaults to the same implementation-dependent value as the :use
     argument to ‘make-package’.

:shadow

     The arguments to :shadow, SYMBOL-NAMES, name symbols that are to be
     created in the package being defined.  These symbols are added to
     the list of shadowing symbols effectively as if by ‘shadow’.

:shadowing-import-from

     The symbols named by the argument SYMBOL-NAMES are found (involving
     a lookup as if by ‘find-symbol’) in the specified PACKAGE-NAME.
     The resulting symbols are imported into the package being defined,
     and placed on the shadowing symbols list as if by
     ‘shadowing-import’.  In no case are symbols created in any package
     other than the one being defined.

:import-from

     The symbols named by the argument SYMBOL-NAMES are found in the
     package named by PACKAGE-NAME and they are imported into the
     package being defined.  In no case are symbols created in any
     package other than the one being defined.

:export

     The symbols named by the argument SYMBOL-NAMES are found or created
     in the package being defined and exported.  The :export option
     interacts with the :use option, since inherited symbols can be used
     rather than new ones created.  The :export option interacts with
     the :import-from and :shadowing-import-from options, since imported
     symbols can be used rather than new ones created.  If an argument
     to the :export option is accessible as an (inherited) internal
     symbol via ‘use-package’, that the symbol named by SYMBOL-NAME is
     first imported into the package being defined, and is then exported
     from that package.

:intern

     The symbols named by the argument SYMBOL-NAMES are found or created
     in the package being defined.  The :intern option interacts with
     the :use option, since inherited symbols can be used rather than
     new ones created.

:size

     The argument to the :size option declares the approximate number of
     symbols expected in the package.  This is an efficiency hint only
     and might be ignored by an implementation.

The order in which the options appear in a ‘defpackage’ form is
irrelevant.  The order in which they are executed is as follows:

  1. :shadow and :shadowing-import-from.
  2. :use.
  3. :import-from and :intern.
  4. :export.

Shadows are established first, since they might be necessary to block
spurious name conflicts when the :use option is processed.  The :use
option is executed next so that :intern and :export options can refer to
normally inherited symbols.  The :export option is executed last so that
it can refer to symbols created by any of the other options; in
particular, shadowing symbols and imported symbols can be made external.

If a defpackage form appears as a top level form, all of the actions
normally performed by this macro at load time must also be performed at
compile time.

Examples:
.........

      (defpackage "MY-PACKAGE"
        (:nicknames "MYPKG" "MY-PKG")
        (:use "COMMON-LISP")
        (:shadow "CAR" "CDR")
        (:shadowing-import-from "VENDOR-COMMON-LISP"  "CONS")
        (:import-from "VENDOR-COMMON-LISP"  "GC")
        (:export "EQ" "CONS" "FROBOLA")
        )


      (defpackage my-package
        (:nicknames mypkg :MY-PKG)  ; remember Common Lisp conventions for case
        (:use common-lisp)          ; conversion on symbols
        (:shadow CAR :cdr #:cons)
        (:export "CONS")            ; this is the shadowed one.
        )

Affected By:
............

Existing packages.

Exceptional Situations:
.......................

If one of the supplied :nicknames already refers to an existing package,
an error of type ‘package-error’ is signaled.

An error of type ‘program-error’ should be signaled if :size or
:documentation appears more than once.

Since implementations might allow extended options an error of type
‘program-error’ should be signaled if an option is present that is not
actually supported in the host implementation.

The collection of SYMBOL-NAME arguments given to the options :shadow,
:intern, :import-from, and :shadowing-import-from must all be disjoint;
additionally, the SYMBOL-NAME arguments given to :export and :intern
must be disjoint.  Disjoint in this context is defined as no two of the
SYMBOL-NAMES being ‘string=’ with each other.  If either condition is
violated, an error of type ‘program-error’ should be signaled.

For the :shadowing-import-from and :import-from options, a correctable
error of type ‘package-error’ is signaled if no symbol is accessible in
the package named by PACKAGE-NAME for one of the argument SYMBOL-NAMES.

Name conflict errors are handled by the underlying calls to
‘make-package’, ‘use-package’, ‘import’, and ‘export’.  See *note
Section 11.1 (Package Concepts): Package Concepts.

See Also:
.........

*note documentation::, *note Section 11.1 (Package Concepts): Package
Concepts, *note Section 3.2 (Compilation): Compilation.

Notes:
......

The :intern option is useful if an :import-from or a
:shadowing-import-from option in a subsequent call to ‘defpackage’ (for
some other package) expects to find these symbols accessible but not
necessarily external.

It is recommended that the entire package definition is put in a single
place, and that all the package definitions of a program are in a single
file.  This file can be loaded before loading or compiling anything else
that depends on those packages.  Such a file can be read in the
‘COMMON-LISP-USER’ package, avoiding any initial state issues.

‘defpackage’ cannot be used to create two “mutually recursive” packages,
such as:

      (defpackage my-package
        (:use common-lisp your-package)    ;requires your-package to exist first
        (:export "MY-FUN"))
      (defpackage your-package
        (:use common-lisp)
        (:import-from my-package "MY-FUN") ;requires my-package to exist first
        (:export "MY-FUN"))

However, nothing prevents the user from using the package-affecting
functions such as ‘use-package’, ‘import’, and ‘export’ to establish
such links after a more standard use of ‘defpackage’.

The macroexpansion of ‘defpackage’ could usefully canonicalize the names
into strings, so that even if a source file has random symbols in the
‘defpackage’ form, the compiled file would only contain strings.

Frequently additional implementation-dependent options take the form of
a keyword standing by itself as an abbreviation for a list ‘(keyword
T)’; this syntax should be properly reported as an unrecognized option
in implementations that do not support it.


File: ansicl,  Node: do-symbols; do-external-symbols; do-all-symbols,  Next: intern,  Prev: defpackage,  Up: Packages

do-symbols, do-external-symbols, do-all-symbols (Macro)
=======================================================

Syntax:
.......

 -- Macro: do-symbols (var [package [result-form]])
          {declaration}* {tag | statement}* → {result}*

 -- Macro: do-external-symbols (var [package [result-form]])
          {declaration}* {tag | statement}* → {result}*

 -- Macro: do-all-symbols (var [result-form])
          {declaration}* {tag | statement}* → {result}*

Arguments and Values:
.....................

VAR—a variable name; not evaluated.

PACKAGE—a package designator; evaluated.  The defaults in ‘do-symbols’
and ‘do-external-symbols’ is the current package.

RESULT-FORM—a form; evaluated as described below.  The default is ‘nil’.

DECLARATION—a declare expression; not evaluated.

TAG—a go tag; not evaluated.

STATEMENT—a compound form; evaluated as described below.

RESULTS—the values returned by the RESULT-FORM if a normal return
occurs, or else, if an explicit return occurs, the values that were
transferred.

Description:
............

‘do-symbols’, ‘do-external-symbols’, and ‘do-all-symbols’ iterate over
the symbols of packages.  For each symbol in the set of packages chosen,
the VAR is bound to the symbol, and the STATEMENTS in the body are
executed.  When all the symbols have been processed, RESULT-FORM is
evaluated and returned as the value of the macro.

‘do-symbols’ iterates over the symbols accessible in PACKAGE.
STATEMENTS may execute more than once for symbols that are inherited
from multiple packages.

‘do-all-symbols’ iterates on every registered package.  ‘do-all-symbols’
will not process every symbol whatsoever, because a symbol not
accessible in any registered package will not be processed.
‘do-all-symbols’ may cause a symbol that is present in several packages
to be processed more than once.

‘do-external-symbols’ iterates on the external symbols of PACKAGE.

When RESULT-FORM is evaluated, VAR is bound and has the value ‘nil’.

An implicit block named ‘nil’ surrounds the entire ‘do-symbols’,
‘do-external-symbols’, or ‘do-all-symbols’ form.  ‘return’ or
‘return-from’ may be used to terminate the iteration prematurely.

If execution of the body affects which symbols are contained in the set
of packages over which iteration is occurring, other than to remove the
symbol currently the value of VAR by using ‘unintern’, the consequences
are undefined.

For each of these macros, the scope of the name binding does not include
any initial value form, but the optional result forms are included.

Any TAG in the body is treated as with ‘tagbody’.

Examples:
.........

      (make-package 'temp :use nil) → #<PACKAGE "TEMP">
      (intern "SHY" 'temp) → TEMP::SHY, NIL ;SHY will be an internal symbol
                                              ;in the package TEMP
      (export (intern "BOLD" 'temp) 'temp)  → T  ;BOLD will be external
      (let ((lst ()))
        (do-symbols (s (find-package 'temp)) (push s lst))
        lst)
     → (TEMP::SHY TEMP:BOLD)
     or→ (TEMP:BOLD TEMP::SHY)
      (let ((lst ()))
        (do-external-symbols (s (find-package 'temp) lst) (push s lst))
        lst)
     → (TEMP:BOLD)
      (let ((lst ()))
        (do-all-symbols (s lst)
          (when (eq (find-package 'temp) (symbol-package s)) (push s lst)))
        lst)
     → (TEMP::SHY TEMP:BOLD)
     or→ (TEMP:BOLD TEMP::SHY)

See Also:
.........

*note intern::, *note export::, *note Section 3.6 (Traversal Rules and
Side Effects): Traversal Rules and Side Effects.


File: ansicl,  Node: intern,  Next: package-name,  Prev: do-symbols; do-external-symbols; do-all-symbols,  Up: Packages

intern (Function)
=================

Syntax:
.......

 -- Function: intern string &optional package → symbol, status

Arguments and Values:
.....................

STRING—a string.

PACKAGE—a package designator.  The default is the current package.

SYMBOL—a symbol.

STATUS—one of :inherited, :external, :internal, or ‘nil’.

Description:
............

‘intern’ enters a symbol named STRING into PACKAGE.  If a symbol whose
name is the same as STRING is already accessible in PACKAGE, it is
returned.  If no such symbol is accessible in PACKAGE, a new symbol with
the given name is created and entered into PACKAGE as an internal
symbol, or as an external symbol if the PACKAGE is the ‘KEYWORD’
package; PACKAGE becomes the home package of the created symbol.

The first value returned by ‘intern’, SYMBOL, is the symbol that was
found or created.  The meaning of the secondary value, STATUS, is as
follows:

:internal

     The symbol was found and is present in PACKAGE as an internal
     symbol.

:external

     The symbol was found and is present as an external symbol.

:inherited

     The symbol was found and is inherited via ‘use-package’ (which
     implies that the symbol is internal).

‘nil’

     No pre-existing symbol was found, so one was created.

     It is implementation-dependent whether the string that becomes the
     new symbol’s name is the given STRING or a copy of it.  Once a
     string has been given as the STRING argument to intern in this
     situation where a new symbol is created, the consequences are
     undefined if a subsequent attempt is made to alter that string.

Examples:
.........

      (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
      (intern "Never-Before") → |Never-Before|, NIL
      (intern "Never-Before") → |Never-Before|, :INTERNAL
      (intern "NEVER-BEFORE" "KEYWORD") → :NEVER-BEFORE, NIL
      (intern "NEVER-BEFORE" "KEYWORD") → :NEVER-BEFORE, :EXTERNAL

See Also:
.........

*note find-symbol::, *note read::, *note symbol::, *note unintern::,
*note Section 2.3.4 (Symbols as Tokens): Symbols as Tokens.

Notes:
......

‘intern’ does not need to do any name conflict checking because it never
creates a new symbol if there is already an accessible symbol with the
name given.


File: ansicl,  Node: package-name,  Next: package-nicknames,  Prev: intern,  Up: Packages

package-name (Function)
=======================

Syntax:
.......

 -- Function: package-name package → name

Arguments and Values:
.....................

PACKAGE—a package designator.

NAME—a string or ‘nil’.

Description:
............

‘package-name’ returns the string that names PACKAGE, or ‘nil’ if the
PACKAGE designator is a package object that has no name (see the
function *note delete-package::).

Examples:
.........

      (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
      (package-name *package*) → "COMMON-LISP-USER"
      (package-name (symbol-package :test)) → "KEYWORD"
      (package-name (find-package 'common-lisp)) → "COMMON-LISP"

      (defvar *foo-package* (make-package "FOO"))
      (rename-package "FOO" "FOO0")
      (package-name *foo-package*) → "FOO0"

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PACKAGE is not a package
designator.


File: ansicl,  Node: package-nicknames,  Next: package-shadowing-symbols,  Prev: package-name,  Up: Packages

package-nicknames (Function)
============================

Syntax:
.......

 -- Function: package-nicknames package → nicknames

Arguments and Values:
.....................

PACKAGE—a package designator.

NICKNAMES—a list of strings.

Description:
............

Returns the list of nickname strings for PACKAGE, not including the name
of PACKAGE.

Examples:
.........

      (package-nicknames (make-package 'temporary
                                        :nicknames '("TEMP" "temp")))
     → ("temp" "TEMP")

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PACKAGE is not a package
designator.


File: ansicl,  Node: package-shadowing-symbols,  Next: package-use-list,  Prev: package-nicknames,  Up: Packages

package-shadowing-symbols (Function)
====================================

Syntax:
.......

 -- Function: package-shadowing-symbols package → symbols

Arguments and Values:
.....................

PACKAGE—a package designator.

SYMBOLS—a list of symbols.

Description:
............

Returns a list of symbols that have been declared as shadowing symbols
in PACKAGE by ‘shadow’ or ‘shadowing-import’ (or the equivalent
‘defpackage’ options).  All symbols on this list are present in PACKAGE.

Examples:
.........

      (package-shadowing-symbols (make-package 'temp)) → ()
      (shadow 'cdr 'temp) → T
      (package-shadowing-symbols 'temp) → (TEMP::CDR)
      (intern "PILL" 'temp) → TEMP::PILL, NIL
      (shadowing-import 'pill 'temp) → T
      (package-shadowing-symbols 'temp) → (PILL TEMP::CDR)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PACKAGE is not a package
designator.

See Also:
.........

*note shadow::, *note shadowing-import::

Notes:
......

Whether the list of SYMBOLS is fresh is implementation-dependent.


File: ansicl,  Node: package-use-list,  Next: package-used-by-list,  Prev: package-shadowing-symbols,  Up: Packages

package-use-list (Function)
===========================

Syntax:
.......

 -- Function: package-use-list package → use-list

Arguments and Values:
.....................

PACKAGE—a package designator.

USE-LIST—a list of package objects.

Description:
............

Returns a list of other packages used by PACKAGE.

Examples:
.........

      (package-use-list (make-package 'temp)) → (#<PACKAGE "COMMON-LISP">)
      (use-package 'common-lisp-user 'temp) → T
      (package-use-list 'temp) → (#<PACKAGE "COMMON-LISP"> #<PACKAGE "COMMON-LISP-USER">)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PACKAGE is not a package
designator.

See Also:
.........

*note use-package::, *note unuse-package::


File: ansicl,  Node: package-used-by-list,  Next: packagep,  Prev: package-use-list,  Up: Packages

package-used-by-list (Function)
===============================

Syntax:
.......

 -- Function: package-used-by-list package → used-by-list

Arguments and Values:
.....................

PACKAGE—a package designator.

USED-BY-LIST—a list of package objects.

Description:
............

‘package-used-by-list’ returns a list of other packages that use
PACKAGE.

Examples:
.........

      (package-used-by-list (make-package 'temp)) → ()
      (make-package 'trash :use '(temp)) → #<PACKAGE "TRASH">
      (package-used-by-list 'temp) → (#<PACKAGE "TRASH">)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PACKAGE is not a package.

See Also:
.........

*note use-package::, *note unuse-package::


File: ansicl,  Node: packagep,  Next: *package*,  Prev: package-used-by-list,  Up: Packages

packagep (Function)
===================

Syntax:
.......

 -- Function: packagep object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘package’; otherwise, returns false.

Examples:
.........

      (packagep *package*) → true
      (packagep 'common-lisp) → false
      (packagep (find-package 'common-lisp)) → true

Notes:
......

      (packagep OBJECT) ≡ (typep OBJECT 'package)


File: ansicl,  Node: *package*,  Next: package-error,  Prev: packagep,  Up: Packages

*package* (Variable)
====================

Value Type:
...........

a package object.

Initial Value:
..............

the ‘COMMON-LISP-USER’ package.

Description:
............

Whatever package object is currently the value of ‘*package*’ is
referred to as the current package.

Examples:
.........

      (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
      *package* → #<PACKAGE "COMMON-LISP-USER">
      (make-package "SAMPLE-PACKAGE" :use '("COMMON-LISP"))
     → #<PACKAGE "SAMPLE-PACKAGE">
      (list
        (symbol-package
          (let ((*package* (find-package 'sample-package)))
            (setq *some-symbol* (read-from-string "just-testing"))))
        *package*)
     → (#<PACKAGE "SAMPLE-PACKAGE"> #<PACKAGE "COMMON-LISP-USER">)
      (list (symbol-package (read-from-string "just-testing"))
            *package*)
     → (#<PACKAGE "COMMON-LISP-USER"> #<PACKAGE "COMMON-LISP-USER">)
      (eq 'foo (intern "FOO")) → true
      (eq 'foo (let ((*package* (find-package 'sample-package)))
                 (intern "FOO")))
     → false

Affected By:
............

‘load’, ‘compile-file’, ‘in-package’

See Also:
.........

*note compile-file::, *note in-package::, *note load::, *note package::


File: ansicl,  Node: package-error,  Next: package-error-package,  Prev: *package*,  Up: Packages

package-error (Condition Type)
==============================

Class Precedence List:
......................

‘package-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘package-error’ consists of error conditions related to
operations on packages.  The offending package (or package name) is
initialized by the :package initialization argument to ‘make-condition’,
and is accessed by the function ‘package-error-package’.

See Also:
.........

*note package-error-package::, *note Chapter 9 (Conditions): Conditions.


File: ansicl,  Node: package-error-package,  Prev: package-error,  Up: Packages

package-error-package (Function)
================================

Syntax:
.......

 -- Function: package-error-package condition → package

Arguments and Values:
.....................

CONDITION—a condition of type ‘package-error’.

PACKAGE—a package designator.

Description:
............

Returns a designator for the offending package in the situation
represented by the CONDITION.

Examples:
.........

      (package-error-package
        (make-condition 'package-error
          :package (find-package "COMMON-LISP")))
     → #<Package "COMMON-LISP">

See Also:
.........

*note package-error::


File: ansicl,  Node: Numbers,  Next: Characters,  Prev: Packages,  Up: Top

12 Numbers
**********

* Menu:

* Number Concepts::

Dictionary

* number::
* complex (System Class)::
* real::
* float (System Class)::
* short-float; single-float; double-float; long-float::
* rational (System Class)::
* ratio::
* integer::
* signed-byte::
* unsigned-byte::
* mod (Type Specifier)::
* bit (Type)::
* fixnum::
* bignum::
* =; /=; <; >; <=; >=::
* max; min::
* minusp; plusp::
* zerop::
* floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround::
* sin; cos; tan::
* asin; acos; atan::
* pi::
* sinh; cosh; tanh; asinh; acosh; atanh::
* * (Function)::
* + (Function)::
* - (Function)::
* / (Function)::
* 1+; 1-::
* abs::
* evenp; oddp::
* exp; expt::
* gcd::
* incf; decf::
* lcm::
* log::
* mod; rem::
* signum::
* sqrt; isqrt::
* random-state::
* make-random-state::
* random::
* random-state-p::
* *random-state*::
* numberp::
* cis::
* complex (Function)::
* complexp::
* conjugate::
* phase::
* realpart; imagpart::
* upgraded-complex-part-type::
* realp::
* numerator; denominator::
* rational; rationalize::
* rationalp::
* ash::
* integer-length::
* integerp::
* parse-integer::
* boole::
* boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+::
* logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+::
* logbitp::
* logcount::
* logtest::
* byte; byte-size; byte-position::
* deposit-field::
* dpb::
* ldb::
* ldb-test::
* mask-field::
* most-positive-fixnum; most-negative-fixnum::
* decode-float; scale-float; float-radix; float-sign; float-digits; float+::
* float (Function)::
* floatp::
* most-positive-short-float; least-positive-short-float; least-positive-n+::
* short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+::
* arithmetic-error::
* arithmetic-error-operands; arithmetic-error-operation::
* division-by-zero::
* floating-point-invalid-operation::
* floating-point-inexact::
* floating-point-overflow::
* floating-point-underflow::


File: ansicl,  Node: Number Concepts,  Next: number,  Up: Numbers

12.1 Number Concepts
====================

* Menu:

* Numeric Operations::
* Implementation-Dependent Numeric Constants::
* Rational Computations::
* Floating-point Computations::
* Complex Computations::
* Interval Designators::
* Random-State Operations::


File: ansicl,  Node: Numeric Operations,  Next: Implementation-Dependent Numeric Constants,  Up: Number Concepts

12.1.1 Numeric Operations
-------------------------

Common Lisp provides a large variety of operations related to numbers.
This section provides an overview of those operations by grouping them
into categories that emphasize some of the relationships among them.

The next figure shows operators relating to arithmetic operations.

*   1+          gcd
+   1-          incf
-   conjugate   lcm
/   decf

Figure 12.1: Operators relating to Arithmetic.

The next figure shows defined names relating to exponential,
logarithmic, and trigonometric operations.

abs     cos     signum
acos    cosh    sin
acosh   exp     sinh
asin    expt    sqrt
asinh   isqrt   tan
atan    log     tanh
atanh   phase
cis     pi

Figure 12.2: Defined names relating to Exponentials, Logarithms, and
Trigonometry.

The next figure shows operators relating to numeric comparison and
predication.

/=   >=       oddp
<    evenp    plusp
<=   max      zerop
=    min
>    minusp

Figure 12.3: Operators for numeric comparison and predication.

The next figure shows defined names relating to numeric type
manipulation and coercion.

ceiling           float-radix            rational
complex           float-sign             rationalize
decode-float      floor                  realpart
denominator       fround                 rem
fceiling          ftruncate              round
ffloor            imagpart               scale-float
float             integer-decode-float   truncate
float-digits      mod
float-precision   numerator

Figure 12.4: Defined names relating to numeric type manipulation and
coercion.

12.1.1.1 Associativity and Commutativity in Numeric Operations
..............................................................

For functions that are mathematically associative (and possibly
commutative), a conforming implementation may process the arguments in
any manner consistent with associative (and possibly commutative)
rearrangement.  This does not affect the order in which the argument
forms are evaluated; for a discussion of evaluation order, see *note
Section 3.1.2.1.2.3 (Function Forms): FunctionForms.  What is
unspecified is only the order in which the parameter values are
processed.  This implies that implementations may differ in which
automatic coercions are applied; see *note Section 12.1.1.2 (Contagion
in Numeric Operations): NumericContagionRules.

A conforming program can control the order of processing explicitly by
separating the operations into separate (possibly nested) function
forms, or by writing explicit calls to functions that perform coercions.

12.1.1.1.1 Examples of Associativity and Commutativity in Numeric Operations
............................................................................

Consider the following expression, in which we assume that ‘1.0’ and
‘1.0e-15’ both denote single floats:

      (+ 1/3 2/3 1.0d0 1.0 1.0e-15)

One conforming implementation might process the arguments from left to
right, first adding ‘1/3’ and ‘2/3’ to get ‘1’, then converting that to
a double float for combination with ‘1.0d0’, then successively
converting and adding ‘1.0’ and ‘1.0e-15’.

Another conforming implementation might process the arguments from right
to left, first performing a single float addition of ‘1.0’ and ‘1.0e-15’
(perhaps losing accuracy in the process), then converting the sum to a
double float and adding ‘1.0d0’, then converting ‘2/3’ to a double float
and adding it, and then converting ‘1/3’ and adding that.

A third conforming implementation might first scan all the arguments,
process all the rationals first to keep that part of the computation
exact, then find an argument of the largest floating-point format among
all the arguments and add that, and then add in all other arguments,
converting each in turn (all in a perhaps misguided attempt to make the
computation as accurate as possible).

In any case, all three strategies are legitimate.

A conforming program could control the order by writing, for example,

      (+ (+ 1/3 2/3) (+ 1.0d0 1.0e-15) 1.0)

12.1.1.2 Contagion in Numeric Operations
........................................

For information about the contagion rules for implicit coercions of
arguments in numeric operations, see *note Section 12.1.4.4 (Rule of
Float Precision Contagion): RuleOfFloatPrecisionContagion, *note Section
12.1.4.1 (Rule of Float and Rational Contagion):
RuleOfFloatAndRationalContagion, and *note Section 12.1.5.2 (Rule of
Complex Contagion): RuleOfComplexContagion.

12.1.1.3 Viewing Integers as Bits and Bytes
...........................................

12.1.1.3.1 Logical Operations on Integers
.........................................

Logical operations require integers as arguments; an error of type
‘type-error’ should be signaled if an argument is supplied that is not
an integer.  Integer arguments to logical operations are treated as if
they were represented in two’s-complement notation.

The next figure shows defined names relating to logical operations on
numbers.

ash           boole-ior        logbitp
boole         boole-nand       logcount
boole-1       boole-nor        logeqv
boole-2       boole-orc1       logior
boole-and     boole-orc2       lognand
boole-andc1   boole-set        lognor
boole-andc2   boole-xor        lognot
boole-c1      integer-length   logorc1
boole-c2      logand           logorc2
boole-clr     logandc1         logtest
boole-eqv     logandc2         logxor

Figure 12.5: Defined names relating to logical operations on numbers.

12.1.1.3.2 Byte Operations on Integers
......................................

The byte-manipulation functions use objects called byte specifiers to
designate the size and position of a specific byte within an integer.
The representation of a byte specifier is implementation-dependent; it
might or might not be a number.  The function ‘byte’ will construct a
byte specifier, which various other byte-manipulation functions will
accept.

The next figure shows defined names relating to manipulating bytes of
numbers.

byte            deposit-field   ldb-test
byte-position   dpb             mask-field
byte-size       ldb

Figure 12.6: Defined names relating to byte manipulation.


File: ansicl,  Node: Implementation-Dependent Numeric Constants,  Next: Rational Computations,  Prev: Numeric Operations,  Up: Number Concepts

12.1.2 Implementation-Dependent Numeric Constants
-------------------------------------------------

The next figure shows defined names relating to implementation-dependent
details about numbers.

double-float-epsilon            most-negative-fixnum
double-float-negative-epsilon   most-negative-long-float
least-negative-double-float     most-negative-short-float
least-negative-long-float       most-negative-single-float
least-negative-short-float      most-positive-double-float
least-negative-single-float     most-positive-fixnum
least-positive-double-float     most-positive-long-float
least-positive-long-float       most-positive-short-float
least-positive-short-float      most-positive-single-float
least-positive-single-float     short-float-epsilon
long-float-epsilon              short-float-negative-epsilon
long-float-negative-epsilon     single-float-epsilon
most-negative-double-float      single-float-negative-epsilon

Figure 12.7: Defined names relating to implementation-dependent details
about numbers.


File: ansicl,  Node: Rational Computations,  Next: Floating-point Computations,  Prev: Implementation-Dependent Numeric Constants,  Up: Number Concepts

12.1.3 Rational Computations
----------------------------

The rules in this section apply to rational computations.

12.1.3.1 Rule of Unbounded Rational Precision
.............................................

Rational computations cannot overflow in the usual sense (though there
may not be enough storage to represent a result), since integers and
ratios may in principle be of any magnitude.

12.1.3.2 Rule of Canonical Representation for Rationals
.......................................................

If any computation produces a result that is a mathematical ratio of two
integers such that the denominator evenly divides the numerator, then
the result is converted to the equivalent integer.

If the denominator does not evenly divide the numerator, the canonical
representation of a rational number is as the ratio that numerator and
that denominator, where the greatest common divisor of the numerator and
denominator is one, and where the denominator is positive and greater
than one.

When used as input (in the default syntax), the notation ‘-0’ always
denotes the integer ‘0’.  A conforming implementation must not have a
representation of “minus zero” for integers that is distinct from its
representation of zero for integers.  However, such a distinction is
possible for floats; see the type ‘float’.

12.1.3.3 Rule of Float Substitutability
.......................................

When the arguments to an irrational mathematical function

are all rational and the true mathematical result is also
(mathematically) rational, then unless otherwise noted an implementation
is free to return either an accurate rational result or a single float
approximation.  If the arguments are all rational but the result cannot
be expressed as a rational number, then a single float approximation is
always returned.

If the arguments to an irrational mathematical function are all of type
‘(or rational (complex rational))’ and the true mathematical result is
(mathematically) a complex number with rational real and imaginary
parts, then unless otherwise noted an implementation is free to return
either an accurate result of type ‘(or rational (complex rational))’ or
a single float (permissible only if the imaginary part of the true
mathematical result is zero) or ‘(complex single-float)’.  If the
arguments are all of type ‘(or rational (complex rational))’ but the
result cannot be expressed as a rational or complex rational, then the
returned value will be of type ‘single-float’ (permissible only if the
imaginary part of the true mathematical result is zero) or ‘(complex
single-float)’.

Float substitutability applies neither to the rational functions ‘+’,
‘-’, ‘*’, and ‘/’ nor to the related operators ‘1+’, ‘1-’, ‘incf’,
‘decf’, and ‘conjugate’.  For rational functions, if all arguments are
rational, then the result is rational; if all arguments are of type ‘(or
rational (complex rational))’, then the result is of type ‘(or rational
(complex rational))’.

Function   Sample Results
-------------------------------------------------------------
‘abs’      ‘(abs #c(3 4)) → 5 or 5.0’
‘acos’     ‘(acos 1) → 0 or 0.0’
‘acosh’    ‘(acosh 1) → 0 or 0.0’
‘asin’     ‘(asin 0) → 0 or 0.0’
‘asinh’    ‘(asinh 0) → 0 or 0.0’
‘atan’     ‘(atan 0) → 0 or 0.0’
‘atanh’    ‘(atanh 0) → 0 or 0.0’
‘cis’      ‘(cis 0) → 1 or #c(1.0 0.0)’
‘cos’      ‘(cos 0) → 1 or 1.0’
‘cosh’     ‘(cosh 0) → 1 or 1.0’
‘exp’      ‘(exp 0) → 1 or 1.0’
‘expt’     ‘(expt 8 1/3) → 2 or 2.0’
‘log’      ‘(log 1) → 0 or 0.0’
           ‘(log 8 2) → 3 or 3.0’
‘phase’    ‘(phase 7) → 0 or 0.0’
‘signum’   ‘(signum #c(3 4)) → #c(3/5 4/5) or #c(0.6 0.8)’
‘sin’      ‘(sin 0) → 0 or 0.0’
‘sinh’     ‘(sinh 0) → 0 or 0.0’
‘sqrt’     ‘(sqrt 4) → 2 or 2.0’
           ‘(sqrt 9/16) → 3/4 or 0.75’
‘tan’      ‘(tan 0) → 0 or 0.0’
‘tanh’     ‘(tanh 0) → 0 or 0.0’

Figure 12.8: Functions Affected by Rule of Float Substitutability


File: ansicl,  Node: Floating-point Computations,  Next: Complex Computations,  Prev: Rational Computations,  Up: Number Concepts

12.1.4 Floating-point Computations
----------------------------------

The following rules apply to floating point computations.

12.1.4.1 Rule of Float and Rational Contagion
.............................................

When rationals and floats are combined by a numerical function, the
rational is first converted to a float of the same format.  For
functions such as ‘+’ that take more than two arguments, it is permitted
that part of the operation be carried out exactly using rationals and
the rest be done using floating-point arithmetic.

When rationals and floats are compared by a numerical function, the
function ‘rational’ is effectively called to convert the float to a
rational and then an exact comparison is performed.  In the case of
complex numbers, the real and imaginary parts are effectively handled
individually.

12.1.4.1.1 Examples of Rule of Float and Rational Contagion
...........................................................

      ;;;; Combining rationals with floats.
      ;;; This example assumes an implementation in which
      ;;; (float-radix 0.5) is 2 (as in IEEE) or 16 (as in IBM/360),
      ;;; or else some other implementation in which 1/2 has an exact
      ;;;  representation in floating point.
      (+ 1/2 0.5) → 1.0
      (- 1/2 0.5d0) → 0.0d0
      (+ 0.5 -0.5 1/2) → 0.5

      ;;;; Comparing rationals with floats.
      ;;; This example assumes an implementation in which the default float
      ;;; format is IEEE single-float, IEEE double-float, or some other format
      ;;; in which 5/7 is rounded upwards by FLOAT.
      (< 5/7 (float 5/7)) → true
      (< 5/7 (rational (float 5/7))) → true
      (< (float 5/7) (float 5/7)) → false

12.1.4.2 Rule of Float Approximation
....................................

Computations with floats are only approximate, although they are
described as if the results were mathematically accurate.  Two
mathematically identical expressions may be computationally different
because of errors inherent in the floating-point approximation process.
The precision of a float is not necessarily correlated with the accuracy
of that number.  For instance, 3.142857142857142857 is a more precise
approximation to π than 3.14159, but the latter is more accurate.  The
precision refers to the number of bits retained in the representation.
When an operation combines a short float with a long float, the result
will be a long float.  Common Lisp functions assume that the accuracy of
arguments to them does not exceed their precision.  Therefore when two
small floats are combined, the result is a small float.  Common
Lisp functions never convert automatically from a larger size to a
smaller one.

12.1.4.3 Rule of Float Underflow and Overflow
.............................................

An error of type ‘floating-point-overflow’ or ‘floating-point-underflow’
should be signaled if a floating-point computation causes exponent
overflow or underflow, respectively.

12.1.4.4 Rule of Float Precision Contagion
..........................................

The result of a numerical function is a float of the largest format
among all the floating-point arguments to the function.


File: ansicl,  Node: Complex Computations,  Next: Interval Designators,  Prev: Floating-point Computations,  Up: Number Concepts

12.1.5 Complex Computations
---------------------------

The following rules apply to complex computations:

12.1.5.1 Rule of Complex Substitutability
.........................................

Except during the execution of irrational and transcendental functions,
no numerical function ever yields a complex unless one or more of its
arguments is a complex.

12.1.5.2 Rule of Complex Contagion
..................................

When a real and a complex are both part of a computation, the real is
first converted to a complex by providing an imaginary part of ‘0’.

12.1.5.3 Rule of Canonical Representation for Complex Rationals
...............................................................

If the result of any computation would be a complex number whose real
part is of type ‘rational’ and whose imaginary part is zero, the result
is converted to the rational which is the real part.  This rule does not
apply to complex numbers whose parts are floats.  For example, ‘#C(5 0)’
and ‘5’ are not different objects in Common Lisp (they are always the
same under ‘eql’); ‘#C(5.0 0.0)’ and ‘5.0’ are always different objects
in Common Lisp (they are never the same under ‘eql’, although they are
the same under ‘equalp’ and ‘=’).

12.1.5.3.1 Examples of Rule of Canonical Representation for Complex Rationals
.............................................................................

      #c(1.0 1.0) → #C(1.0 1.0)
      #c(0.0 0.0) → #C(0.0 0.0)
      #c(1.0 1) → #C(1.0 1.0)
      #c(0.0 0) → #C(0.0 0.0)
      #c(1 1) → #C(1 1)
      #c(0 0) → 0
      (typep #c(1 1) '(complex (eql 1))) → true
      (typep #c(0 0) '(complex (eql 0))) → false

12.1.5.4 Principal Values and Branch Cuts
.........................................

Many of the irrational and transcendental functions are multiply defined
in the complex domain; for example, there are in general an infinite
number of complex values for the logarithm function.  In each such case,
a principal value must be chosen for the function to return.  In
general, such values cannot be chosen so as to make the range
continuous; lines in the domain called branch cuts must be defined,
which in turn define the discontinuities in the range.  Common
Lisp defines the branch cuts, principal values, and boundary conditions
for the complex functions following “Principal Values and Branch Cuts in
Complex APL.” The branch cut rules that apply to each function are
located with the description of that function.

The next figure lists the identities that are obeyed throughout the
applicable portion of the complex domain, even on the branch cuts:

sin i z = i sinh z   sinh i z = i sin z         arctan i z = i arctanh z
cos i z = cosh z     cosh i z = cos z           arcsinh i z = i arcsin z
tan i z = i tanh z   arcsin i z = i arcsinh z   arctanh i z = i arctan z

Figure 12.9: Trigonometric Identities for Complex Domain

The quadrant numbers referred to in the discussions of branch cuts are
as illustrated in the next figure.

                                     Positive
                                 Imaginary Axis

                                        :
                                    II  :  I
                                        :
         Negative Real Axis .......................  Positive Real Axis
                                        :
                                   III  :  IV
                                        :

                                    Negative
                                 Imaginary Axis

Figure 12.10: Quadrant Numbering for Branch Cuts


File: ansicl,  Node: Interval Designators,  Next: Random-State Operations,  Prev: Complex Computations,  Up: Number Concepts

12.1.6 Interval Designators
---------------------------

The compound type specifier form of the numeric type specifiers permit
the user to specify an interval on the real number line which describe a
subtype of the type which would be described by the corresponding atomic
type specifier.  A subtype of some type T is specified using an ordered
pair of objects called interval designators for type T.

The first of the two interval designators for type T can be any of the
following:

a number N of type T

     This denotes a lower inclusive bound of N.  That is, elements of
     the subtype of T will be greater than or equal to N.

a singleton list whose element is a number M of type T

     This denotes a lower exclusive bound of M.  That is, elements of
     the subtype of T will be greater than M.

the symbol *

     This denotes the absence of a lower bound on the interval.

The second of the two interval designators for type T can be any of the
following:

a number N of type T

     This denotes an upper inclusive bound of N.  That is, elements of
     the subtype of T will be less than or equal to N.

a singleton list whose element is a number M of type T

     This denotes an upper exclusive bound of M.  That is, elements of
     the subtype of T will be less than M.

the symbol *

     This denotes the absence of an upper bound on the interval.


File: ansicl,  Node: Random-State Operations,  Prev: Interval Designators,  Up: Number Concepts

12.1.7 Random-State Operations
------------------------------

The next figure lists some defined names that are applicable to random
states.

*random-state*      random
make-random-state   random-state-p

Figure 12.11: Random-state defined names


File: ansicl,  Node: number,  Next: complex (System Class),  Prev: Number Concepts,  Up: Numbers

number (System Class)
=====================

Class Precedence List:
......................

‘number’, ‘t’

Description:
............

The type ‘number’ contains objects which represent mathematical numbers.
The types ‘real’ and ‘complex’ are disjoint subtypes of ‘number’.

The function ‘=’ tests for numerical equality.  The function ‘eql’, when
its arguments are both numbers, tests that they have both the same type
and numerical value.  Two numbers that are the same under ‘eql’ or ‘=’
are not necessarily the same under ‘eq’.

Notes:
......

Common Lisp differs from mathematics on some naming issues.  In
mathematics, the set of real numbers is traditionally described as a
subset of the complex numbers, but in Common Lisp, the type ‘real’ and
the type ‘complex’ are disjoint.  The Common Lisp type which includes
all mathematical complex numbers is called ‘number’.  The reasons for
these differences include historical precedent, compatibility with most
other popular computer languages, and various issues of time and space
efficiency.


File: ansicl,  Node: complex (System Class),  Next: real,  Prev: number,  Up: Numbers

complex (System Class)
======================

Class Precedence List:
......................

‘complex’, ‘number’, ‘t’

Description:
............

The type ‘complex’ includes all mathematical complex numbers other than
those included in the type ‘rational’.  Complexes are expressed in
Cartesian form with a real part and an imaginary part, each of which is
a real.  The real part and imaginary part are either both rational or
both of the same float type.  The imaginary part can be a float zero,
but can never be a rational zero, for such a number is always
represented by Common Lisp as a rational rather than a complex.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(complex [typespec | *])

Compound Type Specifier Arguments:
..................................

TYPESPEC—a type specifier that denotes a subtype of type ‘real’.

Compound Type Specifier Description:
....................................

Every element of this type is a complex whose real part and imaginary
part are each of type ‘(upgraded-complex-part-type TYPESPEC)’.  This
type encompasses those complexes that can result by giving numbers of
type TYPESPEC to ‘complex’.

‘(complex TYPE-SPECIFIER)’ refers to all complexes that can result from
giving numbers of TYPE TYPE-SPECIFIER to the function ‘complex’, plus
all other complexes of the same specialized representation.

See Also:
.........

*note Section 12.1.5.3 (Rule of Canonical Representation for Complex
Rationals): RuleOfCanonRepForComplexRationals, *note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*note Section 22.1.3.1.4 (Printing Complexes): PrintingComplexes.

Notes:
......

The input syntax for a complex with real part r and imaginary part i is
‘#C(r i)’.  For further details, see *note Section 2.4 (Standard Macro
Characters): Standard Macro Characters.

For every float, n, there is a complex which represents the same
mathematical number and which can be obtained by ‘(COERCE n 'COMPLEX)’.


File: ansicl,  Node: real,  Next: float (System Class),  Prev: complex (System Class),  Up: Numbers

real (System Class)
===================

Class Precedence List:
......................

‘real’, ‘number’, ‘t’

Description:
............

The type ‘real’ includes all numbers that represent mathematical real
numbers, though there are mathematical real numbers (e.g., irrational
numbers) that do not have an exact representation in Common Lisp.  Only
reals can be ordered using the ‘<’, ‘>’, ‘<=’, and ‘>=’ functions.

The types ‘rational’ and ‘float’ are disjoint subtypes of type ‘real’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(real [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT—interval designators for type ‘real’.  The
defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ‘*’.

Compound Type Specifier Description:
....................................

This denotes the reals on the interval described by LOWER-LIMIT and
UPPER-LIMIT.


File: ansicl,  Node: float (System Class),  Next: short-float; single-float; double-float; long-float,  Prev: real,  Up: Numbers

float (System Class)
====================

Class Precedence List:
......................

‘float’, ‘real’, ‘number’, ‘t’

Description:
............

A float is a mathematical rational (but not a Common Lisp rational) of
the form s· f· b^e-p, where s is +1 or -1, the sign; b is an integer
greater than 1, the base or radix of the representation; p is a positive
integer, the precision (in base-b digits) of the float; f is a positive
integer between b^p-1 and b^p-1 (inclusive), the significand; and e is
an integer, the exponent.  The value of p and the range of e depends on
the implementation and on the type of float within that implementation.
In addition, there is a floating-point zero; depending on the
implementation, there can also be a “minus zero”.  If there is no minus
zero, then 0.0 and -0.0 are both interpreted as simply a floating-point
zero.  ‘(= 0.0 -0.0)’ is always true.  If there is a minus zero, ‘(eql
-0.0 0.0)’ is false, otherwise it is true.

The types ‘short-float’, ‘single-float’, ‘double-float’, and
‘long-float’ are subtypes of type ‘float’.  Any two of them must be
either disjoint types or the same type; if the same type, then any other
types between them in the above ordering must also be the same type.
For example, if the type ‘single-float’ and the type ‘long-float’ are
the same type, then the type ‘double-float’ must be the same type also.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(float [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT—interval designators for type ‘float’.  The
defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ‘*’.

Compound Type Specifier Description:
....................................

This denotes the floats on the interval described by LOWER-LIMIT and
UPPER-LIMIT.

See Also:
.........

*note Figure 2.9: SyntaxForNumericTokens, *note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*note Section 22.1.3.1.3 (Printing Floats): PrintingFloats.

Notes:
......

Note that all mathematical integers are representable not only as Common
Lisp reals, but also as complex floats.  For example, possible
representations of the mathematical number 1 include the integer ‘1’,
the float ‘1.0’, or the complex ‘#C(1.0 0.0)’.


File: ansicl,  Node: short-float; single-float; double-float; long-float,  Next: rational (System Class),  Prev: float (System Class),  Up: Numbers

short-float, single-float, double-float, long-float (Type)
==========================================================

Supertypes:
...........

‘short-float’: ‘short-float’, ‘float’, ‘real’, ‘number’, ‘t’

‘single-float’: ‘single-float’, ‘float’, ‘real’, ‘number’, ‘t’

‘double-float’: ‘double-float’, ‘float’, ‘real’, ‘number’, ‘t’

‘long-float’: ‘long-float’, ‘float’, ‘real’, ‘number’, ‘t’

Description:
............

For the four defined subtypes of type ‘float’, it is true that
intermediate between the type ‘short-float’ and the type ‘long-float’
are the type ‘single-float’ and the type ‘double-float’.  The precise
definition of these categories is implementation-defined.  The precision
(measured in “bits”, computed as plog


File: ansicl,  Node: rational (System Class),  Next: ratio,  Prev: short-float; single-float; double-float; long-float,  Up: Numbers

rational (System Class)
=======================

Class Precedence List:
......................

‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

The canonical representation of a rational is as an integer if its value
is integral, and otherwise as a ratio.

The types ‘integer’ and ‘ratio’ are disjoint subtypes of type
‘rational’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(rational [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT—interval designators for type ‘rational’.  The
defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ‘*’.

Compound Type Specifier Description:
....................................

This denotes the rationals on the interval described by LOWER-LIMIT and
UPPER-LIMIT.


File: ansicl,  Node: ratio,  Next: integer,  Prev: rational (System Class),  Up: Numbers

ratio (System Class)
====================

Class Precedence List:
......................

‘ratio’, ‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

A ratio is a number representing the mathematical ratio of two non-zero
integers, the numerator and denominator, whose greatest common divisor
is one, and of which the denominator is positive and greater than one.

See Also:
.........

*note Figure 2.9: SyntaxForNumericTokens, *note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*note Section 22.1.3.1.2 (Printing Ratios): PrintingRatios.


File: ansicl,  Node: integer,  Next: signed-byte,  Prev: ratio,  Up: Numbers

integer (System Class)
======================

Class Precedence List:
......................

‘integer’, ‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

An integer is a mathematical integer.  There is no limit on the
magnitude of an integer.

The types ‘fixnum’ and ‘bignum’ form an exhaustive partition of type
‘integer’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(integer [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT—interval designators for type ‘integer’.  The
defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ‘*’.

Compound Type Specifier Description:
....................................

This denotes the integers on the interval described by LOWER-LIMIT and
UPPER-LIMIT.

See Also:
.........

*note Figure 2.9: SyntaxForNumericTokens, *note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*note Section 22.1.3.1.1 (Printing Integers): PrintingIntegers.

Notes:
......

The type ‘(integer lower upper)’, where lower and upper are
‘most-negative-fixnum’ and ‘most-positive-fixnum’, respectively, is also
called ‘fixnum’.

The type ‘(integer 0 1)’ is also called ‘bit’.  The type ‘(integer 0 *)’
is also called ‘unsigned-byte’.


File: ansicl,  Node: signed-byte,  Next: unsigned-byte,  Prev: integer,  Up: Numbers

signed-byte (Type)
==================

Supertypes:
...........

‘signed-byte’, ‘integer’, ‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

The atomic type specifier ‘signed-byte’ denotes the same type as is
denoted by the type specifier ‘integer’; however, the list forms of
these two type specifiers have different semantics.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(signed-byte [s | *])

Compound Type Specifier Arguments:
..................................

S—a positive integer.

Compound Type Specifier Description:
....................................

This denotes the set of integers that can be represented in
two’s-complement form in a byte of S bits.  This is equivalent to
‘(integer -2^s-1 2^s-1-1)’.  The type ‘signed-byte’ or the type
‘(signed-byte *)’ is the same as the type ‘integer’.


File: ansicl,  Node: unsigned-byte,  Next: mod (Type Specifier),  Prev: signed-byte,  Up: Numbers

unsigned-byte (Type)
====================

Supertypes:
...........

‘unsigned-byte’, ‘signed-byte’, ‘integer’, ‘rational’, ‘real’, ‘number’,
‘t’

Description:
............

The atomic type specifier ‘unsigned-byte’ denotes the same type as is
denoted by the type specifier ‘(integer 0 *)’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(unsigned-byte [S | *])

Compound Type Specifier Arguments:
..................................

S—a positive integer.

Compound Type Specifier Description:
....................................

This denotes the set of non-negative integers that can be represented in
a byte of size S (bits).  This is equivalent to ‘(mod M)’ for M=2^s, or
to ‘(integer 0 N)’ for N=2^s-1.  The type ‘unsigned-byte’ or the type
‘(unsigned-byte *)’ is the same as the type ‘(integer 0 *)’, the set of
non-negative integers.

Notes:
......

The type ‘(unsigned-byte 1)’ is also called ‘bit’.


File: ansicl,  Node: mod (Type Specifier),  Next: bit (Type),  Prev: unsigned-byte,  Up: Numbers

mod (Type Specifier)
====================

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(mod n)

Compound Type Specifier Arguments:
..................................

N—a positive integer.

Compound Type Specifier Description:
....................................

This denotes the set of non-negative integers less than N.  This is
equivalent to ‘(integer 0 (N))’ or to ‘(integer 0 M)’, where M=N-1.

The argument is required, and cannot be *.

The symbol ‘mod’ is not valid as a type specifier.


File: ansicl,  Node: bit (Type),  Next: fixnum,  Prev: mod (Type Specifier),  Up: Numbers

bit (Type)
==========

Supertypes:
...........

‘bit’, ‘unsigned-byte’, ‘signed-byte’, ‘integer’, ‘rational’, ‘real’,
‘number’, ‘t’

Description:
............

The type ‘bit’ is equivalent to the type ‘(integer 0 1)’ and
‘(unsigned-byte 1)’.


File: ansicl,  Node: fixnum,  Next: bignum,  Prev: bit (Type),  Up: Numbers

fixnum (Type)
=============

Supertypes:
...........

‘fixnum’, ‘integer’, ‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

A fixnum is an integer whose value is between ‘most-negative-fixnum’ and
‘most-positive-fixnum’ inclusive.  Exactly which integers are fixnums is
implementation-defined.  The type ‘fixnum’ is required to be a supertype
of ‘(signed-byte 16)’.


File: ansicl,  Node: bignum,  Next: =; /=; <; >; <=; >=,  Prev: fixnum,  Up: Numbers

bignum (Type)
=============

Supertypes:
...........

‘bignum’, ‘integer’, ‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

The type ‘bignum’ is defined to be exactly ‘(and integer (not fixnum))’.


File: ansicl,  Node: =; /=; <; >; <=; >=,  Next: max; min,  Prev: bignum,  Up: Numbers

=, /=, <, >, <=, >= (Function)
==============================

Syntax:
.......

 -- Function: = &rest numbers+ → generalized-boolean
 -- Function: /= &rest numbers+ → generalized-boolean
 -- Function: < &rest numbers+ → generalized-boolean
 -- Function: > &rest numbers+ → generalized-boolean
 -- Function: <= &rest numbers+ → generalized-boolean
 -- Function: >= &rest numbers+ → generalized-boolean

Arguments and Values:
.....................

NUMBER—for ‘<’, ‘>’, ‘<=’, ‘>=’: a real; for ‘=’, ‘/=’: a number.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘=’, ‘/=’, ‘<’, ‘>’, ‘<=’, and ‘>=’ perform arithmetic comparisons on
their arguments as follows:

‘=’

     The value of ‘=’ is true if all NUMBERS are the same in value;
     otherwise it is false.  Two complexes are considered equal by ‘=’
     if their real and imaginary parts are equal according to ‘=’.

‘/=’

     The value of ‘/=’ is true if no two NUMBERS are the same in value;
     otherwise it is false.

‘<’

     The value of ‘<’ is true if the NUMBERS are in monotonically
     increasing order; otherwise it is false.

‘>’

     The value of ‘>’ is true if the NUMBERS are in monotonically
     decreasing order; otherwise it is false.

‘<=’

     The value of ‘<=’ is true if the NUMBERS are in monotonically
     nondecreasing order; otherwise it is false.

‘>=’

     The value of ‘>=’ is true if the NUMBERS are in monotonically
     nonincreasing order; otherwise it is false.

‘=’, ‘/=’, ‘<’, ‘>’, ‘<=’, and ‘>=’ perform necessary type conversions.

Examples:
.........

The uses of these functions are illustrated in the next figure.

‘(= 3 3)’ is true.               ‘(/= 3 3)’ is false.
‘(= 3 5)’ is false.              ‘(/= 3 5)’ is true.
‘(= 3 3 3 3)’ is true.           ‘(/= 3 3 3 3)’ is false.
‘(= 3 3 5 3)’ is false.          ‘(/= 3 3 5 3)’ is false.
‘(= 3 6 5 2)’ is false.          ‘(/= 3 6 5 2)’ is true.
‘(= 3 2 3)’ is false.            ‘(/= 3 2 3)’ is false.
‘(< 3 5)’ is true.               ‘(<= 3 5)’ is true.
‘(< 3 -5)’ is false.             ‘(<= 3 -5)’ is false.
‘(< 3 3)’ is false.              ‘(<= 3 3)’ is true.
‘(< 0 3 4 6 7)’ is true.         ‘(<= 0 3 4 6 7)’ is true.
‘(< 0 3 4 4 6)’ is false.        ‘(<= 0 3 4 4 6)’ is true.
‘(> 4 3)’ is true.               ‘(>= 4 3)’ is true.
‘(> 4 3 2 1 0)’ is true.         ‘(>= 4 3 2 1 0)’ is true.
‘(> 4 3 3 2 0)’ is false.        ‘(>= 4 3 3 2 0)’ is true.
‘(> 4 3 1 2 0)’ is false.        ‘(>= 4 3 1 2 0)’ is false.
‘(= 3)’ is true.                 ‘(/= 3)’ is true.
‘(< 3)’ is true.                 ‘(<= 3)’ is true.
‘(= 3.0 #c(3.0 0.0))’ is true.   ‘(/= 3.0 #c(3.0 1.0))’ is true.
‘(= 3 3.0)’ is true.             ‘(= 3.0s0 3.0d0)’ is true.
‘(= 0.0 -0.0)’ is true.          ‘(= 5/2 2.5)’ is true.
‘(> 0.0 -0.0)’ is false.         ‘(= 0 -0.0)’ is true.

Figure 12.13: Uses of /=, =, <, >, <=, and >=

Exceptional Situations:
.......................

Might signal ‘type-error’ if some argument is not a real.  Might signal
‘arithmetic-error’ if otherwise unable to fulfill its contract.

Notes:
......

‘=’ differs from ‘eql’ in that ‘(= 0.0 -0.0)’ is always true, because
‘=’ compares the mathematical values of its operands, whereas ‘eql’
compares the representational values, so to speak.


File: ansicl,  Node: max; min,  Next: minusp; plusp,  Prev: =; /=; <; >; <=; >=,  Up: Numbers

max, min (Function)
===================

Syntax:
.......

 -- Function: max &rest reals+ → max-real
 -- Function: min &rest reals+ → min-real

Arguments and Values:
.....................

REAL—a real.

MAX-REAL, MIN-REAL—a real.

Description:
............

‘max’ returns the REAL that is greatest (closest to positive infinity).
‘min’ returns the REAL that is least (closest to negative infinity).

For ‘max’, the implementation has the choice of returning the largest
argument as is or applying the rules of floating-point contagion, taking
all the arguments into consideration for contagion purposes.  Also, if
one or more of the arguments are ‘=’, then any one of them may be chosen
as the value to return.  For example, if the REALS are a mixture of
rationals and floats, and the largest argument is a rational, then the
implementation is free to produce either that rational or its float
approximation; if the largest argument is a float of a smaller format
than the largest format of any float argument, then the implementation
is free to return the argument in its given format or expanded to the
larger format.  Similar remarks apply to ‘min’ (replacing “largest
argument” by “smallest argument”).

Examples:
.........

      (max 3) → 3
      (min 3) → 3
      (max 6 12) → 12
      (min 6 12) → 6
      (max -6 -12) → -6
      (min -6 -12) → -12
      (max 1 3 2 -7) → 3
      (min 1 3 2 -7) → -7
      (max -2 3 0 7) → 7
      (min -2 3 0 7) → -2
      (max 5.0 2) → 5.0
      (min 5.0 2)
     → 2
     or→ 2.0
      (max 3.0 7 1)
     → 7
     or→ 7.0
      (min 3.0 7 1)
     → 1
     or→ 1.0
      (max 1.0s0 7.0d0) → 7.0d0
      (min 1.0s0 7.0d0)
     → 1.0s0
     or→ 1.0d0
      (max 3 1 1.0s0 1.0d0)
     → 3
     or→ 3.0d0
      (min 3 1 1.0s0 1.0d0)
     → 1
     or→ 1.0s0
     or→ 1.0d0

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NUMBER is not a real.


File: ansicl,  Node: minusp; plusp,  Next: zerop,  Prev: max; min,  Up: Numbers

minusp, plusp (Function)
========================

Syntax:
.......

 -- Function: minusp real → generalized-boolean

 -- Function: plusp real → generalized-boolean

Arguments and Values:
.....................

REAL—a real.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘minusp’ returns true if REAL is less than zero; otherwise, returns
false.

‘plusp’ returns true if REAL is greater than zero; otherwise, returns
false.

Regardless of whether an implementation provides distinct
representations for positive and negative float zeros, ‘(minusp -0.0)’
always returns false.

Examples:
.........

      (minusp -1) → true
      (plusp 0) → false
      (plusp least-positive-single-float) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if REAL is not a real.


File: ansicl,  Node: zerop,  Next: floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround,  Prev: minusp; plusp,  Up: Numbers

zerop (Function)
================

Syntax:
.......

 -- Function: zerop number → generalized-boolean

Pronunciation:
..............

[ˈzē(ˌ)rō(ˌ)pē]

Arguments and Values:
.....................

NUMBER—a number.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if NUMBER is zero (integer, float, or complex); otherwise,
returns false.

Regardless of whether an implementation provides distinct
representations for positive and negative floating-point zeros, ‘(zerop
-0.0)’ always returns true.

Examples:
.........

      (zerop 0) → true
      (zerop 1) → false
      (zerop -0.0) → true
      (zerop 0/100) → true
      (zerop #c(0 0.0)) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NUMBER is not a number.

Notes:
......

      (zerop NUMBER) ≡ (= NUMBER 0)


File: ansicl,  Node: floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround,  Next: sin; cos; tan,  Prev: zerop,  Up: Numbers

floor, ffloor, ceiling, fceiling, truncate, ftruncate, round, fround (Function)
===============================================================================

Syntax:
.......

 -- Function: floor number &optional divisor → quotient, remainder
 -- Function: ffloor number &optional divisor → quotient, remainder
 -- Function: ceiling number &optional divisor → quotient, remainder
 -- Function: fceiling number &optional divisor → quotient, remainder
 -- Function: truncate number &optional divisor → quotient, remainder
 -- Function: ftruncate number &optional divisor → quotient, remainder
 -- Function: round number &optional divisor → quotient, remainder
 -- Function: fround number &optional divisor → quotient, remainder

Arguments and Values:
.....................

NUMBER—a real.

DIVISOR—a non-zero real.  The default is the integer ‘1’.

QUOTIENT—for ‘floor’, ‘ceiling’, ‘truncate’, and ‘round’: an integer;
for ‘ffloor’, ‘fceiling’, ‘ftruncate’, and ‘fround’: a float.

REMAINDER—a real.

Description:
............

These functions divide NUMBER by DIVISOR, returning a QUOTIENT and
REMAINDER, such that

QUOTIENT· DIVISOR+REMAINDER=NUMBER

The QUOTIENT always represents a mathematical integer.  When more than
one mathematical integer might be possible (i.e., when the remainder is
not zero), the kind of rounding or truncation depends on the operator:

‘floor’, ‘ffloor’

     ‘floor’ and ‘ffloor’ produce a QUOTIENT that has been truncated
     toward negative infinity; that is, the QUOTIENT represents the
     largest mathematical integer that is not larger than the
     mathematical quotient.

‘ceiling’, ‘fceiling’

     ‘ceiling’ and ‘fceiling’ produce a QUOTIENT that has been truncated
     toward positive infinity; that is, the QUOTIENT represents the
     smallest mathematical integer that is not smaller than the
     mathematical result.

‘truncate’, ‘ftruncate’

     ‘truncate’ and ‘ftruncate’ produce a QUOTIENT that has been
     truncated towards zero; that is, the QUOTIENT represents the
     mathematical integer of the same sign as the mathematical quotient,
     and that has the greatest integral magnitude not greater than that
     of the mathematical quotient.

‘round’, ‘fround’

     ‘round’ and ‘fround’ produce a QUOTIENT that has been rounded to
     the nearest mathematical integer; if the mathematical quotient is
     exactly halfway between two integers, (that is, it has the form
     integer+1/2), then the QUOTIENT has been rounded to the even
     (divisible by two) integer.

All of these functions perform type conversion operations on NUMBERS.

The REMAINDER is an integer if both ‘x’ and ‘y’ are integers, is a
rational if both ‘x’ and ‘y’ are rationals, and is a float if either ‘x’
or ‘y’ is a float.

‘ffloor’, ‘fceiling’, ‘ftruncate’, and ‘fround’ handle arguments of
different types in the following way: If NUMBER is a float, and DIVISOR
is not a float of longer format, then the first result is a float of the
same type as NUMBER.  Otherwise, the first result is of the type
determined by contagion rules; see *note Section 12.1.1.2 (Contagion in
Numeric Operations): NumericContagionRules.

Examples:
.........

      (floor 3/2) → 1, 1/2
      (ceiling 3 2) → 2, -1
      (ffloor 3 2) → 1.0, 1
      (ffloor -4.7) → -5.0, 0.3
      (ffloor 3.5d0) → 3.0d0, 0.5d0
      (fceiling 3/2) → 2.0, -1/2
      (truncate 1) → 1, 0
      (truncate .5) → 0, 0.5
      (round .5) → 0, 0.5
      (ftruncate -7 2) → -3.0, -1
      (fround -7 2) → -4.0, 1
      (dolist (n '(2.6 2.5 2.4 0.7 0.3 -0.3 -0.7 -2.4 -2.5 -2.6))
        (format t "~&~4,1@F ~2,' D ~2,' D ~2,' D ~2,' D"
                n (floor n) (ceiling n) (truncate n) (round n)))
     ▷ +2.6  2  3  2  3
     ▷ +2.5  2  3  2  2
     ▷ +2.4  2  3  2  2
     ▷ +0.7  0  1  0  1
     ▷ +0.3  0  1  0  0
     ▷ -0.3 -1  0  0  0
     ▷ -0.7 -1  0  0 -1
     ▷ -2.4 -3 -2 -2 -2
     ▷ -2.5 -3 -2 -2 -2
     ▷ -2.6 -3 -2 -2 -3
     → NIL

Notes:
......

When only NUMBER is given, the two results are exact; the mathematical
sum of the two results is always equal to the mathematical value of
NUMBER.

‘(function NUMBER DIVISOR)’ and ‘(function (/ NUMBER DIVISOR))’ (where
function is any of one of ‘floor’, ‘ceiling’, ‘ffloor’, ‘fceiling’,
‘truncate’, ‘round’, ‘ftruncate’, and ‘fround’) return the same first
value, but they return different remainders as the second value.  For
example:

      (floor 5 2) → 2, 1
      (floor (/ 5 2)) → 2, 1/2

If an effect is desired that is similar to ‘round’, but that always
rounds up or down (rather than toward the nearest even integer) if the
mathematical quotient is exactly halfway between two integers, the
programmer should consider a construction such as ‘(floor (+ x 1/2))’ or
‘(ceiling (- x 1/2))’.


File: ansicl,  Node: sin; cos; tan,  Next: asin; acos; atan,  Prev: floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround,  Up: Numbers

sin, cos, tan (Function)
========================

Syntax:
.......

 -- Function: sin radians → number
 -- Function: cos radians → number
 -- Function: tan radians → number

Arguments and Values:
.....................

RADIANS—a number given in radians.

NUMBER—a number.

Description:
............

‘sin’, ‘cos’, and ‘tan’ return the sine, cosine, and tangent,
respectively, of RADIANS.

Examples:
.........

      (sin 0) → 0.0
      (cos 0.7853982) → 0.707107
      (tan #c(0 1)) → #C(0.0 0.761594)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if RADIANS is not a number.
Might signal ‘arithmetic-error’.

See Also:
.........

*note asin::, *note acos::, *note atan::, *note Section 12.1.3.3 (Rule
of Float Substitutability): FloatSubstitutability.


File: ansicl,  Node: asin; acos; atan,  Next: pi,  Prev: sin; cos; tan,  Up: Numbers

asin, acos, atan (Function)
===========================

Syntax:
.......

 -- Function: asin number → radians
 -- Function: acos number → radians
 -- Function: atan number1 &optional number2 → radians

Arguments and Values:
.....................

NUMBER—a number.

NUMBER1—a number if NUMBER2 is not supplied, or a real if NUMBER2 is
supplied.

NUMBER2—a real.

RADIANS—a number (of radians).

Description:
............

‘asin’, ‘acos’, and ‘atan’ compute the arc sine, arc cosine, and arc
tangent respectively.

The arc sine, arc cosine, and arc tangent (with only NUMBER1 supplied)
functions can be defined mathematically for NUMBER or NUMBER1 specified
as x as in the next figure.

Function      Definition
--------------------------------------------------
Arc sine      -i log (ix+ sqrt(1-x^2) )
Arc cosine    (π/2) - arcsin x
Arc tangent   -i log ((1+ix) sqrt(1/(1+x^2)) )

Figure 12.14: Mathematical definition of arc sine, arc cosine, and arc
tangent

These formulae are mathematically correct, assuming completely accurate
computation.  They are not necessarily the simplest ones for real-valued
computations.

If both NUMBER1 and NUMBER2 are supplied for ‘atan’, the result is the
arc tangent of NUMBER1/NUMBER2.  The value of ‘atan’ is always between
-π (exclusive) and π (inclusive) when minus zero is not supported.  The
range of the two-argument arc tangent when minus zero is supported
includes -π.

For a real NUMBER1, the result is a real and lies between -π/2 and π/2
(both exclusive).  NUMBER1 can be a complex if NUMBER2 is not supplied.
If both are supplied, NUMBER2 can be zero provided NUMBER1 is not zero.

The following definition for arc sine determines the range and branch
cuts:

     arcsin z = -i log (iz+sqrt(1-z^2))

The branch cut for the arc sine function is in two pieces: one along the
negative real axis to the left of -1 (inclusive), continuous with
quadrant II, and one along the positive real axis to the right of 1
(inclusive), continuous with quadrant IV. The range is that strip of the
complex plane containing numbers whose real part is between -π/2
and π/2.  A number with real part equal to -π/2 is in the range if and
only if its imaginary part is non-negative; a number with real part
equal to π/2 is in the range if and only if its imaginary part is
non-positive.

The following definition for arc cosine determines the range and branch
cuts:

     arccos z = π/2- arcsin z

or, which are equivalent,

     arccos z = -i log (z+i sqrt(1-z^2))

     arccos z = 2 log (sqrt((1+z)/2) + i sqrt((1-z)/2))/(i)

The branch cut for the arc cosine function is in two pieces: one along
the negative real axis to the left of -1 (inclusive), continuous with
quadrant II, and one along the positive real axis to the right of 1
(inclusive), continuous with quadrant IV. This is the same branch cut as
for arc sine.  The range is that strip of the complex plane containing
numbers whose real part is between 0 and π.  A number with real part
equal to 0 is in the range if and only if its imaginary part is
non-negative; a number with real part equal to π is in the range if and
only if its imaginary part is non-positive.

The following definition for (one-argument) arc tangent determines the
range and branch cuts:

     arctan z = (log (1+iz) - log (1-iz))/2i

Beware of simplifying this formula; “obvious” simplifications are likely
to alter the branch cuts or the values on the branch cuts incorrectly.
The branch cut for the arc tangent function is in two pieces: one along
the positive imaginary axis above i (exclusive), continuous with
quadrant II, and one along the negative imaginary axis below -i
(exclusive), continuous with quadrant IV. The points i and -i are
excluded from the domain.  The range is that strip of the complex plane
containing numbers whose real part is between -π/2 and π/2.  A number
with real part equal to -π/2 is in the range if and only if its
imaginary part is strictly positive; a number with real part equal to
π/2 is in the range if and only if its imaginary part is strictly
negative.  Thus the range of arc tangent is identical to that of arc
sine with the points -π/2 and π/2 excluded.

For ‘atan’, the signs of NUMBER1 (indicated as x) and NUMBER2 (indicated
as y) are used to derive quadrant information.  The next figure details
various special cases.  The asterisk (*) indicates that the entry in the
figure applies to implementations that support minus zero.

 y Condition   x Condition   Cartesian locus   Range of result
--------------------------------------------------------------------
 y = 0         x > 0         Positive x-axis   0
* y = +0       x > 0         Positive x-axis   +0
* y = -0       x > 0         Positive x-axis   -0
 y > 0         x > 0         Quadrant I        0 < result < π/2
 y > 0         x = 0         Positive y-axis   π/2
 y > 0         x < 0         Quadrant II       π/2 < result < π
 y = 0         x < 0         Negative x-axis   π
* y = +0       x < 0         Negative x-axis   +π
* y = -0       x < 0         Negative x-axis   -π
 y < 0         x < 0         Quadrant III      -π < result < -π/2
 y < 0         x = 0         Negative y-axis   -π/2
 y < 0         x > 0         Quadrant IV       -π/2 < result < 0
 y = 0         x = 0         Origin            undefined
                                               consequences
* y = +0       x = +0        Origin            +0
* y = -0       x = +0        Origin            -0
* y = +0       x = -0        Origin            +π
* y = -0       x = -0        Origin            -π

Figure 12.15: Quadrant information for arc tangent

Examples:
.........

      (asin 0) → 0.0
      (acos #c(0 1))  → #C(1.5707963267948966 -0.8813735870195432)
      (/ (atan 1 (sqrt 3)) 6)  → 0.087266
      (atan #c(0 2)) → #C(-1.5707964 0.54930615)

Exceptional Situations:
.......................

‘acos’ and ‘asin’ should signal an error of type ‘type-error’ if NUMBER
is not a number.  ‘atan’ should signal ‘type-error’ if one argument is
supplied and that argument is not a number, or if two arguments are
supplied and both of those arguments are not reals.

‘acos’, ‘asin’, and ‘atan’ might signal ‘arithmetic-error’.

See Also:
.........

*note log::, *note sqrt::, *note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.

Notes:
......

The result of either ‘asin’ or ‘acos’ can be a complex even if NUMBER is
not a complex; this occurs when the absolute value of NUMBER is greater
than one.


File: ansicl,  Node: pi,  Next: sinh; cosh; tanh; asinh; acosh; atanh,  Prev: asin; acos; atan,  Up: Numbers

pi (Constant Variable)
======================

Value:
......

an implementation-dependent long float.

Description:
............

The best long float approximation to the mathematical constant π.

Examples:
.........

      ;; In each of the following computations, the precision depends
      ;; on the implementation.  Also, if `long float' is treated by
      ;; the implementation as equivalent to some other float format
      ;; (e.g., `double float') the exponent marker might be the marker
      ;; for that equivalent (e.g., `D' instead of `L').
      pi → 3.141592653589793L0
      (cos pi) → -1.0L0

      (defun sin-of-degrees (degrees)
        (let ((x (if (floatp degrees) degrees (float degrees pi))))
          (sin (* x (/ (float pi x) 180)))))

Notes:
......

An approximation to π in some other precision can be obtained by writing
‘(float pi x)’, where ‘x’ is a float of the desired precision, or by
writing ‘(coerce pi type)’, where type is the desired type, such as
‘short-float’.


File: ansicl,  Node: sinh; cosh; tanh; asinh; acosh; atanh,  Next: * (Function),  Prev: pi,  Up: Numbers

sinh, cosh, tanh, asinh, acosh, atanh (Function)
================================================

Syntax:
.......

 -- Function: sinh number → result
 -- Function: cosh number → result
 -- Function: tanh number → result
 -- Function: asinh number → result
 -- Function: acosh number → result
 -- Function: atanh number → result

Arguments and Values:
.....................

NUMBER—a number.

RESULT—a number.

Description:
............

These functions compute the hyperbolic sine, cosine, tangent, arc sine,
arc cosine, and arc tangent functions, which are mathematically defined
for an argument x as given in the next figure.

Function                 Definition
------------------------------------------------------------------
Hyperbolic sine          (e^x-e^-x)/2
Hyperbolic cosine        (e^x+e^-x)/2
Hyperbolic tangent       (e^x-e^-x)/(e^x+e^-x)
Hyperbolic arc sine      log (x+sqrt(1+x^2))
Hyperbolic arc cosine    2 log (sqrt((x+1)/2) + sqrt((x-1)/2))
Hyperbolic arc tangent   (log (1+x) - log(1-x))/2

Figure 12.16: Mathematical definitions for hyperbolic functions

The following definition for the inverse hyperbolic cosine determines
the range and branch cuts:

     arccosh z = 2 log (sqrt((z+1)/2) + sqrt((z-1)/2)).

The branch cut for the inverse hyperbolic cosine function lies along the
real axis to the left of 1 (inclusive), extending indefinitely along the
negative real axis, continuous with quadrant II and (between 0 and 1)
with quadrant I. The range is that half-strip of the complex plane
containing numbers whose real part is non-negative and whose imaginary
part is between -π (exclusive) and π (inclusive).  A number with real
part zero is in the range if its imaginary part is between zero
(inclusive) and π (inclusive).

The following definition for the inverse hyperbolic sine determines the
range and branch cuts:

     arcsinh z = log (z+sqrt(1+z^2)).

The branch cut for the inverse hyperbolic sine function is in two
pieces: one along the positive imaginary axis above i (inclusive),
continuous with quadrant I, and one along the negative imaginary axis
below -i (inclusive), continuous with quadrant III. The range is that
strip of the complex plane containing numbers whose imaginary part is
between -π/2 and π/2.  A number with imaginary part equal to -π/2 is in
the range if and only if its real part is non-positive; a number with
imaginary part equal to π/2 is in the range if and only if its imaginary
part is non-negative.

The following definition for the inverse hyperbolic tangent determines
the range and branch cuts:

     arctanh z = (log (1+z) - log (1-z))/2.

Note that:

     i arctan z = arctanh iz.

The branch cut for the inverse hyperbolic tangent function is in two
pieces: one along the negative real axis to the left of -1 (inclusive),
continuous with quadrant III, and one along the positive real axis to
the right of 1 (inclusive), continuous with quadrant I. The points -1
and 1 are excluded from the domain.  The range is that strip of the
complex plane containing numbers whose imaginary part is between -π/2
and π/2.  A number with imaginary part equal to -π/2 is in the range if
and only if its real part is strictly negative; a number with imaginary
part equal to π/2 is in the range if and only if its imaginary part is
strictly positive.  Thus the range of the inverse hyperbolic tangent
function is identical to that of the inverse hyperbolic sine function
with the points -π i/2 and π i/2 excluded.

Examples:
.........

      (sinh 0) → 0.0
      (cosh (complex 0 -1)) → #C(0.540302 -0.0)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NUMBER is not a number.
Might signal ‘arithmetic-error’.

See Also:
.........

*note log::, *note sqrt::, *note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.

Notes:
......

The result of ‘acosh’ may be a complex even if NUMBER is not a complex;
this occurs when NUMBER is less than one.  Also, the result of ‘atanh’
may be a complex even if NUMBER is not a complex; this occurs when the
absolute value of NUMBER is greater than one.

The branch cut formulae are mathematically correct, assuming completely
accurate computation.  Implementors should consult a good text on
numerical analysis.  The formulae given above are not necessarily the
simplest ones for real-valued computations; they are chosen to define
the branch cuts in desirable ways for the complex case.


File: ansicl,  Node: * (Function),  Next: + (Function),  Prev: sinh; cosh; tanh; asinh; acosh; atanh,  Up: Numbers

* (Function)
============

Syntax:
.......

 -- Function: * &rest numbers → product

Arguments and Values:
.....................

NUMBER—a number.

PRODUCT—a number.

Description:
............

Returns the product of NUMBERS, performing any necessary type
conversions in the process.  If no NUMBERS are supplied, ‘1’ is
returned.

Examples:
.........

      (*) → 1
      (* 3 5) → 15
      (* 1.0 #c(22 33) 55/98) → #C(12.346938775510203 18.520408163265305)

Exceptional Situations:
.......................

Might signal ‘type-error’ if some argument is not a number.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note Section 12.1.1 (Numeric Operations): Numeric Operations, *note
Section 12.1.3 (Rational Computations): Rational Computations, *note
Section 12.1.4 (Floating-point Computations): Floating-point
Computations, *note Section 12.1.5 (Complex Computations): Complex
Computations.


File: ansicl,  Node: + (Function),  Next: - (Function),  Prev: * (Function),  Up: Numbers

+ (Function)
============

Syntax:
.......

 -- Function: + &rest numbers → sum

Arguments and Values:
.....................

NUMBER—a number.

SUM—a number.

Description:
............

Returns the sum of NUMBERS, performing any necessary type conversions in
the process.  If no NUMBERS are supplied, ‘0’ is returned.

Examples:
.........

      (+) → 0
      (+ 1) → 1
      (+ 31/100 69/100) → 1
      (+ 1/5 0.8) → 1.0

Exceptional Situations:
.......................

Might signal ‘type-error’ if some argument is not a number.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note Section 12.1.1 (Numeric Operations): Numeric Operations, *note
Section 12.1.3 (Rational Computations): Rational Computations, *note
Section 12.1.4 (Floating-point Computations): Floating-point
Computations, *note Section 12.1.5 (Complex Computations): Complex
Computations.


File: ansicl,  Node: - (Function),  Next: / (Function),  Prev: + (Function),  Up: Numbers

- (Function)
============

Syntax:
.......

 -- Function: - number → negation

 -- Function: - minuend &rest subtrahends+ → difference

Arguments and Values:
.....................

NUMBER, MINUEND, SUBTRAHEND—a number.

NEGATION, DIFFERENCE—a number.

Description:
............

The function ‘-’ performs arithmetic subtraction and negation.

If only one NUMBER is supplied, the negation of that NUMBER is returned.

If more than one argument is given, it subtracts all of the SUBTRAHENDS
from the MINUEND and returns the result.

The function ‘-’ performs necessary type conversions.

Examples:
.........

      (- 55.55) → -55.55
      (- #c(3 -5)) → #C(-3 5)
      (- 0) → 0
      (eql (- 0.0) -0.0) → true
      (- #c(100 45) #c(0 45)) → 100
      (- 10 1 2 3 4) → 0

Exceptional Situations:
.......................

Might signal ‘type-error’ if some argument is not a number.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note Section 12.1.1 (Numeric Operations): Numeric Operations, *note
Section 12.1.3 (Rational Computations): Rational Computations, *note
Section 12.1.4 (Floating-point Computations): Floating-point
Computations, *note Section 12.1.5 (Complex Computations): Complex
Computations.


File: ansicl,  Node: / (Function),  Next: 1+; 1-,  Prev: - (Function),  Up: Numbers

/ (Function)
============

Syntax:
.......

 -- Function: / number → reciprocal
 -- Function: / numerator &rest denominators+ → quotient

Arguments and Values:
.....................

NUMBER, DENOMINATOR—a non-zero number.

NUMERATOR, QUOTIENT, RECIPROCAL—a number.

Description:
............

The function ‘/’ performs division or reciprocation.

If no DENOMINATORS are supplied, the function ‘/’ returns the reciprocal
of NUMBER.

If at least one DENOMINATOR is supplied, the function ‘/’ divides the
NUMERATOR by all of the DENOMINATORS and returns the resulting QUOTIENT.

If each argument is either an integer or a ratio, and the result is not
an integer, then it is a ratio.

The function ‘/’ performs necessary type conversions.

If any ARGUMENT is a float then the rules of floating-point contagion
apply; see *note Section 12.1.4 (Floating-point Computations):
Floating-point Computations.

Examples:
.........

      (/ 12 4) → 3
      (/ 13 4) → 13/4
      (/ -8) → -1/8
      (/ 3 4 5) → 3/20
      (/ 0.5) → 2.0
      (/ 20 5) → 4
      (/ 5 20) → 1/4
      (/ 60 -2 3 5.0) → -2.0
      (/ 2 #c(2 2)) → #C(1/2 -1/2)

Exceptional Situations:
.......................

The consequences are unspecified if any argument other than the first is
zero.  If there is only one argument, the consequences are unspecified
if it is zero.

Might signal ‘type-error’ if some argument is not a number.  Might
signal ‘division-by-zero’ if division by zero is attempted.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note floor::, *note ceiling::, *note truncate::, *note round::


File: ansicl,  Node: 1+; 1-,  Next: abs,  Prev: / (Function),  Up: Numbers

1+, 1- (Function)
=================

Syntax:
.......

 -- Function: 1+ number → successor
 -- Function: 1- number → predecessor

Arguments and Values:
.....................

NUMBER—a number.

SUCCESSOR, PREDECESSOR—a number.

Description:
............

‘1+’ returns a number that is one more than its argument NUMBER.  ‘1-’
returns a number that is one less than its argument NUMBER.

Examples:
.........

      (1+ 99) → 100
      (1- 100) → 99
      (1+ (complex 0.0)) → #C(1.0 0.0)
      (1- 5/3) → 2/3

Exceptional Situations:
.......................

Might signal ‘type-error’ if its argument is not a number.  Might signal
‘arithmetic-error’.

See Also:
.........

*note incf::, *note decf::

Notes:
......

      (1+ NUMBER) ≡ (+ NUMBER 1)
      (1- NUMBER) ≡ (- NUMBER 1)

Implementors are encouraged to make the performance of both the previous
expressions be the same.


File: ansicl,  Node: abs,  Next: evenp; oddp,  Prev: 1+; 1-,  Up: Numbers

abs (Function)
==============

Syntax:
.......

 -- Function: abs number → absolute-value

Arguments and Values:
.....................

NUMBER—a number.

ABSOLUTE-VALUE—a non-negative real.

Description:
............

‘abs’ returns the absolute value of NUMBER.

If NUMBER is a real, the result is of the same type as NUMBER.

If NUMBER is a complex, the result is a positive real with the same
magnitude as NUMBER.  The result can be a float

even if NUMBER’s components are rationals and an exact rational result
would have been possible.  Thus the result of ‘(abs #c(3 4))’ can be
either ‘5’ or ‘5.0’, depending on the implementation.

Examples:
.........

      (abs 0) → 0
      (abs 12/13) → 12/13
      (abs -1.09) → 1.09
      (abs #c(5.0 -5.0)) → 7.071068
      (abs #c(5 5)) → 7.071068
      (abs #c(3/5 4/5)) → 1 or approximately 1.0
      (eql (abs -0.0) -0.0) → true

See Also:
.........

*note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.

Notes:
......

If NUMBER is a complex, the result is equivalent to the following:

‘(sqrt (+ (expt (realpart NUMBER) 2) (expt (imagpart NUMBER) 2)))’

An implementation should not use this formula directly for all complexes
but should handle very large or very small components specially to avoid
intermediate overflow or underflow.


File: ansicl,  Node: evenp; oddp,  Next: exp; expt,  Prev: abs,  Up: Numbers

evenp, oddp (Function)
======================

Syntax:
.......

 -- Function: evenp integer → generalized-boolean
 -- Function: oddp integer → generalized-boolean

Arguments and Values:
.....................

INTEGER—an integer.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘evenp’ returns true if INTEGER is even (divisible by two); otherwise,
returns false.

‘oddp’ returns true if INTEGER is odd (not divisible by two); otherwise,
returns false.

Examples:
.........

      (evenp 0) → true
      (oddp 10000000000000000000000) → false
      (oddp -1) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INTEGER is not an
integer.

Notes:
......

      (evenp INTEGER) ≡ (not (oddp INTEGER))
      (oddp INTEGER)  ≡ (not (evenp INTEGER))


File: ansicl,  Node: exp; expt,  Next: gcd,  Prev: evenp; oddp,  Up: Numbers

exp, expt (Function)
====================

Syntax:
.......

 -- Function: exp number → result
 -- Function: expt base-number power-number → result

Arguments and Values:
.....................

NUMBER—a number.

BASE-NUMBER—a number.

POWER-NUMBER—a number.

RESULT—a number.

Description:
............

‘exp’ and ‘expt’ perform exponentiation.

‘exp’ returns e raised to the power NUMBER, where e is the base of the
natural logarithms.  ‘exp’ has no branch cut.

‘expt’ returns BASE-NUMBER raised to the power POWER-NUMBER.  If the
BASE-NUMBER is a rational and POWER-NUMBER is an integer, the
calculation is exact and the result will be of type ‘rational’;
otherwise a floating-point approximation might result.  For ‘expt’ of a
complex rational to an integer power, the calculation must be exact and
the result is of type ‘(or rational (complex rational))’.

The result of ‘expt’ can be a complex, even when neither argument is a
complex, if BASE-NUMBER is negative and POWER-NUMBER is not an integer.
The result is always the principal complex value.  For example, ‘(expt
-8 1/3)’ is not permitted to return ‘-2’, even though ‘-2’ is one of the
cube roots of ‘-8’.  The principal cube root is a complex approximately
equal to ‘#C(1.0 1.73205)’, not ‘-2’.

‘expt’ is defined as b^x = e^x log b.  This defines the principal values
precisely.  The range of ‘expt’ is the entire complex plane.  Regarded
as a function of x, with b fixed, there is no branch cut.  Regarded as a
function of b, with x fixed, there is in general a branch cut along the
negative real axis, continuous with quadrant II. The domain excludes the
origin.  By definition, 0^0=1.  If b=0 and the real part of x is
strictly positive, then b^x=0.  For all other values of x, 0^x is an
error.

When POWER-NUMBER is an integer ‘0’, then the result is always the value
one in the type of BASE-NUMBER, even if the BASE-NUMBER is zero (of any
type).  That is:

      (expt x 0) ≡ (coerce 1 (type-of x))

If POWER-NUMBER is a zero of any other type, then the result is also the
value one, in the type of the arguments after the application of the
contagion rules in *note Section 12.1.1.2 (Contagion in Numeric
Operations): NumericContagionRules, with one exception: the consequences
are undefined if BASE-NUMBER is zero when POWER-NUMBER is zero and not
of type ‘integer’.

Examples:
.........

      (exp 0) → 1.0
      (exp 1) → 2.718282
      (exp (log 5)) → 5.0
      (expt 2 8) → 256
      (expt 4 .5) → 2.0
      (expt #c(0 1) 2) → -1
      (expt #c(2 2) 3) → #C(-16 16)
      (expt #c(2 2) 4) → -64

See Also:
.........

*note log::, *note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.

Notes:
......

Implementations of ‘expt’ are permitted to use different algorithms for
the cases of a POWER-NUMBER of type ‘rational’ and a POWER-NUMBER of
type ‘float’.

Note that by the following logic, ‘(sqrt (expt x 3))’ is not equivalent
to ‘(expt x 3/2)’.

      (setq x (exp (/ (* 2 pi #c(0 1)) 3)))         ;exp(2.pi.i/3)
      (expt x 3) → 1 ;except for round-off error
      (sqrt (expt x 3)) → 1 ;except for round-off error
      (expt x 3/2) → -1 ;except for round-off error


File: ansicl,  Node: gcd,  Next: incf; decf,  Prev: exp; expt,  Up: Numbers

gcd (Function)
==============

Syntax:
.......

 -- Function: gcd &rest integers → greatest-common-denominator

Arguments and Values:
.....................

INTEGER—an integer.

GREATEST-COMMON-DENOMINATOR—a non-negative integer.

Description:
............

Returns the greatest common divisor of INTEGERS.  If only one INTEGER is
supplied, its absolute value is returned.  If no INTEGERS are given,
‘gcd’ returns ‘0’, which is an identity for this operation.

Examples:
.........

      (gcd) → 0
      (gcd 60 42) → 6
      (gcd 3333 -33 101) → 1
      (gcd 3333 -33 1002001) → 11
      (gcd 91 -49) → 7
      (gcd 63 -42 35) → 7
      (gcd 5) → 5
      (gcd -4) → 4

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INTEGER is not an
integer.

See Also:
.........

*note lcm::

Notes:
......

For three or more arguments,

      (gcd b c ... z) ≡ (gcd (gcd a b) c ... z)


File: ansicl,  Node: incf; decf,  Next: lcm,  Prev: gcd,  Up: Numbers

incf, decf (Macro)
==================

Syntax:
.......

 -- Macro: incf place [delta-form] → new-value
 -- Macro: decf place [delta-form] → new-value

Arguments and Values:
.....................

PLACE—a place.

DELTA-FORM—a form; evaluated to produce a DELTA.  The default is ‘1’.

DELTA—a number.

NEW-VALUE—a number.

Description:
............

‘incf’ and ‘decf’ are used for incrementing and decrementing the value
of PLACE, respectively.

The DELTA is added to (in the case of ‘incf’) or subtracted from (in the
case of ‘decf’) the number in PLACE and the result is stored in PLACE.

Any necessary type conversions are performed automatically.

For information about the evaluation of subforms of PLACES, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

      (setq n 0)
      (incf n) → 1
      n → 1
      (decf n 3) → -2
      n → -2
      (decf n -5) → 3
      (decf n) → 2
      (incf n 0.5) → 2.5
      (decf n) → 1.5
      n → 1.5

Side Effects:
.............

PLACE is modified.

See Also:
.........

*note + (Function)::, *note - (Function)::, *note 1+::, *note 1-
(Function)::, *note setf::


File: ansicl,  Node: lcm,  Next: log,  Prev: incf; decf,  Up: Numbers

lcm (Function)
==============

Syntax:
.......

 -- Function: lcm &rest integers → least-common-multiple

Arguments and Values:
.....................

INTEGER—an integer.

LEAST-COMMON-MULTIPLE—a non-negative integer.

Description:
............

‘lcm’ returns the least common multiple of the INTEGERS.

If no INTEGER is supplied, the integer ‘1’ is returned.

If only one INTEGER is supplied, the absolute value of that INTEGER is
returned.

For two arguments that are not both zero,

      (lcm a b) ≡ (/ (abs (* a b)) (gcd a b))

If one or both arguments are zero,

      (lcm a 0) ≡ (lcm 0 a) ≡ 0

For three or more arguments,

      (lcm a b c ... z) ≡ (lcm (lcm a b) c ... z)

Examples:
.........

      (lcm 10) → 10
      (lcm 25 30) → 150
      (lcm -24 18 10) → 360
      (lcm 14 35) → 70
      (lcm 0 5) → 0
      (lcm 1 2 3 4 5 6) → 60

Exceptional Situations:
.......................

Should signal ‘type-error’ if any argument is not an integer.

See Also:
.........

*note gcd::


File: ansicl,  Node: log,  Next: mod; rem,  Prev: lcm,  Up: Numbers

log (Function)
==============

Syntax:
.......

 -- Function: log number &optional base → logarithm

Arguments and Values:
.....................

NUMBER—a non-zero number.

BASE—a number.

LOGARITHM—a number.

Description:
............

‘log’ returns the logarithm of NUMBER in base BASE.  If BASE is not
supplied its value is e, the base of the natural logarithms.

‘log’ may return a complex when given a real negative NUMBER.

      (log -1.0) ≡ (complex 0.0 (float pi 0.0))

If BASE is zero, ‘log’ returns zero.

The result of ‘(log 8 2)’ may be either ‘3’ or ‘3.0’, depending on the
implementation.  An implementation can use floating-point calculations
even if an exact integer result is possible.

The branch cut for the logarithm function of one argument (natural
logarithm) lies along the negative real axis, continuous with quadrant
II. The domain excludes the origin.

The mathematical definition of a complex logarithm is as follows,
whether or not minus zero is supported by the implementation:

     (log x) ≡ (complex (log (abs x)) (phase x))

Therefore the range of the one-argument logarithm function is that strip
of the complex plane containing numbers with imaginary parts between -π
(exclusive) and π (inclusive) if minus zero is not supported, or -π
(inclusive) and π (inclusive) if minus zero is supported.

The two-argument logarithm function is defined as

      (log BASE NUMBER)
      ≡ (/ (log NUMBER) (log BASE))

This defines the principal values precisely.  The range of the
two-argument logarithm function is the entire complex plane.

Examples:
.........

      (log 100 10)
     → 2.0
     → 2
      (log 100.0 10) → 2.0
      (log #c(0 1) #c(0 -1))
     → #C(-1.0 0.0)
     or→ #C(-1 0)
      (log 8.0 2) → 3.0

      (log #c(-16 16) #c(2 2)) → 3 or approximately #c(3.0 0.0)
                                    or approximately 3.0 (unlikely)

Affected By:
............

The implementation.

See Also:
.........

*note exp::, *note expt::, *note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.


File: ansicl,  Node: mod; rem,  Next: signum,  Prev: log,  Up: Numbers

mod, rem (Function)
===================

Syntax:
.......

 -- Function: mod number divisor → modulus
 -- Function: rem number divisor → remainder

Arguments and Values:
.....................

NUMBER—a real.

DIVISOR—a real.

MODULUS, REMAINDER—a real.

Description:
............

‘mod’ and ‘rem’ are generalizations of the modulus and remainder
functions respectively.

‘mod’ performs the operation ‘floor’ on NUMBER and DIVISOR and returns
the remainder of the ‘floor’ operation.

‘rem’ performs the operation ‘truncate’ on NUMBER and DIVISOR and
returns the remainder of the ‘truncate’ operation.

‘mod’ and ‘rem’ are the modulus and remainder functions when NUMBER and
DIVISOR are integers.

Examples:
.........

      (rem -1 5) → -1
      (mod -1 5) → 4
      (mod 13 4) → 1
      (rem 13 4) → 1
      (mod -13 4) → 3
      (rem -13 4) → -1
      (mod 13 -4) → -3
      (rem 13 -4) → 1
      (mod -13 -4) → -1
      (rem -13 -4) → -1
      (mod 13.4 1) → 0.4
      (rem 13.4 1) → 0.4
      (mod -13.4 1) → 0.6
      (rem -13.4 1) → -0.4

See Also:
.........

*note floor::, *note truncate::

Notes:
......

The result of ‘mod’ is either zero or a real with the same sign as
DIVISOR.


File: ansicl,  Node: signum,  Next: sqrt; isqrt,  Prev: mod; rem,  Up: Numbers

signum (Function)
=================

Syntax:
.......

 -- Function: signum number → signed-prototype

Arguments and Values:
.....................

NUMBER—a number.

SIGNED-PROTOTYPE—a number.

Description:
............

‘signum’ determines a numerical value that indicates whether NUMBER is
negative, zero, or positive.

For a rational, ‘signum’ returns one of ‘-1’, ‘0’, or ‘1’ according to
whether NUMBER is negative, zero, or positive.  For a float, the result
is a float of the same format whose value is minus one, zero, or one.
For a complex number ‘z’, ‘(signum z)’ is a complex number of the same
phase but with unit magnitude, unless ‘z’ is a complex zero, in which
case the result is ‘z’.

For rational arguments, ‘signum’ is a rational function, but it may be
irrational for complex arguments.

If NUMBER is a float, the result is a float.  If NUMBER is a rational,
the result is a rational.  If NUMBER is a complex float, the result is a
complex float.  If NUMBER is a complex rational, the result is a
complex, but it is implementation-dependent whether that result is a
complex rational or a complex float.

Examples:
.........

      (signum 0) → 0
      (signum 99) → 1
      (signum 4/5) → 1
      (signum -99/100) → -1
      (signum 0.0) → 0.0
      (signum #c(0 33)) → #C(0.0 1.0)
      (signum #c(7.5 10.0)) → #C(0.6 0.8)
      (signum #c(0.0 -14.7)) → #C(0.0 -1.0)
      (eql (signum -0.0) -0.0) → true

See Also:
.........

*note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.

Notes:
......

      (signum x) ≡ (if (zerop x) x (/ x (abs x)))


File: ansicl,  Node: sqrt; isqrt,  Next: random-state,  Prev: signum,  Up: Numbers

sqrt, isqrt (Function)
======================

Syntax:
.......

 -- Function: sqrt number → root
 -- Function: isqrt natural → natural-root

Arguments and Values:
.....................

NUMBER, ROOT—a number.

NATURAL, NATURAL-ROOT—a non-negative integer.

Description:
............

‘sqrt’ and ‘isqrt’ compute square roots.

‘sqrt’ returns the principal square root of NUMBER.  If the NUMBER is
not a complex but is negative, then the result is a complex.

‘isqrt’ returns the greatest integer less than or equal to the exact
positive square root of NATURAL.

If NUMBER is a positive rational, it is implementation-dependent whether
ROOT is a rational or a float.  If NUMBER is a negative rational, it is
implementation-dependent whether ROOT is a complex rational or a complex
float.

The mathematical definition of complex square root (whether or not minus
zero is supported) follows:

‘(sqrt x) = (exp (/ (log x) 2))’

The branch cut for square root lies along the negative real axis,
continuous with quadrant II. The range consists of the right half-plane,
including the non-negative imaginary axis and excluding the negative
imaginary axis.

Examples:
.........

      (sqrt 9.0) → 3.0
      (sqrt -9.0) → #C(0.0 3.0)
      (isqrt 9) → 3
      (sqrt 12) → 3.4641016
      (isqrt 12) → 3
      (isqrt 300) → 17
      (isqrt 325) → 18
      (sqrt 25)
     → 5
     or→ 5.0
      (isqrt 25) → 5
      (sqrt -1) → #C(0.0 1.0)
      (sqrt #c(0 2)) → #C(1.0 1.0)

Exceptional Situations:
.......................

The function ‘sqrt’ should signal ‘type-error’ if its argument is not a
number.

The function ‘isqrt’ should signal ‘type-error’ if its argument is not a
non-negative integer.

The functions ‘sqrt’ and ‘isqrt’ might signal ‘arithmetic-error’.

See Also:
.........

*note exp::, *note log::, *note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.

Notes:
......

      (isqrt x) ≡ (values (floor (sqrt x)))

but it is potentially more efficient.


File: ansicl,  Node: random-state,  Next: make-random-state,  Prev: sqrt; isqrt,  Up: Numbers

random-state (System Class)
===========================

Class Precedence List:
......................

‘random-state’, ‘t’

Description:
............

A random state object contains state information used by the
pseudo-random number generator.  The nature of a random state object is
implementation-dependent.  It can be printed out and successfully read
back in by the same implementation, but might not function correctly as
a random state in another implementation.

Implementations are required to provide a read syntax for objects of
type ‘random-state’, but the specific nature of that syntax is
implementation-dependent.

See Also:
.........

*note *random-state*::, *note random::, *note Section 22.1.3.10
(Printing Random States): PrintingRandomStates.


File: ansicl,  Node: make-random-state,  Next: random,  Prev: random-state,  Up: Numbers

make-random-state (Function)
============================

Syntax:
.......

 -- Function: make-random-state &optional state → new-state

Arguments and Values:
.....................

STATE—a random state, or ‘nil’, or ‘t’.  The default is ‘nil’.

NEW-STATE—a random state object.

Description:
............

Creates a fresh object of type ‘random-state’ suitable for use as the
value of ‘*random-state*’.

If STATE is a random state object, the NEW-STATE is a copyIf STATE is
‘nil’, the NEW-STATE is a copyIf STATE is ‘t’, the NEW-STATE is a fresh
random state object that has been randomly initialized by some means.

Examples:
.........

      (let* ((rs1 (make-random-state nil))
             (rs2 (make-random-state t))
             (rs3 (make-random-state rs2))
             (rs4 nil))
        (list (loop for i from 1 to 10
                    collect (random 100)
                    when (= i 5)
                     do (setq rs4 (make-random-state)))
              (loop for i from 1 to 10 collect (random 100 rs1))
              (loop for i from 1 to 10 collect (random 100 rs2))
              (loop for i from 1 to 10 collect (random 100 rs3))
              (loop for i from 1 to 10 collect (random 100 rs4))))
     → ((29 25 72 57 55 68 24 35 54 65)
         (29 25 72 57 55 68 24 35 54 65)
         (93 85 53 99 58 62 2 23 23 59)
         (93 85 53 99 58 62 2 23 23 59)
         (68 24 35 54 65 54 55 50 59 49))

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STATE is not a random
state, or ‘nil’, or ‘t’.

See Also:
.........

*note random::, *note *random-state*::

Notes:
......

One important use of ‘make-random-state’ is to allow the same series of
pseudo-random numbers to be generated many times within a single
program.


File: ansicl,  Node: random,  Next: random-state-p,  Prev: make-random-state,  Up: Numbers

random (Function)
=================

Syntax:
.......

 -- Function: random limit &optional random-state → random-number

Arguments and Values:
.....................

LIMIT—a positive integer, or a positive float.

RANDOM-STATE—a random state.  The default is the current random state.

RANDOM-NUMBER—a non-negative number less than LIMIT and of the same type
as LIMIT.

Description:
............

Returns a pseudo-random number that is a non-negative number less than
LIMIT and of the same type as LIMIT.

The RANDOM-STATE, which is modified by this function, encodes the
internal state maintained by the random number generator.

An approximately uniform choice distribution is used.  If LIMIT is an
integer, each of the possible results occurs with (approximate)
probability 1/LIMIT.

Examples:
.........

      (<= 0 (random 1000) 1000) → true
      (let ((state1 (make-random-state))
            (state2 (make-random-state)))
        (= (random 1000 state1) (random 1000 state2))) → true

Side Effects:
.............

The RANDOM-STATE is modified.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if LIMIT is not a positive
integer or a positive real.

See Also:
.........

*note make-random-state::, *note *random-state*::

Notes:
......

See ‘Common Lisp: The Language’ for information about generating random
numbers.


File: ansicl,  Node: random-state-p,  Next: *random-state*,  Prev: random,  Up: Numbers

random-state-p (Function)
=========================

Syntax:
.......

 -- Function: random-state-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘random-state’; otherwise, returns
false.

Examples:
.........

      (random-state-p *random-state*) → true
      (random-state-p (make-random-state)) → true
      (random-state-p 'test-function) → false

See Also:
.........

*note make-random-state::, *note *random-state*::

Notes:
......

      (random-state-p OBJECT) ≡ (typep OBJECT 'random-state)


File: ansicl,  Node: *random-state*,  Next: numberp,  Prev: random-state-p,  Up: Numbers

*random-state* (Variable)
=========================

Value Type:
...........

a random state.

Initial Value:
..............

implementation-dependent.

Description:
............

The current random state, which is used, for example, by the function
‘random’ when a random state is not explicitly supplied.

Examples:
.........

      (random-state-p *random-state*) → true
      (setq snap-shot (make-random-state))
      ;; The series from any given point is random,
      ;; but if you backtrack to that point, you get the same series.
      (list (loop for i from 1 to 10 collect (random))
            (let ((*random-state* snap-shot))
              (loop for i from 1 to 10 collect (random)))
            (loop for i from 1 to 10 collect (random))
            (let ((*random-state* snap-shot))
              (loop for i from 1 to 10 collect (random))))
     → ((19 16 44 19 96 15 76 96 13 61)
         (19 16 44 19 96 15 76 96 13 61)
         (16 67 0 43 70 79 58 5 63 50)
         (16 67 0 43 70 79 58 5 63 50))

Affected By:
............

The implementation.

‘random’.

See Also:
.........

*note make-random-state::, *note random::, *note random-state::

Notes:
......

Binding ‘*random-state*’ to a different random state object correctly
saves and restores the old random state object.


File: ansicl,  Node: numberp,  Next: cis,  Prev: *random-state*,  Up: Numbers

numberp (Function)
==================

Syntax:
.......

 -- Function: numberp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘number’; otherwise, returns false.

Examples:
.........

      (numberp 12) → true
      (numberp (expt 2 130)) → true
      (numberp #c(5/3 7.2)) → true
      (numberp nil) → false
      (numberp (cons 1 2)) → false

Notes:
......

      (numberp OBJECT) ≡ (typep OBJECT 'number)


File: ansicl,  Node: cis,  Next: complex (Function),  Prev: numberp,  Up: Numbers

cis (Function)
==============

Syntax:
.......

 -- Function: cis radians → number

Arguments and Values:
.....................

RADIANS—a real.

NUMBER—a complex.

Description:
............

‘cis’ returns the value of e^i· radians, which is a complex in which the
real part is equal to the cosine of RADIANS, and the imaginary part is
equal to the sine of RADIANS.

Examples:
.........

      (cis 0) → #C(1.0 0.0)

See Also:
.........

*note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.


File: ansicl,  Node: complex (Function),  Next: complexp,  Prev: cis,  Up: Numbers

complex (Function)
==================

Syntax:
.......

 -- Function: complex realpart &optional imagpart → complex

Arguments and Values:
.....................

REALPART—a real.

IMAGPART—a real.

COMPLEX—a rational or a complex.

Description:
............

‘complex’ returns a number whose real part is REALPART and whose
imaginary part is IMAGPART.

If REALPART is a rational and IMAGPART is the rational number zero, the
result of ‘complex’ is REALPART, a rational.  Otherwise, the result is a
complex.

If either REALPART or IMAGPART is a float, the non-float is converted to
a float before the complex is created.  If IMAGPART is not supplied, the
imaginary part is a zero of the same type as REALPART; i.e., ‘(coerce 0
(type-of REALPART))’ is effectively used.

Type upgrading implies a movement upwards in the type hierarchy lattice.
In the case of complexes, the TYPE-SPECIFIER

must be a subtype of ‘(upgraded-complex-part-type TYPE-SPECIFIER)’.  If
TYPE-SPECIFIER1 is a subtype of TYPE-SPECIFIER2, then
‘(upgraded-complex-element-type 'TYPE-SPECIFIER1)’ must also be a
subtype of ‘(upgraded-complex-element-type 'TYPE-SPECIFIER2)’.  Two
disjoint types can be upgraded into the same thing.

Examples:
.........

      (complex 0) → 0
      (complex 0.0) → #C(0.0 0.0)
      (complex 1 1/2) → #C(1 1/2)
      (complex 1 .99) → #C(1.0 0.99)
      (complex 3/2 0.0) → #C(1.5 0.0)

See Also:
.........

*note realpart::, *note imagpart::, *note Section 2.4.8.11 (Sharpsign
C): SharpsignC.


File: ansicl,  Node: complexp,  Next: conjugate,  Prev: complex (Function),  Up: Numbers

complexp (Function)
===================

Syntax:
.......

 -- Function: complexp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘complex’; otherwise, returns false.

Examples:
.........

      (complexp 1.2d2) → false
      (complexp #c(5/3 7.2)) → true


See Also:
.........

*note complex (Function):: (function and type), *note typep::

Notes:
......

      (complexp OBJECT) ≡ (typep OBJECT 'complex)


File: ansicl,  Node: conjugate,  Next: phase,  Prev: complexp,  Up: Numbers

conjugate (Function)
====================

Syntax:
.......

 -- Function: conjugate number → conjugate

Arguments and Values:
.....................

NUMBER—a number.

CONJUGATE—a number.

Description:
............

Returns the complex conjugate of NUMBER.  The conjugate of a real number
is itself.

Examples:
.........

      (conjugate #c(0 -1)) → #C(0 1)
      (conjugate #c(1 1)) → #C(1 -1)
      (conjugate 1.5) → 1.5
      (conjugate #C(3/5 4/5)) → #C(3/5 -4/5)
      (conjugate #C(0.0D0 -1.0D0)) → #C(0.0D0 1.0D0)
      (conjugate 3.7) → 3.7

Notes:
......

For a complex number ‘z’,

      (conjugate z) ≡ (complex (realpart z) (- (imagpart z)))


File: ansicl,  Node: phase,  Next: realpart; imagpart,  Prev: conjugate,  Up: Numbers

phase (Function)
================

Syntax:
.......

 -- Function: phase number → phase

Arguments and Values:
.....................

NUMBER—a number.

PHASE—a number.

Description:
............

‘phase’ returns the phase of NUMBER (the angle part of its polar
representation) in radians, in the range -π (exclusive) if minus zero is
not supported, or -π (inclusive) if minus zero is supported, to π
(inclusive).  The phase of a positive real number is zero; that of a
negative real number is π.  The phase of zero is defined to be zero.

If NUMBER is a complex float, the result is a float of the same type as
the components of NUMBER.  If NUMBER is a float, the result is a float
of the same type.  If NUMBER is a rational or a complex rational, the
result is a single float.

The branch cut for ‘phase’ lies along the negative real axis, continuous
with quadrant II. The range consists of that portion of the real axis
between -π (exclusive) and π (inclusive).

The mathematical definition of ‘phase’ is as follows:

‘(phase x) = (atan (imagpart x) (realpart x))’

Examples:
.........

      (phase 1) → 0.0s0
      (phase 0) → 0.0s0
      (phase (cis 30)) → -1.4159266
      (phase #c(0 1)) → 1.5707964

Exceptional Situations:
.......................

Should signal ‘type-error’ if its argument is not a number.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.


File: ansicl,  Node: realpart; imagpart,  Next: upgraded-complex-part-type,  Prev: phase,  Up: Numbers

realpart, imagpart (Function)
=============================

Syntax:
.......

 -- Function: realpart number → real
 -- Function: imagpart number → real

Arguments and Values:
.....................

NUMBER—a number.

REAL—a real.

Description:
............

‘realpart’ and ‘imagpart’ return the real and imaginary parts of NUMBER
respectively.  If NUMBER is real, then ‘realpart’ returns NUMBER and
‘imagpart’ returns ‘(* 0 NUMBER)’, which has the effect that the
imaginary part of a rational is ‘0’ and that of a float is a
floating-point zero of the same format.

Examples:
.........

      (realpart #c(23 41)) → 23
      (imagpart #c(23 41.0)) → 41.0
      (realpart #c(23 41.0)) → 23.0
      (imagpart 23.0) → 0.0

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NUMBER is not a number.

See Also:
.........

*note complex (Function)::


File: ansicl,  Node: upgraded-complex-part-type,  Next: realp,  Prev: realpart; imagpart,  Up: Numbers

upgraded-complex-part-type (Function)
=====================================

Syntax:
.......

 -- Function: upgraded-complex-part-type typespec &optional environment
          → upgraded-typespec

Arguments and Values:
.....................

TYPESPEC—a type specifier.

ENVIRONMENT—an environment object.  The default is ‘nil’, denoting the
null lexical environment and the and current global environment.

UPGRADED-TYPESPEC—a type specifier.

Description:
............

‘upgraded-complex-part-type’ returns the part type of the most
specialized complex number representation that can hold parts of type
typespec.

The TYPESPEC is a subtype of (and possibly type equivalent to) the
UPGRADED-TYPESPEC.

The purpose of ‘upgraded-complex-part-type’ is to reveal how an
implementation does its upgrading.

See Also:
.........

*note complex (Function):: (function and type)

Notes:
......


File: ansicl,  Node: realp,  Next: numerator; denominator,  Prev: upgraded-complex-part-type,  Up: Numbers

realp (Function)
================

Syntax:
.......

 -- Function: realp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘real’; otherwise, returns false.

Examples:
.........

      (realp 12) → true
      (realp #c(5/3 7.2)) → false
      (realp nil) → false
      (realp (cons 1 2)) → false

Notes:
......

      (realp OBJECT) ≡ (typep OBJECT 'real)


File: ansicl,  Node: numerator; denominator,  Next: rational; rationalize,  Prev: realp,  Up: Numbers

numerator, denominator (Function)
=================================

Syntax:
.......

 -- Function: numerator rational → numerator
 -- Function: denominator rational → denominator

Arguments and Values:
.....................

RATIONAL—a rational.

NUMERATOR—an integer.

DENOMINATOR—a positive integer.

Description:
............

‘numerator’ and ‘denominator’ reduce RATIONAL to canonical form and
compute the numerator or denominator of that number.

‘numerator’ and ‘denominator’ return the numerator or denominator of the
canonical form of RATIONAL.

If RATIONAL is an integer, ‘numerator’ returns RATIONAL and
‘denominator’ returns 1.

Examples:
.........

      (numerator 1/2) → 1
      (denominator 12/36) → 3
      (numerator -1) → -1
      (denominator (/ -33)) → 33
      (numerator (/ 8 -6)) → -4
      (denominator (/ 8 -6)) → 3

See Also:
.........

*note / (Function)::

Notes:
......

      (gcd (numerator x) (denominator x)) → 1


File: ansicl,  Node: rational; rationalize,  Next: rationalp,  Prev: numerator; denominator,  Up: Numbers

rational, rationalize (Function)
================================

Syntax:
.......

 -- Function: rational number → rational
 -- Function: rationalize number → rational

Arguments and Values:
.....................

NUMBER—a real.

RATIONAL—a rational.

Description:
............

‘rational’ and ‘rationalize’ convert reals to rationals.

If NUMBER is already rational, it is returned.

If NUMBER is a float, ‘rational’ returns a rational that is
mathematically equal in value to the float.  ‘rationalize’ returns a
rational that approximates the float to the accuracy of the underlying
floating-point representation.

‘rational’ assumes that the float is completely accurate.

‘rationalize’ assumes that the float is accurate only to the precision
of the floating-point representation.

Examples:
.........

      (rational 0) → 0
      (rationalize -11/100) → -11/100
      (rational .1) → 13421773/134217728 ;implementation-dependent
      (rationalize .1) → 1/10

Affected By:
............

The implementation.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NUMBER is not a real.
Might signal ‘arithmetic-error’.

Notes:
......

It is always the case that

      (float (rational x) x) ≡ x

and

      (float (rationalize x) x) ≡ x

That is, rationalizing a float by either method and then converting it
back to a float of the same format produces the original NUMBER.


File: ansicl,  Node: rationalp,  Next: ash,  Prev: rational; rationalize,  Up: Numbers

rationalp (Function)
====================

Syntax:
.......

 -- Function: rationalp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘rational’; otherwise, returns false.

Examples:
.........

      (rationalp 12) → true
      (rationalp 6/5) → true
      (rationalp 1.212) → false

See Also:
.........

*note rational::

Notes:
......

      (rationalp OBJECT) ≡ (typep OBJECT 'rational)


File: ansicl,  Node: ash,  Next: integer-length,  Prev: rationalp,  Up: Numbers

ash (Function)
==============

Syntax:
.......

 -- Function: ash integer count → shifted-integer

Arguments and Values:
.....................

INTEGER—an integer.

COUNT—an integer.

SHIFTED-INTEGER—an integer.

Description:
............

‘ash’ performs the arithmetic shift operation on the binary
representation of INTEGER, which is treated as if it were binary.

‘ash’ shifts INTEGER arithmetically left by COUNT bit positions if COUNT
is positive, or right COUNT bit positions if COUNT is negative.  The
shifted value of the same sign as INTEGER is returned.

Mathematically speaking, ‘ash’ performs the computation ‘floor’(INTEGER·
2^COUNT).  Logically, ‘ash’ moves all of the bits in INTEGER to the
left, adding zero-bits at the right, or moves them to the right,
discarding bits.

‘ash’ is defined to behave as if INTEGER were represented in two’s
complement form, regardless of how integers are represented internally.

Examples:
.........

      (ash 16 1) → 32
      (ash 16 0) → 16
      (ash 16 -1) → 8
      (ash -100000000000000000000000000000000 -100) → -79

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INTEGER is not an
integer.  Should signal an error of type ‘type-error’ if COUNT is not an
integer.  Might signal ‘arithmetic-error’.

Notes:
......

      (logbitp J (ash N K))
      ≡ (and (>= J K) (logbitp (- J K) N))


File: ansicl,  Node: integer-length,  Next: integerp,  Prev: ash,  Up: Numbers

integer-length (Function)
=========================

Syntax:
.......

 -- Function: integer-length integer → number-of-bits

Arguments and Values:
.....................

INTEGER—an integer.

NUMBER-OF-BITS—a non-negative integer.

Description:
............

Returns the number of bits needed to represent INTEGER in binary
two’s-complement format.

Examples:
.........

      (integer-length 0) → 0
      (integer-length 1) → 1
      (integer-length 3) → 2
      (integer-length 4) → 3
      (integer-length 7) → 3
      (integer-length -1) → 0
      (integer-length -4) → 2
      (integer-length -7) → 3
      (integer-length -8) → 3
      (integer-length (expt 2 9)) → 10
      (integer-length (1- (expt 2 9))) → 9
      (integer-length (- (expt 2 9))) → 9
      (integer-length (- (1+ (expt 2 9)))) → 10

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INTEGER is not an
integer.

Notes:
......

This function could have been defined by:

     (defun integer-length (integer)
       (ceiling (log (if (minusp integer)
                         (- integer)
                         (1+ integer))
                     2)))

If INTEGER is non-negative, then its value can be represented in
unsigned binary form in a field whose width in bits is no smaller than
‘(integer-length INTEGER)’.  Regardless of the sign of INTEGER, its
value can be represented in signed binary two’s-complement form in a
field whose width in bits is no smaller than ‘(+ (integer-length
INTEGER) 1)’.


File: ansicl,  Node: integerp,  Next: parse-integer,  Prev: integer-length,  Up: Numbers

integerp (Function)
===================

Syntax:
.......

 -- Function: integerp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘integer’; otherwise, returns false.

Examples:
.........

      (integerp 1) → true
      (integerp (expt 2 130)) → true
      (integerp 6/5) → false
      (integerp nil) → false


Notes:
......

      (integerp OBJECT) ≡ (typep OBJECT 'integer)


File: ansicl,  Node: parse-integer,  Next: boole,  Prev: integerp,  Up: Numbers

parse-integer (Function)
========================

Syntax:
.......

 -- Function: parse-integer string &key start end radix junk-allowed →
          integer, pos

Arguments and Values:
.....................

STRING—a string.

START, END—bounding index designators of STRING.  The defaults for START
and END are ‘0’ and ‘nil’, respectively.

RADIX—a radix.  The default is ‘10’.

JUNK-ALLOWED—a generalized boolean.  The default is false.

INTEGER—an integer or false.

POS—a bounding index of STRING.

Description:
............

‘parse-integer’ parses an integer in the specified RADIX from the
substring of STRING delimited by START and END.

‘parse-integer’ expects an optional sign (‘+’ or ‘-’) followed by a a
non-empty sequence of digits to be interpreted in the specified RADIX.
Optional leading and trailing whitespace

‘parse-integer’ does not recognize the syntactic radix-specifier
prefixes ‘#O’, ‘#B’, ‘#X’, and ‘#nR’, nor does it recognize a trailing
decimal point.

If JUNK-ALLOWED is false, an error of type ‘parse-error’ is signaled if
substring does not consist entirely of the representation of a signed
integer, possibly surrounded on either side by whitespacecharacters.

The first value returned is either the integer that was parsed, or else
‘nil’ if no syntactically correct integer was seen but JUNK-ALLOWED was
true.

The second value is either the index into the string of the delimiter
that terminated the parse, or the upper bounding index of the substring
if the parse terminated at the end of the substring (as is always the
case if JUNK-ALLOWED is false).

Examples:
.........

      (parse-integer "123") → 123, 3
      (parse-integer "123" :start 1 :radix 5) → 13, 3
      (parse-integer "no-integer" :junk-allowed t) → NIL, 0

Exceptional Situations:
.......................

If JUNK-ALLOWED is false, an error is signaled if substring does not
consist entirely of the representation of an integer, possibly
surrounded on either side by whitespace


File: ansicl,  Node: boole,  Next: boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+,  Prev: parse-integer,  Up: Numbers

boole (Function)
================

Syntax:
.......

 -- Function: boole op integer-1 integer-2 → result-integer

Arguments and Values:
.....................

OP—a bit-wise logical operation specifier.

INTEGER-1—an integer.

INTEGER-2—an integer.

RESULT-INTEGER—an integer.

Description:
............

‘boole’ performs bit-wise logical operations on INTEGER-1 and INTEGER-2,
which are treated as if they were binary and in two’s complement
representation.

The operation to be performed and the return value are determined by OP.

‘boole’ returns the values specified for any OP in the next figure.

Op              Result
-------------------------------------------------------------
‘boole-1’       INTEGER-1
‘boole-2’       INTEGER-2
‘boole-andc1’   and complement of INTEGER-1 with INTEGER-2
‘boole-andc2’   and INTEGER-1 with complement of INTEGER-2
‘boole-and’     and
‘boole-c1’      complement of INTEGER-1
‘boole-c2’      complement of INTEGER-2
‘boole-clr’     always 0 (all zero bits)
‘boole-eqv’     equivalence (exclusive nor)
‘boole-ior’     inclusive or
‘boole-nand’    not-and
‘boole-nor’     not-or
‘boole-orc1’    or complement of INTEGER-1 with INTEGER-2
‘boole-orc2’    or INTEGER-1 with complement of INTEGER-2
‘boole-set’     always -1 (all one bits)
‘boole-xor’     exclusive or

Figure 12.17: Bit-Wise Logical Operations

Examples:
.........

      (boole boole-ior 1 16) → 17
      (boole boole-and -2 5) → 4
      (boole boole-eqv 17 15) → -31

     ;;; These examples illustrate the result of applying BOOLE and each
     ;;; of the possible values of OP to each possible combination of bits.
      (progn
        (format t "~&Results of (BOOLE <op> #b0011 #b0101) ...~
                ~%---Op-------Decimal-----Binary----Bits---~%")
        (dolist (symbol '(boole-1     boole-2    boole-and  boole-andc1
                          boole-andc2 boole-c1   boole-c2   boole-clr
                          boole-eqv   boole-ior  boole-nand boole-nor
                          boole-orc1  boole-orc2 boole-set  boole-xor))
          (let ((result (boole (symbol-value symbol) #b0011 #b0101)))
            (format t "~& ~A~13T~3,' D~23T~:*~5,' B~31T ...~4,'0B~%"
                    symbol result (logand result #b1111)))))
     ▷ Results of (BOOLE <op> #b0011 #b0101) ...
     ▷ ---Op-------Decimal-----Binary----Bits---
     ▷  BOOLE-1       3          11    ...0011
     ▷  BOOLE-2       5         101    ...0101
     ▷  BOOLE-AND     1           1    ...0001
     ▷  BOOLE-ANDC1   4         100    ...0100
     ▷  BOOLE-ANDC2   2          10    ...0010
     ▷  BOOLE-C1     -4        -100    ...1100
     ▷  BOOLE-C2     -6        -110    ...1010
     ▷  BOOLE-CLR     0           0    ...0000
     ▷  BOOLE-EQV    -7        -111    ...1001
     ▷  BOOLE-IOR     7         111    ...0111
     ▷  BOOLE-NAND   -2         -10    ...1110
     ▷  BOOLE-NOR    -8       -1000    ...1000
     ▷  BOOLE-ORC1   -3         -11    ...1101
     ▷  BOOLE-ORC2   -5        -101    ...1011
     ▷  BOOLE-SET    -1          -1    ...1111
     ▷  BOOLE-XOR     6         110    ...0110
     → NIL

Exceptional Situations:
.......................

Should signal ‘type-error’ if its first argument is not a bit-wise
logical operation specifier or if any subsequent argument is not an
integer.

See Also:
.........

*note logand::

Notes:
......

In general,

      (boole boole-and x y) ≡ (logand x y)

Programmers who would prefer to use numeric indices rather than bit-wise
logical operation specifiers can get an equivalent effect by a technique
such as the following:

     ;; The order of the values in this `table' are such that
     ;; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) => n
      (defconstant boole-n-vector
         (vector boole-clr   boole-and  boole-andc1 boole-2
                 boole-andc2 boole-1    boole-xor   boole-ior
                 boole-nor   boole-eqv  boole-c1    boole-orc1
                 boole-c2    boole-orc2 boole-nand  boole-set))
     → BOOLE-N-VECTOR
      (proclaim '(inline boole-n))
     → implementation-dependent
      (defun boole-n (n integer &rest more-integers)
        (apply #'boole (elt boole-n-vector n) integer more-integers))
     → BOOLE-N
      (boole-n #b0111 5 3) → 7
      (boole-n #b0001 5 3) → 1
      (boole-n #b1101 5 3) → -3
      (loop for n from #b0000 to #b1111 collect (boole-n n 5 3))
     → (0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)


File: ansicl,  Node: boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+,  Next: logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+,  Prev: boole,  Up: Numbers

boole-1, boole-2, boole-and, boole-andc1, boole-andc2, boole-c1, boole-c2, boole-clr, boole-eqv, boole-ior, boole-nand, boole-nor, boole-orc1, boole-orc2, boole-set, boole-xor (Constant Variable)
===================================================================================================================================================================================================

Constant Value:
...............

The identity and nature of the values of each of these variables is
implementation-dependent, except that it must be distinct from each of
the values of the others, and it must be a valid first argument to the
function ‘boole’.

Description:
............

Each of these constants has a value which is one of the sixteen possible
bit-wise logical operation specifiers.

Examples:
.........

      (boole boole-ior 1 16) → 17
      (boole boole-and -2 5) → 4
      (boole boole-eqv 17 15) → -31

See Also:
.........

*note boole::


File: ansicl,  Node: logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+,  Next: logbitp,  Prev: boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+,  Up: Numbers

logand, logandc1, logandc2, logeqv, logior, lognand, lognor, lognot, logorc1, logorc2, logxor (Function)
========================================================================================================

Syntax:
.......

 -- Function: logand &rest integers → result-integer
 -- Function: logandc1 integer-1 integer-2 → result-integer
 -- Function: logandc2 integer-1 integer-2 → result-integer
 -- Function: logeqv &rest integers → result-integer
 -- Function: logior &rest integers → result-integer
 -- Function: lognand integer-1 integer-2 → result-integer
 -- Function: lognor integer-1 integer-2 → result-integer
 -- Function: lognot integer → result-integer
 -- Function: logorc1 integer-1 integer-2 → result-integer
 -- Function: logorc2 integer-1 integer-2 → result-integer
 -- Function: logxor &rest integers → result-integer

Arguments and Values:
.....................

INTEGERS—integers.

INTEGER—an integer.

INTEGER-1—an integer.

INTEGER-2—an integer.

RESULT-INTEGER—an integer.

Description:
............

The functions ‘logandc1’, ‘logandc2’, ‘logand’, ‘logeqv’, ‘logior’,
‘lognand’, ‘lognor’, ‘lognot’, ‘logorc1’, ‘logorc2’, and ‘logxor’
perform bit-wise logical operations on their arguments, that are treated
as if they were binary.

The next figure lists the meaning of each of the functions.  Where an
‘identity’ is shown, it indicates the value yielded by the function when
no arguments are supplied.

Function     Identity   Operation performed
---------------------------------------------------------------------
‘logandc1’   —          and complement of INTEGER-1 with INTEGER-2
‘logandc2’   —          and INTEGER-1 with complement of INTEGER-2
‘logand’     ‘-1’       and
‘logeqv’     ‘-1’       equivalence (exclusive nor)
‘logior’     ‘0’        inclusive or
‘lognand’    —          complement of INTEGER-1 and INTEGER-2
‘lognor’     —          complement of INTEGER-1 or INTEGER-2
‘lognot’     —          complement
‘logorc1’    —          or complement of INTEGER-1 with INTEGER-2
‘logorc2’    —          or INTEGER-1 with complement of INTEGER-2
‘logxor’     ‘0’        exclusive or

Figure 12.18: Bit-wise Logical Operations on Integers

Negative INTEGERS are treated as if they were in two’s-complement
notation.

Examples:
.........

      (logior 1 2 4 8) → 15
      (logxor 1 3 7 15) → 10
      (logeqv) → -1
      (logand 16 31) → 16
      (lognot 0) → -1
      (lognot 1) → -2
      (lognot -1) → 0
      (lognot (1+ (lognot 1000))) → 999

     ;;; In the following example, m is a mask.  For each bit in
     ;;; the mask that is a 1, the corresponding bits in x and y are
     ;;; exchanged.  For each bit in the mask that is a 0, the
     ;;; corresponding bits of x and y are left unchanged.
      (flet ((show (m x y)
               (format t "~%m = #o~6,'0O~%x = #o~6,'0O~%y = #o~6,'0O~%"
                       m x y)))
        (let ((m #o007750)
              (x #o452576)
              (y #o317407))
          (show m x y)
          (let ((z (logand (logxor x y) m)))
            (setq x (logxor z x))
            (setq y (logxor z y))
            (show m x y))))
     ▷ m = #o007750
     ▷ x = #o452576
     ▷ y = #o317407
     ▷
     ▷ m = #o007750
     ▷ x = #o457426
     ▷ y = #o312557
     → NIL

Exceptional Situations:
.......................

Should signal ‘type-error’ if any argument is not an integer.

See Also:
.........

*note boole::

Notes:
......

‘(logbitp K -1)’ returns true for all values of K.

Because the following functions are not associative, they take exactly
two arguments rather than any number of arguments.

      (lognand N1 N2) ≡ (lognot (logand N1 N2))
      (lognor N1 N2) ≡ (lognot (logior N1 N2))
      (logandc1 N1 N2) ≡ (logand (lognot N1) N2)
      (logandc2 N1 N2) ≡ (logand N1 (lognot N2))
      (logiorc1 N1 N2) ≡ (logior (lognot N1) N2)
      (logiorc2 N1 N2) ≡ (logior N1 (lognot N2))
      (logbitp J (lognot X)) ≡ (not (logbitp J X))


File: ansicl,  Node: logbitp,  Next: logcount,  Prev: logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+,  Up: Numbers

logbitp (Function)
==================

Syntax:
.......

 -- Function: logbitp index integer → generalized-boolean

Arguments and Values:
.....................

INDEX—a non-negative integer.

INTEGER—an integer.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘logbitp’ is used to test the value of a particular bit in INTEGER, that
is treated as if it were binary.  The value of ‘logbitp’ is true if the
bit in INTEGER whose index is INDEX (that is, its weight is 2^index) is
a one-bit; otherwise it is false.

Negative INTEGERS are treated as if they were in two’s-complement
notation.

Examples:
.........

      (logbitp 1 1) → false
      (logbitp 0 1) → true
      (logbitp 3 10) → true
      (logbitp 1000000 -1) → true
      (logbitp 2 6) → true
      (logbitp 0 6) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INDEX is not a
non-negative integer.  Should signal an error of type ‘type-error’ if
INTEGER is not an integer.

Notes:
......

      (logbitp K N) ≡ (ldb-test (byte 1 K) N)


File: ansicl,  Node: logcount,  Next: logtest,  Prev: logbitp,  Up: Numbers

logcount (Function)
===================

Syntax:
.......

 -- Function: logcount integer → number-of-on-bits

Arguments and Values:
.....................

INTEGER—an integer.

NUMBER-OF-ON-BITS—a non-negative integer.

Description:
............

Computes and returns the number of bits in the two’s-complement binary
representation of INTEGER that are ‘on’ or ‘set’.  If INTEGER is
negative, the ‘0’ bits are counted; otherwise, the ‘1’ bits are counted.

Examples:
.........

      (logcount 0) → 0
      (logcount -1) → 0
      (logcount 7) → 3
      (logcount  13) → 3 ;Two's-complement binary: ...0001101
      (logcount -13) → 2 ;Two's-complement binary: ...1110011
      (logcount  30) → 4 ;Two's-complement binary: ...0011110
      (logcount -30) → 4 ;Two's-complement binary: ...1100010
      (logcount (expt 2 100)) → 1
      (logcount (- (expt 2 100))) → 100
      (logcount (- (1+ (expt 2 100)))) → 1

Exceptional Situations:
.......................

Should signal ‘type-error’ if its argument is not an integer.

Notes:
......

Even if the implementation does not represent integers internally in
two’s complement binary, ‘logcount’ behaves as if it did.

The following identity always holds:

         (logcount X)
      ≡ (logcount (- (+ X 1)))
      ≡ (logcount (lognot X))


File: ansicl,  Node: logtest,  Next: byte; byte-size; byte-position,  Prev: logcount,  Up: Numbers

logtest (Function)
==================

Syntax:
.......

 -- Function: logtest integer-1 integer-2 → generalized-boolean

Arguments and Values:
.....................

INTEGER-1—an integer.

INTEGER-2—an integer.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if any of the bits designated by the 1’s in INTEGER-1 is 1
in INTEGER-2; otherwise it is false.  INTEGER-1 and INTEGER-2 are
treated as if they were binary.

Negative INTEGER-1 and INTEGER-2 are treated as if they were represented
in two’s-complement binary.

Examples:
.........

      (logtest 1 7) → true
      (logtest 1 2) → false
      (logtest -2 -1) → true
      (logtest 0 -1) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INTEGER-1 is not an
integer.  Should signal an error of type ‘type-error’ if INTEGER-2 is
not an integer.

Notes:
......

      (logtest X Y) ≡ (not (zerop (logand X Y)))


File: ansicl,  Node: byte; byte-size; byte-position,  Next: deposit-field,  Prev: logtest,  Up: Numbers

byte, byte-size, byte-position (Function)
=========================================

Syntax:
.......

 -- Function: byte size position → bytespec

 -- Function: byte-size bytespec → size
 -- Function: byte-position bytespec → position

Arguments and Values:
.....................

SIZE, POSITION—a non-negative integer.

BYTESPEC—a byte specifier.

Description:
............

‘byte’ returns a byte specifier that indicates a byte of width SIZE and
whose bits have weights 2^POSITION + SIZE - 1 through 2^POSITION, and
whose representation is implementation-dependent.

‘byte-size’ returns the number of bits specified by BYTESPEC.

‘byte-position’ returns the position specified by BYTESPEC.

Examples:
.........

      (setq b (byte 100 200)) → #<BYTE-SPECIFIER size 100 position 200>
      (byte-size b) → 100
      (byte-position b) → 200

See Also:
.........

*note ldb::, *note dpb::

Notes:
......

      (byte-size (byte J K)) ≡ J
      (byte-position (byte J K)) ≡ K

A byte of size of ‘0’ is permissible; it refers to a byte of width zero.
For example,

      (ldb (byte 0 3) #o7777) → 0
      (dpb #o7777 (byte 0 3) 0) → 0


File: ansicl,  Node: deposit-field,  Next: dpb,  Prev: byte; byte-size; byte-position,  Up: Numbers

deposit-field (Function)
========================

Syntax:
.......

 -- Function: deposit-field newbyte bytespec integer → result-integer

Arguments and Values:
.....................

NEWBYTE—an integer.

BYTESPEC—a byte specifier.

INTEGER—an integer.

RESULT-INTEGER—an integer.

Description:
............

Replaces a field of bits within INTEGER; specifically, returns an
integer that contains the bits of NEWBYTE within the byte specified by
BYTESPEC, and elsewhere contains the bits of INTEGER.

Examples:
.........

      (deposit-field 7 (byte 2 1) 0) → 6
      (deposit-field -1 (byte 4 0) 0) → 15
      (deposit-field 0 (byte 2 1) -3) → -7

See Also:
.........

*note byte::, *note dpb::

Notes:
......

      (logbitp J (deposit-field M (byte S P) N))
      ≡ (if (and (>= J P) (< J (+ P S)))
             (logbitp J M)
             (logbitp J N))

‘deposit-field’ is to ‘mask-field’ as ‘dpb’ is to ‘ldb’.


File: ansicl,  Node: dpb,  Next: ldb,  Prev: deposit-field,  Up: Numbers

dpb (Function)
==============

Syntax:
.......

 -- Function: dpb newbyte bytespec integer → result-integer

Pronunciation:
..............

[ˌdə ˈpib] or [ˌdə ˈpə b] or [ˈdēˈpēˈbē]

Arguments and Values:
.....................

NEWBYTE—an integer.

BYTESPEC—a byte specifier.

INTEGER—an integer.

RESULT-INTEGER—an integer.

Description:
............

‘dpb’ (deposit byte) is used to replace a field of bits within INTEGER.
‘dpb’ returns an integer that is the same as INTEGER except in the bits
specified by BYTESPEC.

Let ‘s’ be the size specified by BYTESPEC; then the low ‘s’ bits of
NEWBYTE appear in the result in the byte specified by BYTESPEC.  NEWBYTE
is interpreted as being right-justified, as if it were the result of
‘ldb’.

Examples:
.........

      (dpb 1 (byte 1 10) 0) → 1024
      (dpb -2 (byte 2 10) 0) → 2048
      (dpb 1 (byte 2 10) 2048) → 1024

See Also:
.........

*note byte::, *note deposit-field::, *note ldb::

Notes:
......

      (logbitp J (dpb M (byte S P) N))
      ≡ (if (and (>= J P) (< J (+ P S)))
             (logbitp (- J P) M)
             (logbitp J N))

In general,

      (dpb X (byte 0 Y) Z) → Z

for all valid values of X, Y, and Z.

Historically, the name “dpb” comes from a DEC PDP-10 assembly language
instruction meaning “deposit byte.”


File: ansicl,  Node: ldb,  Next: ldb-test,  Prev: dpb,  Up: Numbers

ldb (Accessor)
==============

Syntax:
.......

 -- Function: ldb bytespec integer → byte

(setf (ldb bytespec place) new-byte)

Pronunciation:
..............

[ˈlidib] or [ˈlidə b] or [ˈelˈdēˈbē]

Arguments and Values:
.....................

BYTESPEC—a byte specifier.

INTEGER—an integer.

BYTE, NEW-BYTE—a non-negative integer.

Description:
............

‘ldb’ extracts and returns the byte of INTEGER specified by BYTESPEC.

‘ldb’ returns an integer in which the bits with weights 2^(s-1) through
2^0 are the same as those in INTEGER with weights 2^(p+s-1) through 2^p,
and all other bits zero; s is ‘(byte-size BYTESPEC)’ and p is
‘(byte-position BYTESPEC)’.

‘setf’ may be used with ‘ldb’ to modify a byte within the INTEGER that
is stored in a given PLACE.  The order of evaluation, when an ‘ldb’ form
is supplied to ‘setf’, is exactly left-to-right.  The effect is to
perform a ‘dpb’ operation and then store the result back into the PLACE.

Examples:
.........

      (ldb (byte 2 1) 10) → 1
      (setq a (list 8)) → (8)
      (setf (ldb (byte 2 1) (car a)) 1) → 1
      a → (10)

See Also:
.........

*note byte::, *note byte-position::, *note byte-size::, *note dpb::

Notes:
......

      (logbitp J (ldb (byte S P) N))
         ≡ (and (< J S) (logbitp (+ J P) N))

In general,

      (ldb (byte 0 X) Y) → 0

for all valid values of X and Y.

Historically, the name “ldb” comes from a DEC PDP-10 assembly language
instruction meaning “load byte.”


File: ansicl,  Node: ldb-test,  Next: mask-field,  Prev: ldb,  Up: Numbers

ldb-test (Function)
===================

Syntax:
.......

 -- Function: ldb-test bytespec integer → generalized-boolean

Arguments and Values:
.....................

BYTESPEC—a byte specifier.

INTEGER—an integer.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if any of the bits of the byte in INTEGER specified by
BYTESPEC is non-zero; otherwise returns false.

Examples:
.........

      (ldb-test (byte 4 1) 16) → true
      (ldb-test (byte 3 1) 16) → false
      (ldb-test (byte 3 2) 16) → true

See Also:
.........

*note byte::, *note ldb::, *note zerop::

Notes:
......

      (ldb-test bytespec n) ≡
      (not (zerop (ldb bytespec n))) ≡
      (logtest (ldb bytespec -1) n)


File: ansicl,  Node: mask-field,  Next: most-positive-fixnum; most-negative-fixnum,  Prev: ldb-test,  Up: Numbers

mask-field (Accessor)
=====================

Syntax:
.......

 -- Function: mask-field bytespec integer → masked-integer
(setf (mask-field bytespec place) new-masked-integer)

Arguments and Values:
.....................

BYTESPEC—a byte specifier.

INTEGER—an integer.

MASKED-INTEGER, NEW-MASKED-INTEGER—a non-negative integer.

Description:
............

‘mask-field’ performs a “mask” operation on INTEGER.  It returns an
integer that has the same bits as INTEGER in the byte specified by
BYTESPEC, but that has zero-bits everywhere else.

‘setf’ may be used with ‘mask-field’ to modify a byte within the integer
that is stored in a given PLACE.  The effect is to perform a
‘deposit-field’ operation and then store the result back into the PLACE.

Examples:
.........

      (mask-field (byte 1 5) -1) → 32
      (setq a 15) → 15
      (mask-field (byte 2 0) a) → 3
      a → 15
      (setf (mask-field (byte 2 0) a) 1) → 1
      a → 13

See Also:
.........

*note byte::, *note ldb::

Notes:
......

      (ldb BS (mask-field BS N)) ≡ (ldb BS N)
      (logbitp J (mask-field (byte S P) N))
        ≡ (and (>= J P) (< J S) (logbitp J N))
      (mask-field BS N) ≡ (logand N (dpb -1 BS 0))


File: ansicl,  Node: most-positive-fixnum; most-negative-fixnum,  Next: decode-float; scale-float; float-radix; float-sign; float-digits; float+,  Prev: mask-field,  Up: Numbers

most-positive-fixnum, most-negative-fixnum (Constant Variable)
==============================================================

Constant Value:
...............

implementation-dependent.

Description:
............

‘most-positive-fixnum’ is that fixnum closest in value to positive
infinity provided by the implementation, and greater than or equal to
both 2^15 - 1 and ‘array-dimension-limit’.

‘most-negative-fixnum’ is that fixnum closest in value to negative
infinity provided by the implementation, and less than or equal to
-2^15.


File: ansicl,  Node: decode-float; scale-float; float-radix; float-sign; float-digits; float+,  Next: float (Function),  Prev: most-positive-fixnum; most-negative-fixnum,  Up: Numbers

decode-float, scale-float, float-radix, float-sign, float-digits, float-precision, integer-decode-float (Function)
==================================================================================================================

Syntax:
.......

 -- Function: decode-float float → significand, exponent, sign

 -- Function: scale-float float integer → scaled-float

 -- Function: float-radix float → float-radix

 -- Function: float-sign float-1 &optional float-2 → signed-float

 -- Function: float-digits float → digits1

 -- Function: float-precision float → digits2

 -- Function: integer-decode-float float → significand, exponent,
          integer-sign

Arguments and Values:
.....................

DIGITS1—a non-negative integer.

DIGITS2—a non-negative integer.

EXPONENT—an integer.

FLOAT—a float.

FLOAT-1—a float.

FLOAT-2—a float.

FLOAT-RADIX—an integer.

INTEGER—a non-negative integer.

INTEGER-SIGN—the integer ‘-1’, or the integer ‘1’.

SCALED-FLOAT—a float.

SIGN—A float of the same type as FLOAT but numerically equal to ‘1.0’ or
‘-1.0’.

SIGNED-FLOAT—a float.

SIGNIFICAND—a float.

Description:
............

‘decode-float’ computes three values that characterize FLOAT.  The first
value is of the same type as FLOAT and represents the significand.  The
second value represents the exponent to which the radix (notated in this
description by b) must be raised to obtain the value that, when
multiplied with the first result, produces the absolute value of FLOAT.
If FLOAT is zero, any integer value may be returned, provided that the
identity shown for ‘scale-float’ holds.  The third value is of the same
type as FLOAT and is 1.0 if FLOAT is greater than or equal to zero or
-1.0 otherwise.

‘decode-float’ divides FLOAT by an integral power of b so as to bring
its value between 1/b (inclusive) and 1 (exclusive), and returns the
quotient as the first value.  If FLOAT is zero, however, the result
equals the absolute value of FLOAT (that is, if there is a negative
zero, its significand is considered to be a positive zero).

‘scale-float’ returns ‘(* FLOAT (expt (float b FLOAT) INTEGER))’, where
b is the radix of the floating-point representation.  FLOAT is not
necessarily between 1/b and 1.

‘float-radix’ returns the radix of FLOAT.

‘float-sign’ returns a number ‘z’ such that ‘z’ and FLOAT-1 have the
same sign and also such that ‘z’ and FLOAT-2 have the same absolute
value.  If FLOAT-2 is not supplied, its value is ‘(float 1 FLOAT-1)’.
If an implementation has distinct representations for negative zero and
positive zero, then ‘(float-sign -0.0)’ → ‘-1.0’.

‘float-digits’ returns the number of radix b digits used in the
representation of FLOAT (including any implicit digits, such as a
“hidden bit”).

‘float-precision’ returns the number of significant radix b digits
present in FLOAT; if FLOAT is a float zero, then the result is an
integer zero.

For normalized floats, the results of ‘float-digits’ and
‘float-precision’ are the same, but the precision is less than the
number of representation digits for a denormalized or zero number.

‘integer-decode-float’ computes three values that characterize FLOAT -
the significand scaled so as to be an integer, and the same last two
values that are returned by ‘decode-float’.  If FLOAT is zero,
‘integer-decode-float’ returns zero as the first value.  The second
value bears the same relationship to the first value as for
‘decode-float’:

      (multiple-value-bind (signif expon sign)
                           (integer-decode-float f)
        (scale-float (float signif f) expon)) ≡ (abs f)

Examples:
.........

      ;; Note that since the purpose of this functionality is to expose
      ;; details of the implementation, all of these examples are necessarily
      ;; very implementation-dependent.  Results may vary widely.
      ;; Values shown here are chosen consistently from one particular implementation.
      (decode-float .5) → 0.5, 0, 1.0
      (decode-float 1.0) → 0.5, 1, 1.0
      (scale-float 1.0 1) → 2.0
      (scale-float 10.01 -2) → 2.5025
      (scale-float 23.0 0) → 23.0
      (float-radix 1.0) → 2
      (float-sign 5.0) → 1.0
      (float-sign -5.0) → -1.0
      (float-sign 0.0) → 1.0
      (float-sign 1.0 0.0) → 0.0
      (float-sign 1.0 -10.0) → 10.0
      (float-sign -1.0 10.0) → -10.0
      (float-digits 1.0) → 24
      (float-precision 1.0) → 24
      (float-precision least-positive-single-float) → 1
      (integer-decode-float 1.0) → 8388608, -23, 1

Affected By:
............

The implementation’s representation for floats.

Exceptional Situations:
.......................

The functions ‘decode-float’, ‘float-radix’, ‘float-digits’,
‘float-precision’, and ‘integer-decode-float’ should signal an error if
their only argument is not a float.

The function ‘scale-float’ should signal an error if its first argument
is not a float or if its second argument is not an integer.

The function ‘float-sign’ should signal an error if its first argument
is not a float or if its second argument is supplied but is not a float.

Notes:
......

The product of the first result of ‘decode-float’ or
‘integer-decode-float’, of the radix raised to the power of the second
result, and of the third result is exactly equal to the value of FLOAT.

      (multiple-value-bind (signif expon sign)
                           (decode-float f)
        (scale-float signif expon))
     ≡ (abs f)

and

      (multiple-value-bind (signif expon sign)
                           (decode-float f)
        (* (scale-float signif expon) sign))
     ≡ f


File: ansicl,  Node: float (Function),  Next: floatp,  Prev: decode-float; scale-float; float-radix; float-sign; float-digits; float+,  Up: Numbers

float (Function)
================

Syntax:
.......

 -- Function: float number &optional prototype → float

Arguments and Values:
.....................

NUMBER—a real.

PROTOTYPE—a float.

FLOAT—a float.

Description:
............

‘float’ converts a real number to a float.

If a PROTOTYPE is supplied, a float is returned that is mathematically
equal to NUMBER but has the same format as PROTOTYPE.

If PROTOTYPE is not supplied, then if the NUMBER is already a float, it
is returned; otherwise, a float is returned that is mathematically equal
to NUMBER but is a single float.

Examples:
.........

      (float 0) → 0.0
      (float 1 .5) → 1.0
      (float 1.0) → 1.0
      (float 1/2) → 0.5
     → 1.0d0
     or→ 1.0
      (eql (float 1.0 1.0d0) 1.0d0) → true

See Also:
.........

*note coerce::


File: ansicl,  Node: floatp,  Next: most-positive-short-float; least-positive-short-float; least-positive-n+,  Prev: float (Function),  Up: Numbers

floatp (Function)
=================

Syntax:
.......

 -- Function: floatp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘float’; otherwise, returns false.

Examples:
.........

      (floatp 1.2d2) → true
      (floatp 1.212) → true
      (floatp 1.2s2) → true
      (floatp (expt 2 130)) → false

Notes:
......

      (floatp OBJECT) ≡ (typep OBJECT 'float)


File: ansicl,  Node: most-positive-short-float; least-positive-short-float; least-positive-n+,  Next: short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+,  Prev: floatp,  Up: Numbers

most-positive-short-float, least-positive-short-float, least-positive-normalized-short-float, most-positive-double-float, least-positive-double-float, least-positive-normalized-double-float, most-positive-long-float, least-positive-long-float, least-positive-normalized-long-float, most-positive-single-float, least-positive-single-float, least-positive-normalized-single-float, most-negative-short-float, least-negative-short-float, least-negative-normalized-short-float, most-negative-single-float, least-negative-single-float, least-negative-normalized-single-float, most-negative-double-float, least-negative-double-float, least-negative-normalized-double-float, most-negative-long-float, least-negative-long-float, least-negative-normalized-long-float (Constant Variable)
========================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================

Constant Value:
...............

implementation-dependent.

Description:
............

These constant variables provide a way for programs to examine the
implementation-defined limits for the various float formats.

Of these variables, each which has “‘-normalized’” in its name must have
a value which is a normalized float, and each which does not have
“‘-normalized’” in its name may have a value which is either a
normalized float or a denormalized float, as appropriate.

Of these variables, each which has “‘short-float’” in its name must have
a value which is a short float, each which has “‘single-float’” in its
name must have a value which is a single float, each which has
“‘double-float’” in its name must have a value which is a double float,
and each which has “‘long-float’” in its name must have a value which is
a long float.

   • ‘most-positive-short-float’, ‘most-positive-single-float’,
     ‘most-positive-double-float’, ‘most-positive-long-float’

     Each of these constant variables has as its value the positive
     float of the largest magnitude (closest in value to, but not equal
     to, positive infinity) for the float format implied by its name.

   • 
     ‘least-positive-short-float’, ‘least-positive-normalized-short-float’,
     ‘least-positive-single-float’, ‘least-positive-normalized-single-float’,
     ‘least-positive-double-float’, ‘least-positive-normalized-double-float’,
     ‘least-positive-long-float’, ‘least-positive-normalized-long-float’

     Each of these constant variables has as its value the smallest
     positive (nonzero) float for the float format implied by its name.

   • 
     ‘least-negative-short-float’, ‘least-negative-normalized-short-float’,
     ‘least-negative-single-float’, ‘least-negative-normalized-single-float’,
     ‘least-negative-double-float’, ‘least-negative-normalized-double-float’,
     ‘least-negative-long-float’, ‘least-negative-normalized-long-float’

     Each of these constant variables has as its value the negative
     (nonzero) float of the smallest magnitude for the float format
     implied by its name.  (If an implementation supports minus zero as
     a different object from positive zero, this value must not be minus
     zero.)

   • ‘most-negative-short-float’, ‘most-negative-single-float’,
     ‘most-negative-double-float’, ‘most-negative-long-float’

     Each of these constant variables has as its value the negative
     float of the largest magnitude (closest in value to, but not equal
     to, negative infinity) for the float format implied by its name.

Notes:
......


File: ansicl,  Node: short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+,  Next: arithmetic-error,  Prev: most-positive-short-float; least-positive-short-float; least-positive-n+,  Up: Numbers

short-float-epsilon, short-float-negative-epsilon, single-float-epsilon, single-float-negative-epsilon, double-float-epsilon, double-float-negative-epsilon, long-float-epsilon, long-float-negative-epsilon (Constant Variable)
================================================================================================================================================================================================================================

Constant Value:
...............

implementation-dependent.

Description:
............

The value of each of the constants ‘short-float-epsilon’,
‘single-float-epsilon’, ‘double-float-epsilon’, and ‘long-float-epsilon’
is the smallest positive float ε of the given format, such that the
following expression is true when evaluated:

‘(not (= (float 1 ε) (+ (float 1 ε) ε)))’

The value of each of the constants ‘short-float-negative-epsilon’,
‘single-float-negative-epsilon’, ‘double-float-negative-epsilon’, and
‘long-float-negative-epsilon’ is the smallest positive float ε of the
given format, such that the following expression is true when evaluated:

‘(not (= (float 1 ε) (- (float 1 ε) ε)))’


File: ansicl,  Node: arithmetic-error,  Next: arithmetic-error-operands; arithmetic-error-operation,  Prev: short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+,  Up: Numbers

arithmetic-error (Condition Type)
=================================

Class Precedence List:
......................

‘arithmetic-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘arithmetic-error’ consists of error conditions that occur
during arithmetic operations.  The operation and operands are
initialized with the initialization arguments named :operation and
:operands to ‘make-condition’, and are accessed by the functions
‘arithmetic-error-operation’ and ‘arithmetic-error-operands’.

See Also:
.........

*note arithmetic-error-operation::, *note arithmetic-error-operands::


File: ansicl,  Node: arithmetic-error-operands; arithmetic-error-operation,  Next: division-by-zero,  Prev: arithmetic-error,  Up: Numbers

arithmetic-error-operands, arithmetic-error-operation (Function)
================================================================

Syntax:
.......

 -- Function: arithmetic-error-operands condition → operands
 -- Function: arithmetic-error-operation condition → operation

Arguments and Values:
.....................

CONDITION—a condition of type ‘arithmetic-error’.

OPERANDS—a list.

OPERATION—a function designator.

Description:
............

‘arithmetic-error-operands’ returns a list of the operands which were
used in the offending call to the operation that signaled the CONDITION.

‘arithmetic-error-operation’ returns a list of the offending operation
in the offending call that signaled the CONDITION.

See Also:
.........

*note arithmetic-error::, *note Chapter 9 (Conditions): Conditions.

Notes:
......


File: ansicl,  Node: division-by-zero,  Next: floating-point-invalid-operation,  Prev: arithmetic-error-operands; arithmetic-error-operation,  Up: Numbers

division-by-zero (Condition Type)
=================================

Class Precedence List:
......................

‘division-by-zero’, ‘arithmetic-error’, ‘error’, ‘serious-condition’,
‘condition’, ‘t’

Description:
............

The type ‘division-by-zero’ consists of error conditions that occur
because of division by zero.


File: ansicl,  Node: floating-point-invalid-operation,  Next: floating-point-inexact,  Prev: division-by-zero,  Up: Numbers

floating-point-invalid-operation (Condition Type)
=================================================

Class Precedence List:
......................

‘floating-point-invalid-operation’, ‘arithmetic-error’, ‘error’,
‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘floating-point-invalid-operation’ consists of error conditions
that occur because of certain floating point traps.

It is implementation-dependent whether floating point traps occur, and
whether or how they may be enabled or disabled.  Therefore, conforming
code may establish handlers for this condition, but must not depend on
its being signaled.


File: ansicl,  Node: floating-point-inexact,  Next: floating-point-overflow,  Prev: floating-point-invalid-operation,  Up: Numbers

floating-point-inexact (Condition Type)
=======================================

Class Precedence List:
......................

‘floating-point-inexact’, ‘arithmetic-error’, ‘error’,
‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘floating-point-inexact’ consists of error conditions that
occur because of certain floating point traps.

It is implementation-dependent whether floating point traps occur, and
whether or how they may be enabled or disabled.  Therefore, conforming
code may establish handlers for this condition, but must not depend on
its being signaled.


File: ansicl,  Node: floating-point-overflow,  Next: floating-point-underflow,  Prev: floating-point-inexact,  Up: Numbers

floating-point-overflow (Condition Type)
========================================

Class Precedence List:
......................

‘floating-point-overflow’, ‘arithmetic-error’, ‘error’,
‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘floating-point-overflow’ consists of error conditions that
occur because of floating-point overflow.


File: ansicl,  Node: floating-point-underflow,  Prev: floating-point-overflow,  Up: Numbers

floating-point-underflow (Condition Type)
=========================================

Class Precedence List:
......................

‘floating-point-underflow’, ‘arithmetic-error’, ‘error’,
‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘floating-point-underflow’ consists of error conditions that
occur because of floating-point underflow.


File: ansicl,  Node: Characters,  Next: Conses,  Prev: Numbers,  Up: Top

13 Characters
*************

* Menu:

* Character Concepts::

Dictionary

* character (System Class)::
* base-char::
* standard-char::
* extended-char::
* char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+::
* character (Function)::
* characterp::
* alpha-char-p::
* alphanumericp::
* digit-char::
* digit-char-p::
* graphic-char-p::
* standard-char-p::
* char-upcase; char-downcase::
* upper-case-p; lower-case-p; both-case-p::
* char-code::
* char-int::
* code-char::
* char-code-limit::
* char-name::
* name-char::


File: ansicl,  Node: Character Concepts,  Next: character (System Class),  Up: Characters

13.1 Character Concepts
=======================

* Menu:

* Introduction to Characters::
* Introduction to Scripts and Repertoires::
* Character Attributes::
* Character Categories::
* Identity of Characters::
* Ordering of Characters::
* Character Names::
* Treatment of Newline during Input and Output::
* Character Encodings::
* Documentation of Implementation-Defined Scripts::


File: ansicl,  Node: Introduction to Characters,  Next: Introduction to Scripts and Repertoires,  Up: Character Concepts

13.1.1 Introduction to Characters
---------------------------------

A “character” is an object that represents a unitary token (e.g., a
letter, a special symbol, or a “control character”) in an aggregate
quantity of text (e.g., a string or a text stream).

Common Lisp allows an implementation to provide support for
international language characters as well as characters used in
specialized arenas (e.g., mathematics).

The following figures contain lists of defined names applicable to
characters.

The next figure lists some defined names relating to character
attributes and character predicates.

alpha-char-p      char-not-equal      char>
alphanumericp     char-not-greaterp   char>=
both-case-p       char-not-lessp      digit-char-p
char-code-limit   char/=              graphic-char-p
char-equal        char<               lower-case-p
char-greaterp     char<=              standard-char-p
char-lessp        char=               upper-case-p

Figure 13.1: Character defined names – 1

The next figure lists some character construction and conversion defined
names.

char-code       char-name     code-char
char-downcase   char-upcase   digit-char
char-int        character     name-char

Figure 13.2: Character defined names – 2


File: ansicl,  Node: Introduction to Scripts and Repertoires,  Next: Character Attributes,  Prev: Introduction to Characters,  Up: Character Concepts

13.1.2 Introduction to Scripts and Repertoires
----------------------------------------------

13.1.2.1 Character Scripts
..........................

A script is one of possibly several sets that form an exhaustive
partition of the type ‘character’.

The number of such sets and boundaries between them is
implementation-defined.  Common Lisp does not require these sets to be
types, but an implementation is permitted to define such types as an
extension.  Since no character from one script can ever be a member of
another script, it is generally more useful to speak about character
repertoires.

Although the term “script” is chosen for definitional compatibility with
ISO terminology, no conforming implementation is required to use any
particular scripts standardized by ISO or by any other standards
organization.

Whether and how the script or scripts used by any given implementation
are named is implementation-dependent.

13.1.2.2 Character Repertoires
..............................

A “repertoire” is a type specifier for a subtype of type ‘character’.
This term is generally used when describing a collection of characters
independent of their coding.  Characters in repertoires are only
identified by name, by glyph, or by character description.

A repertoire can contain characters from several scripts, and a
character can appear in more than one repertoire.

For some examples of repertoires, see the coded character standards ISO
8859/1, ISO 8859/2, and ISO 6937/2.  Note, however, that although the
term “repertoire” is chosen for definitional compatibility with ISO
terminology, no conforming implementation is required to use repertoires
standardized by ISO or any other standards organization.


File: ansicl,  Node: Character Attributes,  Next: Character Categories,  Prev: Introduction to Scripts and Repertoires,  Up: Character Concepts

13.1.3 Character Attributes
---------------------------

Characters have only one standardized attribute: a code.  A character’s
code is a non-negative integer.  This code is composed from a character
script and a character label in an implementation-dependent way.  See
the functions *note char-code:: and ‘code-char’.

Additional, implementation-defined attributes of characters are also
permitted so that, for example, two characters with the same code may
differ in some other, implementation-defined way.

For any implementation-defined attribute there is a distinguished value
called the “null” value for that attribute.  A character for which each
implementation-defined attribute has the null value for that attribute
is called a simple character.  If the implementation has no
implementation-defined attributes, then all characters are simple
characters.


File: ansicl,  Node: Character Categories,  Next: Identity of Characters,  Prev: Character Attributes,  Up: Character Concepts

13.1.4 Character Categories
---------------------------

There are several (overlapping) categories of characters that have no
formally associated type but that are nevertheless useful to name.  They
include graphic characters, alphabeticcharacters with case (uppercase
and lowercase characters), numeric characters, alphanumeric characters,
and digits (in a given radix).

For each implementation-defined attribute of a character, the
documentation for that implementation must specify whether characters
that differ only in that attribute are permitted to differ in whether
are not they are members of one of the aforementioned categories.

Note that these terms are defined independently of any special syntax
which might have been enabled in the current readtable.

13.1.4.1 Graphic Characters
...........................

Characters that are classified as “graphic”, or displayable, are each
associated with a glyph, a visual representation of the character.

A graphic character is one that has a standard textual representation as
a single glyph, such as ‘A’ or ‘*’ or ‘=’.  Space, which effectively has
a blank glyph, is defined to be a graphic.

Of the standard characters, newline is non-graphic and all others are
graphic; see *note Section 2.1.3 (Standard Characters): Standard
Characters.

Characters that are not graphic are called “non-graphic”.  Non-graphic
characters are sometimes informally called “formatting characters” or
“control characters.”

‘#\Backspace’, ‘#\Tab’, ‘#\Rubout’, ‘#\Linefeed’, ‘#\Return’, and
‘#\Page’, if they are supported by the implementation, are non-graphic.

13.1.4.2 Alphabetic Characters
..............................

The alphabetica subset of the graphic characters.  Of the standard
characters, only these are the alphabetic

‘A B C D E F G H I J K L M N O P Q R S T U V W X Y Z’

‘a b c d e f g h i j k l m n o p q r s t u v w x y z’

Any implementation-defined character that has case must be alphabeticFor
each implementation-defined graphic character that has no case, it is
implementation-defined whether that character is alphabetic

13.1.4.3 Characters With Case
.............................

The characters with case are a subset of the alphabeticA character with
case has the property of being either uppercase or lowercase.  Every
character with case is in one-to-one correspondence with some other
character with the opposite case.

13.1.4.3.1 Uppercase Characters
...............................

An uppercase character is one that has a corresponding lowercase
character that is different (and can be obtained using ‘char-downcase’).

Of the standard characters, only these are uppercase characters:

‘A B C D E F G H I J K L M N O P Q R S T U V W X Y Z’

13.1.4.3.2 Lowercase Characters
...............................

A lowercase character is one that has a corresponding uppercase
character that is different (and can be obtained using ‘char-upcase’).

Of the standard characters, only these are lowercase characters:

‘a b c d e f g h i j k l m n o p q r s t u v w x y z’

13.1.4.3.3 Corresponding Characters in the Other Case
.....................................................

The uppercase standard characters ‘A’ through ‘Z’ mentioned above
respectively correspond to the lowercase standard characters ‘a’ through
‘z’ mentioned above.  For example, the uppercase character ‘E’
corresponds to the lowercase character ‘e’, and vice versa.

13.1.4.3.4 Case of Implementation-Defined Characters
....................................................

An implementation may define that other implementation-defined graphic
characters have case.  Such definitions must always be done in pairs—one
uppercase character in one-to-one correspondence with one lowercase
character.

13.1.4.4 Numeric Characters
...........................

The numeric characters are a subset of the graphic characters.  Of the
standard characters, only these are numeric characters:

‘0 1 2 3 4 5 6 7 8 9’

For each implementation-defined graphic character that has no case, the
implementation must define whether or not it is a numeric character.

13.1.4.5 Alphanumeric Characters
................................

The set of alphanumeric characters is the union of the set of
alphabeticand the set of numeric characters.

13.1.4.6 Digits in a Radix
..........................

What qualifies as a digit depends on the radix (an integer between ‘2’
and ‘36’, inclusive).  The potential digits are:

‘0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y
Z’

Their respective weights are ‘0’, ‘1’, ‘2’, ... ‘35’.  In any given
radix n, only the first n potential digits are considered to be digits.
For example, the digits in radix ‘2’ are ‘0’ and ‘1’, the digits in
radix ‘10’ are ‘0’ through ‘9’, and the digits in radix ‘16’ are ‘0’
through ‘F’.

Case is not significant in digits; for example, in radix ‘16’, both ‘F’
and ‘f’ are digits with weight ‘15’.


File: ansicl,  Node: Identity of Characters,  Next: Ordering of Characters,  Prev: Character Categories,  Up: Character Concepts

13.1.5 Identity of Characters
-----------------------------

Two characters that are ‘eql’, ‘char=’, or ‘char-equal’ are not
necessarily ‘eq’.


File: ansicl,  Node: Ordering of Characters,  Next: Character Names,  Prev: Identity of Characters,  Up: Character Concepts

13.1.6 Ordering of Characters
-----------------------------

The total ordering on characters is guaranteed to have the following
properties:

   • If two characters have the same implementation-defined attributes,
     then their ordering by ‘char<’ is consistent with the numerical
     ordering by the predicate ‘<’ on their code attributes.

   • If two characters differ in any attribute, then they are not
     ‘char=’.

   • The total ordering is not necessarily the same as the total
     ordering on the integers produced by applying ‘char-int’ to the
     characters.

   • While alphabeticmust obey a partial ordering, they need not be
     contiguous; it is permissible for uppercase and lowercase
     characters to be interleaved.  Thus ‘(char<= #\a x #\z)’ is not a
     valid way of determining whether or not ‘x’ is a lowercase
     character.

Of the standard characters, those which are alphanumeric obey the
following partial ordering:

      A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z
      a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y<z
      0<1<2<3<4<5<6<7<8<9
      either 9<A or Z<0
      either 9<a or z<0

This implies that, for standard characters, alphabeticordering holds
within each case (uppercase and lowercase), and that the numeric
characters as a group are not interleaved with alphabetic characters.
However, the ordering or possible interleaving of uppercase characters
and lowercase characters is implementation-defined.


File: ansicl,  Node: Character Names,  Next: Treatment of Newline during Input and Output,  Prev: Ordering of Characters,  Up: Character Concepts

13.1.7 Character Names
----------------------

The following character names must be present in all conforming
implementations:

‘Newline’

     The character that represents the division between lines.  An
     implementation must translate between ‘#\Newline’, a
     single-character representation, and whatever external
     representation(s) may be used.

‘Space’

     The space or blank character.

The following names are semi-standard; if an implementation supports
them, they should be used for the described characters and no others.

‘Rubout’

     The rubout or delete character.

‘Page’

     The form-feed or page-separator character.

‘Tab’

     The tabulate character.

‘Backspace’

     The backspace character.

‘Return’

     The carriage return character.

‘Linefeed’

     The line-feed character.

In some implementations, one or more of these character names might
denote a standard character; for example, ‘#\Linefeed’ and ‘#\Newline’
might be the same character in some implementations.


File: ansicl,  Node: Treatment of Newline during Input and Output,  Next: Character Encodings,  Prev: Character Names,  Up: Character Concepts

13.1.8 Treatment of Newline during Input and Output
---------------------------------------------------

When the character ‘#\Newline’ is written to an output file, the
implementation must take the appropriate action to produce a line
division.  This might involve writing out a record or translating
‘#\Newline’ to a CR/LF sequence.  When reading, a corresponding reverse
transformation must take place.


File: ansicl,  Node: Character Encodings,  Next: Documentation of Implementation-Defined Scripts,  Prev: Treatment of Newline during Input and Output,  Up: Character Concepts

13.1.9 Character Encodings
--------------------------

A character is sometimes represented merely by its code, and sometimes
by another integer value which is composed from the code and all
implementation-defined attributes (in an implementation-defined way that
might vary between Lisp images even in the same implementation).  This
integer, returned by the function ‘char-int’, is called the character’s
“encoding.” There is no corresponding function from a character’s
encoding back to the character, since its primary intended uses include
things like hashing where an inverse operation is not really called for.


File: ansicl,  Node: Documentation of Implementation-Defined Scripts,  Prev: Character Encodings,  Up: Character Concepts

13.1.10 Documentation of Implementation-Defined Scripts
-------------------------------------------------------

An implementation must document the character scripts it supports.  For
each character script supported, the documentation must describe at
least the following:

   • Character labels, glyphs, and descriptions.  Character labels must
     be uniquely named using only Latin capital letters A–Z, hyphen (-),
     and digits 0–9.
   • Reader canonicalization.  Any mechanisms by which ‘read’ treats
     different characters as equivalent must be documented.
   • The impact on ‘char-upcase’, ‘char-downcase’, and the
     case-sensitive format directives.  In particular, for each
     character with case, whether it is uppercase or lowercase, and
     which character is its equivalent in the opposite case.
   • The behavior of the case-insensitive functions ‘char-equal’,
     ‘char-not-equal’, ‘char-lessp’, ‘char-greaterp’,
     ‘char-not-greaterp’, and ‘char-not-lessp’.
   • The behavior of any character predicates; in particular, the
     effects of ‘alpha-char-p’, ‘lower-case-p’, ‘upper-case-p’,
     ‘both-case-p’, ‘graphic-char-p’, and ‘alphanumericp’.
   • The interaction with file I/O, in particular, the supported coded
     character sets (for example, ISO8859/1-1987) and external encoding
     schemes supported are documented.


File: ansicl,  Node: character (System Class),  Next: base-char,  Prev: Character Concepts,  Up: Characters

character (System Class)
========================

Class Precedence List:
......................

‘character’, ‘t’

Description:
............

A character is an object that represents a unitary token in an aggregate
quantity of text; see *note Section 13.1 (Character Concepts): Character
Concepts.

The types ‘base-char’ and ‘extended-char’ form an exhaustive partition
of the type ‘character’.

See Also:
.........

*note Section 13.1 (Character Concepts): Character Concepts, *note
Section 2.4.8.1 (Sharpsign Backslash): SharpsignBackslash, *note Section
22.1.3.2 (Printing Characters): PrintingCharacters.


File: ansicl,  Node: base-char,  Next: standard-char,  Prev: character (System Class),  Up: Characters

base-char (Type)
================

Supertypes:
...........

‘base-char’, ‘character’, ‘t’

Description:
............

The type ‘base-char’ is defined as the upgraded array element type of
‘standard-char’.  An implementation can support additional subtypes of
type ‘character’ (besides the ones listed in this standard) that might
or might not be supertypes of type ‘base-char’.  In addition, an
implementation can define ‘base-char’ to be the same type as
‘character’.

Base characters are distinguished in the following respects:

  1. The type ‘standard-char’ is a subrepertoire of the type
     ‘base-char’.
  2. The selection of base characters that are not standard characters
     is implementation defined.
  3. Only objects of the type ‘base-char’ can be elements of a base
     string.
  4. No upper bound is specified for the number of characters in the
     ‘base-char’ repertoire; the size of that repertoire is
     implementation-defined.  The lower bound is 96, the number of
     standard characters.

Whether a character is a base character depends on the way that an
implementation represents strings, and not any other properties of the
implementation or the host operating system.  For example, one
implementation might encode all strings as characters having 16-bit
encodings, and another might have two kinds of strings: those with
characters having 8-bit encodings and those with characters having
16-bit encodings.  In the first implementation, the type ‘base-char’ is
equivalent to the type ‘character’: there is only one kind of string.
In the second implementation, the base characters might be those
characters that could be stored in a string of characters having 8-bit
encodings.  In such an implementation, the type ‘base-char’ is a proper
subtype of the type ‘character’.

The type ‘standard-char’ is a subtype of type ‘base-char’.


File: ansicl,  Node: standard-char,  Next: extended-char,  Prev: base-char,  Up: Characters

standard-char (Type)
====================

Supertypes:
...........

‘standard-char’, ‘base-char’, ‘character’, ‘t’

Description:
............

A fixed set of 96 characters required to be present in all conforming
implementations.  Standard characters are defined in *note Section 2.1.3
(Standard Characters): Standard Characters.

Any character that is not simple is not a standard character.

See Also:
.........

*note Section 2.1.3 (Standard Characters): Standard Characters.


File: ansicl,  Node: extended-char,  Next: char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+,  Prev: standard-char,  Up: Characters

extended-char (Type)
====================

Supertypes:
...........

‘extended-char’, ‘character’, ‘t’

Description:
............

The type ‘extended-char’ is equivalent to the type ‘(and character (not
base-char))’.

Notes:
......

The type ‘extended-char’ might have no elementsin implementations in
which all characters are of type ‘base-char’.


File: ansicl,  Node: char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+,  Next: character (Function),  Prev: extended-char,  Up: Characters

char=, char/=, char<, char>, char<=, char>=, char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp, char-not-lessp (Function)
================================================================================================================================================

Syntax:
.......

 -- Function: char= &rest characters+ → generalized-boolean
 -- Function: char/= &rest characters+ → generalized-boolean
 -- Function: char< &rest characters+ → generalized-boolean
 -- Function: char> &rest characters+ → generalized-boolean
 -- Function: char<= &rest characters+ → generalized-boolean
 -- Function: char>= &rest characters+ → generalized-boolean
 -- Function: char-equal &rest characters+ → generalized-boolean
 -- Function: char-not-equal &rest characters+ → generalized-boolean
 -- Function: char-lessp &rest characters+ → generalized-boolean
 -- Function: char-greaterp &rest characters+ → generalized-boolean
 -- Function: char-not-greaterp &rest characters+ → generalized-boolean
 -- Function: char-not-lessp &rest characters+ → generalized-boolean

Arguments and Values:
.....................

CHARACTER—a character.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

These predicates compare characters.

‘char=’ returns true if all CHARACTERS are the same; otherwise, it
returns false.  If two CHARACTERS differ in any implementation-defined
attributes, then they are not ‘char=’.

‘char/=’ returns true if all CHARACTERS are different; otherwise, it
returns false.

‘char<’ returns true if the CHARACTERS are monotonically increasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ‘char<’ is
consistent with the numerical ordering by the predicate ‘<’ on their
codes.

‘char>’ returns true if the CHARACTERS are monotonically decreasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ‘char>’ is
consistent with the numerical ordering by the predicate ‘>’ on their
codes.

‘char<=’ returns true if the CHARACTERS are monotonically nondecreasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ‘char<=’ is
consistent with the numerical ordering by the predicate ‘<=’ on their
codes.

‘char>=’ returns true if the CHARACTERS are monotonically nonincreasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ‘char>=’ is
consistent with the numerical ordering by the predicate ‘>=’ on their
codes.

‘char-equal’, ‘char-not-equal’, ‘char-lessp’, ‘char-greaterp’,
‘char-not-greaterp’, and ‘char-not-lessp’ are similar to ‘char=’,
‘char/=’, ‘char<’, ‘char>’, ‘char<=’, ‘char>=’, respectively, except
that they ignore differences in case and might have an
implementation-defined behavior for non-simple characters.  For example,
an implementation might define that ‘char-equal’, etc.  ignore certain
implementation-defined attributes.  The effect, if any, of each
implementation-defined attribute upon these functions must be specified
as part of the definition of that attribute.

Examples:
.........

      (char= #\d #\d) → true
      (char= #\A #\a) → false
      (char= #\d #\x) → false
      (char= #\d #\D) → false
      (char/= #\d #\d) → false
      (char/= #\d #\x) → true
      (char/= #\d #\D) → true
      (char= #\d #\d #\d #\d) → true
      (char/= #\d #\d #\d #\d) → false
      (char= #\d #\d #\x #\d) → false
      (char/= #\d #\d #\x #\d) → false
      (char= #\d #\y #\x #\c) → false
      (char/= #\d #\y #\x #\c) → true
      (char= #\d #\c #\d) → false
      (char/= #\d #\c #\d) → false
      (char< #\d #\x) → true
      (char<= #\d #\x) → true
      (char< #\d #\d) → false
      (char<= #\d #\d) → true
      (char< #\a #\e #\y #\z) → true
      (char<= #\a #\e #\y #\z) → true
      (char< #\a #\e #\e #\y) → false
      (char<= #\a #\e #\e #\y) → true
      (char> #\e #\d) → true
      (char>= #\e #\d) → true
      (char> #\d #\c #\b #\a) → true
      (char>= #\d #\c #\b #\a) → true
      (char> #\d #\d #\c #\a) → false
      (char>= #\d #\d #\c #\a) → true
      (char> #\e #\d #\b #\c #\a) → false
      (char>= #\e #\d #\b #\c #\a) → false
      (char> #\z #\A) → implementation-dependent
      (char> #\Z #\a) → implementation-dependent
      (char-equal #\A #\a) → true
      (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char-lessp)
     → (#\A #\a #\b #\B #\c #\C)
      (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char<)
     → (#\A #\B #\C #\a #\b #\c) ;Implementation A
     → (#\a #\b #\c #\A #\B #\C) ;Implementation B
     → (#\a #\A #\b #\B #\c #\C) ;Implementation C
     → (#\A #\a #\B #\b #\C #\c) ;Implementation D
     → (#\A #\B #\a #\b #\C #\c) ;Implementation E

Exceptional Situations:
.......................

Should signal an error of type ‘program-error’ if at least one CHARACTER
is not supplied.

See Also:
.........

*note Section 2.1 (Character Syntax): Character Syntax, *note Section
13.1.10 (Documentation of Implementation-Defined Scripts): Documentation
of Implementation-Defined Scripts.

Notes:
......

If characters differ in their code attribute or any
implementation-defined attribute, they are considered to be different by
‘char=’.

There is no requirement that ‘(eq c1 c2)’ be true merely because ‘(char=
c1 c2)’ is true.  While ‘eq’ can distinguish two characters that ‘char=’
does not, it is distinguishing them not as characters, but in some sense
on the basis of a lower level implementation characteristic.  If ‘(eq c1
c2)’ is true, then ‘(char= c1 c2)’ is also true.  ‘eql’ and ‘equal’
compare characters in the same way that ‘char=’ does.

The manner in which case is used by ‘char-equal’, ‘char-not-equal’,
‘char-lessp’, ‘char-greaterp’, ‘char-not-greaterp’, and ‘char-not-lessp’
implies an ordering for standard characters such that ‘A=a’, ‘B=b’, and
so on, up to ‘Z=z’, and furthermore either ‘9<A’ or ‘Z<0’.


File: ansicl,  Node: character (Function),  Next: characterp,  Prev: char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+,  Up: Characters

character (Function)
====================

Syntax:
.......

 -- Function: character character → denoted-character

Arguments and Values:
.....................

CHARACTER—a character designator.

DENOTED-CHARACTER—a character.

Description:
............

Returns the character denoted by the CHARACTER designator.

Examples:
.........

      (character #\a) → #\a
      (character "a") → #\a
      (character 'a) → #\A
      (character '\a) → #\a
      (character 65.) is an error.
      (character 'apple) is an error.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if OBJECT is not a character
designator.

See Also:
.........

*note coerce::

Notes:
......

      (character OBJECT) ≡ (coerce OBJECT 'character)


File: ansicl,  Node: characterp,  Next: alpha-char-p,  Prev: character (Function),  Up: Characters

characterp (Function)
=====================

Syntax:
.......

 -- Function: characterp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘character’; otherwise, returns false.

Examples:
.........

      (characterp #\a) → true
      (characterp 'a) → false
      (characterp "a") → false
      (characterp 65.) → false
      (characterp #\Newline) → true
      ;; This next example presupposes an implementation
      ;; in which #\Rubout is an implementation-defined character.
      (characterp #\Rubout) → true

See Also:
.........

*note character (Function):: (type and function), *note typep::

Notes:
......

      (characterp OBJECT) ≡ (typep OBJECT 'character)


File: ansicl,  Node: alpha-char-p,  Next: alphanumericp,  Prev: characterp,  Up: Characters

alpha-char-p (Function)
=======================

Syntax:
.......

 -- Function: alpha-char-p character → generalized-boolean

Arguments and Values:
.....................

CHARACTER—a character.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if CHARACTER is an alphabetic

Examples:
.........

      (alpha-char-p #\a) → true
      (alpha-char-p #\5) → false
      (alpha-char-p #\Newline) → false
      ;; This next example presupposes an implementation
      ;; in which #\α is a defined character.
      (alpha-char-p #\α) → implementation-dependent

Affected By:
............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current
readtable.)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note alphanumericp::, *note Section 13.1.10 (Documentation of
Implementation-Defined Scripts): Documentation of Implementation-Defined
Scripts.


File: ansicl,  Node: alphanumericp,  Next: digit-char,  Prev: alpha-char-p,  Up: Characters

alphanumericp (Function)
========================

Syntax:
.......

 -- Function: alphanumericp character → generalized-boolean

Arguments and Values:
.....................

CHARACTER—a character.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if CHARACTER is an alphabetic

Examples:
.........

      (alphanumericp #\Z) → true
      (alphanumericp #\9) → true
      (alphanumericp #\Newline) → false
      (alphanumericp #\#) → false

Affected By:
............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current
readtable.)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note alpha-char-p::, *note graphic-char-p::, *note digit-char-p::

Notes:
......

Alphanumeric characters are graphic as defined by ‘graphic-char-p’.  The
alphanumeric characters are a subset of the graphic characters.  The
standard characters ‘A’ through ‘Z’, ‘a’ through ‘z’, and ‘0’ through
‘9’ are alphanumeric characters.

      (alphanumericp x)
        ≡ (or (alpha-char-p x) (not (null (digit-char-p x))))


File: ansicl,  Node: digit-char,  Next: digit-char-p,  Prev: alphanumericp,  Up: Characters

digit-char (Function)
=====================

Syntax:
.......

 -- Function: digit-char weight &optional radix → char

Arguments and Values:
.....................

WEIGHT—a non-negative integer.

RADIX—a radix.  The default is ‘10’.

CHAR—a character or false.

Description:
............

If WEIGHT is less than RADIX, ‘digit-char’ returns a character which has
that WEIGHT when considered as a digit in the specified radix.  If the
resulting character is to be an alphabeticit will be an uppercase
character.

If WEIGHT is greater than or equal to RADIX, ‘digit-char’ returns false.

Examples:
.........

      (digit-char 0) → #\0
      (digit-char 10 11) → #\A
      (digit-char 10 10) → false
      (digit-char 7) → #\7
      (digit-char 12) → false
      (digit-char 12 16) → #\C  ;not #\c
      (digit-char 6 2) → false
      (digit-char 1 2) → #\1

See Also:
.........

*note digit-char-p::, *note graphic-char-p::, *note Section 2.1
(Character Syntax): Character Syntax.

Notes:
......


File: ansicl,  Node: digit-char-p,  Next: graphic-char-p,  Prev: digit-char,  Up: Characters

digit-char-p (Function)
=======================

Syntax:
.......

 -- Function: digit-char-p char &optional radix → weight

Arguments and Values:
.....................

CHAR—a character.

RADIX—a radix.  The default is ‘10’.

WEIGHT—either a non-negative integer less than RADIX, or false.

Description:
............

Tests whether CHAR is a digit in the specified RADIX (i.e., with a
weight less than RADIX).  If it is a digit in that RADIX, its weight is
returned as an integer; otherwise ‘nil’ is returned.

Examples:
.........

      (digit-char-p #\5)    → 5
      (digit-char-p #\5 2)  → false
      (digit-char-p #\A)    → false
      (digit-char-p #\a)    → false
      (digit-char-p #\A 11) → 10
      (digit-char-p #\a 11) → 10
      (mapcar #'(lambda (radix)
                  (map 'list #'(lambda (x) (digit-char-p x radix))
                       "059AaFGZ"))
              '(2 8 10 16 36))
      → ((0 NIL NIL NIL NIL NIL NIL NIL)
          (0 5 NIL NIL NIL NIL NIL NIL)
          (0 5 9 NIL NIL NIL NIL NIL)
          (0 5 9 10 10 15 NIL NIL)
          (0 5 9 10 10 15 16 35))

Affected By:
............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current
readtable.)

See Also:
.........

*note alphanumericp::

Notes:
......

Digits are graphic characters.

