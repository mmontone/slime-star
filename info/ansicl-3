This is ansicl, produced by makeinfo version 6.7 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: block,  Next: catch,  Prev: psetq,  Up: Data and Control Flow

block (Special Operator)
========================

Syntax:
.......

 -- Special Form: block NAME FORM* → {result}*

Arguments and Values:
.....................

NAME—a symbol.

FORM—a form.

RESULTS—the values of the forms if a normal return occurs, or else, if
an explicit return occurs, the values that were transferred.

Description:
............

‘block’ establishes a block named NAME and then evaluates FORMS as an
implicit progn.

The special operators ‘block’ and ‘return-from’ work together to provide
a structured, lexical, non-local exit facility.  At any point lexically
contained within forms, ‘return-from’ can be used with the given NAME to
return control and values from the ‘block’ form, except when an
intervening block with the same name has been established, in which case
the outer block is shadowed by the inner one.

The block named name has lexical scope and dynamic extent.

Once established, a block may only be exited once, whether by normal
return or explicit return.

Examples:
.........

      (block empty) → NIL
      (block whocares (values 1 2) (values 3 4)) → 3, 4
      (let ((x 1))
        (block stop (setq x 2) (return-from stop) (setq x 3))
        x) → 2
      (block early (return-from early (values 1 2)) (values 3 4)) → 1, 2
      (block outer (block inner (return-from outer 1)) 2) → 1
      (block twin (block twin (return-from twin 1)) 2) → 2
      ;; Contrast behavior of this example with corresponding example of CATCH.
      (block b
        (flet ((b1 () (return-from b 1)))
          (block b (b1) (print 'unreachable))
          2)) → 1

See Also:
.........

*note return::, *note return-from::, *note Section 3.1 (Evaluation):
Evaluation.

Notes:
......


File: ansicl,  Node: catch,  Next: go,  Prev: block,  Up: Data and Control Flow

catch (Special Operator)
========================

Syntax:
.......

 -- Special Form: catch TAG {form}* → {result}*

Arguments and Values:
.....................

TAG—a catch tag; evaluated.

FORMS—an implicit progn.

RESULTS—if the FORMS exit normally, the values returned by the FORMS; if
a throw occurs to the TAG, the values that are thrown.

Description:
............

‘catch’ is used as the destination of a non-local control transfer by
‘throw’.  TAGS are used to find the ‘catch’ to which a ‘throw’ is
transferring control.  ‘(catch 'foo form)’ catches a ‘(throw 'foo form)’
but not a ‘(throw 'bar form)’.

The order of execution of ‘catch’ follows:

  1. TAG is evaluated.  It serves as the name of the ‘catch’.

  2. FORMS are then evaluated as an implicit ‘progn’, and the results of
     the last FORM are returned unless a ‘throw’ occurs.

  3. If a ‘throw’ occurs during the execution of one of the FORMS,
     control is transferred to the ‘catch’ form whose TAG is ‘eq’ to the
     tag argument of the ‘throw’ and which is the most recently
     established ‘catch’ with that TAG.  No further evaluation of FORMS
     occurs.

  4. The TAG established by ‘catch’ is disestablished just before the
     results are returned.

If during the execution of one of the FORMS, a ‘throw’ is executed whose
tag is ‘eq’ to the ‘catch’ tag, then the values specified by the ‘throw’
are returned as the result of the dynamically most recently established
‘catch’ form with that tag.

The mechanism for ‘catch’ and ‘throw’ works even if ‘throw’ is not
within the lexical scope of ‘catch’.  ‘throw’ must occur within the
dynamic extent of the evaluation of the body of a ‘catch’ with a
corresponding TAG.

Examples:
.........

      (catch 'dummy-tag 1 2 (throw 'dummy-tag 3) 4) → 3
      (catch 'dummy-tag 1 2 3 4) → 4
      (defun throw-back (tag) (throw tag t)) → THROW-BACK
      (catch 'dummy-tag (throw-back 'dummy-tag) 2) → T

      ;; Contrast behavior of this example with corresponding example of BLOCK.
      (catch 'c
        (flet ((c1 () (throw 'c 1)))
          (catch 'c (c1) (print 'unreachable))
          2)) → 2

Exceptional Situations:
.......................

An error of type ‘control-error’ is signaled if ‘throw’ is done when
there is no suitable ‘catch’ TAG.

See Also:
.........

*note throw::, *note Section 3.1 (Evaluation): Evaluation.

Notes:
......

It is customary for symbols to be used as TAGS, but any object is
permitted.  However, numbers should not be used because the comparison
is done using ‘eq’.

‘catch’ differs from ‘block’ in that ‘catch’ tags have dynamic scope
while ‘block’ names have lexical scope.


File: ansicl,  Node: go,  Next: return-from,  Prev: catch,  Up: Data and Control Flow

go (Special Operator)
=====================

Syntax:
.......

 -- Special Form: go tag →|

Arguments and Values:
.....................

TAG—a go tag.

Description:
............

‘go’ transfers control to the point in the body of an enclosing
‘tagbody’ form labeled by a tag ‘eql’ to TAG.  If there is no such TAG
in the body, the bodies of lexically containing ‘tagbody’ forms (if any)
are examined as well.  If several tags are ‘eql’ to TAG, control is
transferred to whichever matching TAG is contained in the innermost
‘tagbody’ form that contains the ‘go’.  The consequences are undefined
if there is no matching TAG lexically visible to the point of the ‘go’.

The transfer of control initiated by ‘go’ is performed as described in
*note Section 5.2 (Transfer of Control to an Exit Point): Transfer of
Control to an Exit Point.

Examples:
.........

      (tagbody
        (setq val 2)
        (go lp)
        (incf val 3)
        lp (incf val 4)) → NIL
      val → 6

The following is in error because there is a normal exit of the
‘tagbody’ before the ‘go’ is executed.

      (let ((a nil))
        (tagbody t (setq a #'(lambda () (go t))))
        (funcall a))

The following is in error because the ‘tagbody’ is passed over before
the ‘go’ form is executed.

      (funcall (block nil
                 (tagbody a (return #'(lambda () (go a))))))

See Also:
.........

*note tagbody::


File: ansicl,  Node: return-from,  Next: return,  Prev: go,  Up: Data and Control Flow

return-from (Special Operator)
==============================

Syntax:
.......

 -- Special Form: return-from NAME [RESULT] →|

Arguments and Values:
.....................

NAME—a block tag; not evaluated.

RESULT—a form; evaluated.  The default is ‘nil’.

Description:
............

Returns control and multiple values

A ‘block’ form named NAME must lexically enclose the occurrence of
‘return-from’; any values yielded by the evaluation of RESULT are
immediately returned from the innermost such lexically enclosing block.

The transfer of control initiated by ‘return-from’ is performed as
described in *note Section 5.2 (Transfer of Control to an Exit Point):
Transfer of Control to an Exit Point.

Examples:
.........

      (block alpha (return-from alpha) 1) → NIL
      (block alpha (return-from alpha 1) 2) → 1
      (block alpha (return-from alpha (values 1 2)) 3) → 1, 2
      (let ((a 0))
         (dotimes (i 10) (incf a) (when (oddp i) (return)))
         a) → 2
      (defun temp (x)
         (if x (return-from temp 'dummy))
         44) → TEMP
      (temp nil) → 44
      (temp t) → DUMMY
      (block out
        (flet ((exit (n) (return-from out n)))
          (block out (exit 1)))
        2) → 1
      (block nil
        (unwind-protect (return-from nil 1)
          (return-from nil 2)))
     → 2
      (dolist (flag '(nil t))
        (block nil
          (let ((x 5))
            (declare (special x))
            (unwind-protect (return-from nil)
              (print x))))
        (print 'here))
     ▷ 5
     ▷ HERE
     ▷ 5
     ▷ HERE
     → NIL
      (dolist (flag '(nil t))
        (block nil
          (let ((x 5))
            (declare (special x))
            (unwind-protect
                (if flag (return-from nil))
              (print x))))
        (print 'here))
     ▷ 5
     ▷ HERE
     ▷ 5
     ▷ HERE
     → NIL

The following has undefined consequences because the ‘block’ form exits
normally before the ‘return-from’ form is attempted.

      (funcall (block nil #'(lambda () (return-from nil)))) is an error.

See Also:
.........

*note block::, *note return::, *note Section 3.1 (Evaluation):
Evaluation.


File: ansicl,  Node: return,  Next: tagbody,  Prev: return-from,  Up: Data and Control Flow

return (Macro)
==============

Syntax:
.......

 -- Macro: return [RESULT] →|

Arguments and Values:
.....................

RESULT—a form; evaluated.  The default is ‘nil’.

Description:
............

Returns, as if by ‘return-from’, from the block named ‘nil’.

Examples:
.........

      (block nil (return) 1) → NIL
      (block nil (return 1) 2) → 1
      (block nil (return (values 1 2)) 3) → 1, 2
      (block nil (block alpha (return 1) 2)) → 1
      (block alpha (block nil (return 1)) 2) → 2
      (block nil (block nil (return 1) 2)) → 1

See Also:
.........

*note block::, *note return-from::, *note Section 3.1 (Evaluation):
Evaluation.

Notes:
......

      (return) ≡ (return-from nil)
      (return FORM) ≡ (return-from nil FORM)

The implicit blocks established by macros such as ‘do’ are often named
‘nil’, so that ‘return’ can be used to exit from such forms.


File: ansicl,  Node: tagbody,  Next: throw,  Prev: return,  Up: Data and Control Flow

tagbody (Special Operator)
==========================

Syntax:
.......

 -- Special Form: tagbody {TAG | STATEMENT}* → ‘nil’

Arguments and Values:
.....................

TAG—a go tag; not evaluated.

STATEMENT—a compound form; evaluated as described below.

Description:
............

Executes zero or more statements in a lexical environment that provides
for control transfers to labels indicated by the TAGS.

The STATEMENTS in a ‘tagbody’ are evaluated in order from left to right,
and their values are discarded.  If at any time there are no remaining
STATEMENTS, ‘tagbody’ returns ‘nil’.  However, if ‘(go TAG)’ is
evaluated, control jumps to the part of the body labeled with the TAG.
(Tags are compared with ‘eql’.)

A TAG established by ‘tagbody’ has lexical scope and has dynamic extent.
Once ‘tagbody’ has been exited, it is no longer valid to ‘go’ to a TAG
in its body.  It is permissible for ‘go’ to jump to a ‘tagbody’ that is
not the innermost ‘tagbody’ containing that ‘go’; the TAGS established
by a ‘tagbody’ only shadow other TAGS of like name.

The determination of which elements of the body are TAGS and which are
STATEMENTS is made prior to any macro expansion of that element.  If a
STATEMENT is a macro form and its macro expansion is an atom, that atom
is treated as a STATEMENT, not a TAG.

Examples:
.........

      (let (val)
         (tagbody
           (setq val 1)
           (go point-a)
           (incf val 16)
          point-c
           (incf val 04)
           (go point-b)
           (incf val 32)
          point-a
           (incf val 02)
           (go point-c)
           (incf val 64)
          point-b
           (incf val 08))
         val)
     → 15
      (defun f1 (flag)
        (let ((n 1))
          (tagbody
            (setq n (f2 flag #'(lambda () (go out))))
           out
            (prin1 n))))
     → F1
      (defun f2 (flag escape)
        (if flag (funcall escape) 2))
     → F2
      (f1 nil)
     ▷ 2
     → NIL
      (f1 t)
     ▷ 1
     → NIL

See Also:
.........

*note go::

Notes:
......

The macros in the next figure have implicit tagbodies.

do               do-external-symbols   dotimes
do*              do-symbols            prog
do-all-symbols   dolist                prog*

Figure 5.10: Macros that have implicit tagbodies.


File: ansicl,  Node: throw,  Next: unwind-protect,  Prev: tagbody,  Up: Data and Control Flow

throw (Special Operator)
========================

Syntax:
.......

 -- Special Form: throw tag result-form →|

Arguments and Values:
.....................

TAG—a catch tag; evaluated.

RESULT-FORM—a form; evaluated as described below.

Description:
............

‘throw’ causes a non-local control transfer to a ‘catch’ whose tag is
‘eq’ to TAG.

TAG is evaluated first to produce an object called the throw tag; then
RESULT-FORM is evaluated, and its results are saved.  If the RESULT-FORM
produces multiple values, then all the values are saved.  The most
recent outstanding ‘catch’ whose TAG is ‘eq’ to the throw tag is exited;
the saved results are returned as the value or values of ‘catch’.

The transfer of control initiated by ‘throw’ is performed as described
in *note Section 5.2 (Transfer of Control to an Exit Point): Transfer of
Control to an Exit Point.

Examples:
.........

      (catch 'result
         (setq i 0 j 0)
         (loop (incf j 3) (incf i)
               (if (= i 3) (throw 'result (values i j))))) → 3, 9


      (catch nil
        (unwind-protect (throw nil 1)
          (throw nil 2))) → 2

The consequences of the following are undefined because the ‘catch’ of
‘b’ is passed over by the first ‘throw’, hence portable programs must
assume that its dynamic extent is terminated.  The binding of the catch
tag is not yet disestablished and therefore it is the target of the
second ‘throw’.

      (catch 'a
        (catch 'b
          (unwind-protect (throw 'a 1)
            (throw 'b 2))))

The following prints “‘The inner catch returns :SECOND-THROW’” and then
returns ‘:outer-catch’.

      (catch 'foo
              (format t "The inner catch returns ~s.~%"
                      (catch 'foo
                          (unwind-protect (throw 'foo :first-throw)
                              (throw 'foo :second-throw))))
              :outer-catch)
     ▷ The inner catch returns :SECOND-THROW
     → :OUTER-CATCH

Exceptional Situations:
.......................

If there is no outstanding catch tag that matches the throw tag, no
unwinding of the stack is performed, and an error of type
‘control-error’ is signaled.  When the error is signaled, the dynamic
environment is that which was in force at the point of the ‘throw’.

See Also:
.........

*note block::, *note catch::, *note return-from::, *note
unwind-protect::, *note Section 3.1 (Evaluation): Evaluation.

Notes:
......

‘catch’ and ‘throw’ are normally used when the exit point must have
dynamic scope (e.g., the ‘throw’ is not lexically enclosed by the
‘catch’), while ‘block’ and ‘return’ are used when lexical scope is
sufficient.


File: ansicl,  Node: unwind-protect,  Next: nil (Constant Variable),  Prev: throw,  Up: Data and Control Flow

unwind-protect (Special Operator)
=================================

Syntax:
.......

 -- Special Form: unwind-protect PROTECTED-FORM {cleanup-form}* →
          {result}*

Arguments and Values:
.....................

PROTECTED-FORM—a form.

CLEANUP-FORM—a form.

RESULTS—the values of the protected-form.

Description:
............

‘unwind-protect’ evaluates PROTECTED-FORM and guarantees that
CLEANUP-FORMS are executed before ‘unwind-protect’ exits, whether it
terminates normally or is aborted by a control transfer of some kind.
‘unwind-protect’ is intended to be used to make sure that certain side
effects take place after the evaluation of PROTECTED-FORM.

If a non-local exit occurs during execution of CLEANUP-FORMS, no special
action is taken.  The CLEANUP-FORMS of ‘unwind-protect’ are not
protected by that ‘unwind-protect’.

‘unwind-protect’ protects against all attempts to exit from
PROTECTED-FORM, including ‘go’, ‘handler-case’, ‘ignore-errors’,
‘restart-case’, ‘return-from’, ‘throw’, and ‘with-simple-restart’.

Undoing of handler and restart bindings during an exit happens in
parallel with the undoing of the bindings of dynamic variables and
‘catch’ tags, in the reverse order in which they were established.  The
effect of this is that CLEANUP-FORM sees the same handler and restart
bindings, as well as dynamic variable bindings and ‘catch’ tags, as were
visible when the ‘unwind-protect’ was entered.

Examples:
.........

      (tagbody
        (let ((x 3))
          (unwind-protect
            (if (numberp x) (go out))
            (print x)))
       out
        ...)

When ‘go’ is executed, the call to ‘print’ is executed first, and then
the transfer of control to the tag ‘out’ is completed.

      (defun dummy-function (x)
         (setq state 'running)
         (unless (numberp x) (throw 'abort 'not-a-number))
         (setq state (1+ x))) → DUMMY-FUNCTION
      (catch 'abort (dummy-function 1)) → 2
      state → 2
      (catch 'abort (dummy-function 'trash)) → NOT-A-NUMBER
      state → RUNNING
      (catch 'abort (unwind-protect (dummy-function 'trash)
                       (setq state 'aborted))) → NOT-A-NUMBER
      state → ABORTED

The following code is not correct:

      (unwind-protect
        (progn (incf *access-count*)
               (perform-access))
        (decf *access-count*))

If an exit occurs before completion of ‘incf’, the ‘decf’ form is
executed anyway, resulting in an incorrect value for ‘*access-count*’.
The correct way to code this is as follows:

      (let ((old-count *access-count*))
        (unwind-protect
          (progn (incf *access-count*)
                 (perform-access))
          (setq *access-count* old-count)))

     ;;; The following returns 2.
      (block nil
        (unwind-protect (return 1)
          (return 2)))

     ;;; The following has undefined consequences.
      (block a
        (block b
          (unwind-protect (return-from a 1)
            (return-from b 2))))

     ;;; The following returns 2.
      (catch nil
        (unwind-protect (throw nil 1)
          (throw nil 2)))

     ;;; The following has undefined consequences because the catch of B is
     ;;; passed over by the first THROW, hence portable programs must assume
     ;;; its dynamic extent is terminated.  The binding of the catch tag is not
     ;;; yet disestablished and therefore it is the target of the second throw.
      (catch 'a
        (catch 'b
          (unwind-protect (throw 'a 1)
            (throw 'b 2))))

     ;;; The following prints "The inner catch returns :SECOND-THROW"
     ;;; and then returns :OUTER-CATCH.
      (catch 'foo
              (format t "The inner catch returns ~s.~%"
                      (catch 'foo
                          (unwind-protect (throw 'foo :first-throw)
                              (throw 'foo :second-throw))))
              :outer-catch)


     ;;; The following returns 10. The inner CATCH of A is passed over, but
     ;;; because that CATCH is disestablished before the THROW to A is executed,
     ;;; it isn't seen.
      (catch 'a
        (catch 'b
          (unwind-protect (1+ (catch 'a (throw 'b 1)))
            (throw 'a 10))))


     ;;; The following has undefined consequences because the extent of
     ;;; the (CATCH 'BAR ...) exit ends when the (THROW 'FOO ...)
     ;;; commences.
      (catch 'foo
        (catch 'bar
            (unwind-protect (throw 'foo 3)
              (throw 'bar 4)
              (print 'xxx))))


     ;;; The following returns 4; XXX is not printed.
     ;;; The (THROW 'FOO ...) has no effect on the scope of the BAR
     ;;; catch tag or the extent of the (CATCH 'BAR ...) exit.
      (catch 'bar
        (catch 'foo
            (unwind-protect (throw 'foo 3)
              (throw 'bar 4)
              (print 'xxx))))


     ;;; The following prints 5.
      (block nil
        (let ((x 5))
          (declare (special x))
          (unwind-protect (return)
            (print x))))

See Also:
.........

*note catch::, *note go::, *note handler-case::, *note restart-case::,
*note return::, *note return-from::, *note throw::, *note Section 3.1
(Evaluation): Evaluation.


File: ansicl,  Node: nil (Constant Variable),  Next: not (Function),  Prev: unwind-protect,  Up: Data and Control Flow

nil (Constant Variable)
=======================

Constant Value:
...............

‘nil’.

Description:
............

‘nil’ represents both boolean (and generalized boolean) false and the
empty list.

Examples:
.........

      nil → NIL

See Also:
.........

*note t (Constant Variable)::


File: ansicl,  Node: not (Function),  Next: t (Constant Variable),  Prev: nil (Constant Variable),  Up: Data and Control Flow

not (Function)
==============

Syntax:
.......

 -- Function: not x → boolean

Arguments and Values:
.....................

X—a generalized boolean (i.e., any object).

BOOLEAN—a boolean.

Description:
............

Returns ‘t’ if X is false; otherwise, returns ‘nil’.

Examples:
.........

      (not nil) → T
      (not '()) → T
      (not (integerp 'sss)) → T
      (not (integerp 1)) → NIL
      (not 3.7) → NIL
      (not 'apple) → NIL

See Also:
.........

*note null (Function)::

Notes:
......

‘not’ is intended to be used to invert the ‘truth value’ of a boolean
(or generalized boolean) whereas ‘null’ is intended to be used to test
for the empty list.  Operationally, ‘not’ and ‘null’ compute the same
result; which to use is a matter of style.


File: ansicl,  Node: t (Constant Variable),  Next: eq,  Prev: not (Function),  Up: Data and Control Flow

t (Constant Variable)
=====================

Constant Value:
...............

t.

Description:
............

The boolean representing true, and the canonical generalized boolean
representing true.  Although any object other than ‘nil’ is considered
true, ‘t’ is generally used when there is no special reason to prefer
one such object over another.

The symbol ‘t’ is also sometimes used for other purposes as well.  For
example, as the name of a class, as a designator (e.g., a stream
designator) or as a special symbol for some syntactic reason (e.g., in
‘case’ and ‘typecase’ to label the OTHERWISE-CLAUSE).

Examples:
.........

      t → T
      (eq t 't) → true
      (find-class 't) → #<CLASS T 610703333>
      (case 'a (a 1) (t 2)) → 1
      (case 'b (a 1) (t 2)) → 2
      (prin1 'hello t)
     ▷ HELLO
     → HELLO

See Also:
.........

*note nil (Constant Variable)::


File: ansicl,  Node: eq,  Next: eql (Function),  Prev: t (Constant Variable),  Up: Data and Control Flow

eq (Function)
=============

Syntax:
.......

 -- Function: eq x y → generalized-boolean

Arguments and Values:
.....................

X—an object.

Y—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if its arguments are the same, identical object; otherwise,
returns false.

Examples:
.........

      (eq 'a 'b) → false
      (eq 'a 'a) → true
      (eq 3 3)
     → true
     or→ false
      (eq 3 3.0) → false
      (eq 3.0 3.0)
     → true
     or→ false
      (eq #c(3 -4) #c(3 -4))
     → true
     or→ false
      (eq #c(3 -4.0) #c(3 -4)) → false
      (eq (cons 'a 'b) (cons 'a 'c)) → false
      (eq (cons 'a 'b) (cons 'a 'b)) → false
      (eq '(a . b) '(a . b))
     → true
     or→ false
      (progn (setq x (cons 'a 'b)) (eq x x)) → true
      (progn (setq x '(a . b)) (eq x x)) → true
      (eq #\A #\A)
     → true
     or→ false
      (let ((x "Foo")) (eq x x)) → true
      (eq "Foo" "Foo")
     → true
     or→ false
      (eq "Foo" (copy-seq "Foo")) → false
      (eq "FOO" "foo") → false
      (eq "string-seq" (copy-seq "string-seq")) → false
      (let ((x 5)) (eq x x))
     → true
     or→ false

See Also:
.........

*note eql (Function)::, *note equal::, *note equalp::, *note =::, *note
Section 3.2 (Compilation): Compilation.

Notes:
......

Objects that appear the same when printed are not necessarily ‘eq’ to
each other.  Symbols that print the same usually are ‘eq’ to each other
because of the use of the ‘intern’ function.  However, numbers with the
same value need not be ‘eq’, and two similar lists are usually not
identical.

An implementation is permitted to make “copies” of characters and
numbers at any time.  The effect is that Common Lisp makes no guarantee
that ‘eq’ is true even when both its arguments are “the same thing” if
that thing is a character or number.

Most Common Lisp operators use ‘eql’ rather than ‘eq’ to compare
objects, or else they default to ‘eql’ and only use ‘eq’ if specifically
requested to do so.  However, the following operators are defined to use
‘eq’ rather than ‘eql’ in a way that cannot be overridden by the code
which employs them:

catch            getf      throw
get              remf
get-properties   remprop

Figure 5.11: Operators that always prefer EQ over EQL


File: ansicl,  Node: eql (Function),  Next: equal,  Prev: eq,  Up: Data and Control Flow

eql (Function)
==============

Syntax:
.......

 -- Function: eql x y → generalized-boolean

Arguments and Values:
.....................

X—an object.

Y—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

The value of ‘eql’ is true of two objects, X and Y, in the folowing
cases:

  1. If X and Y are ‘eq’.
  2. If X and Y are both numbers of the same type and the same value.
  3. If they are both characters that represent the same character.

Otherwise the value of ‘eql’ is false.

If an implementation supports positive and negative zeros as distinct
values, then ‘(eql 0.0 -0.0)’ returns false.  Otherwise, when the syntax
‘-0.0’ is read it is interpreted as the value ‘0.0’, and so ‘(eql 0.0
-0.0)’ returns true.

Examples:
.........

      (eql 'a 'b) → false
      (eql 'a 'a) → true
      (eql 3 3) → true
      (eql 3 3.0) → false
      (eql 3.0 3.0) → true
      (eql #c(3 -4) #c(3 -4)) → true
      (eql #c(3 -4.0) #c(3 -4)) → false
      (eql (cons 'a 'b) (cons 'a 'c)) → false
      (eql (cons 'a 'b) (cons 'a 'b)) → false
      (eql '(a . b) '(a . b))
     → true
     or→ false
      (progn (setq x (cons 'a 'b)) (eql x x)) → true
      (progn (setq x '(a . b)) (eql x x)) → true
      (eql #\A #\A) → true
      (eql "Foo" "Foo")
     → true
     or→ false
      (eql "Foo" (copy-seq "Foo")) → false
      (eql "FOO" "foo") → false

Normally ‘(eql 1.0s0 1.0d0)’ is false, under the assumption that ‘1.0s0’
and ‘1.0d0’ are of distinct data types.  However, implementations that
do not provide four distinct floating-point formats are permitted to
“collapse” the four formats into some smaller number of them; in such an
implementation ‘(eql 1.0s0 1.0d0)’ might be true.

See Also:
.........

*note eq::, *note equal::, *note equalp::, *note =::, *note char=::

Notes:
......

‘eql’ is the same as ‘eq’, except that if the arguments are characters
or numbers of the same type then their values are compared.  Thus ‘eql’
tells whether two objects are conceptually the same, whereas ‘eq’ tells
whether two objects are implementationally identical.  It is for this
reason that ‘eql’, not ‘eq’, is the default comparison predicate for
operators that take sequences as arguments.

‘eql’ may not be true of two floats even when they represent the same
value.  ‘=’ is used to compare mathematical values.

Two complex numbers are considered to be ‘eql’ if their real parts are
‘eql’ and their imaginary parts are ‘eql’.  For example, ‘(eql #C(4 5)
#C(4 5))’ is true and ‘(eql #C(4 5) #C(4.0 5.0))’ is false.  Note that
while ‘(eql #C(5.0 0.0) 5.0)’ is false, ‘(eql #C(5 0) 5)’ is true.  In
the case of ‘(eql #C(5.0 0.0) 5.0)’ the two arguments are of different
types, and so cannot satisfy ‘eql’.  In the case of ‘(eql #C(5 0) 5)’,
‘#C(5 0)’ is not a complex number, but is automatically reduced to the
integer ‘5’.


File: ansicl,  Node: equal,  Next: equalp,  Prev: eql (Function),  Up: Data and Control Flow

equal (Function)
================

Syntax:
.......

 -- Function: equal x y → generalized-boolean

Arguments and Values:
.....................

X—an object.

Y—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if X and Y are structurally similar (isomorphic) objects.
Objects are treated as follows by ‘equal’.

Symbols, Numbers, and Characters

     ‘equal’ is true of two objects if they are symbols that are ‘eq’,
     if they are numbers that are ‘eql’, or if they are characters that
     are ‘eql’.

Conses

     For conses, ‘equal’ is defined recursively as the two cars being
     ‘equal’ and the two cdrs being ‘equal’.

Arrays

     Two arrays are ‘equal’ only if they are ‘eq’, with one exception:
     strings and bit vectors are compared element-by-element (using
     ‘eql’).  If either X or Y has a fill pointer, the fill pointer
     limits the number of elements examined by ‘equal’.  Uppercase and
     lowercase letters in strings are considered by ‘equal’ to be
     different.

Pathnames

     Two pathnames are ‘equal’ if and only if all the corresponding
     components (host, device, and so on) are equivalent.  Whether or
     not uppercase and lowercase letters are considered equivalent in
     strings appearing in components is implementation-dependent.
     pathnames that are ‘equal’ should be functionally equivalent.

Other (Structures, hash-tables, instances, ...)

     Two other objects are ‘equal’ only if they are ‘eq’.

‘equal’ does not descend any objects other than the ones explicitly
specified above.  The next figure summarizes the information given in
the previous list.  In addition, the figure specifies the priority of
the behavior of ‘equal’, with upper entries taking priority over lower
ones.

Type           Behavior
-------------------------------------------
number         uses ‘eql’
character      uses ‘eql’
cons           descends
bit vector     descends
string         descends
pathname       “functionally equivalent”
structure      uses ‘eq’
Other array    uses ‘eq’
hash table     uses ‘eq’
Other object   uses ‘eq’

Figure 5.12: Summary and priorities of behavior of ‘equal’

Any two objects that are ‘eql’ are also ‘equal’.

‘equal’ may fail to terminate if X or Y is circular.

Examples:
.........

      (equal 'a 'b) → false
      (equal 'a 'a) → true
      (equal 3 3) → true
      (equal 3 3.0) → false
      (equal 3.0 3.0) → true
      (equal #c(3 -4) #c(3 -4)) → true
      (equal #c(3 -4.0) #c(3 -4)) → false
      (equal (cons 'a 'b) (cons 'a 'c)) → false
      (equal (cons 'a 'b) (cons 'a 'b)) → true
      (equal #\A #\A) → true
      (equal #\A #\a) → false
      (equal "Foo" "Foo") → true
      (equal "Foo" (copy-seq "Foo")) → true
      (equal "FOO" "foo") → false
      (equal "This-string" "This-string") → true
      (equal "This-string" "this-string") → false

See Also:
.........

*note eq::, *note eql (Function)::, *note equalp::, *note =::, *note
string=::, *note string-equal::, *note char=::, *note char-equal::,
*note tree-equal::

Notes:
......

Object equality is not a concept for which there is a uniquely
determined correct algorithm.  The appropriateness of an equality
predicate can be judged only in the context of the needs of some
particular program.  Although these functions take any type of argument
and their names sound very generic, ‘equal’ and ‘equalp’ are not
appropriate for every application.

A rough rule of thumb is that two objects are ‘equal’ if and only if
their printed representations are the same.


File: ansicl,  Node: equalp,  Next: identity,  Prev: equal,  Up: Data and Control Flow

equalp (Function)
=================

Syntax:
.......

 -- Function: equalp x y → generalized-boolean

Arguments and Values:
.....................

X—an object.

Y—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if X and Y are ‘equal’, or if they have components that are
of the same type as each other and if those components are ‘equalp’;
specifically, ‘equalp’ returns true in the following cases:

Characters

     If two characters are ‘char-equal’.

Numbers

     If two numbers are the same under ‘=’.

Conses

     If the two cars in the conses are ‘equalp’ and the two cdrs in the
     conses are ‘equalp’.

Arrays

     If two arrays have the same number of dimensions, the dimensions
     match, and the corresponding active elements are ‘equalp’.  The
     types for which the arrays are specialized need not match; for
     example, a string and a general array that happens to contain the
     same characters are ‘equalp’.  Because ‘equalp’ performs
     element-by-element comparisons of strings and ignores the case of
     characters, case distinctions are ignored when ‘equalp’ compares
     strings.

Structures

     If two structures Sand the value of each slot in Sas the value of
     the corresponding slot in S

Hash Tables

     ‘equalp’ descends hash-tables by first comparing the count of
     entries and the :test function; if those are the same, it compares
     the keys of the tables using the :test function and then the values
     of the matching keys using ‘equalp’ recursively.

‘equalp’ does not descend any objects other than the ones explicitly
specified above.  The next figure summarizes the information given in
the previous list.  In addition, the figure specifies the priority of
the behavior of ‘equalp’, with upper entries taking priority over lower
ones.

Type           Behavior
----------------------------------------------
number         uses ‘=’
character      uses ‘char-equal’
cons           descends
bit vector     descends
string         descends
pathname       same as ‘equal’
structure      descends, as described above
Other array    descends
hash table     descends, as described above
Other object   uses ‘eq’

Figure 5.13: Summary and priorities of behavior of ‘equalp’

Examples:
.........

      (equalp 'a 'b) → false
      (equalp 'a 'a) → true
      (equalp 3 3) → true
      (equalp 3 3.0) → true
      (equalp 3.0 3.0) → true
      (equalp #c(3 -4) #c(3 -4)) → true
      (equalp #c(3 -4.0) #c(3 -4)) → true
      (equalp (cons 'a 'b) (cons 'a 'c)) → false
      (equalp (cons 'a 'b) (cons 'a 'b)) → true
      (equalp #\A #\A) → true
      (equalp #\A #\a) → true
      (equalp "Foo" "Foo") → true
      (equalp "Foo" (copy-seq "Foo")) → true
      (equalp "FOO" "foo") → true

      (setq array1 (make-array 6 :element-type 'integer
                                 :initial-contents '(1 1 1 3 5 7)))
     → #(1 1 1 3 5 7)
      (setq array2 (make-array 8 :element-type 'integer
                                 :initial-contents '(1 1 1 3 5 7 2 6)
                                 :fill-pointer 6))
     → #(1 1 1 3 5 7)
      (equalp array1 array2) → true
      (setq vector1 (vector 1 1 1 3 5 7)) → #(1 1 1 3 5 7)
      (equalp array1 vector1) → true

See Also:
.........

*note eq::, *note eql (Function)::, *note equal::, *note =::, *note
string=::, *note string-equal::, *note char=::, *note char-equal::

Notes:
......

Object equality is not a concept for which there is a uniquely
determined correct algorithm.  The appropriateness of an equality
predicate can be judged only in the context of the needs of some
particular program.  Although these functions take any type of argument
and their names sound very generic, ‘equal’ and ‘equalp’ are not
appropriate for every application.


File: ansicl,  Node: identity,  Next: complement,  Prev: equalp,  Up: Data and Control Flow

identity (Function)
===================

Syntax:
.......

 -- Function: identity object → object

Arguments and Values:
.....................

OBJECT—an object.

Description:
............

Returns its argument OBJECT.

Examples:
.........

      (identity 101) → 101
      (mapcan #'identity (list (list 1 2 3) '(4 5 6))) → (1 2 3 4 5 6)

Notes:
......

‘identity’ is intended for use with functions that require a function as
an argument.

‘(eql x (identity x))’ returns true for all possible values of X, but
‘(eq x (identity x))’ might return false when X is a number or
character.

‘identity’ could be defined by

     (defun identity (x) x)


File: ansicl,  Node: complement,  Next: constantly,  Prev: identity,  Up: Data and Control Flow

complement (Function)
=====================

Syntax:
.......

 -- Function: complement function → complement-function

Arguments and Values:
.....................

FUNCTION—a function.

COMPLEMENT-FUNCTION—a function.

Description:
............

Returns a function that takes the same arguments as FUNCTION, and has
the same side-effect behavior as FUNCTION, but returns only a single
value: a generalized boolean with the opposite truth value of that which
would be returned as the primary value of FUNCTION.  That is, when the
FUNCTION would have returned true as its primary value the
COMPLEMENT-FUNCTION returns false, and when the FUNCTION would have
returned false as its primary value the COMPLEMENT-FUNCTION returns
true.

Examples:
.........

      (funcall (complement #'zerop) 1) → true
      (funcall (complement #'characterp) #\A) → false
      (funcall (complement #'member) 'a '(a b c)) → false
      (funcall (complement #'member) 'd '(a b c)) → true

See Also:
.........

*note not (Function)::

Notes:
......

      (complement x) ≡ #'(lambda (&rest arguments) (not (apply x arguments)))

In Common Lisp, functions with names like “‘xxx-if-not’” are related to
functions with names like “‘” in that ’
     (xxx-if-not f . arguments) ≡ (xxx-if (complement f) . arguments)

For example,

      (find-if-not #'zerop '(0 0 3)) ≡
      (find-if (complement #'zerop) '(0 0 3)) → 3

Note that since the “‘xxx-if-not’” functions and the :test-not arguments
have been deprecated, uses of “‘xxx-if’” functions or :test arguments
with ‘complement’ are preferred.


File: ansicl,  Node: constantly,  Next: every; some; notevery; notany,  Prev: complement,  Up: Data and Control Flow

constantly (Function)
=====================

Syntax:
.......

 -- Function: constantly value → function

Arguments and Values:
.....................

VALUE—an object.

FUNCTION—a function.

Description:
............

‘constantly’ returns a function that accepts any number of arguments,
that has no side-effects, and that always returns VALUE.

Examples:
.........

      (mapcar (constantly 3) '(a b c d)) → (3 3 3 3)
      (defmacro with-vars (vars &body forms)
        `((lambda ,vars ,@forms) ,@(mapcar (constantly nil) vars)))
     → WITH-VARS
      (macroexpand '(with-vars (a b) (setq a 3 b (* a a)) (list a b)))
     → ((LAMBDA (A B) (SETQ A 3 B (* A A)) (LIST A B)) NIL NIL), true

See Also:
.........

*note identity::

Notes:
......

‘constantly’ could be defined by:

      (defun constantly (object)
        #'(lambda (&rest arguments) object))


File: ansicl,  Node: every; some; notevery; notany,  Next: and (Macro),  Prev: constantly,  Up: Data and Control Flow

every, some, notevery, notany (Function)
========================================

Syntax:
.......

 -- Function: every predicate &rest sequences+ → generalized-boolean
 -- Function: some predicate &rest sequences+ → result
 -- Function: notevery predicate &rest sequences+ → generalized-boolean
 -- Function: notany predicate &rest sequences+ → generalized-boolean

Arguments and Values:
.....................

PREDICATE—a designator for a function of as many arguments as there are
SEQUENCES.

SEQUENCE—a sequence.

RESULT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘every’, ‘some’, ‘notevery’, and ‘notany’ test elements of SEQUENCES for
satisfaction of a given PREDICATE.  The first argument to PREDICATE is
an element of the first SEQUENCE; each succeeding argument is an element
of a succeeding SEQUENCE.

PREDICATE is first applied to the elements with index ‘0’ in each of the
SEQUENCES, and possibly then to the elements with index ‘1’, and so on,
until a termination criterion is met or the end of the shortest of the
SEQUENCES is reached.

‘every’ returns false as soon as any invocation of PREDICATE returns
false.  If the end of a SEQUENCE is reached, ‘every’ returns true.
Thus, ‘every’ returns true if and only if every invocation of PREDICATE
returns true.

‘some’ returns the first non-nil value which is returned by an
invocation of PREDICATE.  If the end of a SEQUENCE is reached without
any invocation of the PREDICATE returning true, ‘some’ returns false.
Thus, ‘some’ returns true if and only if some invocation of PREDICATE
returns true.

‘notany’ returns false as soon as any invocation of PREDICATE returns
true.  If the end of a SEQUENCE is reached, ‘notany’ returns true.
Thus, ‘notany’ returns true if and only if it is not the case that any
invocation of PREDICATE returns true.

‘notevery’ returns true as soon as any invocation of PREDICATE returns
false.  If the end of a SEQUENCE is reached, ‘notevery’ returns false.
Thus, ‘notevery’ returns true if and only if it is not the case that
every invocation of PREDICATE returns true.

Examples:
.........

      (every #'characterp "abc") → true
      (some #'= '(1 2 3 4 5) '(5 4 3 2 1)) → true
      (notevery #'< '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) → false
      (notany #'> '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) → true

Exceptional Situations:
.......................

Should signal ‘type-error’ if its first argument is neither a symbol nor
a function or if any subsequent argument is not a proper sequence.

Other exceptional situations are possible, depending on the nature of
the PREDICATE.

See Also:
.........

*note and (Macro)::, *note or (Macro)::, *note Section 3.6 (Traversal
Rules and Side Effects): Traversal Rules and Side Effects.

Notes:
......

      (notany PREDICATE {sequence}*) ≡ (not (some PREDICATE {sequence}*))
      (notevery PREDICATE {sequence}*) ≡ (not (every PREDICATE {sequence}*))


File: ansicl,  Node: and (Macro),  Next: cond,  Prev: every; some; notevery; notany,  Up: Data and Control Flow

and (Macro)
===========

Syntax:
.......

 -- Macro: and {form}* → {result}*

Arguments and Values:
.....................

FORM—a form.

RESULTS—the values resulting from the evaluation of the last FORM, or
the symbols ‘nil’ or ‘t’.

Description:
............

The macro ‘and’ evaluates each FORM one at a time from left to right.
As soon as any FORM evaluates to ‘nil’, ‘and’ returns ‘nil’ without
evaluating the remaining FORMS.  If all FORMS but the last evaluate to
true values, ‘and’ returns the results produced by evaluating the last
FORM.

If no FORMS are supplied, ‘(and)’ returns ‘t’.

‘and’ passes back multiple values from the last subform but not from
subforms other than the last.

Examples:
.........

      (if (and (>= n 0)
               (< n (length a-simple-vector))
               (eq (elt a-simple-vector n) 'foo))
          (princ "Foo!"))

The above expression prints ‘Foo!’ if element ‘n’ of ‘a-simple-vector’
is the symbol ‘foo’, provided also that ‘n’ is indeed a valid index for
‘a-simple-vector’.  Because ‘and’ guarantees left-to-right testing of
its parts, ‘elt’ is not called if ‘n’ is out of range.

      (setq temp1 1 temp2 1 temp3 1) → 1
      (and (incf temp1) (incf temp2) (incf temp3)) → 2
      (and (eql 2 temp1) (eql 2 temp2) (eql 2 temp3)) → true
      (decf temp3) → 1
      (and (decf temp1) (decf temp2) (eq temp3 'nil) (decf temp3)) → NIL
      (and (eql temp1 temp2) (eql temp2 temp3)) → true
      (and) → T

See Also:
.........

*note cond::, *note every::, *note if::, *note or (Macro)::, *note
when::

Notes:
......

      (and FORM) ≡ (let () FORM)
      (and FORM1 FORM2 ...) ≡ (when FORM1 (and FORM2 ...))


File: ansicl,  Node: cond,  Next: if,  Prev: and (Macro),  Up: Data and Control Flow

cond (Macro)
============

Syntax:
.......

 -- Macro: cond {↓clause}* → {result}*

CLAUSE::=
     (test-form {form}*)

Arguments and Values:
.....................

TEST-FORM—a form.

FORMS—an implicit progn.

RESULTS—the values of the FORMS in the first CLAUSE whose TEST-FORM
yields true, or the primary value of the TEST-FORM if there are no FORMS
in that CLAUSE, or else ‘nil’ if no TEST-FORM yields true.

Description:
............

‘cond’ allows the execution of FORMS to be dependent on TEST-FORM.

TEST-FORMS are evaluated one at a time in the order in which they are
given in the argument list until a TEST-FORM is found that evaluates to
true.

If there are no forms in that clause, the primary value of the TEST-FORM
is returned by the ‘cond’ form.  Otherwise, the FORMS associated with
this TEST-FORM are evaluated in order, left to right, as an implicit
progn, and the values returned by the last FORM are returned by the
‘cond’ form.

Once one TEST-FORM has yielded true, no additional TEST-FORMS are
evaluated.  If no TEST-FORM yields true, ‘nil’ is returned.

Examples:
.........

      (defun select-options ()
        (cond ((= a 1) (setq a 2))
              ((= a 2) (setq a 3))
              ((and (= a 3) (floor a 2)))
              (t (floor a 3)))) → SELECT-OPTIONS
      (setq a 1) → 1
      (select-options) → 2
      a → 2
      (select-options) → 3
      a → 3
      (select-options) → 1
      (setq a 5) → 5
      (select-options) → 1, 2

See Also:
.........

*note if::, *note case::.


File: ansicl,  Node: if,  Next: or (Macro),  Prev: cond,  Up: Data and Control Flow

if (Special Operator)
=====================

Syntax:
.......

 -- Special Form: if TEST-FORM THEN-FORM [ELSE-FORM] → {result}*

Arguments and Values:
.....................

TEST-FORM—a form.

THEN-FORM—a form.

ELSE-FORM—a form.  The default is ‘nil’.

RESULTS—if the TEST-FORM yielded true, the values returned by the
THEN-FORM; otherwise, the values returned by the ELSE-FORM.

Description:
............

‘if’ allows the execution of a form to be dependent on a single
TEST-FORM.

First TEST-FORM is evaluated.  If the result is true, then THEN-FORM is
selected; otherwise ELSE-FORM is selected.  Whichever form is selected
is then evaluated.

Examples:
.........

      (if t 1) → 1
      (if nil 1 2) → 2
      (defun test ()
        (dolist (truth-value '(t nil 1 (a b c)))
          (if truth-value (print 'true) (print 'false))
          (prin1 truth-value))) → TEST
      (test)
     ▷ TRUE T
     ▷ FALSE NIL
     ▷ TRUE 1
     ▷ TRUE (A B C)
     → NIL

See Also:
.........

*note cond::, *note unless::, *note when::

Notes:
......

      (if TEST-FORM THEN-FORM ELSE-FORM)
      ≡ (cond (TEST-FORM THEN-FORM) (t ELSE-FORM))


File: ansicl,  Node: or (Macro),  Next: when; unless,  Prev: if,  Up: Data and Control Flow

or (Macro)
==========

Syntax:
.......

 -- Macro: or {form}* → {results}*

Arguments and Values:
.....................

FORM—a form.

RESULTS—the values or primary value (see below) resulting from the
evaluation of the last FORM executed or ‘nil’.

Description:
............

‘or’ evaluates each FORM, one at a time, from left to right.  The
evaluation of all FORMS terminates when a FORM evaluates to true (i.e.,
something other than ‘nil’).

If the evaluation of any FORM other than the last returns a primary
value that is true, ‘or’ immediately returns that value (but no
additional values) without evaluating the remaining FORMS.  If every
FORM but the last returns false as its primary value, ‘or’ returns all
values returned by the last FORM.  If no FORMS are supplied, ‘or’
returns ‘nil’.

Examples:
.........

      (or) → NIL
      (setq temp0 nil temp1 10 temp2 20 temp3 30) → 30
      (or temp0 temp1 (setq temp2 37)) → 10
      temp2 → 20
      (or (incf temp1) (incf temp2) (incf temp3)) → 11
      temp1 → 11
      temp2 → 20
      temp3 → 30
      (or (values) temp1) → 11
      (or (values temp1 temp2) temp3) → 11
      (or temp0 (values temp1 temp2)) → 11, 20
      (or (values temp0 temp1) (values temp2 temp3)) → 20, 30

See Also:
.........

*note and (Macro)::, *note some::, *note unless::


File: ansicl,  Node: when; unless,  Next: case; ccase; ecase,  Prev: or (Macro),  Up: Data and Control Flow

when, unless (Macro)
====================

Syntax:
.......

 -- Macro: when test-form {form}* → {result}*

 -- Macro: unless test-form {form}* → {result}*

Arguments and Values:
.....................

TEST-FORM—a form.

FORMS—an implicit progn.

RESULTS—the values of the forms in a ‘when’ form if the TEST-FORM yields
true or in an ‘unless’ form if the TEST-FORM yields false; otherwise
‘nil’.

Description:
............

‘when’ and ‘unless’ allow the execution of FORMS to be dependent on a
single TEST-FORM.

In a ‘when’ form, if the TEST-FORM yields true, the FORMS are evaluated
in order from left to right and the values returned by the FORMS are
returned from the ‘when’ form.  Otherwise, if the TEST-FORM yields
false, the FORMS are not evaluated, and the ‘when’ form returns ‘nil’.

In an ‘unless’ form, if the TEST-FORM yields false, the FORMS are
evaluated in order from left to right and the values returned by the
FORMS are returned from the ‘unless’ form.  Otherwise, if the TEST-FORM
yields false, the FORMS are not evaluated, and the ‘unless’ form returns
‘nil’.

Examples:
.........

      (when t 'hello) → HELLO
      (unless t 'hello) → NIL
      (when nil 'hello) → NIL
      (unless nil 'hello) → HELLO
      (when t) → NIL
      (unless nil) → NIL
      (when t (prin1 1) (prin1 2) (prin1 3))
     ▷ 123
     → 3
      (unless t (prin1 1) (prin1 2) (prin1 3)) → NIL
      (when nil (prin1 1) (prin1 2) (prin1 3)) → NIL
      (unless nil (prin1 1) (prin1 2) (prin1 3))
     ▷ 123
     → 3
      (let ((x 3))
        (list (when (oddp x) (incf x) (list x))
              (when (oddp x) (incf x) (list x))
              (unless (oddp x) (incf x) (list x))
              (unless (oddp x) (incf x) (list x))
              (if (oddp x) (incf x) (list x))
              (if (oddp x) (incf x) (list x))
              (if (not (oddp x)) (incf x) (list x))
              (if (not (oddp x)) (incf x) (list x))))
     → ((4) NIL (5) NIL 6 (6) 7 (7))

See Also:
.........

*note and (Macro)::, *note cond::, *note if::, *note or (Macro)::

Notes:
......

      (when TEST {FORM}+) ≡ (and TEST (progn {FORM}+))
      (when TEST {FORM}+) ≡ (cond (TEST {FORM}+))
      (when TEST {FORM}+) ≡ (if TEST (progn {FORM}+) nil)
      (when TEST {FORM}+) ≡ (unless (not TEST) {FORM}+)
      (unless TEST {FORM}+) ≡ (cond ((not TEST) {FORM}+))
      (unless TEST {FORM}+) ≡ (if TEST nil (progn {FORM}+))
      (unless TEST {FORM}+) ≡ (when (not TEST) {FORM}+)


File: ansicl,  Node: case; ccase; ecase,  Next: typecase; ctypecase; etypecase,  Prev: when; unless,  Up: Data and Control Flow

case, ccase, ecase (Macro)
==========================

Syntax:
.......

 -- Macro: case keyform {↓normal-clause}* [↓otherwise-clause] →
          {result}*
 -- Macro: ccase keyplace {↓normal-clause}* → {result}*
 -- Macro: ecase keyform {↓normal-clause}* → {result}*

NORMAL-CLAUSE::=
     (keys {form}*)
OTHERWISE-CLAUSE::=
     ({otherwise | t} {form}*)
CLAUSE::=
     normal-clause | otherwise-clause

Arguments and Values:
.....................

KEYFORM—a form; evaluated to produce a TEST-KEY.

KEYPLACE—a form; evaluated initially to produce a TEST-KEY.  Possibly
also used later as a place if no KEYS match.

TEST-KEY—an object produced by evaluating KEYFORM or KEYPLACE.

KEYS—a designator for a list of objects.  In the case of ‘case’, the
symbols ‘t’ and otherwise may not be used as the KEYS designator.  To
refer to these symbols by themselves as KEYS, the designators ‘(t)’ and
‘(otherwise)’, respectively, must be used instead.

FORMS—an implicit progn.

RESULTS—the values returned by the FORMS in the matching CLAUSE.

Description:
............

These macros allow the conditional execution of a body of FORMS in a
CLAUSE that is selected by matching the TEST-KEY on the basis of its
identity.

The KEYFORM or KEYPLACE is evaluated to produce the TEST-KEY.

Each of the NORMAL-CLAUSES is then considered in turn.  If the TEST-KEY
is the same as any key for that CLAUSE, the FORMS in that CLAUSE are
EVALUATED as an implicit progn, and the values it returns are returned
as the value of the ‘case’, ‘ccase’, or ‘ecase’ form.

These macros differ only in their behavior when no NORMAL-CLAUSE
matches; specifically:

‘case’

     If no NORMAL-CLAUSE matches, and there is an OTHERWISE-CLAUSE, then
     that OTHERWISE-CLAUSE automatically matches; the FORMS in that
     CLAUSE are EVALUATED as an implicit progn, and the values it
     returns are returned as the value of the ‘case’.

     If there is no OTHERWISE-CLAUSE, ‘case’ returns ‘nil’.

‘ccase’

     If no NORMAL-CLAUSE matches, a correctable error of type
     ‘type-error’ is signaled.  The offending datum is the TEST-KEY and
     the expected type is type equivalent to ‘(member KEY1 KEY2 ...)’.
     the ‘store-value’ restart can be used to correct the error.

     If the ‘store-value’ restart is invoked, its argument becomes the
     new TEST-KEY, and is stored in KEYPLACE as if by ‘(setf KEYPLACE
     TEST-KEY)’.  Then ‘ccase’ starts over, considering each CLAUSE
     anew.

     The subforms of KEYPLACE might be evaluated again if none of the
     cases holds.

‘ecase’

     If no NORMAL-CLAUSE matches, a non-correctable error of type
     ‘type-error’ is signaled.  The offending datum is the TEST-KEY and
     the expected type is type equivalent to ‘(member KEY1 KEY2 ...)’.

     Note that in contrast with ‘ccase’, the caller of ‘ecase’ may rely
     on the fact that ‘ecase’ does not return if a NORMAL-CLAUSE does
     not match.

Examples:
.........

      (dolist (k '(1 2 3 :four #\v () t 'other))
         (format t "~S "
            (case k ((1 2) 'clause1)
                    (3 'clause2)
                    (nil 'no-keys-so-never-seen)
                    ((nil) 'nilslot)
                    ((:four #\v) 'clause4)
                    ((t) 'tslot)
                    (otherwise 'others))))
     ▷ CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS
     → NIL
      (defun add-em (x) (apply #'+ (mapcar #'decode x)))
     → ADD-EM
      (defun decode (x)
        (ccase x
          ((i uno) 1)
          ((ii dos) 2)
          ((iii tres) 3)
          ((iv cuatro) 4)))
     → DECODE
      (add-em '(uno iii)) → 4
      (add-em '(uno iiii))
     ▷ Error: The value of X, IIII, is not I, UNO, II, DOS, III,
     ▷        TRES, IV, or CUATRO.
     ▷  1: Supply a value to use instead.
     ▷  2: Return to Lisp Toplevel.
     ▷ Debug> :CONTINUE 1
     ▷ Value to evaluate and use for X: 'IV
     → 5

Side Effects:
.............

The debugger might be entered.  If the ‘store-value’ restart is invoked,
the value of KEYPLACE might be changed.

Affected By:
............

‘ccase’ and ‘ecase’, since they might signal an error, are potentially
affected by existing HANDLERS and ‘*debug-io*’.

Exceptional Situations:
.......................

‘ccase’ and ‘ecase’ signal an error of type ‘type-error’ if no
NORMAL-CLAUSE matches.

See Also:
.........

*note cond::, *note typecase::, *note setf::, *note Section 5.1
(Generalized Reference): Generalized Reference.

Notes:
......

     (case TEST-KEY
       {(({key}*) {form}*)}*)
     ≡
     (let ((#1=#:g0001 TEST-KEY))
       (cond {((member #1# '({key}*)) {form}*)}*))

The specific error message used by ‘ecase’ and ‘ccase’ can vary between
implementations.  In situations where control of the specific wording of
the error message is important, it is better to use ‘case’ with an
OTHERWISE-CLAUSE that explicitly signals an error with an appropriate
message.


File: ansicl,  Node: typecase; ctypecase; etypecase,  Next: multiple-value-bind,  Prev: case; ccase; ecase,  Up: Data and Control Flow

typecase, ctypecase, etypecase (Macro)
======================================

Syntax:
.......

 -- Macro: typecase keyform {↓normal-clause}* [↓otherwise-clause] →
          {result}*
 -- Macro: ctypecase keyplace {↓normal-clause}* → {result}*
 -- Macro: etypecase keyform {↓normal-clause}* → {result}*

NORMAL-CLAUSE::=
     (type {form}*)
OTHERWISE-CLAUSE::=
     ({otherwise | t} {form}*)
CLAUSE::=
     normal-clause | otherwise-clause

Arguments and Values:
.....................

KEYFORM—a form; evaluated to produce a TEST-KEY.

KEYPLACE—a form; evaluated initially to produce a TEST-KEY.  Possibly
also used later as a place if no TYPES match.

TEST-KEY—an object produced by evaluating KEYFORM or KEYPLACE.

TYPE—a type specifier.

FORMS—an implicit progn.

RESULTS—the values returned by the FORMS in the matching CLAUSE.

Description:
............

These macros allow the conditional execution of a body of FORMS in a
CLAUSE that is selected by matching the TEST-KEY on the basis of its
type.

The KEYFORM or KEYPLACE is evaluated to produce the TEST-KEY.

Each of the NORMAL-CLAUSES is then considered in turn.  If the TEST-KEY
is of the type given by the CLAUSES’s TYPE, the FORMS in that CLAUSE are
EVALUATED as an implicit progn, and the values it returns are returned
as the value of the ‘typecase’, ‘ctypecase’, or ‘etypecase’ form.

These macros differ only in their behavior when no NORMAL-CLAUSE
matches; specifically:

‘typecase’

     If no NORMAL-CLAUSE matches, and there is an OTHERWISE-CLAUSE, then
     that OTHERWISE-CLAUSE automatically matches; the FORMS in that
     CLAUSE are EVALUATED as an implicit progn, and the values it
     returns are returned as the value of the ‘typecase’.

     If there is no OTHERWISE-CLAUSE, ‘typecase’ returns ‘nil’.

‘ctypecase’

     If no NORMAL-CLAUSE matches, a correctable error of type
     ‘type-error’ is signaled.  The offending datum is the TEST-KEY and
     the expected type is type equivalent to ‘(or TYPE1 TYPE2 ...)’.
     the ‘store-value’ restart can be used to correct the error.

     If the ‘store-value’ restart is invoked, its argument becomes the
     new TEST-KEY, and is stored in KEYPLACE as if by ‘(setf KEYPLACE
     TEST-KEY)’.  Then ‘ctypecase’ starts over, considering each CLAUSE
     anew.

     If the ‘store-value’ restart is invoked interactively, the user is
     prompted for a new TEST-KEY to use.

     The subforms of KEYPLACE might be evaluated again if none of the
     cases holds.

‘etypecase’

     If no NORMAL-CLAUSE matches, a non-correctable error of type
     ‘type-error’ is signaled.  The offending datum is the TEST-KEY and
     the expected type is type equivalent to ‘(or TYPE1 TYPE2 ...)’.

     Note that in contrast with ‘ctypecase’, the caller of ‘etypecase’
     may rely on the fact that ‘etypecase’ does not return if a
     NORMAL-CLAUSE does not match.

In all three cases, is permissible for more than one CLAUSE to specify a
matching type, particularly if one is a subtype of another; the earliest
applicable CLAUSE is chosen.

Examples:
.........

     ;;; (Note that the parts of this example which use TYPE-OF
     ;;;  are implementation-dependent.)
      (defun what-is-it (x)
        (format t "~&~S is ~A.~%"
                x (typecase x
                    (float "a float")
                    (null "a symbol, boolean false, or the empty list")
                    (list "a list")
                    (t (format nil "a(n) ~(~A~)" (type-of x))))))
     → WHAT-IS-IT
      (map 'nil #'what-is-it '(nil (a b) 7.0 7 box))
     ▷ NIL is a symbol, boolean false, or the empty list.
     ▷ (A B) is a list.
     ▷ 7.0 is a float.
     ▷ 7 is a(n) integer.
     ▷ BOX is a(n) symbol.
     → NIL
      (setq x 1/3)
     → 1/3
      (ctypecase x
          (integer (* x 4))
          (symbol  (symbol-value x)))
     ▷ Error: The value of X, 1/3, is neither an integer nor a symbol.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Specify a value to use instead.
     ▷  2: Return to Lisp Toplevel.
     ▷ Debug> :CONTINUE 1
     ▷ Use value: 3.7
     ▷ Error: The value of X, 3.7, is neither an integer nor a symbol.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Specify a value to use instead.
     ▷  2: Return to Lisp Toplevel.
     ▷ Debug> :CONTINUE 1
     ▷ Use value: 12
     → 48
      x → 12

Affected By:
............

‘ctypecase’ and ‘etypecase’, since they might signal an error, are
potentially affected by existing HANDLERS and ‘*debug-io*’.

Exceptional Situations:
.......................

‘ctypecase’ and ‘etypecase’ signal an error of type ‘type-error’ if no
NORMAL-CLAUSE matches.

The compiler may choose to issue a warning of type ‘style-warning’ if a
CLAUSE will never be selected because it is completely shadowed by
earlier clauses.

See Also:
.........

*note case::, *note cond::, *note setf::, *note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

     (typecase TEST-KEY
       {(TYPE {form}*)}*)
     ≡
     (let ((#1=#:g0001 TEST-KEY))
       (cond {((typep #1# 'TYPE) {form}*)}*))

The specific error message used by ‘etypecase’ and ‘ctypecase’ can vary
between implementations.  In situations where control of the specific
wording of the error message is important, it is better to use
‘typecase’ with an OTHERWISE-CLAUSE that explicitly signals an error
with an appropriate message.


File: ansicl,  Node: multiple-value-bind,  Next: multiple-value-call,  Prev: typecase; ctypecase; etypecase,  Up: Data and Control Flow

multiple-value-bind (Macro)
===========================

Syntax:
.......

 -- Macro: multiple-value-bind ({var}*) VALUES-FORM {declaration}*
          {form}* → {result}*

Arguments and Values:
.....................

VAR—a symbol naming a variable; not evaluated.

VALUES-FORM—a form; evaluated.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—the values returned by the FORMS.

Description:
............

Creates new variable bindings for the VARS and executes a series of
FORMS that use these bindings.

The variable bindings created are lexical unless ‘special’ declarations
are specified.

VALUES-FORM is evaluated, and each of the VARS is bound to the
respective value returned by that form.  If there are more VARS than
values returned, extra values of ‘nil’ are given to the remaining VARS.
If there are more values than VARS, the excess values are discarded.
The VARS are bound to the values over the execution of the FORMS, which
make up an implicit ‘progn’.  The consequences are unspecified if a type
DECLARATION is specified for a VAR, but the value to which that VAR is
bound is not consistent with the type DECLARATION.

The scopes of the name binding and DECLARATIONS do not include the
VALUES-FORM.

Examples:
.........

      (multiple-value-bind (f r)
          (floor 130 11)
        (list f r)) → (11 9)

See Also:
.........

*note let::, *note multiple-value-call::

Notes:
......

      (multiple-value-bind ({var}*) VALUES-FORM {form}*)
      ≡ (multiple-value-call #'(lambda (&optional {var}* &rest #1=#:ignore)
                                  (declare (ignore #1#))
                                  {form}*)
                              VALUES-FORM)


File: ansicl,  Node: multiple-value-call,  Next: multiple-value-list,  Prev: multiple-value-bind,  Up: Data and Control Flow

multiple-value-call (Special Operator)
======================================

Syntax:
.......

 -- Special Form: multiple-value-call FUNCTION-FORM FORM* → {result}*

Arguments and Values:
.....................

FUNCTION-FORM—a form; evaluated to produce FUNCTION.

FUNCTION—a function designator resulting from the evaluation of
FUNCTION-FORM.

FORM—a form.

RESULTS—the values returned by the FUNCTION.

Description:
............

Applies FUNCTION to a list of the objects collected from groups of
multiple values

‘multiple-value-call’ first evaluates the FUNCTION-FORM to obtain
FUNCTION, and then evaluates each FORM.  All the values of each FORM are
gathered together (not just one value from each) and given as arguments
to the FUNCTION.

Examples:
.........

      (multiple-value-call #'list 1 '/ (values 2 3) '/ (values) '/ (floor 2.5))
     → (1 / 2 3 / / 2 0.5)
      (+ (floor 5 3) (floor 19 4)) ≡ (+ 1 4)
     → 5
      (multiple-value-call #'+ (floor 5 3) (floor 19 4)) ≡ (+ 1 2 4 3)
     → 10

See Also:
.........

*note multiple-value-list::, *note multiple-value-bind::


File: ansicl,  Node: multiple-value-list,  Next: multiple-value-prog1,  Prev: multiple-value-call,  Up: Data and Control Flow

multiple-value-list (Macro)
===========================

Syntax:
.......

 -- Macro: multiple-value-list form → list

Arguments and Values:
.....................

FORM—a form; evaluated as described below.

LIST—a list of the values returned by FORM.

Description:
............

‘multiple-value-list’ evaluates FORM and creates a list of the multiple
values

Examples:
.........

      (multiple-value-list (floor -3 4)) → (-1 1)

See Also:
.........

*note values-list::, *note multiple-value-call::

Notes:
......

‘multiple-value-list’ and ‘values-list’ are inverses of each other.

      (multiple-value-list form) ≡ (multiple-value-call #'list form)


File: ansicl,  Node: multiple-value-prog1,  Next: multiple-value-setq,  Prev: multiple-value-list,  Up: Data and Control Flow

multiple-value-prog1 (Special Operator)
=======================================

Syntax:
.......

 -- Special Form: multiple-value-prog1 first-form {form}* →
          first-form-results

Arguments and Values:
.....................

FIRST-FORM—a form; evaluated as described below.

FORM—a form; evaluated as described below.

FIRST-FORM-RESULTS—the values resulting from the evaluation of
FIRST-FORM.

Description:
............

‘multiple-value-prog1’ evaluates FIRST-FORM and saves all the values
produced by that form.  It then evaluates each FORM from left to right,
discarding their values.

Examples:
.........

      (setq temp '(1 2 3)) → (1 2 3)
      (multiple-value-prog1
         (values-list temp)
         (setq temp nil)
         (values-list temp)) → 1, 2, 3

See Also:
.........

*note prog1::


File: ansicl,  Node: multiple-value-setq,  Next: values (Accessor),  Prev: multiple-value-prog1,  Up: Data and Control Flow

multiple-value-setq (Macro)
===========================

Syntax:
.......

 -- Macro: multiple-value-setq vars form → result

Arguments and Values:
.....................

VARS—a list of symbols that are either variable names or names of symbol
macros.

FORM—a form.

RESULT—The primary value returned by the FORM.

Description:
............

‘multiple-value-setq’ assigns values to VARS.

The FORM is evaluated, and each VAR is assigned to the corresponding
value returned by that form.  If there are more VARS than values
returned, ‘nil’ is assigned to the extra VARS.  If there are more values
than VARS, the extra values are discarded.

If any VAR is the name of a symbol macro, then it is assigned as if by
‘setf’.  Specifically,

      (multiple-value-setq (symbol

is defined to always behave in the same way as

      (values (setf (values symbol

in order that the rules for order of evaluation and side-effects be
consistent with those used by ‘setf’.  See *note Section 5.1.2.3 (VALUES
Forms as Places): SETFofVALUES.

Examples:
.........

      (multiple-value-setq (quotient remainder) (truncate 3.2 2)) → 1
      quotient → 1
      remainder → 1.2
      (multiple-value-setq (a b c) (values 1 2)) → 1
      a → 1
      b → 2
      c → NIL
      (multiple-value-setq (a b) (values 4 5 6)) → 4
      a → 4
      b → 5

See Also:
.........

*note setq::, *note symbol-macrolet::


File: ansicl,  Node: values (Accessor),  Next: values-list,  Prev: multiple-value-setq,  Up: Data and Control Flow

values (Accessor)
=================

Syntax:
.......

 -- Function: values &rest object → {object}*
(setf (values &rest place) new-values)

Arguments and Values:
.....................

OBJECT—an object.

PLACE—a place.

NEW-VALUE—an object.

Description:
............

‘values’ returns the OBJECTS as multiple values

‘setf’ of ‘values’ is used to store the multiple valuesSee *note Section
5.1.2.3 (VALUES Forms as Places): SETFofVALUES.

Examples:
.........

      (values) → <no values>
      (values 1) → 1
      (values 1 2) → 1, 2
      (values 1 2 3) → 1, 2, 3
      (values (values 1 2 3) 4 5) → 1, 4, 5
      (defun polar (x y)
        (values (sqrt (+ (* x x) (* y y))) (atan y x))) → POLAR
      (multiple-value-bind (r theta) (polar 3.0 4.0)
        (vector r theta))
     → #(5.0 0.927295)

Sometimes it is desirable to indicate explicitly that a function returns
exactly one value.  For example, the function

      (defun foo (x y)
        (floor (+ x y) y)) → FOO

returns two values because ‘floor’ returns two values.  It may be that
the second value makes no sense, or that for efficiency reasons it is
desired not to compute the second value.  ‘values’ is the standard idiom
for indicating that only one value is to be returned:

      (defun foo (x y)
        (values (floor (+ x y) y))) → FOO

This works because ‘values’ returns exactly one value for each of ARGS;
as for any function call, if any of ARGS produces more than one value,
all but the first are discarded.

See Also:
.........

*note values-list::, *note multiple-value-bind::, *note
multiple-values-limit::, *note Section 3.1 (Evaluation): Evaluation.

Notes:
......

Since ‘values’ is a function, not a macro or special form, it receives
as arguments only the primary values of its argument forms.


File: ansicl,  Node: values-list,  Next: multiple-values-limit,  Prev: values (Accessor),  Up: Data and Control Flow

values-list (Function)
======================

Syntax:
.......

 -- Function: values-list list → {element}*

Arguments and Values:
.....................

LIST—a list.

ELEMENTS—the elements of the LIST.

Description:
............

Returns the elements of the LIST as multiple values

Examples:
.........

      (values-list nil) → <no values>
      (values-list '(1)) → 1
      (values-list '(1 2)) → 1, 2
      (values-list '(1 2 3)) → 1, 2, 3

Exceptional Situations:
.......................

Should signal ‘type-error’ if its argument is not a proper list.

See Also:
.........

*note multiple-value-bind::, *note multiple-value-list::, *note
multiple-values-limit::, *note values (Accessor)::

Notes:
......

      (values-list LIST) ≡ (apply #'values LIST)

‘(equal X (multiple-value-list (values-list X)))’ returns true for all
lists X.


File: ansicl,  Node: multiple-values-limit,  Next: nth-value,  Prev: values-list,  Up: Data and Control Flow

multiple-values-limit (Constant Variable)
=========================================

Constant Value:
...............

An integer not smaller than ‘20’, the exact magnitude of which is
implementation-dependent.

Description:
............

The upper exclusive bound on the number of values that may be returned
from a function, bound or assigned by ‘multiple-value-bind’ or
‘multiple-value-setq’, or passed as a first argument to ‘nth-value’.
(If these individual limits might differ, the minimum value is used.)

See Also:
.........

*note lambda-parameters-limit::, *note call-arguments-limit::

Notes:
......

Implementors are encouraged to make this limit as large as possible.


File: ansicl,  Node: nth-value,  Next: prog; prog*,  Prev: multiple-values-limit,  Up: Data and Control Flow

nth-value (Macro)
=================

Syntax:
.......

 -- Macro: nth-value n form → object

Arguments and Values:
.....................

N—a non-negative integer; evaluated.

FORM—a form; evaluated as described below.

OBJECT—an object.

Description:
............

Evaluates N and then FORM, returning as its only value the Nth value
yielded by FORM, or ‘nil’ if N is greater than or equal to the number of
values returned by FORM.  (The first returned value is numbered ‘0’.)

Examples:
.........

      (nth-value 0 (values 'a 'b)) → A
      (nth-value 1 (values 'a 'b)) → B
      (nth-value 2 (values 'a 'b)) → NIL
      (let* ((x 83927472397238947423879243432432432)
             (y 32423489732)
             (a (nth-value 1 (floor x y)))
             (b (mod x y)))
        (values a b (= a b)))
     → 3332987528, 3332987528, true

See Also:
.........

*note multiple-value-list::, *note nth::

Notes:
......

Operationally, the following relationship is true, although ‘nth-value’
might be more efficient in some implementations because, for example,
some consing might be avoided.

      (nth-value N FORM) ≡ (nth N (multiple-value-list FORM))


File: ansicl,  Node: prog; prog*,  Next: prog1; prog2,  Prev: nth-value,  Up: Data and Control Flow

prog, prog* (Macro)
===================

Syntax:
.......

 -- Macro: prog ({VAR | (VAR [INIT-FORM])}*) {declaration}* {TAG |
          STATEMENT}* → {result}*

 -- Macro: prog* ({VAR | (VAR [INIT-FORM])}*) {declaration}* {TAG |
          STATEMENT}* → {result}*

Arguments and Values:
.....................

VAR—variable name.

INIT-FORM—a form.

DECLARATION—a declare expression; not evaluated.

TAG—a go tag; not evaluated.

STATEMENT—a compound form; evaluated as described below.

RESULTS—‘nil’ if a normal return occurs, or else, if an explicit return
occurs, the values that were transferred.

Description:
............

Three distinct operations are performed by ‘prog’ and ‘prog*’: they bind
local variables, they permit use of the ‘return’ statement, and they
permit use of the ‘go’ statement.  A typical ‘prog’ looks like this:

      (prog (var1 var2 (var3 init-form-3) var4 (var5 init-form-5))
            {declaration}*
            statement1
       tag1
            statement2
            statement3
            statement4
       tag2
            statement5
            ...
            )

For ‘prog’, INIT-FORMS are evaluated first, in the order in which they
are supplied.  The VARS are then bound to the corresponding values in
parallel.  If no INIT-FORM is supplied for a given VAR, that VAR is
bound to ‘nil’.

The body of ‘prog’ is executed as if it were a ‘tagbody’ form; the ‘go’
statement can be used to transfer control to a TAG.  TAGS label
STATEMENTS.

‘prog’ implicitly establishes a ‘block’ named ‘nil’ around the entire
‘prog’ form, so that ‘return’ can be used at any time to exit from the
‘prog’ form.

The difference between ‘prog*’ and ‘prog’ is that in ‘prog*’ the binding
and initialization of the VARS is done sequentially, so that the
INIT-FORM for each one can use the values of previous ones.

Examples:
.........

     (prog* ((y z) (x (car y)))
            (return x))

returns the car of the value of ‘z’.

      (setq a 1) → 1
      (prog ((a 2) (b a)) (return (if (= a b) '= '/=))) → /=
      (prog* ((a 2) (b a)) (return (if (= a b) '= '/=))) → =
      (prog () 'no-return-value) → NIL

      (defun king-of-confusion (w)
        "Take a cons of two lists and make a list of conses.
         Think of this function as being like a zipper."
        (prog (x y z)          ;Initialize x, y, z to NIL
             (setq y (car w) z (cdr w))
         loop
             (cond ((null y) (return x))
                   ((null z) (go err)))
         rejoin
             (setq x (cons (cons (car y) (car z)) x))
             (setq y (cdr y) z (cdr z))
             (go loop)
         err
             (cerror "Will self-pair extraneous items"
                     "Mismatch - gleep!  ~S" y)
             (setq z y)
             (go rejoin))) → KING-OF-CONFUSION

This can be accomplished more perspicuously as follows:

      (defun prince-of-clarity (w)
        "Take a cons of two lists and make a list of conses.
         Think of this function as being like a zipper."
        (do ((y (car w) (cdr y))
             (z (cdr w) (cdr z))
             (x '() (cons (cons (car y) (car z)) x)))
            ((null y) x)
          (when (null z)
            (cerror "Will self-pair extraneous items"
                   "Mismatch - gleep!  ~S" y)
            (setq z y)))) → PRINCE-OF-CLARITY

See Also:
.........

*note block::, *note let::, *note tagbody::, *note go::, *note return::,
*note Section 3.1 (Evaluation): Evaluation.

Notes:
......

‘prog’ can be explained in terms of ‘block’, ‘let’, and ‘tagbody’ as
follows:

      (prog VARIABLE-LIST DECLARATION . BODY)
         ≡ (block nil (let VARIABLE-LIST DECLARATION (tagbody . BODY)))


File: ansicl,  Node: prog1; prog2,  Next: progn,  Prev: prog; prog*,  Up: Data and Control Flow

prog1, prog2 (Macro)
====================

Syntax:
.......

 -- Macro: prog1 first-form {form}* → result-1
 -- Macro: prog2 first-form second-form {form}* → result-2

Arguments and Values:
.....................

FIRST-FORM—a form; evaluated as described below.

SECOND-FORM—a form; evaluated as described below.

FORMS—an implicit progn; evaluated as described below.

RESULT-1—the primary value resulting from the evaluation of FIRST-FORM.

RESULT-2—the primary value resulting from the evaluation of SECOND-FORM.

Description:
............

‘prog1’ evaluates FIRST-FORM and then FORMS, yielding as its only value
the primary value yielded by FIRST-FORM.

‘prog2’ evaluates FIRST-FORM, then SECOND-FORM, and then FORMS, yielding
as its only value the primary value yielded by FIRST-FORM.

Examples:
.........

      (setq temp 1) → 1
      (prog1 temp (print temp) (incf temp) (print temp))
     ▷ 1
     ▷ 2
     → 1
      (prog1 temp (setq temp nil)) → 2
      temp → NIL
      (prog1 (values 1 2 3) 4) → 1
      (setq temp (list 'a 'b 'c))
      (prog1 (car temp) (setf (car temp) 'alpha)) → A
      temp → (ALPHA B C)
      (flet ((swap-symbol-values (x y)
               (setf (symbol-value x)
                     (prog1 (symbol-value y)
                            (setf (symbol-value y) (symbol-value x))))))
        (let ((*foo* 1) (*bar* 2))
          (declare (special *foo* *bar*))
          (swap-symbol-values '*foo* '*bar*)
          (values *foo* *bar*)))
     → 2, 1
      (setq temp 1) → 1
      (prog2 (incf temp) (incf temp) (incf temp)) → 3
      temp → 4
      (prog2 1 (values 2 3 4) 5) → 2

See Also:
.........

*note multiple-value-prog1::, *note progn::

Notes:
......

‘prog1’ and ‘prog2’ are typically used to evaluate one or more forms
with side effects and return a value that must be computed before some
or all of the side effects happen.

      (prog1 {form}*) ≡ (values (multiple-value-prog1 {form}*))
      (prog2 FORM1 {form}*) ≡ (let () FORM1 (prog1 {form}*))


File: ansicl,  Node: progn,  Next: define-modify-macro,  Prev: prog1; prog2,  Up: Data and Control Flow

progn (Special Operator)
========================

Syntax:
.......

 -- Special Form: progn {form}* → {result}*

Arguments and Values:
.....................

FORMS—an implicit progn.

RESULTS—the values of the forms.

Description:
............

‘progn’ evaluates FORMS, in the order in which they are given.

The values of each FORM but the last are discarded.

If ‘progn’ appears as a top level form, then all forms within that
‘progn’ are considered by the compiler to be top level forms.

Examples:
.........

      (progn) → NIL
      (progn 1 2 3) → 3
      (progn (values 1 2 3)) → 1, 2, 3
      (setq a 1) → 1
      (if a
           (progn (setq a nil) 'here)
           (progn (setq a t) 'there)) → HERE
      a → NIL

See Also:
.........

*note prog1::, *note prog2::, *note Section 3.1 (Evaluation):
Evaluation.

Notes:
......

Many places in Common Lisp involve syntax that uses implicit progns.
That is, part of their syntax allows many forms to be written that are
to be evaluated sequentially, discarding the results of all forms but
the last and returning the results of the last form.  Such places
include, but are not limited to, the following: the body of a lambda
expression; the bodies of various control and conditional forms (e.g.,
‘case’, ‘catch’, ‘progn’, and ‘when’).


File: ansicl,  Node: define-modify-macro,  Next: defsetf,  Prev: progn,  Up: Data and Control Flow

define-modify-macro (Macro)
===========================

Syntax:
.......

 -- Macro: define-modify-macro name lambda-list function [documentation]
          → name

Arguments and Values:
.....................

NAME—a symbol.

LAMBDA-LIST—a define-modify-macro lambda list

FUNCTION—a symbol.

DOCUMENTATION—a string; not evaluated.

Description:
............

‘define-modify-macro’ defines a macro named NAME to read and write a
place.

The arguments to the new macro are a place, followed by the arguments
that are supplied in LAMBDA-LIST.  Macros defined with
‘define-modify-macro’ correctly pass the environment parameter to
‘get-setf-expansion’.

When the macro is invoked, FUNCTION is applied to the old contents of
the place and the LAMBDA-LIST arguments to obtain the new value, and the
place is updated to contain the result.

Except for the issue of avoiding multiple evaluation (see below), the
expansion of a ‘define-modify-macro’ is equivalent to the following:

      (defmacro NAME (reference . LAMBDA-LIST)
        DOCUMENTATION
        `(setf ,reference
               (FUNCTION ,reference ,arg1 ,arg2 ...)))

where arg1, arg2, ..., are the parameters appearing in LAMBDA-LIST;
appropriate provision is made for a rest parameter.

The subforms of the macro calls defined by ‘define-modify-macro’ are
evaluated as specified in *note Section 5.1.1.1 (Evaluation of Subforms
to Places): GenRefSubFormEval.

DOCUMENTATION is attached as a documentation string to NAME (as kind
‘function’) and to the macro function.

If a ‘define-modify-macro’ form appears as a top level form, the
compiler must store the macro definition at compile time, so that
occurrences of the macro later on in the file can be expanded correctly.

Examples:
.........

      (define-modify-macro appendf (&rest args)
         append "Append onto list") → APPENDF
      (setq x '(a b c) y x) → (A B C)
      (appendf x '(d e f) '(1 2 3)) → (A B C D E F 1 2 3)
      x → (A B C D E F 1 2 3)
      y → (A B C)
      (define-modify-macro new-incf (&optional (delta 1)) +)
      (define-modify-macro unionf (other-set &rest keywords) union)

Side Effects:
.............

A macro definition is assigned to NAME.

See Also:
.........

*note defsetf::, *note define-setf-expander::, *note documentation::,
*note Section 3.4.11 (Syntactic Interaction of Documentation Strings and
Declarations): Syntactic Interaction of Documentation Strings and
Declarations.


File: ansicl,  Node: defsetf,  Next: define-setf-expander,  Prev: define-modify-macro,  Up: Data and Control Flow

defsetf (Macro)
===============

Syntax:
.......

The “short form”:

 -- Macro: defsetf access-fn update-fn [documentation] → access-fn

The “long form”:

 -- Macro: defsetf access-fn lambda-list ({store-variable}*) 〚
          {declaration}* | documentation〛 {form}* → access-fn

Arguments and Values:
.....................

ACCESS-FN—a symbol which names a function or a macro.

UPDATE-FN—a symbol naming a function or macro.

LAMBDA-LIST—a defsetf lambda list.

STORE-VARIABLE—a symbol (a variable name).

DECLARATION—a declare expression; not evaluated.

DOCUMENTATION—a string; not evaluated.

FORM—a form.

Description:
............

‘defsetf’ defines how to ‘setf’ a place of the form ‘(access-fn ...)’
for relatively simple cases.  (See ‘define-setf-expander’ for more
general access to this facility.)  It must be the case that the function
or macro named by ACCESS-FN evaluates all of its arguments.

‘defsetf’ may take one of two forms, called the “short form” and the
“long form,” which are distinguished by the type of the second argument.

When the short form is used, UPDATE-FN must name a function (or macro)
that takes one more argument than ACCESS-FN takes.  When ‘setf’ is given
a place that is a call on ACCESS-FN, it expands into a call on UPDATE-FN
that is given all the arguments to ACCESS-FN and also, as its last
argument, the new value (which must be returned by UPDATE-FN as its
value).

The long form ‘defsetf’ resembles ‘defmacro’.  The LAMBDA-LIST describes
the arguments of ACCESS-FN.  The STORE-VARIABLES describe the value or
values to be stored into the place.  The BODY must compute the expansion
of a ‘setf’ of a call on ACCESS-FN.  The expansion function is defined
in the same lexical environment in which the ‘defsetf’ form appears.

During the evaluation of the FORMS, the variables in the LAMBDA-LIST and
the STORE-VARIABLES are bound to names of temporary variables, generated
as if by ‘gensym’ or ‘gentemp’, that will be bound by the expansion of
‘setf’ to the values of those subforms.  This binding permits the FORMS
to be written without regard for order-of-evaluation issues.  ‘defsetf’
arranges for the temporary variables to be optimized out of the final
result in cases where that is possible.

The body code in ‘defsetf’ is implicitly enclosed in a block whose name
is ACCESS-FN

‘defsetf’ ensures that subforms of the place are evaluated exactly once.

DOCUMENTATION is attached to ACCESS-FN as a documentation string of kind
setf.

If a ‘defsetf’ form appears as a top level form, the compiler must make
the setf expander available so that it may be used to expand calls to
‘setf’ later on in the file.  Users must ensure that the FORMS, if any,
can be evaluated at compile time if the ACCESS-FN is used in a place
later in the same file.  The compiler must make these setf expanders
available to compile-time calls to ‘get-setf-expansion’ when its
ENVIRONMENT argument is a value received as the environment parameter of
a macro.

Examples:
.........

The effect of

      (defsetf symbol-value set)

is built into the Common Lisp system.  This causes the form ‘(setf
(symbol-value foo) fu)’ to expand into ‘(set foo fu)’.

Note that

      (defsetf car rplaca)

would be incorrect because ‘rplaca’ does not return its last argument.

      (defun middleguy (x) (nth (truncate (1- (list-length x)) 2) x)) → MIDDLEGUY
      (defun set-middleguy (x v)
         (unless (null x)
           (rplaca (nthcdr (truncate (1- (list-length x)) 2) x) v))
         v) → SET-MIDDLEGUY
      (defsetf middleguy set-middleguy) → MIDDLEGUY
      (setq a (list 'a 'b 'c 'd)
            b (list 'x)
            c (list 1 2 3 (list 4 5 6) 7 8 9)) → (1 2 3 (4 5 6) 7 8 9)
      (setf (middleguy a) 3) → 3
      (setf (middleguy b) 7) → 7
      (setf (middleguy (middleguy c)) 'middleguy-symbol) → MIDDLEGUY-SYMBOL
      a → (A 3 C D)
      b → (7)
      c → (1 2 3 (4 MIDDLEGUY-SYMBOL 6) 7 8 9)

An example of the use of the long form of ‘defsetf’:

      (defsetf subseq (sequence start &optional end) (new-sequence)
        `(progn (replace ,sequence ,new-sequence
                         :start1 ,start :end1 ,end)
                ,new-sequence)) → SUBSEQ

      (defvar *xy* (make-array '(10 10)))
      (defun xy (&key ((x x) 0) ((y y) 0)) (aref *xy* x y)) → XY
      (defun set-xy (new-value &key ((x x) 0) ((y y) 0))
        (setf (aref *xy* x y) new-value)) → SET-XY
      (defsetf xy (&key ((x x) 0) ((y y) 0)) (store)
        `(set-xy ,store 'x ,x 'y ,y)) → XY
      (get-setf-expansion '(xy a b))
     → (#:t0 #:t1),
        (a b),
        (#:store),
        ((lambda (&key ((x #:x)) ((y #:y)))
           (set-xy #:store 'x #:x 'y #:y))
         #:t0 #:t1),
        (xy #:t0 #:t1)
      (xy 'x 1) → NIL
      (setf (xy 'x 1) 1) → 1
      (xy 'x 1) → 1
      (let ((a 'x) (b 'y))
        (setf (xy a 1 b 2) 3)
        (setf (xy b 5 a 9) 14))
     → 14
      (xy 'y 0 'x 1) → 1
      (xy 'x 1 'y 2) → 3

See Also:
.........

*note documentation::, *note setf::, *note define-setf-expander::, *note
get-setf-expansion::, *note Section 5.1 (Generalized Reference):
Generalized Reference, *note Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations): Syntactic Interaction of
Documentation Strings and Declarations.

Notes:
......

FORMS must include provision for returning the correct value (the value
or values of STORE-VARIABLE).  This is handled by FORMS rather than by
‘defsetf’ because in many cases this value can be returned at no extra
cost, by calling a function that simultaneously stores into the place
and returns the correct value.

A ‘setf’ of a call on ACCESS-FN also evaluates all of ACCESS-FN’s
arguments; it cannot treat any of them specially.  This means that
‘defsetf’ cannot be used to describe how to store into a generalized
reference to a byte, such as ‘(ldb field reference)’.
‘define-setf-expander’ is used to handle situations that do not fit the
restrictions imposed by ‘defsetf’ and gives the user additional control.


File: ansicl,  Node: define-setf-expander,  Next: get-setf-expansion,  Prev: defsetf,  Up: Data and Control Flow

define-setf-expander (Macro)
============================

Syntax:
.......

 -- Macro: define-setf-expander access-fn lambda-list
          〚{declaration}* | documentation〛 {form}* → access-fn

Arguments and Values:
.....................

ACCESS-FN—a symbol that names a function or macro.

LAMBDA-LIST—macro lambda list.

DECLARATION—a declare expression; not evaluated.

DOCUMENTATION—a string; not evaluated.

FORMS—an implicit progn.

Description:
............

‘define-setf-expander’ specifies the means by which ‘setf’ updates a
place that is referenced by ACCESS-FN.

When ‘setf’ is given a place that is specified in terms of ACCESS-FN and
a new value for the place, it is expanded into a form that performs the
appropriate update.

The LAMBDA-LIST supports destructuring.  See *note Section 3.4.4 (Macro
Lambda Lists): Macro Lambda Lists.

DOCUMENTATION is attached to ACCESS-FN as a documentation string of kind
setf.

FORMS constitute the body of the setf expander definition and must
compute the setf expansion for a call on ‘setf’ that references the
place by means of the given ACCESS-FN.  The setf expander function is
defined in the same lexical environment in which the
‘define-setf-expander’ form appears.  While FORMS are being executed,
the variables in LAMBDA-LIST are bound to parts of the place form.  The
body FORMS (but not the LAMBDA-LIST) in a ‘define-setf-expander’ form
are implicitly enclosed in a block whose name is ACCESS-FN.

The evaluation of FORMS must result in the five values described in
*note Section 5.1.1.2 (Setf Expansions): SetfExpansions.

If a ‘define-setf-expander’ form appears as a top level form, the
compiler must make the setf expander available so that it may be used to
expand calls to ‘setf’ later on in the file.  Programmers must ensure
that the FORMS can be evaluated at compile time if the ACCESS-FN is used
in a place later in the same file.  The compiler must make these setf
expanders available to compile-time calls to ‘get-setf-expansion’ when
its ENVIRONMENT argument is a value received as the environment
parameter of a macro.

Examples:
.........

      (defun lastguy (x) (car (last x))) → LASTGUY
      (define-setf-expander lastguy (x &environment env)
        "Set the last element in a list to the given value."
        (multiple-value-bind (dummies vals newval setter getter)
            (get-setf-expansion x env)
          (let ((store (gensym)))
            (values dummies
                    vals
                    `(,store)
                    `(progn (rplaca (last ,getter) ,store) ,store)
                    `(lastguy ,getter))))) → LASTGUY
      (setq a (list 'a 'b 'c 'd)
            b (list 'x)
            c (list 1 2 3 (list 4 5 6))) → (1 2 3 (4 5 6))
      (setf (lastguy a) 3) → 3
      (setf (lastguy b) 7) → 7
      (setf (lastguy (lastguy c)) 'lastguy-symbol) → LASTGUY-SYMBOL
      a → (A B C 3)
      b → (7)
      c → (1 2 3 (4 5 LASTGUY-SYMBOL))

     ;;; Setf expander for the form (LDB bytespec int).
     ;;; Recall that the int form must itself be suitable for SETF.
      (define-setf-expander ldb (bytespec int &environment env)
        (multiple-value-bind (temps vals stores
                               store-form access-form)
            (get-setf-expansion int env);Get setf expansion for int.
          (let ((btemp (gensym))     ;Temp var for byte specifier.
                (store (gensym))     ;Temp var for byte to store.
                (stemp (first stores))) ;Temp var for int to store.
            (if (cdr stores) (error "Can't expand this."))
     ;;; Return the setf expansion for LDB as five values.
            (values (cons btemp temps)       ;Temporary variables.
                    (cons bytespec vals)     ;Value forms.
                    (list store)             ;Store variables.
                    `(let ((,stemp (dpb ,store ,btemp ,access-form)))
                       ,store-form
                       ,store)               ;Storing form.
                    `(ldb ,btemp ,access-form) ;Accessing form.
                   ))))

See Also:
.........

*note setf::, *note defsetf::, *note documentation::, *note
get-setf-expansion::, *note Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations): Syntactic Interaction of
Documentation Strings and Declarations.

Notes:
......

‘define-setf-expander’ differs from the long form of ‘defsetf’ in that
while the body is being executed the variables in LAMBDA-LIST are bound
to parts of the place form, not to temporary variables that will be
bound to the values of such parts.  In addition, ‘define-setf-expander’
does not have ‘defsetf’’s restriction that ACCESS-FN must be a function
or a function-like macro; an arbitrary ‘defmacro’ destructuring pattern
is permitted in LAMBDA-LIST.


File: ansicl,  Node: get-setf-expansion,  Next: setf; psetf,  Prev: define-setf-expander,  Up: Data and Control Flow

get-setf-expansion (Function)
=============================

Syntax:
.......

 -- Function: get-setf-expansion place &optional environment → vars,
          vals, store-vars, writer-form, reader-form

Arguments and Values:
.....................

PLACE—a place.

ENVIRONMENT—an environment object.

VARS, VALS, STORE-VARS, WRITER-FORM, READER-FORM—a setf expansion.

Description:
............

Determines five values constituting the setf expansion for PLACE in
ENVIRONMENT; see *note Section 5.1.1.2 (Setf Expansions):
SetfExpansions.

If ENVIRONMENT is not supplied or ‘nil’, the environment is the null
lexical environment.

Examples:
.........

      (get-setf-expansion 'x)
     → NIL, NIL, (#:G0001), (SETQ X #:G0001), X

     ;;; This macro is like POP

      (defmacro xpop (place &environment env)
        (multiple-value-bind (dummies vals new setter getter)
                             (get-setf-expansion place env)
           `(let* (,@(mapcar #'list dummies vals) (,(car new) ,getter))
              (if (cdr new) (error "Can't expand this."))
              (prog1 (car ,(car new))
                     (setq ,(car new) (cdr ,(car new)))
                     ,setter))))

      (defsetf frob (x) (value)
          `(setf (car ,x) ,value)) → FROB
     ;;; The following is an error; an error might be signaled at macro expansion time
      (flet ((frob (x) (cdr x)))  ;Invalid
        (xpop (frob z)))


See Also:
.........

*note defsetf::, *note define-setf-expander::, *note setf::

Notes:
......

Any compound form is a valid place, since any compound form whose
operator F has no setf expander are expanded into a call to ‘(setf F)’.


File: ansicl,  Node: setf; psetf,  Next: shiftf,  Prev: get-setf-expansion,  Up: Data and Control Flow

setf, psetf (Macro)
===================

Syntax:
.......

 -- Macro: setf {↓pair}* → {result}*
 -- Macro: psetf {↓pair}* → ‘nil’

PAIR::=
     place newvalue

Arguments and Values:
.....................

PLACE—a place.

NEWVALUE—a form.

RESULTS—the multiple valuesreturned by the storing form for the last
PLACE, or ‘nil’ if there are no PAIRS.

Description:
............

‘setf’ changes the value of PLACE to be NEWVALUE.

‘(setf place newvalue)’ expands into an update form that stores the
result of evaluating NEWVALUE into the location referred to by PLACE.
Some PLACE forms involve uses of accessors that take optional arguments.
Whether those optional arguments are permitted by ‘setf’, or what their
use is, is up to the ‘setf’ expander function and is not under the
control of ‘setf’.  The documentation for any function that accepts
‘&optional’, ‘&rest’, or ‘&key’ arguments and that claims to be usable
with ‘setf’ must specify how those arguments are treated.

If more than one PAIR is supplied, the PAIRS are processed sequentially;
that is,

      (setf place-1 newvalue-1
            place-2 newvalue-2
            ...
            place-N newvalue-N)

is precisely equivalent to

      (progn (setf place-1 newvalue-1)
             (setf place-2 newvalue-2)
             ...
             (setf place-N newvalue-N))

For ‘psetf’, if more than one PAIR is supplied then the assignments of
new values to places are done in parallel.  More precisely, all subforms
(in both the PLACE and NEWVALUE forms) that are to be evaluated are
evaluated from left to right; after all evaluations have been performed,
all of the assignments are performed in an unpredictable order.

For detailed treatment of the expansion of ‘setf’ and ‘psetf’, see *note
Section 5.1.2 (Kinds of Places): Kinds of Places.

Examples:
.........

      (setq x (cons 'a 'b) y (list 1 2 3)) → (1 2 3)
      (setf (car x) 'x (cadr y) (car x) (cdr x) y) → (1 X 3)
      x → (X 1 X 3)
      y → (1 X 3)
      (setq x (cons 'a 'b) y (list 1 2 3)) → (1 2 3)
      (psetf (car x) 'x (cadr y) (car x) (cdr x) y) → NIL
      x → (X 1 A 3)
      y → (1 A 3)

Affected By:
............

‘define-setf-expander’, ‘defsetf’, ‘*macroexpand-hook*’

See Also:
.........

*note define-setf-expander::, *note defsetf::, *note macroexpand-1::,
*note rotatef::, *note shiftf::, *note Section 5.1 (Generalized
Reference): Generalized Reference.


File: ansicl,  Node: shiftf,  Next: rotatef,  Prev: setf; psetf,  Up: Data and Control Flow

shiftf (Macro)
==============

Syntax:
.......

 -- Macro: shiftf {PLACE}+ newvalue → old-value-1

Arguments and Values:
.....................

PLACE—a place.

NEWVALUE—a form; evaluated.

OLD-VALUE-1—an object (the old value of the first PLACE).

Description:
............

‘shiftf’ modifies the values of each PLACE by storing NEWVALUE into the
last PLACE, and shifting the values of the second through the last PLACE
into the remaining PLACES.

If NEWVALUE produces more values than there are store variables, the
extra values are ignored.  If NEWVALUE produces fewer values than there
are store variables, the missing values are set to ‘nil’.

In the form ‘(shiftf place1 place2 ... placen newvalue)’, the values in
place1 through placen are read and saved, and newvalue is evaluated, for
a total of ‘n’+1 values in all.  Values 2 through ‘n’+1 are then stored
into place1 through placen, respectively.  It is as if all the PLACES
form a shift register; the NEWVALUE is shifted in from the right, all
values shift over to the left one place, and the value shifted out of
place1 is returned.

For information about the evaluation of subforms of PLACES, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

      (setq x (list 1 2 3) y 'trash) → TRASH
      (shiftf y x (cdr x) '(hi there)) → TRASH
      x → (2 3)
      y → (1 HI THERE)

      (setq x (list 'a 'b 'c)) → (A B C)
      (shiftf (cadr x) 'z) → B
      x → (A Z C)
      (shiftf (cadr x) (cddr x) 'q) → Z
      x → (A (C) . Q)
      (setq n 0) → 0
      (setq x (list 'a 'b 'c 'd)) → (A B C D)
      (shiftf (nth (setq n (+ n 1)) x) 'z) → B
      x → (A Z C D)

Affected By:
............

‘define-setf-expander’, ‘defsetf’, ‘*macroexpand-hook*’

See Also:
.........

*note setf::, *note rotatef::, *note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of ‘(shiftf PLACE1 PLACE2 ... PLACEN NEWVALUE)’ is roughly
equivalent to

      (let ((var1 PLACE1)
            (var2 PLACE2)
            ...
            (varn PLACEN)
            (var0 NEWVALUE))
        (setf PLACE1 var2)
        (setf PLACE2 var3)
        ...
        (setf PLACEN var0)
        var1)

except that the latter would evaluate any subforms of each ‘place’
twice, whereas ‘shiftf’ evaluates them once.  For example,

      (setq n 0) → 0
      (setq x (list 'a 'b 'c 'd)) → (A B C D)
      (prog1 (nth (setq n (+ n 1)) x)
             (setf (nth (setq n (+ n 1)) x) 'z)) → B
      x → (A B Z D)


File: ansicl,  Node: rotatef,  Next: control-error,  Prev: shiftf,  Up: Data and Control Flow

rotatef (Macro)
===============

Syntax:
.......

 -- Macro: rotatef {place}* → ‘nil’

Arguments and Values:
.....................

PLACE—a place.

Description:
............

‘rotatef’ modifies the values of each PLACE by rotating values from one
PLACE into another.

If a PLACE produces more values than there are store variables, the
extra values are ignored.  If a PLACE produces fewer values than there
are store variables, the missing values are set to ‘nil’.

In the form ‘(rotatef place1 place2 ... placen)’, the values in place1
through placen are read and written.  Values 2 through n and value 1 are
then stored into place1 through placen.  It is as if all the places form
an end-around shift register that is rotated one place to the left, with
the value of place1 being shifted around the end to placen.

For information about the evaluation of subforms of PLACES, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

      (let ((n 0)
             (x (list 'a 'b 'c 'd 'e 'f 'g)))
         (rotatef (nth (incf n) x)
                  (nth (incf n) x)
                  (nth (incf n) x))
         x) → (A C D B E F G)

See Also:
.........

*note define-setf-expander::, *note defsetf::, *note setf::, *note
shiftf::, *note *macroexpand-hook*::, *note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of ‘(rotatef PLACE1 PLACE2 ... PLACEN)’ is roughly equivalent
to

      (psetf PLACE1 PLACE2
             PLACE2 PLACE3
             ...
             PLACEN PLACE1)

except that the latter would evaluate any subforms of each ‘place’
twice, whereas ‘rotatef’ evaluates them once.


File: ansicl,  Node: control-error,  Next: program-error,  Prev: rotatef,  Up: Data and Control Flow

control-error (Condition Type)
==============================

Class Precedence List:
......................

‘control-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘control-error’ consists of error conditions that result from
invalid dynamic transfers of control in a program.  The errors that
result from giving ‘throw’ a tag that is not active or from giving ‘go’
or ‘return-from’ a tag that is no longer dynamically available are of
type ‘control-error’.


File: ansicl,  Node: program-error,  Next: undefined-function,  Prev: control-error,  Up: Data and Control Flow

program-error (Condition Type)
==============================

Class Precedence List:
......................

‘program-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘program-error’ consists of error conditions related to
incorrect program syntax.  The errors that result from naming a go tag
or a block tag that is not lexically apparent are of type
‘program-error’.


File: ansicl,  Node: undefined-function,  Prev: program-error,  Up: Data and Control Flow

undefined-function (Condition Type)
===================================

Class Precedence List:
......................

‘undefined-function’, ‘cell-error’, ‘error’, ‘serious-condition’,
‘condition’, ‘t’

Description:
............

The type ‘undefined-function’ consists of error conditions that
represent attempts to read the definition of an undefined function.

The name of the cell (see ‘cell-error’) is the function name which was
funbound.

See Also:
.........

*note cell-error-name::


File: ansicl,  Node: Iteration,  Next: Objects,  Prev: Data and Control Flow,  Up: Top

6 Iteration
***********

* Menu:

* The LOOP Facility::

Dictionary

* do; do*::
* dotimes::
* dolist::
* loop::
* loop-finish::


File: ansicl,  Node: The LOOP Facility,  Next: do; do*,  Up: Iteration

6.1 The LOOP Facility
=====================

* Menu:

* Overview of the Loop Facility::
* Variable Initialization and Stepping Clauses::
* Value Accumulation Clauses::
* Termination Test Clauses::
* Unconditional Execution Clauses::
* Conditional Execution Clauses::
* Miscellaneous Clauses::
* Examples of Miscellaneous Loop Features::
* Notes about Loop::


File: ansicl,  Node: Overview of the Loop Facility,  Next: Variable Initialization and Stepping Clauses,  Up: The LOOP Facility

6.1.1 Overview of the Loop Facility
-----------------------------------

The ‘loop’ macro performs iteration.

6.1.1.1 Simple vs Extended Loop
...............................

‘loop’ forms are partitioned into two categories: simple ‘loop’ forms
and extended ‘loop’ forms.

6.1.1.1.1 Simple Loop
.....................

A simple ‘loop’ form is one that has a body containing only compound
forms.  Each form is evaluated in turn from left to right.  When the
last FORM has been evaluated, then the first FORM is evaluated again,
and so on, in a never-ending cycle.  A simple ‘loop’ form establishes an
implicit block named ‘nil’.  The execution of a simple ‘loop’ can be
terminated by explicitly transfering control to the implicit block
(using ‘return’ or ‘return-from’) or to some exit point outside of the
block (e.g., using ‘throw’, ‘go’, or ‘return-from’).

6.1.1.1.2 Extended Loop
.......................

An extended ‘loop’ form is one that has a body containing atomic
expressions.  When the ‘loop’ macro processes such a form, it invokes a
facility that is commonly called “the Loop Facility.”

The Loop Facility provides standardized access to mechanisms commonly
used in iterations through Loop schemas, which are introduced by loop
keywords.

The body of an extended ‘loop’ form is divided into ‘loop’ clauses, each
which is in turn made up of loop keywords and forms.

6.1.1.2 Loop Keywords
.....................

Loop keywords are not true keywordsthey are special symbols, recognized
by name rather than object identity, that are meaningful only to the
‘loop’ facility.  A loop keyword is a symbol but is recognized by its
name (not its identity), regardless of the packages in which it is
accessible.

In general, loop keywords are not external symbols of the ‘COMMON-LISP’
package, except in the coincidental situation that a symbol with the
same name as a loop keyword was needed for some other purpose in Common
Lisp.  For example, there is a symbol in the ‘COMMON-LISP’ package whose
name is ‘"UNLESS"’ but not one whose name is ‘"UNTIL"’.

If no loop keywords are supplied in a ‘loop’ form, the Loop Facility
executes the loop body repeatedly; see *note Section 6.1.1.1.1 (Simple
Loop): SimpleLoop.

6.1.1.3 Parsing Loop Clauses
............................

The syntactic parts of an extended ‘loop’ form are called clauses; the
rules for parsing are determined by that clause’s keyword.  The
following example shows a ‘loop’ form with six clauses:

      (loop for i from 1 to (compute-top-value)       ; first clause
            while (not (unacceptable i))              ; second clause
            collect (square i)                        ; third clause
            do (format t "Working on ~D now" i)       ; fourth clause
            when (evenp i)                            ; fifth clause
              do (format t "~D is a non-odd number" i)
            finally (format t "About to exit!"))      ; sixth clause

Each loop keyword introduces either a compound loop clause or a simple
loop clause that can consist of a loop keyword followed by a single
form.  The number of forms in a clause is determined by the loop keyword
that begins the clause and by the auxiliary keywords in the clause.  The
keywords ‘do’, ‘doing’, ‘initially’, and ‘finally’ are the only loop
keywords that can take any number of forms and group them as an implicit
progn.

Loop clauses can contain auxiliary keywords, which are sometimes called
prepositions.  For example, the first clause in the code above includes
the prepositions ‘from’ and ‘to’, which mark the value from which
stepping begins and the value at which stepping ends.

For detailed information about ‘loop’ syntax, see the macro *note
loop::.

6.1.1.4 Expanding Loop Forms
............................

A ‘loop’ macro form expands into a form containing one or more binding
forms (that establish bindings of loop variables) and a ‘block’ and a
‘tagbody’ (that express a looping control structure).  The variables
established in ‘loop’ are bound as if by ‘let’ or lambda.

Implementations can interleave the setting of initial values with the
bindings.  However, the assignment of the initial values is always
calculated in the order specified by the user.  A variable is thus
sometimes bound to a meaningless value of the correct type, and then
later in the prologue it is set to the true initial value by using
‘setq’.  One implication of this interleaving is that it is
implementation-dependent whether the lexical environment in which the
initial value forms (variously called the FORM1, FORM2, FORM3, STEP-FUN,
VECTOR, HASH-TABLE, and PACKAGE) in any FOR-AS-SUBCLAUSE, except
FOR-AS-EQUALS-THEN, are evaluated includes only the loop variables
preceding that form or includes more or all of the loop variables; the
FORM1 and FORM2 in a FOR-AS-EQUALS-THEN form includes the lexical
environment of all the loop variables.

After the form is expanded, it consists of three basic parts in the
‘tagbody’: the loop prologue, the loop body, and the loop epilogue.

Loop prologue

     The loop prologue contains forms that are executed before iteration
     begins, such as any automatic variable initializations prescribed
     by the VARIABLE clauses, along with any ‘initially’ clauses in the
     order they appear in the source.

Loop body

     The loop body contains those forms that are executed during
     iteration, including application-specific calculations, termination
     tests, and variable stepping

Loop epilogue

     The loop epilogue contains forms that are executed after iteration
     terminates, such as ‘finally’ clauses, if any, along with any
     implicit return value from an ACCUMULATION clause or an
     TERMINATION-TEST clause.

Some clauses from the source form contribute code only to the loop
prologue; these clauses must come before other clauses that are in the
main body of the ‘loop’ form.  Others contribute code only to the loop
epilogue.  All other clauses contribute to the final translated form in
the same order given in the original source form of the ‘loop’.

Expansion of the ‘loop’ macro produces an implicit block named ‘nil’ 
unless ‘named’ is supplied.  Thus, ‘return-from’ (and sometimes
‘return’) can be used to return values from ‘loop’ or to exit ‘loop’.

6.1.1.5 Summary of Loop Clauses
...............................

Loop clauses fall into one of the following categories:

6.1.1.5.1 Summary of Variable Initialization and Stepping Clauses
.................................................................

The ‘for’ and ‘as’ constructs provide iteration control clauses that
establish a variable to be initialized.  ‘for’ and ‘as’ clauses can be
combined with the loop keyword ‘and’ to get parallel initialization and
steppingOtherwise, the initialization and stepping

The ‘with’ construct is similar to a single ‘let’ clause.  ‘with’
clauses can be combined using the loop keyword ‘and’ to get parallel
initialization.

For more information, see *note Section 6.1.2 (Variable Initialization
and Stepping Clauses): Variable Initialization and Stepping Clauses.

6.1.1.5.2 Summary of Value Accumulation Clauses
...............................................

The ‘collect’ (or ‘collecting’) construct takes one form in its clause
and adds the value of that form to the end of a list of values.  By
default, the list of values is returned when the ‘loop’ finishes.

The ‘append’ (or ‘appending’) construct takes one form in its clause and
appends the value of that form to the end of a list of values.  By
default, the list of values is returned when the ‘loop’ finishes.

The ‘nconc’ (or ‘nconcing’) construct is similar to the ‘append’
construct, but its list values are concatenated as if by the function
‘nconc’.  By default, the list of values is returned when the ‘loop’
finishes.

The ‘sum’ (or ‘summing’) construct takes one form in its clause that
must evaluate to a number and accumulates the sum of all these numbers.
By default, the cumulative sum is returned when the ‘loop’ finishes.

The ‘count’ (or ‘counting’) construct takes one form in its clause and
counts the number of times that the form evaluates to true.  By default,
the count is returned when the ‘loop’ finishes.

The ‘minimize’ (or ‘minimizing’) construct takes one form in its clause
and determines the minimum value obtained by evaluating that form.  By
default, the minimum value is returned when the ‘loop’ finishes.

The ‘maximize’ (or ‘maximizing’) construct takes one form in its clause
and determines the maximum value obtained by evaluating that form.  By
default, the maximum value is returned when the ‘loop’ finishes.

For more information, see *note Section 6.1.3 (Value Accumulation
Clauses): Value Accumulation Clauses.

6.1.1.5.3 Summary of Termination Test Clauses
.............................................

The ‘for’ and ‘as’ constructs provide a termination test that is
determined by the iteration control clause.

The ‘repeat’ construct causes termination after a specified number of
iterations.  (It uses an internal variable to keep track of the number
of iterations.)

The ‘while’ construct takes one form, a TEST, and terminates the
iteration if the TEST evaluates to false.  A ‘while’ clause is
equivalent to the expression ‘(if (not TEST) (loop-finish))’.

The ‘until’ construct is the inverse of ‘while’; it terminates the
iteration if the TEST evaluates to any non-nil value.  An ‘until’ clause
is equivalent to the expression ‘(if TEST (loop-finish))’.

The ‘always’ construct takes one form and terminates the ‘loop’ if the
form ever evaluates to false; in this case, the ‘loop’ form returns
‘nil’.  Otherwise, it provides a default return value of ‘t’.

The ‘never’ construct takes one form and terminates the ‘loop’ if the
form ever evaluates to true; in this case, the ‘loop’ form returns
‘nil’.  Otherwise, it provides a default return value of ‘t’.

The ‘thereis’ construct takes one form and terminates the ‘loop’ if the
form ever evaluates to a non-nil object; in this case, the ‘loop’ form
returns that object.  Otherwise, it provides a default return value of
‘nil’.

If multiple termination test clauses are specified, the ‘loop’ form
terminates if any are satisfied.

For more information, see *note Section 6.1.4 (Termination Test
Clauses): Termination Test Clauses.

6.1.1.5.4 Summary of Unconditional Execution Clauses
....................................................

The ‘do’ (or ‘doing’) construct evaluates all forms in its clause.

The ‘return’ construct takes one form.  Any values returned by the form
are immediately returned by the ‘loop’ form.  It is equivalent to the
clause ‘do (return-from block-name value)’, where block-name is the name
specified in a ‘named’ clause, or ‘nil’ if there is no ‘named’ clause.

For more information, see *note Section 6.1.5 (Unconditional Execution
Clauses): Unconditional Execution Clauses.

6.1.1.5.5 Summary of Conditional Execution Clauses
..................................................

The ‘if’ and ‘when’ constructs take one form as a test and a clause that
is executed when the test yields true.  The clause can be a value
accumulation, unconditional, or another conditional clause; it can also
be any combination of such clauses connected by the ‘loop’ ‘and’
keyword.

The ‘loop’ ‘unless’ construct is similar to the ‘loop’ ‘when’ construct
except that it complements the test result.

The ‘loop’ ‘else’ construct provides an optional component of ‘if’,
‘when’, and ‘unless’ clauses that is executed when an ‘if’ or ‘when’
test yields false or when an ‘unless’ test yields true.  The component
is one of the clauses described under ‘if’.

The ‘loop’ ‘end’ construct provides an optional component to mark the
end of a conditional clause.

For more information, see *note Section 6.1.6 (Conditional Execution
Clauses): Conditional Execution Clauses.

6.1.1.5.6 Summary of Miscellaneous Clauses
..........................................

The ‘loop’ ‘named’ construct gives a name for the block of the loop.

The ‘loop’ ‘initially’ construct causes its forms to be evaluated in the
loop prologue, which precedes all ‘loop’ code except for initial
settings supplied by the constructs ‘with’, ‘for’, or ‘as’.

The ‘loop’ ‘finally’ construct causes its forms to be evaluated in the
loop epilogue after normal iteration terminates.

For more information, see *note Section 6.1.7 (Miscellaneous Clauses):
Miscellaneous Clauses.

6.1.1.6 Order of Execution
..........................

With the exceptions listed below, clauses are executed in the loop body
in the order in which they appear in the source.  Execution is repeated
until a clause terminates the ‘loop’ or until a ‘return’, ‘go’, or
‘throw’ form is encountered which transfers control to a point outside
of the loop.  The following actions are exceptions to the linear order
of execution:

   • All variables are initialized first, regardless of where the
     establishing clauses appear in the source.  The order of
     initialization follows the order of these clauses.

   • The code for any ‘initially’ clauses is collected into one ‘progn’
     in the order in which the clauses appear in the source.  The
     collected code is executed once in the loop prologue after any
     implicit variable initializations.

   • The code for any ‘finally’ clauses is collected into one ‘progn’ in
     the order in which the clauses appear in the source.  The collected
     code is executed once in the loop epilogue before any implicit
     values from the accumulation clauses are returned.  Explicit
     returns anywhere in the source, however, will exit the ‘loop’
     without executing the epilogue code.

   • A ‘with’ clause introduces a variable binding and an optional
     initial value.  The initial values are calculated in the order in
     which the ‘with’ clauses occur.

   • Iteration control clauses implicitly perform the following actions:

        – initialize variables;

        – step variables, generally between each execution of the loop
          body;

        – perform termination tests, generally just before the execution
          of the loop body.

6.1.1.7 Destructuring
.....................

The D-TYPE-SPEC argument is used for destructuring.  If the D-TYPE-SPEC
argument consists solely of the type ‘fixnum’, ‘float’, ‘t’, or ‘nil’,
the ‘of-type’ keyword is optional.  The ‘of-type’ construct is optional
in these cases to provide backwards compatibility; thus, the following
two expressions are the same:

     ;;; This expression uses the old syntax for type specifiers.
      (loop for i fixnum upfrom 3 ...)

     ;;; This expression uses the new syntax for type specifiers.
      (loop for i of-type fixnum upfrom 3 ...)

     ;; Declare X and Y to be of type VECTOR and FIXNUM respectively.
      (loop for (x y) of-type (vector fixnum)
            in l do ...)

A type specifier for a destructuring pattern is a tree of type
specifiers with the same shape as the tree of variable names, with the
following exceptions:

   • When aligning the trees, an atom in the tree of type specifiers
     that matches a cons in the variable tree declares the same type for
     each variable in the subtree rooted at the cons.

   • A cons in the tree of type specifiers that matches an atom in the
     tree of variable names is a compound type specifer.

Destructuring allows binding of a set of variables to a corresponding
set of values anywhere that a value can normally be bound to a single
variable.  During ‘loop’ expansion, each variable in the variable list
is matched with the values in the values list.  If there are more
variables in the variable list than there are values in the values list,
the remaining variables are given a value of ‘nil’.  If there are more
values than variables listed, the extra values are discarded.

To assign values from a list to the variables ‘a’, ‘b’, and ‘c’, the
‘for’ clause could be used to bind the variable ‘numlist’ to the car of
the supplied FORM, and then another ‘for’ clause could be used to bind
the variables ‘a’, ‘b’, and ‘c’ sequentially.

     ;; Collect values by using FOR constructs.
      (loop for numlist in '((1 2 4.0) (5 6 8.3) (8 9 10.4))
            for a of-type integer = (first numlist)
            and b of-type integer = (second numlist)
            and c of-type float = (third numlist)
            collect (list c b a))
     → ((4.0 2 1) (8.3 6 5) (10.4 9 8))

Destructuring makes this process easier by allowing the variables to be
bound in each loop iteration.  Types can be declared by using a list of
TYPE-SPEC arguments.  If all the types are the same, a shorthand
destructuring syntax can be used, as the second example illustrates.

     ;; Destructuring simplifies the process.
      (loop for (a b c) of-type (integer integer float) in
            '((1 2 4.0) (5 6 8.3) (8 9 10.4))
            collect (list c b a))
     → ((4.0 2 1) (8.3 6 5) (10.4 9 8))


     ;; If all the types are the same, this way is even simpler.
      (loop for (a b c) of-type float in
            '((1.0 2.0 4.0) (5.0 6.0 8.3) (8.0 9.0 10.4))
            collect (list c b a))
     → ((4.0 2.0 1.0) (8.3 6.0 5.0) (10.4 9.0 8.0))

If destructuring is used to declare or initialize a number of groups of
variables into types, the loop keyword ‘and’ can be used to simplify the
process further.
     ;; Initialize and declare variables in parallel by using the AND construct.
      (loop with (a b) of-type float = '(1.0 2.0)
            and (c d) of-type integer = '(3 4)
            and (e f)
            return (list a b c d e f))
     → (1.0 2.0 3 4 NIL NIL)

If ‘nil’ is used in a destructuring list, no variable is provided for
its place.

      (loop for (a nil b) = '(1 2 3)
            do (return (list a b)))
     → (1 3)

Note that dotted lists can specify destructuring.

      (loop for (x . y) = '(1 . 2)
            do (return y))
     → 2
      (loop for ((a . b) (c . d)) of-type ((float . float) (integer . integer)) in
            '(((1.2 . 2.4) (3 . 4)) ((3.4 . 4.6) (5 . 6)))
            collect (list a b c d))
     → ((1.2 2.4 3 4) (3.4 4.6 5 6))

An error of type ‘program-error’ is signaled (at macro expansion time)
if the same variable is bound twice in any variable-binding clause of a
single ‘loop’ expression.  Such variables include local variables,
iteration control variables, and variables found by destructuring.

6.1.1.8 Restrictions on Side-Effects
....................................

See *note Section 3.6 (Traversal Rules and Side Effects): Traversal
Rules and Side Effects.


File: ansicl,  Node: Variable Initialization and Stepping Clauses,  Next: Value Accumulation Clauses,  Prev: Overview of the Loop Facility,  Up: The LOOP Facility

6.1.2 Variable Initialization and Stepping Clauses
--------------------------------------------------

6.1.2.1 Iteration Control
.........................

Iteration control clauses allow direction of ‘loop’ iteration.  The loop
keywords ‘for’ and ‘as’ designate iteration control clauses.  Iteration
control clauses differ with respect to the specification of termination
tests and to the initialization and steppingof loop variables.
Iteration clauses by themselves do not cause the Loop Facility to return
values, but they can be used in conjunction with value-accumulation
clauses to return values.

All variables are initialized in the loop prologue.  A variable binding
has lexical scope unless it is proclaimed ‘special’; thus, by default,
the variable can be accessed only by forms that lie textually within the
‘loop’.  Stepping assignments are made in the loop body before any other
forms are evaluated in the body.

The variable argument in iteration control clauses can be a
destructuring list.  A destructuring list is a tree whose non-nil atoms
are variable names.  See *note Section 6.1.1.7 (Destructuring):
DestructuringLOOPVars.

The iteration control clauses ‘for’, ‘as’, and ‘repeat’ must precede any
other loop clauses, except ‘initially’, ‘with’, and ‘named’, since they
establish variable bindings.  When iteration control clauses are used in
a ‘loop’, the corresponding termination tests in the loop body are
evaluated before any other loop body code is executed.

If multiple iteration clauses are used to control iteration, variable
initialization and steppingThe ‘and’ construct can be used to connect
two or more iteration clauses when sequential binding and steppingThe
iteration behavior of clauses joined by ‘and’ is analogous to the
behavior of the macro ‘do’ with respect to ‘do*’.

The ‘for’ and ‘as’ clauses iterate by using one or more local loop
variables that are initialized to some value and that can be modified or
steppedFor these clauses, iteration terminates when a local variable
reaches some supplied value or when some other loop clause terminates
iteration.  At each iteration, variables can be steppedor can be
assigned a new value by the evaluation of a form).  Destructuring can be
used to assign values to variables during iteration.

The ‘for’ and ‘as’ keywords are synonyms; they can be used
interchangeably.  There are seven syntactic formats for these
constructs.  In each syntactic format, the type of VAR can be supplied
by the optional TYPE-SPEC argument.  If VAR is a destructuring list, the
type supplied by the TYPE-SPEC argument must appropriately match the
elements of the list.  By convention, ‘for’ introduces new iterations
and ‘as’ introduces iterations that depend on a previous iteration
specification.

6.1.2.1.1 The for-as-arithmetic subclause
.........................................

In the for-as-arithmetic subclause, the ‘for’ or ‘as’ construct iterates
from the value supplied by FORM1 to the value supplied by FORM2 in
increments or decrements denoted by FORM3.  Each expression is evaluated
only once and must evaluate to a number.  The variable VAR is bound to
the value of FORM1 in the first iteration and is steppedby the value of
FORM3 in each succeeding iteration, or by 1 if FORM3 is not provided.
The following loop keywords serve as valid prepositions within this
syntax.  At least one of the prepositions must be used; and at most one
from each line may be used in a single subclause.

‘from | downfrom | upfrom’

‘to | downto | upto | below | above’

‘by’

The prepositional phrases in each subclause may appear in any order.
For example, either “‘from x by y’” or “‘by y from x’” is permitted.
However, because left-to-right order of evaluation is preserved, the
effects will be different in the case of side effects.  Consider:

     (let ((x 1)) (loop for i from x by (incf x) to 10 collect i))
     → (1 3 5 7 9)
     (let ((x 1)) (loop for i by (incf x) from x to 10 collect i))
     → (2 4 6 8 10)

The descriptions of the prepositions follow:

‘from’

     The loop keyword ‘from’ specifies the value from which
     steppingSteppingdecremental steppingthe preposition ‘downto’ or
     ‘above’ must be used with FORM2.  For incremental stepping

‘downfrom, upfrom’

     The loop keyword ‘downfrom’ indicates that the variable VAR is
     decreased in decrements supplied by FORM3; the loop keyword
     ‘upfrom’ indicates that VAR is increased in increments supplied by
     FORM3.

‘to’

     The loop keyword ‘to’ marks the end value for steppingSteppingIf
     decremental steppingthe preposition ‘downfrom’ must be used with
     FORM1, or else the preposition ‘downto’ or ‘above’ should be used
     instead of ‘to’ with FORM2.

‘downto, upto’

     The loop keyword ‘downto’ specifies decremental stepping; the loop
     keyword ‘upto’ specifies incremental stepping.  In both cases, the
     amount of change on each step is specified by FORM3, and the ‘loop’
     terminates when the variable VAR passes the value of FORM2.  Since
     there is no default for FORM1 in decremental steppinga FORM1 value
     must be supplied (using ‘from’ or ‘downfrom’) when ‘downto’ is
     supplied.

‘below, above’

     The loop keywords ‘below’ and ‘above’ are analogous to ‘upto’ and
     ‘downto’ respectively.  These keywords stop iteration just before
     the value of the variable VAR reaches the value supplied by FORM2;
     the end value of FORM2 is not included.  Since there is no default
     for FORM1 in decremental steppinga FORM1 value must be supplied
     (using ‘from’ or ‘downfrom’) when ‘above’ is supplied.

‘by’

     The loop keyword ‘by’ marks the increment or decrement supplied by
     FORM3.  The value of FORM3 can be any positive number.  The default
     value is 1.

In an iteration control clause, the ‘for’ or ‘as’ construct causes
termination when the supplied limit is reached.  That is, iteration
continues until the value VAR is stepped to the exclusive or inclusive
limit supplied by FORM2.  The range is exclusive if FORM3 increases or
decreases VAR to the value of FORM2 without reaching that value; the
loop keywords ‘below’ and ‘above’ provide exclusive limits.  An
inclusive limit allows VAR to attain the value of FORM2; ‘to’, ‘downto’,
and ‘upto’ provide inclusive limits.

6.1.2.1.1.1 Examples of for-as-arithmetic subclause
...................................................

     ;; Print some numbers.
      (loop for i from 1 to 3
            do (print i))
     ▷ 1
     ▷ 2
     ▷ 3
     → NIL

     ;; Print every third number.
      (loop for i from 10 downto 1 by 3
            do (print i))
     ▷ 10
     ▷ 7
     ▷ 4
     ▷ 1
     → NIL

     ;; Step incrementally from the default starting value.
      (loop for i below 3
            do (print i))
     ▷ 0
     ▷ 1
     ▷ 2
     → NIL

6.1.2.1.2 The for-as-in-list subclause
......................................

In the for-as-in-list subclause, the ‘for’ or ‘as’ construct iterates
over the contents of a list.  It checks for the end of the list as if by
using ‘endp’.  The variable VAR is bound to the successive elements of
the list in FORM1 before each iteration.  At the end of each iteration,
the function STEP-FUN is applied to the list; the default value for
STEP-FUN is ‘cdr’.  The loop keywords ‘in’ and ‘by’ serve as valid
prepositions in this syntax.  The ‘for’ or ‘as’ construct causes
termination when the end of the list is reached.

6.1.2.1.2.1 Examples of for-as-in-list subclause
................................................

     ;; Print every item in a list.
      (loop for item in '(1 2 3) do (print item))
     ▷ 1
     ▷ 2
     ▷ 3
     → NIL

     ;; Print every other item in a list.
      (loop for item in '(1 2 3 4 5) by #'cddr
            do (print item))
     ▷ 1
     ▷ 3
     ▷ 5
     → NIL

     ;; Destructure a list, and sum the x values using fixnum arithmetic.
      (loop for (item . x) of-type (t . fixnum) in '((A . 1) (B . 2) (C . 3))
            unless (eq item 'B) sum x)
     → 4

6.1.2.1.3 The for-as-on-list subclause
......................................

In the for-as-on-list subclause, the ‘for’ or ‘as’ construct iterates
over a list.  It checks for the end of the list as if by using ‘atom’.
The variable VAR is bound to the successive tails of the list in FORM1.
At the end of each iteration, the function STEP-FUN is applied to the
list; the default value for STEP-FUN is ‘cdr’.  The loop keywords ‘on’
and ‘by’ serve as valid prepositions in this syntax.  The ‘for’ or ‘as’
construct causes termination when the end of the list is reached.

6.1.2.1.3.1 Examples of for-as-on-list subclause
................................................

     ;; Collect successive tails of a list.
      (loop for sublist on '(a b c d)
            collect sublist)
     → ((A B C D) (B C D) (C D) (D))

     ;; Print a list by using destructuring with the loop keyword ON.
      (loop for (item) on '(1 2 3)
            do (print item))
     ▷ 1
     ▷ 2
     ▷ 3
     → NIL


6.1.2.1.4 The for-as-equals-then subclause
..........................................

In the for-as-equals-then subclause the ‘for’ or ‘as’ construct
initializes the variable VAR by setting it to the result of evaluating
FORM1 on the first iteration, then setting it to the result of
evaluating FORM2 on the second and subsequent iterations.  If FORM2 is
omitted, the construct uses FORM1 on the second and subsequent
iterations.  The loop keywords = and ‘then’ serve as valid prepositions
in this syntax.  This construct does not provide any termination tests.

6.1.2.1.4.1 Examples of for-as-equals-then subclause
....................................................

     ;; Collect some numbers.
      (loop for item = 1 then (+ item 10)
            for iteration from 1 to 5
            collect item)
     → (1 11 21 31 41)

6.1.2.1.5 The for-as-across subclause
.....................................

In the for-as-across subclause the ‘for’ or ‘as’ construct binds the
variable VAR to the value of each element in the array VECTOR.  The loop
keyword ‘across’ marks the array VECTOR; ‘across’ is used as a
preposition in this syntax.  Iteration stops when there are no more
elements in the supplied array that can be referenced.  Some
implementations might recognize a ‘the’ special form in the VECTOR form
to produce more efficient code.

6.1.2.1.5.1 Examples of for-as-across subclause
...............................................

      (loop for char across (the simple-string (find-message channel))
            do (write-char char stream))

6.1.2.1.6 The for-as-hash subclause
...................................

In the for-as-hash subclause the ‘for’ or ‘as’ construct iterates over
the elements, keys, and values of a hash-table.  In this syntax, a
compound preposition is used to designate access to a hash table.  The
variable VAR takes on the value of each hash key or hash value in the
supplied HASH-TABLE.  The following loop keywords serve as valid
prepositions within this syntax:

‘being’

     The keyword ‘being’ introduces either the Loop schema ‘hash-key’ or
     ‘hash-value’.

‘each’, ‘the’

     The loop keyword ‘each’ follows the loop keyword ‘being’ when
     ‘hash-key’ or ‘hash-value’ is used.  The loop keyword ‘the’ is used
     with ‘hash-keys’ and ‘hash-values’ only for ease of reading.  This
     agreement isn’t required.

‘hash-key’, ‘hash-keys’

     These loop keywords access each key entry of the hash table.  If
     the name ‘hash-value’ is supplied in a ‘using’ construct with one
     of these Loop schemas, the iteration can optionally access the
     keyed value.  The order in which the keys are accessed is
     undefined; empty slots in the hash table are ignored.

‘hash-value’, ‘hash-values’

     These loop keywords access each value entry of a hash table.  If
     the name ‘hash-key’ is supplied in a ‘using’ construct with one of
     these Loop schemas, the iteration can optionally access the key
     that corresponds to the value.  The order in which the keys are
     accessed is undefined; empty slots in the hash table are ignored.

‘using’

     The loop keyword ‘using’ introduces the optional key or the keyed
     value to be accessed.  It allows access to the hash key if
     iteration is over the hash values, and the hash value if iteration
     is over the hash keys.

‘in’, ‘of’

     These loop prepositions introduce HASH-TABLE.

In effect

‘being’ {‘each’ | ‘the’} {‘hash-value’ | ‘hash-values’ | ‘hash-key’ |
‘hash-keys’} {‘in’ | ‘of’}

is a compound preposition.

Iteration stops when there are no more hash keys or hash values to be
referenced in the supplied HASH-TABLE.

6.1.2.1.7 The for-as-package subclause
......................................

In the for-as-package subclause the ‘for’ or ‘as’ construct iterates
over the symbols in a package.  In this syntax, a compound preposition
is used to designate access to a package.  The variable VAR takes on the
value of each symbol in the supplied package.  The following loop
keywords serve as valid prepositions within this syntax:

‘being’

     The keyword ‘being’ introduces either the Loop schema ‘symbol’,
     ‘present-symbol’, or ‘external-symbol’.

‘each’, ‘the’

     The loop keyword ‘each’ follows the loop keyword ‘being’ when
     ‘symbol’, ‘present-symbol’, or ‘external-symbol’ is used.  The loop
     keyword ‘the’ is used with ‘symbols’, ‘present-symbols’, and
     ‘external-symbols’ only for ease of reading.  This agreement isn’t
     required.

‘present-symbol’, ‘present-symbols’

     These Loop schemas iterate over the symbols that are present in a
     package.  The PACKAGE to be iterated over is supplied in the same
     way that package arguments to ‘find-package’ are supplied.  If the
     PACKAGE for the iteration is not supplied, the current package is
     used.  If a PACKAGE that does not exist is supplied, an error of
     type ‘package-error’ is signaled.

‘symbol’, ‘symbols’

     These Loop schemas iterate over symbols that are accessible in a
     given PACKAGE.  The PACKAGE to be iterated over is supplied in the
     same way that package arguments to ‘find-package’ are supplied.  If
     the PACKAGE for the iteration is not supplied, the current package
     is used.  If a PACKAGE that does not exist is supplied, an error of
     type ‘package-error’ is signaled.

‘external-symbol’, ‘external-symbols’

     These Loop schemas iterate over the external symbols of a PACKAGE.
     The PACKAGE to be iterated over is supplied in the same way that
     package arguments to ‘find-package’ are supplied.  If the PACKAGE
     for the iteration is not supplied, the current package is used.  If
     a PACKAGE that does not exist is supplied, an error of type
     ‘package-error’ is signaled.

‘in’, ‘of’

     These loop prepositions introduce PACKAGE.

In effect

‘being’ {‘each’ | ‘the’} {‘symbol’ | ‘symbols’ | ‘present-symbol’ |
‘present-symbols’ | ‘external-symbol’ | ‘external-symbols’} {‘in’ |
‘of’}

is a compound preposition.

Iteration stops when there are no more symbols to be referenced in the
supplied PACKAGE.

6.1.2.1.7.1 Examples of for-as-package subclause
................................................

      (let ((*package* (make-package "TEST-PACKAGE-1")))
        ;; For effect, intern some symbols
        (read-from-string "(THIS IS A TEST)")
        (export (intern "THIS"))
        (loop for x being each present-symbol of *package*
               do (print x)))
     ▷ A
     ▷ TEST
     ▷ THIS
     ▷ IS
     → NIL

6.1.2.2 Local Variable Initializations
......................................

When a ‘loop’ form is executed, the local variables are bound and are
initialized to some value.  These local variables exist until ‘loop’
iteration terminates, at which point they cease to exist.  Implicit
variables are also established by iteration control clauses and the
‘into’ preposition of accumulation clauses.

The ‘with’ construct initializes variables that are local to a loop.
The variables are initialized one time only.  If the optional TYPE-SPEC
argument is supplied for the variable VAR, but there is no related
expression to be evaluated, VAR is initialized to an appropriate default
value for its type.  For example, for the types ‘t’, ‘number’, and
‘float’, the default values are ‘nil’, ‘0’, and ‘0.0’ respectively.  The
consequences are undefined if a TYPE-SPEC argument is supplied for VAR
if the related expression returns a value that is not of the supplied
type.  By default, the ‘with’ construct initializes variables
sequentially; that is, one variable is assigned a value before the next
expression is evaluated.  However, by using the loop keyword ‘and’ to
join several ‘with’ clauses, initializations can be forced to occur in
parallel; that is, all of the supplied FORMS are evaluated, and the
results are bound to the respective variables simultaneously.

Sequential binding is used when it is desireable for the initialization
of some variables to depend on the values of previously bound variables.
For example, suppose the variables ‘a’, ‘b’, and ‘c’ are to be bound in
sequence:

      (loop with a = 1
            with b = (+ a 2)
            with c = (+ b 3)
            return (list a b c))
     → (1 3 6)

The execution of the above ‘loop’ is equivalent to the execution of the
following code:

      (block nil
        (let* ((a 1)
               (b (+ a 2))
               (c (+ b 3)))
          (tagbody
              (next-loop (return (list a b c))
                         (go next-loop)
                         end-loop))))

If the values of previously bound variables are not needed for the
initialization of other local variables, an ‘and’ clause can be used to
specify that the bindings are to occur in parallel:

      (loop with a = 1
            and b = 2
            and c = 3
            return (list a b c))
     → (1 2 3)

The execution of the above loop is equivalent to the execution of the
following code:

      (block nil
        (let ((a 1)
              (b 2)
              (c 3))
          (tagbody
              (next-loop (return (list a b c))
                         (go next-loop)
                         end-loop))))

6.1.2.2.1 Examples of WITH clause
.................................

     ;; These bindings occur in sequence.
      (loop with a = 1
            with b = (+ a 2)
            with c = (+ b 3)
            return (list a b c))
     → (1 3 6)

     ;; These bindings occur in parallel.
      (setq a 5 b 10)
     → 10
      (loop with a = 1
            and b = (+ a 2)
            and c = (+ b 3)
            return (list a b c))
     → (1 7 13)

     ;; This example shows a shorthand way to declare local variables
     ;; that are of different types.
      (loop with (a b c) of-type (float integer float)
            return (format nil "~A ~A ~A" a b c))
     → "0.0 0 0.0"

     ;; This example shows a shorthand way to declare local variables
     ;; that are the same type.
      (loop with (a b c) of-type float
            return (format nil "~A ~A ~A" a b c))
     → "0.0 0.0 0.0"


File: ansicl,  Node: Value Accumulation Clauses,  Next: Termination Test Clauses,  Prev: Variable Initialization and Stepping Clauses,  Up: The LOOP Facility

6.1.3 Value Accumulation Clauses
--------------------------------

The constructs ‘collect’, ‘collecting’, ‘append’, ‘appending’, ‘nconc’,
‘nconcing’, ‘count’, ‘counting’, ‘maximize’, ‘maximizing’, ‘minimize’,
‘minimizing’, ‘sum’, and ‘summing’, allow values to be accumulated in a
‘loop’.

The constructs ‘collect’, ‘collecting’, ‘append’, ‘appending’, ‘nconc’,
and ‘nconcing’, designate clauses that accumulate values in lists and
return them.  The constructs ‘count’, ‘counting’, ‘maximize’,
‘maximizing’, ‘minimize’, ‘minimizing’, ‘sum’, and ‘summing’ designate
clauses that accumulate and return numerical values.

During each iteration, the constructs ‘collect’ and ‘collecting’ collect
the value of the supplied FORM into a list.  When iteration terminates,
the list is returned.  The argument VAR is set to the list of collected
values; if VAR is supplied, the ‘loop’ does not return the final list
automatically.  If VAR is not supplied, it is equivalent to supplying an
internal name for VAR and returning its value in a ‘finally’ clause.
The VAR argument is bound as if by the construct ‘with’.  No mechanism
is provided for declaring the type of VAR; it must be of type ‘list’.

The constructs ‘append’, ‘appending’, ‘nconc’, and ‘nconcing’ are
similar to ‘collect’ except that the values of the supplied FORM must be
lists.

   • The ‘append’ keyword causes its list values to be concatenated into
     a single list, as if they were arguments to the function ‘append’.

   • The ‘nconc’ keyword causes its list values to be concatenated into
     a single list, as if they were arguments to the function ‘nconc’.

The argument VAR is set to the list of concatenated values; if VAR is
supplied, ‘loop’ does not return the final list automatically.  The VAR
argument is bound as if by the construct ‘with’.  A type cannot be
supplied for VAR; it must be of type ‘list’.  The construct ‘nconc’
destructively modifies its argument lists.

The ‘count’ construct counts the number of times that the supplied FORM
returns true.  The argument VAR accumulates the number of occurrences;
if VAR is supplied, ‘loop’ does not return the final count
automatically.  The VAR argument is bound as if by the construct ‘with’
to a zero of the appropriate type.  Subsequent values (including any
necessary coercions) are computed as if by the function ‘1+’.  If ‘into’
VAR is used, a type can be supplied for VAR with the TYPE-SPEC argument;
the consequences are unspecified if a nonnumeric type is supplied.  If
there is no ‘into’ variable, the optional TYPE-SPEC argument applies to
the internal variable that is keeping the count.  The default type is
implementation-dependent; but it must be a supertype of type ‘fixnum’.

The ‘maximize’ and ‘minimize’ constructs compare the value of the
supplied FORM obtained during the first iteration with values obtained
in successive iterations.  The maximum (for ‘maximize’) or minimum (for
‘minimize’) value encountered is determined (as if by the function ‘max’
for ‘maximize’ and as if by the function ‘min’ for ‘minimize’) and
returned.  If the ‘maximize’ or ‘minimize’ clause is never executed, the
accumulated value is unspecified.  The argument VAR accumulates the
maximum or minimum value; if VAR is supplied, ‘loop’ does not return the
maximum or minimum automatically.  The VAR argument is bound as if by
the construct ‘with’.  If ‘into’ VAR is used, a type can be supplied for
VAR with the TYPE-SPEC argument; the consequences are unspecified if a
nonnumeric type is supplied.  If there is no ‘into’ variable, the
optional TYPE-SPEC argument applies to the internal variable that is
keeping the maximum or minimum value.  The default type is
implementation-dependent; but it must be a supertype of type ‘real’.

The ‘sum’ construct forms a cumulative sum of the successive primary
values of the supplied FORM at each iteration.  The argument VAR is used
to accumulate the sum; if VAR is supplied, ‘loop’ does not return the
final sum automatically.  The VAR argument is bound as if by the
construct ‘with’ to a zero of the appropriate type.  Subsequent values
(including any necessary coercions) are computed as if by the function
‘+’.  If ‘into’ VAR is used, a type can be supplied for VAR with the
TYPE-SPEC argument; the consequences are unspecified if a nonnumeric
type is supplied.  If there is no ‘into’ variable, the optional
TYPE-SPEC argument applies to the internal variable that is keeping the
sum.  The default type is implementation-dependent; but it must be a
supertype of type ‘number’.

If ‘into’ is used, the construct does not provide a default return
value; however, the variable is available for use in any ‘finally’
clause.

Certain kinds of accumulation clauses can be combined in a ‘loop’ if
their destination is the same (the result of ‘loop’ or an ‘into’ VAR)
because they are considered to accumulate conceptually compatible
quantities.  In particular, any elements of following sets of
accumulation clauses can be mixed with other elements of the same set
for the same destination in a ‘loop’ form:

   • ‘collect’, ‘append’, ‘nconc’

   • ‘sum’, ‘count’

   • ‘maximize’, ‘minimize’

     ;; Collect every name and the kids in one list by using
     ;; COLLECT and APPEND.
      (loop for name in '(fred sue alice joe june)
            for kids in '((bob ken) () () (kris sunshine) ())
            collect name
            append kids)
     → (FRED BOB KEN SUE ALICE JOE KRIS SUNSHINE JUNE)

Any two clauses that do not accumulate the same type of object can
coexist in a ‘loop’ only if each clause accumulates its values into a
different variable.

6.1.3.1 Examples of COLLECT clause
..................................

     ;; Collect all the symbols in a list.
      (loop for i in '(bird 3 4 turtle (1 . 4) horse cat)
            when (symbolp i) collect i)
     → (BIRD TURTLE HORSE CAT)

     ;; Collect and return odd numbers.
      (loop for i from 1 to 10
            if (oddp i) collect i)
     → (1 3 5 7 9)

     ;; Collect items into local variable, but don't return them.
      (loop for i in '(a b c d) by #'cddr
            collect i into my-list
            finally (print my-list))
     ▷ (A C)
     → NIL

6.1.3.2 Examples of APPEND and NCONC clauses
............................................

     ;; Use APPEND to concatenate some sublists.
       (loop for x in '((a) (b) ((c)))
             append x)
     → (A B (C))

     ;; NCONC some sublists together.  Note that only lists made by the
     ;; call to LIST are modified.
       (loop for i upfrom 0
             as x in '(a b (c))
             nconc (if (evenp i) (list x) nil))
     → (A (C))

6.1.3.3 Examples of COUNT clause
................................

      (loop for i in '(a b nil c nil d e)
            count i)
     → 5

6.1.3.4 Examples of MAXIMIZE and MINIMIZE clauses
.................................................

      (loop for i in '(2 1 5 3 4)
            maximize i)
     → 5
      (loop for i in '(2 1 5 3 4)
            minimize i)
     → 1

     ;; In this example, FIXNUM applies to the internal variable that holds
     ;; the maximum value.
      (setq series '(1.2 4.3 5.7))
     → (1.2 4.3 5.7)
      (loop for v in series
            maximize (round v) of-type fixnum)
     → 6

     ;; In this example, FIXNUM applies to the variable RESULT.
      (loop for v of-type float in series
            minimize (round v) into result of-type fixnum
            finally (return result))
     → 1

6.1.3.5 Examples of SUM clause
..............................

      (loop for i of-type fixnum in '(1 2 3 4 5)
            sum i)
     → 15
      (setq series '(1.2 4.3 5.7))
     → (1.2 4.3 5.7)
      (loop for v in series
            sum (* 2.0 v))
     → 22.4


File: ansicl,  Node: Termination Test Clauses,  Next: Unconditional Execution Clauses,  Prev: Value Accumulation Clauses,  Up: The LOOP Facility

6.1.4 Termination Test Clauses
------------------------------

The ‘repeat’ construct causes iteration to terminate after a specified
number of times.  The loop body executes n times, where n is the value
of the expression FORM.  The FORM argument is evaluated one time in the
loop prologue.  If the expression evaluates to 0 or to a negative
number, the loop body is not evaluated.

The constructs ‘always’, ‘never’, ‘thereis’, ‘while’, ‘until’, and the
macro ‘loop-finish’ allow conditional termination of iteration within a
‘loop’.

The constructs ‘always’, ‘never’, and ‘thereis’ provide specific values
to be returned when a ‘loop’ terminates.  Using ‘always’, ‘never’, or
‘thereis’ in a loop with value accumulation clauses that are not ‘into’
causes an error of type ‘program-error’ to be signaled (at macro
expansion time).  Since ‘always’, ‘never’, and ‘thereis’ use the
‘return-from’ special operator to terminate iteration, any ‘finally’
clause that is supplied is not evaluated when exit occurs due to any of
these constructs.  In all other respects these constructs behave like
the ‘while’ and ‘until’ constructs.

The ‘always’ construct takes one form and terminates the ‘loop’ if the
form ever evaluates to ‘nil’; in this case, it returns ‘nil’.
Otherwise, it provides a default return value of ‘t’.  If the value of
the supplied form is never ‘nil’, some other construct can terminate the
iteration.

The ‘never’ construct terminates iteration the first time that the value
of the supplied FORM is non-nil; the ‘loop’ returns ‘nil’.  If the value
of the supplied FORM is always ‘nil’, some other construct can terminate
the iteration.  Unless some other clause contributes a return value, the
default value returned is ‘t’.

The ‘thereis’ construct terminates iteration the first time that the
value of the supplied FORM is non-nil; the ‘loop’ returns the value of
the supplied FORM.  If the value of the supplied FORM is always ‘nil’,
some other construct can terminate the iteration.  Unless some other
clause contributes a return value, the default value returned is ‘nil’.

There are two differences between the ‘thereis’ and ‘until’ constructs:

   • The ‘until’ construct does not return a value or ‘nil’ based on the
     value of the supplied FORM.

   • The ‘until’ construct executes any ‘finally’ clause.  Since
     ‘thereis’ uses the ‘return-from’ special operator to terminate
     iteration, any ‘finally’ clause that is supplied is not evaluated
     when exit occurs due to ‘thereis’.

The ‘while’ construct allows iteration to continue until the supplied
FORM evaluates to false.  The supplied FORM is reevaluated at the
location of the ‘while’ clause.

The ‘until’ construct is equivalent to ‘while (not FORM)...’.  If the
value of the supplied FORM is non-nil, iteration terminates.

Termination-test control constructs can be used anywhere within the loop
body.  The termination tests are used in the order in which they appear.
If an ‘until’ or ‘while’ clause causes termination, any clauses that
precede it in the source are still evaluated.  If the ‘until’ and
‘while’ constructs cause termination, control is passed to the loop
epilogue, where any ‘finally’ clauses will be executed.

There are two differences between the ‘never’ and ‘until’ constructs:

   • The ‘until’ construct does not return ‘t’ or ‘nil’ based on the
     value of the supplied FORM.

   • The ‘until’ construct does not bypass any ‘finally’ clauses.  Since
     ‘never’ uses the ‘return-from’ special operator to terminate
     iteration, any ‘finally’ clause that is supplied is not evaluated
     when exit occurs due to ‘never’.

In most cases it is not necessary to use ‘loop-finish’ because other
loop control clauses terminate the ‘loop’.  The macro ‘loop-finish’ is
used to provide a normal exit from a nested conditional inside a ‘loop’.
Since ‘loop-finish’ transfers control to the loop epilogue, using
‘loop-finish’ within a ‘finally’ expression can cause infinite looping.

6.1.4.1 Examples of REPEAT clause
.................................

      (loop repeat 3
            do (format t "~&What I say three times is true.~%"))
     ▷ What I say three times is true.
     ▷ What I say three times is true.
     ▷ What I say three times is true.
     → NIL
      (loop repeat -15
        do (format t "What you see is what you expect~%"))
     → NIL

6.1.4.2 Examples of ALWAYS, NEVER, and THEREIS clauses
......................................................

     ;; Make sure I is always less than 11 (two ways).
     ;; The FOR construct terminates these loops.
      (loop for i from 0 to 10
            always (< i 11))
     → T
      (loop for i from 0 to 10
            never (> i 11))
     → T

     ;; If I exceeds 10 return I; otherwise, return NIL.
     ;; The THEREIS construct terminates this loop.
      (loop for i from 0
            thereis (when (> i 10) i) )
     → 11

     ;;; The FINALLY clause is not evaluated in these examples.
      (loop for i from 0 to 10
            always (< i 9)
            finally (print "you won't see this"))
     → NIL
      (loop never t
            finally (print "you won't see this"))
     → NIL
      (loop thereis "Here is my value"
            finally (print "you won't see this"))
     → "Here is my value"

     ;; The FOR construct terminates this loop, so the FINALLY clause
     ;; is evaluated.
      (loop for i from 1 to 10
            thereis (> i 11)
            finally (prin1 'got-here))
     ▷ GOT-HERE
     → NIL

     ;; If this code could be used to find a counterexample to Fermat's
     ;; last theorem, it would still not return the value of the
     ;; counterexample because all of the THEREIS clauses in this example
     ;; only return T.  But if Fermat is right, that won't matter
     ;; because this won't terminate.

      (loop for z upfrom 2
            thereis
              (loop for n upfrom 3 below (log z 2)
                    thereis
                      (loop for x below z
                            thereis
                              (loop for y below z
                                    thereis (= (+ (expt x n) (expt y n))
                                               (expt z n))))))

6.1.4.3 Examples of WHILE and UNTIL clauses
...........................................

      (loop while (hungry-p) do (eat))

     ;; UNTIL NOT is equivalent to WHILE.
      (loop until (not (hungry-p)) do (eat))

     ;; Collect the length and the items of STACK.
      (let ((stack '(a b c d e f)))
        (loop for item = (length stack) then (pop stack)
              collect item
              while stack))
     → (6 A B C D E F)

     ;; Use WHILE to terminate a loop that otherwise wouldn't terminate.
     ;; Note that WHILE occurs after the WHEN.
      (loop for i fixnum from 3
            when (oddp i) collect i
            while (< i 5))
     → (3 5)


File: ansicl,  Node: Unconditional Execution Clauses,  Next: Conditional Execution Clauses,  Prev: Termination Test Clauses,  Up: The LOOP Facility

6.1.5 Unconditional Execution Clauses
-------------------------------------

The ‘do’ and ‘doing’ constructs evaluate the supplied FORMS wherever
they occur in the expanded form of ‘loop’.  The FORM argument can be any
compound form.  Each FORM is evaluated in every iteration.  Because
every loop clause must begin with a loop keyword, the keyword ‘do’ is
used when no control action other than execution is required.

The ‘return’ construct takes one form.  Any values returned by the form
are immediately returned by the ‘loop’ form.  It is equivalent to the
clause ‘do (return-from block-name value)’, where block-name is the name
specified in a ‘named’ clause, or ‘nil’ if there is no ‘named’ clause.

6.1.5.1 Examples of unconditional execution
...........................................

     ;; Print numbers and their squares.
     ;; The DO construct applies to multiple forms.
      (loop for i from 1 to 3
            do (print i)
               (print (* i i)))
     ▷ 1
     ▷ 1
     ▷ 2
     ▷ 4
     ▷ 3
     ▷ 9
     → NIL



File: ansicl,  Node: Conditional Execution Clauses,  Next: Miscellaneous Clauses,  Prev: Unconditional Execution Clauses,  Up: The LOOP Facility

6.1.6 Conditional Execution Clauses
-----------------------------------

The ‘if’, ‘when’, and ‘unless’ constructs establish conditional control
in a ‘loop’.  If the test passes, the succeeding loop clause is
executed.  If the test does not pass, the succeeding clause is skipped,
and program control moves to the clause that follows the loop keyword
‘else’.  If the test does not pass and no ‘else’ clause is supplied,
control is transferred to the clause or construct following the entire
conditional clause.

If conditional clauses are nested, each ‘else’ is paired with the
closest preceding conditional clause that has no associated ‘else’ or
‘end’.

In the ‘if’ and ‘when’ clauses, which are synonymous, the test passes if
the value of FORM is true.

In the ‘unless’ clause, the test passes if the value of FORM is false.

Clauses that follow the test expression can be grouped by using the loop
keyword ‘and’ to produce a conditional block consisting of a compound
clause.

The loop keyword ‘it’ can be used to refer to the result of the test
expression in a clause.  Use the loop keyword ‘it’ in place of the form
in a ‘return’ clause or an accumulation clause that is inside a
conditional execution clause.  If multiple clauses are connected with
‘and’, the ‘it’ construct must be in the first clause in the block.

The optional loop keyword ‘end’ marks the end of the clause.  If this
keyword is not supplied, the next loop keyword marks the end.  The
construct ‘end’ can be used to distinguish the scoping of compound
clauses.

6.1.6.1 Examples of WHEN clause
...............................

     ;; Signal an exceptional condition.
      (loop for item in '(1 2 3 a 4 5)
            when (not (numberp item))
             return (cerror "enter new value" "non-numeric value: ~s" item))
     Error: non-numeric value: A

     ;; The previous example is equivalent to the following one.
      (loop for item in '(1 2 3 a 4 5)
            when (not (numberp item))
             do (return
                 (cerror "Enter new value" "non-numeric value: ~s" item)))
     Error: non-numeric value: A

     ;; This example parses a simple printed string representation from
     ;; BUFFER (which is itself a string) and returns the index of the
     ;; closing double-quote character.
      (let ((buffer "\"a\" \"b\""))
        (loop initially (unless (char= (char buffer 0) #\")
                          (loop-finish))
              for i of-type fixnum from 1 below (length (the string buffer))
              when (char= (char buffer i) #\")
               return i))
     → 2

     ;; The collected value is returned.
      (loop for i from 1 to 10
            when (> i 5)
              collect i
            finally (prin1 'got-here))
     ▷ GOT-HERE
     → (6 7 8 9 10)

     ;; Return both the count of collected numbers and the numbers.
      (loop for i from 1 to 10
            when (> i 5)
              collect i into number-list
              and count i into number-count
            finally (return (values number-count number-list)))
     → 5, (6 7 8 9 10)


File: ansicl,  Node: Miscellaneous Clauses,  Next: Examples of Miscellaneous Loop Features,  Prev: Conditional Execution Clauses,  Up: The LOOP Facility

6.1.7 Miscellaneous Clauses
---------------------------

6.1.7.1 Control Transfer Clauses
................................

The ‘named’ construct establishes a name for an implicit block
surrounding the entire ‘loop’ so that the ‘return-from’ special operator
can be used to return values from or to exit ‘loop’.  Only one name per
‘loop’ form can be assigned.  If used, the ‘named’ construct must be the
first clause in the loop expression.

The ‘return’ construct takes one form.  Any values returned by the form
are immediately returned by the ‘loop’ form.  This construct is similar
to the ‘return-from’ special operator and the ‘return’ macro.  The
‘return’ construct does not execute any ‘finally’ clause that the ‘loop’
form is given.

6.1.7.1.1 Examples of NAMED clause
..................................

     ;; Just name and return.
      (loop named max
            for i from 1 to 10
            do (print i)
            do (return-from max 'done))
     ▷ 1
     → DONE

6.1.7.2 Initial and Final Execution
...................................

The ‘initially’ and ‘finally’ constructs evaluate forms that occur
before and after the loop body.

The ‘initially’ construct causes the supplied COMPOUND-FORMS to be
evaluated in the loop prologue, which precedes all loop code except for
initial settings supplied by constructs ‘with’, ‘for’, or ‘as’.  The
code for any ‘initially’ clauses is executed in the order in which the
clauses appeared in the ‘loop’.

The ‘finally’ construct causes the supplied COMPOUND-FORMS to be
evaluated in the loop epilogue after normal iteration terminates.  The
code for any ‘finally’ clauses is executed in the order in which the
clauses appeared in the ‘loop’.  The collected code is executed once in
the loop epilogue before any implicit values are returned from the
accumulation clauses.  An explicit transfer of control (e.g., by
‘return’, ‘go’, or ‘throw’) from the loop body, however, will exit the
‘loop’ without executing the epilogue code.

Clauses such as ‘return’, ‘always’, ‘never’, and ‘thereis’ can bypass
the ‘finally’ clause.  ‘return’ (or ‘return-from’, if the ‘named’ option
was supplied) can be used after ‘finally’ to return values from a
‘loop’.  Such an explicit return inside the ‘finally’ clause takes
precedence over returning the accumulation from clauses supplied by such
keywords as ‘collect’, ‘nconc’, ‘append’, ‘sum’, ‘count’, ‘maximize’,
and ‘minimize’; the accumulation values for these preempted clauses are
not returned by ‘loop’ if ‘return’ or ‘return-from’ is used.


File: ansicl,  Node: Examples of Miscellaneous Loop Features,  Next: Notes about Loop,  Prev: Miscellaneous Clauses,  Up: The LOOP Facility

6.1.8 Examples of Miscellaneous Loop Features
---------------------------------------------

      (let ((i 0))                     ; no loop keywords are used
         (loop (incf i) (if (= i 3) (return i)))) → 3
      (let ((i 0)(j 0))
         (tagbody
           (loop (incf j 3) (incf i) (if (= i 3) (go exit)))
           exit)
         j) → 9

In the following example, the variable ‘x’ is stepped before ‘y’ is
stepped; thus, the value of ‘y’ reflects the updated value of ‘x’:

      (loop for x from 1 to 10
            for y = nil then x
            collect (list x y))
     → ((1 NIL) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9) (10 10))

In this example, ‘x’ and ‘y’ are stepped in parallel:

      (loop for x from 1 to 10
            and y = nil then x
            collect (list x y))
     → ((1 NIL) (2 1) (3 2) (4 3) (5 4) (6 5) (7 6) (8 7) (9 8) (10 9))

6.1.8.1 Examples of clause grouping
...................................

     ;; Group conditional clauses.
      (loop for i in '(1 324 2345 323 2 4 235 252)
            when (oddp i)
              do (print i)
              and collect i into odd-numbers
              and do (terpri)
            else                              ; I is even.
              collect i into even-numbers
            finally
              (return (values odd-numbers even-numbers)))
     ▷ 1
     ▷
     ▷ 2345
     ▷
     ▷ 323
     ▷
     ▷ 235
     → (1 2345 323 235), (324 2 4 252)

     ;; Collect numbers larger than 3.
      (loop for i in '(1 2 3 4 5 6)
            when (and (> i 3) i)
            collect it)                      ; IT refers to (and (> i 3) i).
     → (4 5 6)

     ;; Find a number in a list.
      (loop for i in '(1 2 3 4 5 6)
            when (and (> i 3) i)
            return it)
     → 4

     ;; The above example is similar to the following one.
      (loop for i in '(1 2 3 4 5 6)
            thereis (and (> i 3) i))
     → 4

      
      
     ;; Nest conditional clauses.
      (let ((list '(0 3.0 apple 4 5 9.8 orange banana)))
        (loop for i in list
              when (numberp i)
                when (floatp i)
                  collect i into float-numbers
                else                                  ; Not (floatp i)
                  collect i into other-numbers
              else                                    ; Not (numberp i)
                when (symbolp i)
                  collect i into symbol-list
                else                                  ; Not (symbolp i)
                  do (error "found a funny value in list ~S, value ~S~%" list i)
              finally (return (values float-numbers other-numbers symbol-list))))
     → (3.0 9.8), (0 4 5), (APPLE ORANGE BANANA)

     ;; Without the END preposition, the last AND would apply to the
     ;; inner IF rather than the outer one.
      (loop for x from 0 to 3
            do (print x)
            if (zerop (mod x 2))
              do (princ " a")
               and if (zerop (floor x 2))
                     do (princ " b")
                     end
               and do (princ " c"))
     ▷ 0  a b c
     ▷ 1
     ▷ 2  a c
     ▷ 3
     → NIL


File: ansicl,  Node: Notes about Loop,  Prev: Examples of Miscellaneous Loop Features,  Up: The LOOP Facility

6.1.9 Notes about Loop
----------------------

Types can be supplied for loop variables.  It is not necessary to supply
a type for any variable, but supplying the type can ensure that the
variable has a correctly typed initial value, and it can also enable
compiler optimizations (depending on the implementation).

The clause ‘repeat’ n ...  is roughly equivalent to a clause such as

      (loop for internal-variable downfrom (- n 1) to 0 ...)

but in some implementations, the ‘repeat’ construct might be more
efficient.

Within the executable parts of the loop clauses and around the entire
‘loop’ form, variables can be bound by using ‘let’.

Use caution when using a variable named ‘IT’ (in any package) in
connection with ‘loop’, since ‘it’ is a loop keyword that can be used in
place of a form in certain contexts.

There is no standardized mechanism for users to add extensions to
‘loop’.


File: ansicl,  Node: do; do*,  Next: dotimes,  Prev: The LOOP Facility,  Up: Iteration

do, do* (Macro)
===============

Syntax:
.......

 -- Macro: do ({VAR | (var [init-form [step-form]])}*)
          (end-test-form {result-form}*)
          {declaration}* {tag | statement}* → {result}*

 -- Macro: do* ({VAR | (var [init-form [step-form]])}*)
          (end-test-form {result-form}*)
          {declaration}* {tag | statement}* → {result}*

Arguments and Values:
.....................

VAR—a symbol.

INIT-FORM—a form.

STEP-FORM—a form.

END-TEST-FORM—a form.

RESULT-FORMS—an implicit progn.

DECLARATION—a declare expression; not evaluated.

TAG—a go tag; not evaluated.

STATEMENT—a compound form; evaluated as described below.

RESULTS—if a ‘return’ or ‘return-from’ form is executed, the values
passed from that form; otherwise, the values returned by the
RESULT-FORMS.

Description:
............

‘do’ iterates over a group of STATEMENTS while a test condition holds.
‘do’ accepts an arbitrary number of iteration VARS which are bound
within the iteration and stepped in parallel.  An initial value may be
supplied for each iteration variable by use of an INIT-FORM.  STEP-FORMS
may be used to specify how the VARS should be updated on succeeding
iterations through the loop.  STEP-FORMS may be used both to generate
successive values or to accumulate results.  If the END-TEST-FORM
condition is met prior to an execution of the body, the iteration
terminates.  TAGS label STATEMENTS.

‘do*’ is exactly like ‘do’ except that the bindings and steppings of the
VARS are performed sequentially rather than in parallel.

Before the first iteration, all the INIT-FORMS are evaluated, and each
VAR is bound to the value of its respective INIT-FORM, if supplied.
This is a binding, not an assignment; when the loop terminates, the old
values of those variables will be restored.  For ‘do’, all of the
INIT-FORMS are evaluated before any VAR is bound.  The INIT-FORMS can
refer to the bindings of the VARS visible before beginning execution of
‘do’.  For ‘do*’, the first INIT-FORM is evaluated, then the first VAR
is bound to that value, then the second INIT-FORM is evaluated, then the
second VAR is bound, and so on; in general, the kth INIT-FORM can refer
to the new binding of the jth VAR if j < k, and otherwise to the old
binding of the jth VAR.

At the beginning of each iteration, after processing the variables, the
END-TEST-FORM is evaluated.  If the result is false, execution proceeds
with the body of the ‘do’ (or ‘do*’) form.  If the result is true, the
RESULT-FORMS are evaluated in order as an implicit progn, and then ‘do’
or ‘do*’ returns.

At the beginning of each iteration other than the first, VARS are
updated as follows.  All the STEP-FORMS, if supplied, are evaluated,
from left to right, and the resulting values are assigned to the
respective VARS.  Any VAR that has no associated STEP-FORM is not
assigned to.  For ‘do’, all the STEP-FORMS are evaluated before any VAR
is updated; the assignment of values to VARS is done in parallel, as if
by ‘psetq’.  Because all of the STEP-FORMS are evaluated before any of
the VARS are altered, a STEP-FORM when evaluated always has access to
the old values of all the VARS, even if other STEP-FORMS precede it.
For ‘do*’, the first STEP-FORM is evaluated, then the value is assigned
to the first VAR, then the second STEP-FORM is evaluated, then the value
is assigned to the second VAR, and so on; the assignment of values to
variables is done sequentially, as if by ‘setq’.  For either ‘do’ or
‘do*’, after the VARS have been updated, the END-TEST-FORM is evaluated
as described above, and the iteration continues.

The remainder of the ‘do’ (or ‘do*’) form constitutes an implicit
tagbody.  TAGS may appear within the body of a ‘do’ loop for use by ‘go’
statements appearing in the body (but such ‘go’ statements may not
appear in the variable specifiers, the END-TEST-FORM, or the
RESULT-FORMS).  When the end of a ‘do’ body is reached, the next
iteration cycle (beginning with the evaluation of STEP-FORMS) occurs.

An implicit block named ‘nil’ surrounds the entire ‘do’ (or ‘do*’) form.
A ‘return’ statement may be used at any point to exit the loop
immediately.

INIT-FORM is an initial value for the VAR with which it is associated.
If INIT-FORM is omitted, the initial value of VAR is ‘nil’.  If a
DECLARATION is supplied for a VAR, INIT-FORM must be consistent with the
DECLARATION.

DECLARATIONS can appear at the beginning of a ‘do’ (or ‘do*’) body.
They apply to code in the ‘do’ (or ‘do*’) body, to the bindings of the
‘do’ (or ‘do*’) VARS, to the STEP-FORMS, to the END-TEST-FORM, and to
the RESULT-FORMS.

Examples:
.........

      (do ((temp-one 1 (1+ temp-one))
            (temp-two 0 (1- temp-two)))
           ((> (- temp-one temp-two) 5) temp-one)) → 4

      (do ((temp-one 1 (1+ temp-one))
            (temp-two 0 (1+ temp-one)))
           ((= 3 temp-two) temp-one)) → 3

      (do* ((temp-one 1 (1+ temp-one))
             (temp-two 0 (1+ temp-one)))
            ((= 3 temp-two) temp-one)) → 2

      (do ((j 0 (+ j 1)))
          (nil)                       ;Do forever.
        (format t "~%Input ~D:" j)
        (let ((item (read)))
          (if (null item) (return)   ;Process items until NIL seen.
              (format t "~&Output ~D: ~S" j item))))
     ▷ Input 0: banana
     ▷ Output 0: BANANA
     ▷ Input 1: (57 boxes)
     ▷ Output 1: (57 BOXES)
     ▷ Input 2: NIL
     → NIL

      (setq a-vector (vector 1 nil 3 nil))
      (do ((i 0 (+ i 1))     ;Sets every null element of a-vector to zero.
           (n (array-dimension a-vector 0)))
          ((= i n))
        (when (null (aref a-vector i))
          (setf (aref a-vector i) 0))) → NIL
     a-vector → #(1 0 3 0)

      (do ((x e (cdr x))
           (oldx x x))
          ((null x))
        body)

is an example of parallel assignment to index variables.  On the first
iteration, the value of ‘oldx’ is whatever value ‘x’ had before the ‘do’
was entered.  On succeeding iterations, ‘oldx’ contains the value that
‘x’ had on the previous iteration.

      (do ((x foo (cdr x))
           (y bar (cdr y))
           (z '() (cons (f (car x) (car y)) z)))
          ((or (null x) (null y))
           (nreverse z)))

does the same thing as ‘(mapcar #'f foo bar)’.  The step computation for
‘z’ is an example of the fact that variables are stepped in parallel.
Also, the body of the loop is empty.

      (defun list-reverse (list)
             (do ((x list (cdr x))
                  (y '() (cons (car x) y)))
                 ((endp x) y)))

As an example of nested iterations, consider a data structure that is a
list of conses.  The car of each cons is a list of symbols, and the cdr
of each cons is a list of equal length containing corresponding values.
Such a data structure is similar to an association list, but is divided
into “frames”; the overall structure resembles a rib-cage.  A lookup
function on such a data structure might be:

      (defun ribcage-lookup (sym ribcage)
             (do ((r ribcage (cdr r)))
                 ((null r) nil)
               (do ((s (caar r) (cdr s))
                    (v (cdar r) (cdr v)))
                   ((null s))
                 (when (eq (car s) sym)
                   (return-from ribcage-lookup (car v)))))) → RIBCAGE-LOOKUP

See Also:
.........

other iteration functions (*note dolist::, *note dotimes::, and *note
loop::) and more primitive functionality (*note tagbody::, *note go::,
*note block::, *note return::, *note let::, and *note setq::)

Notes:
......

If END-TEST-FORM is ‘nil’, the test will never succeed.  This provides
an idiom for “do forever”: the body of the ‘do’ or ‘do*’ is executed
repeatedly.  The infinite loop can be terminated by the use of ‘return’,
‘return-from’, ‘go’ to an outer level, or ‘throw’.

A ‘do’ form may be explained in terms of the more primitive forms
‘block’, ‘return’, ‘let’, ‘loop’, ‘tagbody’, and ‘psetq’ as follows:

      (block nil
        (let ((var1 init1)
              (var2 init2)
              ...
              (varn initn))
          declarations
          (loop (when end-test (return (progn . result)))
                (tagbody . tagbody)
                (psetq var1 step1
                       var2 step2
                       ...
                       varn stepn))))

‘do*’ is similar, except that ‘let*’ and ‘setq’ replace the ‘let’ and
‘psetq’, respectively.


File: ansicl,  Node: dotimes,  Next: dolist,  Prev: do; do*,  Up: Iteration

dotimes (Macro)
===============

Syntax:
.......

 -- Macro: dotimes (var count-form [result-form]) {declaration}* {tag |
          statement}* → {result}*

Arguments and Values:
.....................

VAR—a symbol.

COUNT-FORM—a form.

RESULT-FORM—a form.

DECLARATION—a declare expression; not evaluated.

TAG—a go tag; not evaluated.

STATEMENT—a compound form; evaluated as described below.

RESULTS—if a ‘return’ or ‘return-from’ form is executed, the values
passed from that form; otherwise, the values returned by the RESULT-FORM
or ‘nil’ if there is no RESULT-FORM.

Description:
............

‘dotimes’ iterates over a series of integers.

‘dotimes’ evaluates COUNT-FORM, which should produce an integer.  If
COUNT-FORM is zero or negative, the body is not executed.  ‘dotimes’
then executes the body once for each integer from 0 up to but not
including the value of COUNT-FORM, in the order in which the TAGS and
STATEMENTS occur, with VAR bound to each integer.  Then RESULT-FORM is
evaluated.  At the time RESULT-FORM is processed, VAR is bound to the
number of times the body was executed.  TAGS label STATEMENTS.

An implicit block named ‘nil’ surrounds ‘dotimes’.  ‘return’ may be used
to terminate the loop immediately without performing any further
iterations, returning zero or more values.

The body of the loop is an implicit tagbody; it may contain tags to
serve as the targets of ‘go’ statements.  Declarations may appear before
the body of the loop.

The scope of the binding of VAR does not include the COUNT-FORM, but the
RESULT-FORM is included.

It is implementation-dependent whether ‘dotimes’ establishes a new
binding of VAR on each iteration or whether it establishes a binding for
VAR once at the beginning and then ASSIGNS it on any subsequent
iterations.

Examples:
.........

      (dotimes (temp-one 10 temp-one)) → 10
      (setq temp-two 0) → 0
      (dotimes (temp-one 10 t) (incf temp-two)) → T
      temp-two → 10

Here is an example of the use of ‘dotimes’ in processing strings:

     ;;; True if the specified subsequence of the string is a
     ;;; palindrome (reads the same forwards and backwards).
      (defun palindromep (string &optional
                                (start 0)
                                (end (length string)))
        (dotimes (k (floor (- end start) 2) t)
         (unless (char-equal (char string (+ start k))
                             (char string (- end k 1)))
           (return nil))))
      (palindromep "Able was I ere I saw Elba") → T
      (palindromep "A man, a plan, a canal--Panama!") → NIL
      (remove-if-not #'alpha-char-p          ;Remove punctuation.
                    "A man, a plan, a canal--Panama!")
     → "AmanaplanacanalPanama"
      (palindromep
       (remove-if-not #'alpha-char-p
                     "A man, a plan, a canal--Panama!")) → T
      (palindromep
       (remove-if-not
        #'alpha-char-p
        "Unremarkable was I ere I saw Elba Kramer, nu?")) → T
      (palindromep
       (remove-if-not
        #'alpha-char-p
        "A man, a plan, a cat, a ham, a yak,
                       a yam, a hat, a canal--Panama!")) → T

See Also:
.........

*note do::, *note dolist::, *note tagbody::

Notes:
......

‘go’ may be used within the body of ‘dotimes’ to transfer control to a
statement labeled by a TAG.


File: ansicl,  Node: dolist,  Next: loop,  Prev: dotimes,  Up: Iteration

dolist (Macro)
==============

Syntax:
.......

 -- Macro: dolist (var list-form [result-form]) {declaration}* {tag |
          statement}* → {result}*

Arguments and Values:
.....................

VAR—a symbol.

LIST-FORM—a form.

RESULT-FORM—a form.

DECLARATION—a declare expression; not evaluated.

TAG—a go tag; not evaluated.

STATEMENT—a compound form; evaluated as described below.

RESULTS—if a ‘return’ or ‘return-from’ form is executed, the values
passed from that form; otherwise, the values returned by the RESULT-FORM
or ‘nil’ if there is no RESULT-FORM.

Description:
............

‘dolist’ iterates over the elements of a list.  The body of ‘dolist’ is
like a ‘tagbody’.  It consists of a series of TAGS and STATEMENTS.

‘dolist’ evaluates LIST-FORM, which should produce a list.  It then
executes the body once for each element in the list, in the order in
which the TAGS and STATEMENTS occur, with VAR bound to the element.
Then RESULT-FORM is evaluated.  TAGS label STATEMENTS.

At the time RESULT-FORM is processed, VAR is bound to ‘nil’.

An implicit block named ‘nil’ surrounds ‘dolist’.  ‘return’ may be used
to terminate the loop immediately without performing any further
iterations, returning zero or more values.

The scope of the binding of VAR does not include the LIST-FORM, but the
RESULT-FORM is included.

It is implementation-dependent whether ‘dolist’ establishes a new
binding of VAR on each iteration or whether it establishes a binding for
VAR once at the beginning and then ASSIGNS it on any subsequent
iterations.

Examples:
.........

      (setq temp-two '()) → NIL
      (dolist (temp-one '(1 2 3 4) temp-two) (push temp-one temp-two)) → (4 3 2 1)

      (setq temp-two 0) → 0
      (dolist (temp-one '(1 2 3 4)) (incf temp-two)) → NIL
      temp-two → 4

      (dolist (x '(a b c d)) (prin1 x) (princ " "))
     ▷ A B C D
     → NIL

See Also:
.........

*note do::, *note dotimes::, *note tagbody::, *note Section 3.6
(Traversal Rules and Side Effects): Traversal Rules and Side Effects.

Notes:
......

‘go’ may be used within the body of ‘dolist’ to transfer control to a
statement labeled by a TAG.


File: ansicl,  Node: loop,  Next: loop-finish,  Prev: dolist,  Up: Iteration

loop (Macro)
============

Syntax:
.......

The “simple” ‘loop’ form:

 -- Macro: loop {compound-form}* → {result}*

The “extended” ‘loop’ form:

 -- Macro: loop [↓name-clause] {↓variable-clause}* {↓main-clause}* →
          {result}*

NAME-CLAUSE::=
     ‘named’ NAME
VARIABLE-CLAUSE::=
     ↓with-clause | ↓initial-final | ↓for-as-clause
WITH-CLAUSE::=
     ‘with’ VAR1 [TYPE-SPEC] [= FORM1] {‘and’ VAR2 [TYPE-SPEC] [=
     FORM2]}*
MAIN-CLAUSE::=
     ↓unconditional | ↓accumulation | ↓conditional | ↓termination-test |
     ↓initial-final
INITIAL-FINAL::=
     ‘initially’ {COMPOUND-FORM}+ | ‘finally’ {COMPOUND-FORM}+
UNCONDITIONAL::=
     {‘do’ | ‘doing’} {COMPOUND-FORM}+ | ‘return’ {FORM | ‘it’}
ACCUMULATION::=
     ↓list-accumulation | ↓numeric-accumulation
LIST-ACCUMULATION::=
     {‘collect’ | ‘collecting’ | ‘append’ | ‘appending’ | ‘nconc’ |
     ‘nconcing’} {FORM | ‘it’}
     [‘into’ SIMPLE-VAR]
NUMERIC-ACCUMULATION::=
     {‘count’ | ‘counting’ | ‘sum’ | ‘summing’ |
     {‘maximize’ | ‘maximizing’ | ‘minimize’ | ‘minimizing’} {FORM |
     ‘it’}
     [‘into’ SIMPLE-VAR] [TYPE-SPEC]
CONDITIONAL::=
     {‘if’ | ‘when’ | ‘unless’} FORM ↓selectable-clause {‘and’
     ↓selectable-clause}*
     [‘else’ ↓selectable-clause {‘and’ ↓selectable-clause}*]
     [‘end’]
SELECTABLE-CLAUSE::=
     ↓unconditional | ↓accumulation | ↓conditional
TERMINATION-TEST::=
     ‘while’ FORM | ‘until’ FORM | ‘repeat’ FORM | ‘always’ FORM |
     ‘never’ FORM | ‘thereis’ FORM
FOR-AS-CLAUSE::=
     {‘for’ | ‘as’} ↓for-as-subclause {‘and’ ↓for-as-subclause}*
FOR-AS-SUBCLAUSE::=
     ↓for-as-arithmetic | ↓for-as-in-list | ↓for-as-on-list |
     ↓for-as-equals-then |
     ↓for-as-across | ↓for-as-hash | ↓for-as-package
FOR-AS-ARITHMETIC::=
     VAR [TYPE-SPEC] ↓for-as-arithmetic-subclause
FOR-AS-ARITHMETIC-SUBCLAUSE::=
     ↓arithmetic-up | ↓arithmetic-downto | ↓arithmetic-downfrom
ARITHMETIC-UP::=
     〚{‘from’ | ‘upfrom’} FORM1 | 〚{‘to’ | ‘upto’ | ‘below’} FORM2 | 〚
     ‘by’ FORM3〛
ARITHMETIC-DOWNTO::=
     〚{‘from’ FORM1}¹ | 〚{{‘downto’ | ‘above’} FORM2}¹ | 〚‘by’ FORM3〛
ARITHMETIC-DOWNFROM::=
     〚{‘downfrom’ FORM1}¹ | 〚{‘to’ | ‘downto’ | ‘above’} FORM2 | 〚
     ‘by’ FORM3〛
FOR-AS-IN-LIST::=
     VAR [TYPE-SPEC] ‘in’ FORM1 [‘by’ STEP-FUN]
FOR-AS-ON-LIST::=
     VAR [TYPE-SPEC] ‘on’ FORM1 [‘by’ STEP-FUN]
FOR-AS-EQUALS-THEN::=
     VAR [TYPE-SPEC] = FORM1 [‘then’ FORM2]
FOR-AS-ACROSS::=
     VAR [TYPE-SPEC] ‘across’ VECTOR
FOR-AS-HASH::=
     VAR [TYPE-SPEC] ‘being’ {‘each’ | ‘the’}
     {{‘hash-key’ | ‘hash-keys’} {‘in’ | ‘of’} HASH-TABLE
     {[‘using’ (‘hash-value’ OTHER-VAR)] |
     {{‘hash-value’ | ‘hash-values’} {‘in’ | ‘of’} HASH-TABLE
     {[‘using’ (‘hash-key’ OTHER-VAR)]}
FOR-AS-PACKAGE::=
     VAR [TYPE-SPEC] ‘being’ {‘each’ | ‘the’}
     {‘symbol’ | ‘symbols’ |
     {‘present-symbol’ | ‘present-symbols’ |
     {‘external-symbol’ | ‘external-symbols’}
     [{‘in’ | ‘of’} PACKAGE]
TYPE-SPEC::=
     ↓simple-type-spec | ↓destructured-type-spec
SIMPLE-TYPE-SPEC::=
     ‘fixnum’ | ‘float’ | ‘t’ | ‘nil’
DESTRUCTURED-TYPE-SPEC::=
     ‘of-type’ D-TYPE-SPEC
D-TYPE-SPEC::=
     TYPE-SPECIFIER | ‘(D-TYPE-SPEC . D-TYPE-SPEC)’
VAR::=
     ↓d-var-spec
VAR1::=
     ↓d-var-spec
VAR2::=
     ↓d-var-spec
OTHER-VAR::=
     ↓d-var-spec
D-VAR-SPEC::=
     SIMPLE-VAR | ‘nil’ | (↓d-var-spec ‘.’  ↓d-var-spec)

Arguments and Values:
.....................

COMPOUND-FORM—a compound form.

NAME—a symbol.

SIMPLE-VAR—a symbol (a variable name).

FORM, FORM1, FORM2, FORM3—a form.

STEP-FUN—a form that evaluates to a function of one argument.

VECTOR—a form that evaluates to a vector.

HASH-TABLE—a form that evaluates to a hash table.

PACKAGE—a form that evaluates to a package designator.

TYPE-SPECIFIER—a type specifier.  This might be either an atomic type
specifier or a compound type specifier, which introduces some additional
complications to proper parsing in the face of destructuring; for
further information, see *note Section 6.1.1.7 (Destructuring):
DestructuringLOOPVars.

RESULT—an object.

Description:
............

For details, see *note Section 6.1 (The LOOP Facility): The LOOP
Facility.

Examples:
.........

     ;; An example of the simple form of LOOP.
      (defun sqrt-advisor ()
        (loop (format t "~&Number: ")
              (let ((n (parse-integer (read-line) :junk-allowed t)))
                (when (not n) (return))
                (format t "~&The square root of ~D is ~D.~%" n (sqrt n)))))
     → SQRT-ADVISOR
      (sqrt-advisor)
     ▷ Number: 5↩
     ▷ The square root of 5 is 2.236068.
     ▷ Number: 4↩
     ▷ The square root of 4 is 2.
     ▷ Number: done↩
     → NIL

     ;; An example of the extended form of LOOP.
      (defun square-advisor ()
        (loop as n = (progn (format t "~&Number: ")
                            (parse-integer (read-line) :junk-allowed t))
              while n
              do (format t "~&The square of ~D is ~D.~%" n (* n n))))
     → SQUARE-ADVISOR
      (square-advisor)
     ▷ Number: 4↩
     ▷ The square of 4 is 16.
     ▷ Number: 23↩
     ▷ The square of 23 is 529.
     ▷ Number: done↩
     → NIL

     ;; Another example of the extended form of LOOP.
      (loop for n from 1 to 10
            when (oddp n)
              collect n)
     → (1 3 5 7 9)

See Also:
.........

*note do::, *note dolist::, *note dotimes::, *note return::, *note go::,
*note throw::, *note Section 6.1.1.7 (Destructuring):
DestructuringLOOPVars.

Notes:
......

Except that ‘loop-finish’ cannot be used within a simple ‘loop’ form, a
simple ‘loop’ form is related to an extended ‘loop’ form in the
following way:

      (loop {compound-form}*) ≡ (loop do {compound-form}*)


File: ansicl,  Node: loop-finish,  Prev: loop,  Up: Iteration

loop-finish (Local Macro)
=========================

Syntax:
.......

 -- Macro: loop-finish <no arguments> →|

Description:
............

The ‘loop-finish’ macro can be used lexically within an extended ‘loop’
form to terminate that form “normally.” That is, it transfers control to
the loop epilogue of the lexically innermost extended ‘loop’ form.  This
permits execution of any ‘finally’ clause (for effect) and the return of
any accumulated result.

Examples:
.........

     ;; Terminate the loop, but return the accumulated count.
      (loop for i in '(1 2 3 stop-here 4 5 6)
            when (symbolp i) do (loop-finish)
            count i)
     → 3

     ;; The preceding loop is equivalent to:
      (loop for i in '(1 2 3 stop-here 4 5 6)
            until (symbolp i)
            count i)
     → 3

     ;; While LOOP-FINISH can be used can be used in a variety of
     ;; situations it is really most needed in a situation where a need
     ;; to exit is detected at other than the loop's `top level'
     ;; (where UNTIL or WHEN often work just as well), or where some
     ;; computation must occur between the point where a need to exit is
     ;; detected and the point where the exit actually occurs.  For example:
      (defun tokenize-sentence (string)
        (macrolet ((add-word (wvar svar)
                     `(when ,wvar
                        (push (coerce (nreverse ,wvar) 'string) ,svar)
                        (setq ,wvar nil))))
          (loop with word = '() and sentence = '() and endpos = nil
                for i below (length string)
                do (let ((char (aref string i)))
                     (case char
                       (#\Space (add-word word sentence))
                       (#\. (setq endpos (1+ i)) (loop-finish))
                       (otherwise (push char word))))
                finally (add-word word sentence)
                        (return (values (nreverse sentence) endpos)))))
     → TOKENIZE-SENTENCE

      (tokenize-sentence "this is a sentence. this is another sentence.")
     → ("this" "is" "a" "sentence"), 19

      (tokenize-sentence "this is a sentence")
     → ("this" "is" "a" "sentence"), NIL


Side Effects:
.............

Transfers control.

Exceptional Situations:
.......................

Whether or not ‘loop-finish’ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ‘loop-finish’ are the same as for symbols in the
‘COMMON-LISP’ package which are fbound in the global environment.  The
consequences of attempting to use ‘loop-finish’ outside of ‘loop’ are
undefined.

See Also:
.........

*note loop::, *note Section 6.1 (The LOOP Facility): The LOOP Facility.

Notes:
......


File: ansicl,  Node: Objects,  Next: Structures,  Prev: Iteration,  Up: Top

7 Objects
*********

* Menu:

* Object Creation and Initialization::
* Changing the Class of an Instance::
* Reinitializing an Instance::
* Meta-Objects::
* Slots::
* Generic Functions and Methods::

Dictionary

* function-keywords::
* ensure-generic-function::
* allocate-instance::
* reinitialize-instance::
* shared-initialize (Standard Generic Function)::
* update-instance-for-different-class::
* update-instance-for-redefined-class::
* change-class::
* slot-boundp::
* slot-exists-p::
* slot-makunbound::
* slot-missing::
* slot-unbound::
* slot-value::
* method-qualifiers::
* no-applicable-method::
* no-next-method::
* remove-method::
* make-instance::
* make-instances-obsolete::
* make-load-form::
* make-load-form-saving-slots::
* with-accessors::
* with-slots::
* defclass::
* defgeneric::
* defmethod::
* find-class::
* next-method-p::
* call-method; make-method::
* call-next-method::
* compute-applicable-methods::
* define-method-combination::
* find-method::
* add-method::
* initialize-instance (Standard Generic Function)::
* class-name::
* setf class-name::
* class-of::
* unbound-slot::
* unbound-slot-instance::


File: ansicl,  Node: Object Creation and Initialization,  Next: Changing the Class of an Instance,  Up: Objects

7.1 Object Creation and Initialization
======================================

The generic function ‘make-instance’ creates and returns a new instance
of a class.  The first argument is a class or the name of a class, and
the remaining arguments form an “initialization argument list”.

The initialization of a new instance consists of several distinct steps,
including the following: combining the explicitly supplied
initialization arguments with default values for the unsupplied
initialization arguments, checking the validity of the initialization
arguments, allocating storage for the instance, filling slots with
values, and executing user-supplied methods that perform additional
initialization.  Each step of ‘make-instance’ is implemented by a
generic function to provide a mechanism for customizing that step.  In
addition, ‘make-instance’ is itself a generic function and thus also can
be customized.

The object system specifies system-supplied primary methods for each
step and thus specifies a well-defined standard behavior for the entire
initialization process.  The standard behavior provides four simple
mechanisms for controlling initialization:

   • Declaring a symbol to be an initialization argument for a slot.  An
     initialization argument is declared by using the :initarg slot
     option to ‘defclass’.  This provides a mechanism for supplying a
     value for a slot in a call to ‘make-instance’.

   • Supplying a default value form for an initialization argument.
     Default value forms for initialization arguments are defined by
     using the :default-initargs class option to ‘defclass’.  If an
     initialization argument is not explicitly provided as an argument
     to ‘make-instance’, the default value form is evaluated in the
     lexical environment of the ‘defclass’ form that defined it, and the
     resulting value is used as the value of the initialization
     argument.

   • Supplying a default initial value form for a slot.  A default
     initial value form for a slot is defined by using the :initform
     slot option to ‘defclass’.  If no initialization argument
     associated with that slot is given as an argument to
     ‘make-instance’ or is defaulted by :default-initargs, this default
     initial value form is evaluated in the lexical environment of the
     ‘defclass’ form that defined it, and the resulting value is stored
     in the slot.  The :initform form for a local slot may be used when
     creating an instance, when updating an instance to conform to a
     redefined class, or when updating an instance to conform to the
     definition of a different class.  The :initform form for a shared
     slot may be used when defining or re-defining the class.

   • Defining methods for ‘initialize-instance’ and ‘shared-initialize’.
     The slot-filling behavior described above is implemented by a
     system-supplied primary method for ‘initialize-instance’ which
     invokes ‘shared-initialize’.  The generic function
     ‘shared-initialize’ implements the parts of initialization shared
     by these four situations: when making an instance, when
     re-initializing an instance, when updating an instance to conform
     to a redefined class, and when updating an instance to conform to
     the definition of a different class.  The system-supplied primary
     method for ‘shared-initialize’ directly implements the slot-filling
     behavior described above, and ‘initialize-instance’ simply invokes
     ‘shared-initialize’.

* Menu:

* Initialization Arguments::
* Declaring the Validity of Initialization Arguments::
* Defaulting of Initialization Arguments::
* Rules for Initialization Arguments::
* Shared-Initialize::
* Initialize-Instance::
* Definitions of Make-Instance and Initialize-Instance::


File: ansicl,  Node: Initialization Arguments,  Next: Declaring the Validity of Initialization Arguments,  Up: Object Creation and Initialization

7.1.1 Initialization Arguments
------------------------------

An initialization argument controls object creation and initialization.
It is often convenient to use keyword symbols to name initialization
arguments, but the name of an initialization argument can be any symbol,
including ‘nil’.  An initialization argument can be used in two ways: to
fill a slot with a value or to provide an argument for an initialization
method.  A single initialization argument can be used for both purposes.

An initialization argument list is a property list of initialization
argument names and values.  Its structure is identical to a property
list and also to the portion of an argument list processed for ‘&key’
parameters.  As in those lists, if an initialization argument name
appears more than once in an initialization argument list, the leftmost
occurrence supplies the value and the remaining occurrences are ignored.
The arguments to ‘make-instance’ (after the first argument) form an
initialization argument list.

An initialization argument can be associated with a slot.  If the
initialization argument has a value in the initialization argument list,
the value is stored into the slot of the newly created object,
overriding any :initform form associated with the slot.  A single
initialization argument can initialize more than one slot.  An
initialization argument that initializes a shared slot stores its value
into the shared slot, replacing any previous value.

An initialization argument can be associated with a method.  When an
object is created and a particular initialization argument is supplied,
the generic functions ‘initialize-instance’, ‘shared-initialize’, and
‘allocate-instance’ are called with that initialization argument’s name
and value as a keyword argument pair.  If a value for the initialization
argument is not supplied in the initialization argument list, the
method’s lambda list supplies a default value.

Initialization arguments are used in four situations: when making an
instance, when re-initializing an instance, when updating an instance to
conform to a redefined class, and when updating an instance to conform
to the definition of a different class.

Because initialization arguments are used to control the creation and
initialization of an instance of some particular class, we say that an
initialization argument is “an initialization argument for” that class.


File: ansicl,  Node: Declaring the Validity of Initialization Arguments,  Next: Defaulting of Initialization Arguments,  Prev: Initialization Arguments,  Up: Object Creation and Initialization

7.1.2 Declaring the Validity of Initialization Arguments
--------------------------------------------------------

Initialization arguments are checked for validity in each of the four
situations that use them.  An initialization argument may be valid in
one situation and not another.  For example, the system-supplied primary
method for ‘make-instance’ defined for the class ‘standard-class’ checks
the validity of its initialization arguments and signals an error if an
initialization argument is supplied that is not declared as valid in
that situation.

There are two means for declaring initialization arguments valid.

   • Initialization arguments that fill slots are declared as valid by
     the :initarg slot option to ‘defclass’.  The :initarg slot option
     is inherited from superclasses.  Thus the set of valid
     initialization arguments that fill slots for a class is the union
     of the initialization arguments that fill slots declared as valid
     by that class and its superclasses.  Initialization arguments that
     fill slots are valid in all four contexts.

   • Initialization arguments that supply arguments to methods are
     declared as valid by defining those methods.  The keyword name of
     each keyword parameter specified in the method’s lambda list
     becomes an initialization argument for all classes for which the
     method is applicable.  The presence of &allow-other-keys in the
     lambda list of an applicable method disables validity checking of
     initialization arguments.  Thus method inheritance controls the set
     of valid initialization arguments that supply arguments to methods.
     The generic functions for which method definitions serve to declare
     initialization arguments valid are as follows:

        – Making an instance of a class: ‘allocate-instance’,
          ‘initialize-instance’, and ‘shared-initialize’.
          Initialization arguments declared as valid by these methods
          are valid when making an instance of a class.

        – Re-initializing an instance: ‘reinitialize-instance’ and
          ‘shared-initialize’.  Initialization arguments declared as
          valid by these methods are valid when re-initializing an
          instance.

        – Updating an instance to conform to a redefined class:
          ‘update-instance-for-redefined-class’ and ‘shared-initialize’.
          Initialization arguments declared as valid by these methods
          are valid when updating an instance to conform to a redefined
          class.

        – Updating an instance to conform to the definition of a
          different class: ‘update-instance-for-different-class’ and
          ‘shared-initialize’.  Initialization arguments declared as
          valid by these methods are valid when updating an instance to
          conform to the definition of a different class.

The set of valid initialization arguments for a class is the set of
valid initialization arguments that either fill slots or supply
arguments to methods, along with the predefined initialization argument
:allow-other-keys.  The default value for :allow-other-keys is ‘nil’.
Validity checking of initialization arguments is disabled if the value
of the initialization argument :allow-other-keys is true.


File: ansicl,  Node: Defaulting of Initialization Arguments,  Next: Rules for Initialization Arguments,  Prev: Declaring the Validity of Initialization Arguments,  Up: Object Creation and Initialization

7.1.3 Defaulting of Initialization Arguments
--------------------------------------------

A default value form can be supplied for an initialization argument by
using the :default-initargs class option.  If an initialization argument
is declared valid by some particular class, its default value form might
be specified by a different class.  In this case :default-initargs is
used to supply a default value for an inherited initialization argument.

The :default-initargs option is used only to provide default values for
initialization arguments; it does not declare a symbol as a valid
initialization argument name.  Furthermore, the :default-initargs option
is used only to provide default values for initialization arguments when
making an instance.

The argument to the :default-initargs class option is a list of
alternating initialization argument names and forms.  Each form is the
default value form for the corresponding initialization argument.  The
default value form of an initialization argument is used and evaluated
only if that initialization argument does not appear in the arguments to
‘make-instance’ and is not defaulted by a more specific class.  The
default value form is evaluated in the lexical environment of the
‘defclass’ form that supplied it; the resulting value is used as the
initialization argument’s value.

The initialization arguments supplied to ‘make-instance’ are combined
with defaulted initialization arguments to produce a defaulted
initialization argument list.  A defaulted initialization argument list
is a list of alternating initialization argument names and values in
which unsupplied initialization arguments are defaulted and in which the
explicitly supplied initialization arguments appear earlier in the list
than the defaulted initialization arguments.  Defaulted initialization
arguments are ordered according to the order in the class precedence
list of the classes that supplied the default values.

There is a distinction between the purposes of the :default-initargs and
the :initform options with respect to the initialization of slots.  The
:default-initargs class option provides a mechanism for the user to give
a default value form for an initialization argument without knowing
whether the initialization argument initializes a slot or is passed to a
method.  If that initialization argument is not explicitly supplied in a
call to ‘make-instance’, the default value form is used, just as if it
had been supplied in the call.  In contrast, the :initform slot option
provides a mechanism for the user to give a default initial value form
for a slot.  An :initform form is used to initialize a slot only if no
initialization argument associated with that slot is given as an
argument to ‘make-instance’ or is defaulted by :default-initargs.

The order of evaluation of default value forms for initialization
arguments and the order of evaluation of :initform forms are undefined.
If the order of evaluation is important, ‘initialize-instance’ or
‘shared-initialize’ methods should be used instead.


File: ansicl,  Node: Rules for Initialization Arguments,  Next: Shared-Initialize,  Prev: Defaulting of Initialization Arguments,  Up: Object Creation and Initialization

7.1.4 Rules for Initialization Arguments
----------------------------------------

The :initarg slot option may be specified more than once for a given
slot.

The following rules specify when initialization arguments may be
multiply defined:

   • A given initialization argument can be used to initialize more than
     one slot if the same initialization argument name appears in more
     than one :initarg slot option.

   • A given initialization argument name can appear in the lambda list
     of more than one initialization method.

   • A given initialization argument name can appear both in an :initarg
     slot option and in the lambda list of an initialization method.

If two or more initialization arguments that initialize the same slot
are given in the arguments to ‘make-instance’, the leftmost of these
initialization arguments in the initialization argument list supplies
the value, even if the initialization arguments have different names.

If two or more different initialization arguments that initialize the
same slot have default values and none is given explicitly in the
arguments to ‘make-instance’, the initialization argument that appears
in a :default-initargs class option in the most specific of the classes
supplies the value.  If a single :default-initargs class option
specifies two or more initialization arguments that initialize the same
slot and none is given explicitly in the arguments to ‘make-instance’,
the leftmost in the :default-initargs class option supplies the value,
and the values of the remaining default value forms are ignored.

Initialization arguments given explicitly in the arguments to
‘make-instance’ appear to the left of defaulted initialization
arguments.  Suppose that the classes Cvalues of defaulted initialization
arguments for different slots, and suppose that Cdefaulted
initialization argument whose value is supplied by Cis to the left of
the defaulted initialization argument whose value is supplied by Clist.
If a single :default-initargs class option supplies the values of
initialization arguments for two different slots, the initialization
argument whose value is specified farther to the left in the
:default-initargs class option appears farther to the left in the
defaulted initialization argument list.

If a slot has both an :initform form and an :initarg slot option, and
the initialization argument is defaulted using :default-initargs or is
supplied to ‘make-instance’, the captured :initform form is neither used
nor evaluated.

The following is an example of the above rules:

      (defclass q () ((x :initarg a)))
      (defclass r (q) ((x :initarg b))
        (:default-initargs a 1 b 2))

Form                             Defaulted              Contents
                                 Initialization         of Slot X
                                 Argument List
--------------------------------------------------------------------
(make-instance ’r)               (a 1 b 2)              1
(make-instance ’r ’a 3)          (a 3 b 2)              3
(make-instance ’r ’b 4)          (b 4 a 1)              4
(make-instance ’r ’a 1 ’a 2)     (a 1 a 2 b 2)          1


File: ansicl,  Node: Shared-Initialize,  Next: Initialize-Instance,  Prev: Rules for Initialization Arguments,  Up: Object Creation and Initialization

7.1.5 Shared-Initialize
-----------------------

The generic function ‘shared-initialize’ is used to fill the slots of an
instance using initialization arguments and :initform forms when an
instance is created, when an instance is re-initialized, when an
instance is updated to conform to a redefined class, and when an
instance is updated to conform to a different class.  It uses standard
method combination.  It takes the following arguments: the instance to
be initialized, a specification of a set of names of slots accessible in
that instance, and any number of initialization arguments.  The
arguments after the first two must form an initialization argument list.

The second argument to ‘shared-initialize’ may be one of the following:

   • It can be a (possibly empty) list of slot names, which specifies
     the set of those slot names.

   • It can be the symbol ‘t’, which specifies the set of all of the
     slots.

There is a system-supplied primary method for ‘shared-initialize’ whose
first parameter specializer is the class ‘standard-object’.  This method
behaves as follows on each slot, whether shared or local:

   • If an initialization argument in the initialization argument list
     specifies a value for that slot, that value is stored into the
     slot, even if a value has already been stored in the slot before
     the method is run.  The affected slots are independent of which
     slots are indicated by the second argument to ‘shared-initialize’.

   • Any slots indicated by the second argument that are still unbound
     at this point are initialized according to their :initform forms.
     For any such slot that has an :initform form, that form is
     evaluated in the lexical environment of its defining ‘defclass’
     form and the result is stored into the slot.  For example, if a
     before method stores a value in the slot, the :initform form will
     not be used to supply a value for the slot.  If the second argument
     specifies a name that does not correspond to any slots accessible
     in the instance, the results are unspecified.

   • The rules mentioned in *note Section 7.1.4 (Rules for
     Initialization Arguments): Rules for Initialization Arguments. are
     obeyed.

The generic function ‘shared-initialize’ is called by the
system-supplied primary methods for ‘reinitialize-instance’,
‘update-instance-for-different-class’,
‘update-instance-for-redefined-class’, and ‘initialize-instance’.  Thus,
methods can be written for ‘shared-initialize’ to specify actions that
should be taken in all of these contexts.


File: ansicl,  Node: Initialize-Instance,  Next: Definitions of Make-Instance and Initialize-Instance,  Prev: Shared-Initialize,  Up: Object Creation and Initialization

7.1.6 Initialize-Instance
-------------------------

The generic function ‘initialize-instance’ is called by ‘make-instance’
to initialize a newly created instance.  It uses standard method
combination.  Methods for ‘initialize-instance’ can be defined in order
to perform any initialization that cannot be achieved simply by
supplying initial values for slots.

During initialization, ‘initialize-instance’ is invoked after the
following actions have been taken:

   • The defaulted initialization argument list has been computed by
     combining the supplied initialization argument list with any
     default initialization arguments for the class.

   • The validity of the defaulted initialization argument list has been
     checked.  If any of the initialization arguments has not been
     declared as valid, an error is signaled.

   • A new instance whose slots are unbound has been created.

The generic function ‘initialize-instance’ is called with the new
instance and the defaulted initialization arguments.  There is a
system-supplied primary method for ‘initialize-instance’ whose parameter
specializer is the class ‘standard-object’.  This method calls the
generic function ‘shared-initialize’ to fill in the slots according to
the initialization arguments and the :initform forms for the slots; the
generic function ‘shared-initialize’ is called with the following
arguments: the instance, ‘t’, and the defaulted initialization
arguments.

Note that ‘initialize-instance’ provides the defaulted initialization
argument list in its call to ‘shared-initialize’, so the first step
performed by the system-supplied primary method for ‘shared-initialize’
takes into account both the initialization arguments provided in the
call to ‘make-instance’ and the defaulted initialization argument list.

Methods for ‘initialize-instance’ can be defined to specify actions to
be taken when an instance is initialized.  If only after methods for
‘initialize-instance’ are defined, they will be run after the
system-supplied primary method for initialization and therefore will not
interfere with the default behavior of ‘initialize-instance’.

The object system provides two functions that are useful in the bodies
of ‘initialize-instance’ methods.  The function ‘slot-boundp’ returns a
generic boolean value that indicates whether a specified slot has a
value; this provides a mechanism for writing after methods for
‘initialize-instance’ that initialize slots only if they have not
already been initialized.  The function ‘slot-makunbound’ causes the
slot to have no value.


File: ansicl,  Node: Definitions of Make-Instance and Initialize-Instance,  Prev: Initialize-Instance,  Up: Object Creation and Initialization

7.1.7 Definitions of Make-Instance and Initialize-Instance
----------------------------------------------------------

The generic function ‘make-instance’ behaves as if it were defined as
follows, except that certain optimizations are permitted:

      (defmethod make-instance ((class standard-class) &rest initargs)
        ...
        (let ((instance (apply #'allocate-instance class initargs)))
          (apply #'initialize-instance instance initargs)
          instance))

      (defmethod make-instance ((class-name symbol) &rest initargs)
        (apply #'make-instance (find-class class-name) initargs))

The elided code in the definition of ‘make-instance’ augments the
‘initargs’ with any defaulted initialization arguments and checks the
resulting initialization arguments to determine whether an
initialization argument was supplied that neither filled a slot nor
supplied an argument to an applicable method.

The generic function ‘initialize-instance’ behaves as if it were defined
as follows, except that certain optimizations are permitted:

      (defmethod initialize-instance ((instance standard-object) &rest initargs)
        (apply #'shared-initialize instance t initargs)))

These procedures can be customized.

Customizing at the Programmer Interface level includes using the
:initform, :initarg, and :default-initargs options to ‘defclass’, as
well as defining methods for ‘make-instance’, ‘allocate-instance’, and
‘initialize-instance’.  It is also possible to define methods for
‘shared-initialize’, which would be invoked by the generic functions
‘reinitialize-instance’, ‘update-instance-for-redefined-class’,
‘update-instance-for-different-class’, and ‘initialize-instance’.  The
meta-object level supports additional customization.

Implementations are permitted to make certain optimizations to
‘initialize-instance’ and ‘shared-initialize’.  The description of
‘shared-initialize’ in Chapter 7 mentions the possible optimizations.


File: ansicl,  Node: Changing the Class of an Instance,  Next: Reinitializing an Instance,  Prev: Object Creation and Initialization,  Up: Objects

7.2 Changing the Class of an Instance
=====================================

The function ‘change-class’ can be used to change the class of an
instance from its current class, Cto a different class, Cstructure of
the instance to conform to the definition of the class C

Note that changing the class of an instance may cause slots to be added
or deleted.  Changing the class of an instance does not change its
identity as defined by the ‘eq’ function.

When ‘change-class’ is invoked on an instance, a two-step updating
process takes place.  The first step modifies the structure of the
instance by adding new local slots and discarding local slots that are
not specified in the new version of the instance.  The second step
initializes the newly added local slots and performs any other
user-defined actions.  These two steps are further described in the two
following sections.

* Menu:

* Modifying the Structure of the Instance::
* Initializing Newly Added Local Slots::
* Customizing the Change of Class of an Instance::


File: ansicl,  Node: Modifying the Structure of the Instance,  Next: Initializing Newly Added Local Slots,  Up: Changing the Class of an Instance

7.2.1 Modifying the Structure of the Instance
---------------------------------------------

In order to make the instance conform to the class Cthe class Cclass C

The values of local slots specified by both the class Cunbound.

The values of slots specified as shared in the class C

This first step of the update does not affect the values of any shared
slots.


File: ansicl,  Node: Initializing Newly Added Local Slots,  Next: Customizing the Change of Class of an Instance,  Prev: Modifying the Structure of the Instance,  Up: Changing the Class of an Instance

7.2.2 Initializing Newly Added Local Slots
------------------------------------------

The second step of the update initializes the newly added slots and
performs any other user-defined actions.  This step is implemented by
the generic function ‘update-instance-for-different-class’.  The generic
function ‘update-instance-for-different-class’ is invoked by
‘change-class’ after the first step of the update has been completed.

The generic function ‘update-instance-for-different-class’ is invoked on
arguments computed by ‘change-class’.  The first argument passed is a
copy of the instance being updated and is an instance of the class Cthis
copy has dynamic extent within the generic function ‘change-class’.  The
second argument is the instance as updated so far by ‘change-class’ and
is an instance of the class CThe remaining arguments are an
initialization argument list.

There is a system-supplied primary method for
‘update-instance-for-different-class’ that has two parameter
specializers, each of which is the class ‘standard-object’.  First this
method checks the validity of initialization arguments and signals an
error if an initialization argument is supplied that is not declared as
valid.  (For more information, see *note Section 7.1.2 (Declaring the
Validity of Initialization Arguments): Declaring the Validity of
Initialization Arguments.)  Then it calls the generic function
‘shared-initialize’ with the following arguments: the new instance, a
list of names of the newly added slots, and the initialization arguments
it received.


File: ansicl,  Node: Customizing the Change of Class of an Instance,  Prev: Initializing Newly Added Local Slots,  Up: Changing the Class of an Instance

7.2.3 Customizing the Change of Class of an Instance
----------------------------------------------------

Methods for ‘update-instance-for-different-class’ may be defined to
specify actions to be taken when an instance is updated.  If only after
methods for ‘update-instance-for-different-class’ are defined, they will
be run after the system-supplied primary method for initialization and
will not interfere with the default behavior of
‘update-instance-for-different-class’.

Methods for ‘shared-initialize’ may be defined to customize class
redefinition.  For more information, see *note Section 7.1.5
(Shared-Initialize): Shared-Initialize.


File: ansicl,  Node: Reinitializing an Instance,  Next: Meta-Objects,  Prev: Changing the Class of an Instance,  Up: Objects

7.3 Reinitializing an Instance
==============================

The generic function ‘reinitialize-instance’ may be used to change the
values of slots according to initialization arguments.

The process of reinitialization changes the values of some slots and
performs any user-defined actions.  It does not modify the structure of
an instance to add or delete slots, and it does not use any :initform
forms to initialize slots.

The generic function ‘reinitialize-instance’ may be called directly.  It
takes one required argument, the instance.  It also takes any number of
initialization arguments to be used by methods for
‘reinitialize-instance’ or for ‘shared-initialize’.  The arguments after
the required instance must form an initialization argument list.

There is a system-supplied primary method for ‘reinitialize-instance’
whose parameter specializer is the class ‘standard-object’.  First this
method checks the validity of initialization arguments and signals an
error if an initialization argument is supplied that is not declared as
valid.  (For more information, see *note Section 7.1.2 (Declaring the
Validity of Initialization Arguments): Declaring the Validity of
Initialization Arguments.)  Then it calls the generic function
‘shared-initialize’ with the following arguments: the instance, ‘nil’,
and the initialization arguments it received.

* Menu:

* Customizing Reinitialization::


File: ansicl,  Node: Customizing Reinitialization,  Up: Reinitializing an Instance

7.3.1 Customizing Reinitialization
----------------------------------

Methods for ‘reinitialize-instance’ may be defined to specify actions to
be taken when an instance is updated.  If only after methods for
‘reinitialize-instance’ are defined, they will be run after the
system-supplied primary method for initialization and therefore will not
interfere with the default behavior of ‘reinitialize-instance’.

Methods for ‘shared-initialize’ may be defined to customize class
redefinition.  For more information, see *note Section 7.1.5
(Shared-Initialize): Shared-Initialize.


File: ansicl,  Node: Meta-Objects,  Next: Slots,  Prev: Reinitializing an Instance,  Up: Objects

7.4 Meta-Objects
================

The implementation of the object system manipulates classes, methods,
and generic functions.  The object system contains a set of generic
functions defined by methods on classes; the behavior of those generic
functions defines the behavior of the object system.  The instances of
the classes on which those methods are defined are called meta-objects.

* Menu:

* Standard Meta-objects::


File: ansicl,  Node: Standard Meta-objects,  Up: Meta-Objects

7.4.1 Standard Meta-objects
---------------------------

The object system supplies a set of meta-objects, called standard
meta-objects.  These include the class ‘standard-object’ and instances
of the classes ‘standard-method’, ‘standard-generic-function’, and
‘method-combination’.

   • The class ‘standard-method’ is the default class of methods defined
     by the ‘defmethod’ and ‘defgeneric’ forms.

   • The class ‘standard-generic-function’ is the default class of
     generic functions defined by the forms ‘defmethod’, ‘defgeneric’,
     and ‘defclass’.

   • The class named ‘standard-object’ is an instance of the class
     ‘standard-class’ and is a superclass of every class that is an
     instance of ‘standard-class’ except itself and ‘structure-class’.

   • Every method combination object is an instance of a subclass of
     type ‘method-combination’.


File: ansicl,  Node: Slots,  Next: Generic Functions and Methods,  Prev: Meta-Objects,  Up: Objects

7.5 Slots
=========

* Menu:

* Introduction to Slots::
* Accessing Slots::
* Inheritance of Slots and Slot Options::


File: ansicl,  Node: Introduction to Slots,  Next: Accessing Slots,  Up: Slots

7.5.1 Introduction to Slots
---------------------------

An object of metaclass ‘standard-class’ has zero or more named slots.
The slots of an object are determined by the class of the object.  Each
slot can hold one value.

The name of a slot is a symbol that is syntactically valid for use as a
variable name.

When a slot does not have a value, the slot is said to be unbound.  When
an unbound slot is read,

the generic function ‘slot-unbound’ is invoked.  The system-supplied
primary method for ‘slot-unbound’ on class ‘t’ signals an error.  If
‘slot-unbound’ returns, its primary value is used that time as the value
of the slot.

The default initial value form for a slot is defined by the :initform
slot option.  When the :initform form is used to supply a value, it is
evaluated in the lexical environment in which the ‘defclass’ form was
evaluated.  The :initform along with the lexical environment in which
the ‘defclass’ form was evaluated is called a captured initialization
form.  For more details, see *note Section 7.1 (Object Creation and
Initialization): Object Creation and Initialization.

A local slot is defined to be a slot that is accessible to exactly one
instance, namely the one in which the slot is allocated.  A shared slot
is defined to be a slot that is visible to more than one instance of a
given class and its subclasses.

A class is said to define a slot with a given name when the ‘defclass’
form for that class contains a slot specifier with that name.  Defining
a local slot does not immediately create a slot; it causes a slot to be
created each time an instance of the class is created.  Defining a
shared slot immediately creates a slot.

The :allocation slot option to ‘defclass’ controls the kind of slot that
is defined.  If the value of the :allocation slot option is :instance, a
local slot is created.  If the value of :allocation is :class, a shared
slot is created.

A slot is said to be accessible in an instance of a class if the slot is
defined by the class of the instance or is inherited from a superclass
of that class.  At most one slot of a given name can be accessible in an
instance.  A shared slot defined by a class is accessible in all
instances of that class.  A detailed explanation of the inheritance of
slots is given in *note Section 7.5.3 (Inheritance of Slots and Slot
Options): Inheritance of Slots and Slot Options.


File: ansicl,  Node: Accessing Slots,  Next: Inheritance of Slots and Slot Options,  Prev: Introduction to Slots,  Up: Slots

7.5.2 Accessing Slots
---------------------

Slots can be accessed in two ways: by use of the primitive function
‘slot-value’ and by use of generic functions generated by the ‘defclass’
form.

The function ‘slot-value’ can be used with any of the slot names
specified in the ‘defclass’ form to access a specific slot accessible in
an instance of the given class.

The macro ‘defclass’ provides syntax for generating methods to read and
write slots.  If a reader method is requested, a method is automatically
generated for reading the value of the slot, but no method for storing a
value into it is generated.  If a writer method is requested, a method
is automatically generated for storing a value into the slot, but no
method for reading its value is generated.  If an accessor method is
requested, a method for reading the value of the slot and a method for
storing a value into the slot are automatically generated.  Reader and
writer methods are implemented using ‘slot-value’.

When a reader or writer method is specified for a slot, the name of the
generic function to which the generated method belongs is directly
specified.  If the name specified for the writer method is the symbol
‘name’, the name of the generic function for writing the slot is the
symbol ‘name’, and the generic function takes two arguments: the new
value and the instance, in that order.  If the name specified for the
accessor method is the symbol ‘name’, the name of the generic function
for reading the slot is the symbol ‘name’, and the name of the generic
function for writing the slot is the list ‘(setf name)’.

A generic function created or modified by supplying :reader, :writer, or
:accessor slot options can be treated exactly as an ordinary generic
function.

Note that ‘slot-value’ can be used to read or write the value of a slot
whether or not reader or writer methods exist for that slot.  When
‘slot-value’ is used, no reader or writer methods are invoked.

The macro ‘with-slots’ can be used to establish a lexical environment in
which specified slots are lexically available as if they were variables.
The macro ‘with-slots’ invokes the function ‘slot-value’ to access the
specified slots.

The macro ‘with-accessors’ can be used to establish a lexical
environment in which specified slots are lexically available through
their accessors as if they were variables.  The macro ‘with-accessors’
invokes the appropriate accessors to access the specified slots.


File: ansicl,  Node: Inheritance of Slots and Slot Options,  Prev: Accessing Slots,  Up: Slots

7.5.3 Inheritance of Slots and Slot Options
-------------------------------------------

The set of the names of all slots accessible in an instance of a class C
is the union of the sets of names of slots defined by C and its
superclasses.  The structure of an instance is the set of names of local
slots in that instance.

In the simplest case, only one class among C and its superclasses
defines a slot with a given slot name.  If a slot is defined by a
superclass of C, the slot is said to be inherited.  The characteristics
of the slot are determined by the slot specifier of the defining class.
Consider the defining class for a slot S. If the value of the
:allocation slot option is :instance, then S is a local slot and each
instance of C has its own slot named S that stores its own value.  If
the value of the :allocation slot option is :class, then S is a shared
slot, the class that defined S stores the value, and all instances of C
can access that single slot.  If the :allocation slot option is omitted,
:instance is used.

In general, more than one class among C and its superclasses can define
a slot with a given name.  In such cases, only one slot with the given
name is accessible in an instance of C, and the characteristics of that
slot are a combination of the several slot specifiers, computed as
follows:

   • All the slot specifiers for a given slot name are ordered from most
     specific to least specific, according to the order in C’s class
     precedence list of the classes that define them.  All references to
     the specificity of slot specifiers immediately below refers to this
     ordering.

   • The allocation of a slot is controlled by the most specific slot
     specifier.  If the most specific slot specifier does not contain an
     :allocation slot option, :instance is used.  Less specific slot
     specifiers do not affect the allocation.

   • The default initial value form for a slot is the value of the
     :initform slot option in the most specific slot specifier that
     contains one.  If no slot specifier contains an :initform slot
     option, the slot has no default initial value form.

   • The contents of a slot will always be of type ‘(and Tthe values of
     the :type slot options contained in all of the slot specifiers. If
     no slot specifier contains the :type slot option, the contents of
     the slot will always be of type t. The consequences of attempting
     to store in a slot a value that does not satisfy the type of the
     slot are undefined. ’
   • The set of initialization arguments that initialize a given slot is
     the union of the initialization arguments declared in the :initarg
     slot options in all the slot specifiers.

   • The documentation string for a slot is the value of the
     :documentation slot option in the most specific slot specifier that
     contains one.  If no slot specifier contains a :documentation slot
     option, the slot has no documentation string.

A consequence of the allocation rule is that a shared slot can be
shadowed.  For example, if a class Ca slot named S whose value for the
:allocation slot option is :class, that slot is accessible in instances
of Csubclasses.  However, if Cof Cdefines a slot named S, Cslot is not
shared by instances of CCunless the ‘defclass’ form for Cname or there
is a superclass of CC

A consequence of the type rule is that the value of a slot satisfies the
type constraint of each slot specifier that contributes to that slot.
Because the result of attempting to store in a slot a value that does
not satisfy the type constraint for the slot is undefined, the value in
a slot might fail to satisfy its type constraint.

The :reader, :writer, and :accessor slot options create methods rather
than define the characteristics of a slot.  Reader and writer methods
are inherited in the sense described in *note Section 7.6.7 (Inheritance
of Methods): Inheritance of Methods.

Methods that access slots use only the name of the slot and the type of
the slot’s value.  Suppose a superclass provides a method that expects
to access a shared slot of a given name, and a subclass defines a local
slot with the same name.  If the method provided by the superclass is
used on an instance of the subclass, the method accesses the local slot.


File: ansicl,  Node: Generic Functions and Methods,  Next: function-keywords,  Prev: Slots,  Up: Objects

7.6 Generic Functions and Methods
=================================

* Menu:

* Introduction to Generic Functions::
* Introduction to Methods::
* Agreement on Parameter Specializers and Qualifiers::
* Congruent Lambda-lists for all Methods of a Generic Function::
* Keyword Arguments in Generic Functions and Methods::
* Method Selection and Combination::
* Inheritance of Methods::


File: ansicl,  Node: Introduction to Generic Functions,  Next: Introduction to Methods,  Up: Generic Functions and Methods

7.6.1 Introduction to Generic Functions
---------------------------------------

A “generic function” is a function whose behavior depends on the classes
or identities of the arguments supplied to it.  A generic function
object is associated with a set of methods, a lambda list, a method
combinationand other information.

Like an ordinary function, a generic function takes arguments, performs
a series of operations, and perhaps returns useful values.  An ordinary
function has a single body of code that is always executed when the
function is called.  A generic function has a set of bodies of code of
which a subset is selected for execution.  The selected bodies of code
and the manner of their combination are determined by the classes or
identities of one or more of the arguments to the generic function and
by its method combination.

Ordinary functions and generic functions are called with identical
syntax.

Generic functions are true functions that can be passed as arguments and
used as the first argument to ‘funcall’ and ‘apply’.

A binding of a function name to a generic function can be established in
one of several ways.  It can be established in the global environment by
‘ensure-generic-function’, ‘defmethod’ (implicitly, due to
‘ensure-generic-function’) or ‘defgeneric’ (also implicitly, due to
‘ensure-generic-function’).  No standardized mechanism is provided for
establishing a binding of a function name to a generic function in the
lexical environment.

When a ‘defgeneric’ form is evaluated, one of three actions is taken
(due to ‘ensure-generic-function’):

   • If a generic function of the given name already exists, the
     existing generic function object is modified.  Methods specified by
     the current ‘defgeneric’ form are added, and any methods in the
     existing generic function that were defined by a previous
     ‘defgeneric’ form are removed.  Methods added by the current
     ‘defgeneric’ form might replace methods defined by ‘defmethod’,
     ‘defclass’, ‘define-condition’, or ‘defstruct’.  No other methods
     in the generic function are affected or replaced.

   • If the given name names an ordinary function, a macro, or a special
     operator, an error is signaled.

   • Otherwise a generic function is created with the methods specified
     by the method definitions in the ‘defgeneric’ form.

Some operators permit specification of the options of a generic
function, such as the type of method combination it uses or its argument
precedence order.  These operators will be referred to as “operators
that specify generic function options.” The only standardized operator
in this category is ‘defgeneric’.

Some operators define methods for a generic function.  These operators
will be referred to as “method-defining operators”; their associated
forms are called method-defining forms.  The standardized
method-defining operators are listed in the next figure.

defgeneric         defmethod   defclass
define-condition   defstruct

Figure 7.1: Standardized Method-Defining Operators

Note that of the standardized method-defining operators only
‘defgeneric’ can specify generic function options.  ‘defgeneric’ and any
implementation-defined operators that can specify generic function
options are also referred to as “operators that specify generic function
options.”


File: ansicl,  Node: Introduction to Methods,  Next: Agreement on Parameter Specializers and Qualifiers,  Prev: Introduction to Generic Functions,  Up: Generic Functions and Methods

7.6.2 Introduction to Methods
-----------------------------

Methods define the class-specific or identity-specific behavior and
operations of a generic function.

A method object is associated with code that implements the method’s
behavior, a sequence of parameter specializers that specify when the
given method is applicable, a lambda list, and a sequence of qualifiers
that are used by the method combination facility to distinguish among
methods.

A method object is not a function and cannot be invoked as a function.
Various mechanisms in the object system take a method object and invoke
its method function, as is the case when a generic function is invoked.
When this occurs it is said that the method is invoked or called.

A method-defining form contains the code that is to be run when the
arguments to the generic function cause the method that it defines to be
invoked.  When a method-defining form is evaluated, a method object is
created and one of four actions is taken:

   • If a generic function of the given name already exists and if a
     method object already exists that agrees with the new one on
     parameter specializers and qualifiers, the new method object
     replaces the old one.  For a definition of one method agreeing with
     another on parameter specializers and qualifiers, see *note Section
     7.6.3 (Agreement on Parameter Specializers and Qualifiers):
     Agreement on Parameter Specializers and Qualifiers.

   • If a generic function of the given name already exists and if there
     is no method object that agrees with the new one on parameter
     specializers and qualifiers, the existing generic function object
     is modified to contain the new method object.

   • If the given name names an ordinary function, a macro, or a special
     operator, an error is signaled.

   • Otherwise a generic function is created with the method specified
     by the method-defining form.

If the lambda list of a new method is not congruent with the lambda list
of the generic function, an error is signaled.  If a method-defining
operator that cannot specify generic function options creates a new
generic function, a lambda list for that generic function is derived
from the lambda list of the method in the method-defining form in such a
way as to be congruent with it.  For a discussion of “congruence”, see
*note Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic
Function): Congruent Lambda-lists for all Methods of a Generic Function.

Each method has a specialized lambda list, which determines when that
method can be applied.  A specialized lambda list is like an ordinary
lambda list except that a specialized parameter may occur instead of the
name of a required parameter.  A specialized parameter is a list
‘(variable-name parameter-specializer-name)’, where
parameter-specializer-name is one of the following:

a symbol

     denotes a parameter specializer which is the class named by that
     symbol.

a class

     denotes a parameter specializer which is the class itself.

‘(eql form)’

     denotes a parameter specializer which satisfies the type specifier
     ‘(eql object)’, where object is the result of evaluating form.  The
     form form is evaluated in the lexical environment in which the
     method-defining form is evaluated.  Note that form is evaluated
     only once, at the time the method is defined, not each time the
     generic function is called.

Parameter specializer names are used in macros intended as the
user-level interface (‘defmethod’), while parameter specializers are
used in the functional interface.

Only required parameters may be specialized, and there must be a
parameter specializer for each required parameter.  For notational
simplicity, if some required parameter in a specialized lambda list in a
method-defining form is simply a variable name, its parameter
specializer defaults to the class ‘t’.

Given a generic function and a set of arguments, an applicable method is
a method for that generic function whose parameter specializers are
satisfied by their corresponding arguments.  The following definition
specifies what it means for a method to be applicable and for an
argument to satisfy a parameter specializer.

Let 〈 Aarguments to a generic function in order.  Let 〈 P..., Pthe
required parameters of the method M in order.  The method M is
applicable when each Athe type specifier PBecause every valid parameter
specializer is also a valid type specifier, the function ‘typep’ can be
used during method selection to determine whether an argument satisfies
a parameter specializer.

A method all of whose parameter specializers are the class ‘t’ is called
a “default method”; it is always applicable but may be shadowed by a
more specific method.

Methods can have qualifiers, which give the method combination procedure
a way to distinguish among methods.  A method that has one or more
qualifiers is called a qualified method.  A method with no qualifiers is
called an unqualified method.  A qualifier is any non-list.  The
qualifiers defined by the standardized method combination types are
symbols.

In this specification, the terms “primary method” and “auxiliary method”
are used to partition methods within a method combination type according
to their intended use.  In standard method combination, primary methods
are unqualified methods and auxiliary methods are methods with a single
qualifier that is one of :around, :before, or :after.  Methods with
these qualifiers are called around methods, before methods, and after
methods, respectively.  When a method combination type is defined using
the short form of ‘define-method-combination’, primary methods are
methods qualified with the name of the type of method combination, and
auxiliary methods have the qualifier :around.  Thus the terms “primary
method” and “auxiliary method” have only a relative definition within a
given method combination type.


File: ansicl,  Node: Agreement on Parameter Specializers and Qualifiers,  Next: Congruent Lambda-lists for all Methods of a Generic Function,  Prev: Introduction to Methods,  Up: Generic Functions and Methods

7.6.3 Agreement on Parameter Specializers and Qualifiers
--------------------------------------------------------

Two methods are said to agree with each other on parameter specializers
and qualifiers if the following conditions hold:

  1. Both methods have the same number of required parameters.  Suppose
     the parameter specializers of the two methods are P

  2. For each 1≤ i≤ n, PThe parameter specializer PPPP‘(eql
     objectOtherwise P ’
  3. The two lists of qualifiers are the same under ‘equal’.


File: ansicl,  Node: Congruent Lambda-lists for all Methods of a Generic Function,  Next: Keyword Arguments in Generic Functions and Methods,  Prev: Agreement on Parameter Specializers and Qualifiers,  Up: Generic Functions and Methods

7.6.4 Congruent Lambda-lists for all Methods of a Generic Function
------------------------------------------------------------------

These rules define the congruence of a set of lambda lists, including
the lambda list of each method for a given generic function and the
lambda list specified for the generic function itself, if given.

  1. Each lambda list must have the same number of required parameters.

  2. Each lambda list must have the same number of optional parameters.
     Each method can supply its own default for an optional parameter.

  3. If any lambda list mentions ‘&rest’ or ‘&key’, each lambda list
     must mention one or both of them.

  4. If the generic function lambda list mentions ‘&key’, each method
     must accept all of the keyword names mentioned after ‘&key’, either
     by accepting them explicitly, by specifying ‘&allow-other-keys’, or
     by specifying ‘&rest’ but not ‘&key’.  Each method can accept
     additional keyword arguments of its own.  The checking of the
     validity of keyword names is done in the generic function, not in
     each method.  A method is invoked as if the keyword argument pair
     whose name is :allow-other-keys and whose value is true were
     supplied, though no such argument pair will be passed.

  5. The use of ‘&allow-other-keys’ need not be consistent across lambda
     lists.  If ‘&allow-other-keys’ is mentioned in the lambda list of
     any applicable method or of the generic function, any keyword
     arguments may be mentioned in the call to the generic function.

  6. The use of ‘&aux’ need not be consistent across methods.

     If a method-defining operator that cannot specify generic function
     options creates a generic function, and if the lambda list for the
     method mentions keyword arguments, the lambda list of the generic
     function will mention ‘&key’ (but no keyword arguments).


File: ansicl,  Node: Keyword Arguments in Generic Functions and Methods,  Next: Method Selection and Combination,  Prev: Congruent Lambda-lists for all Methods of a Generic Function,  Up: Generic Functions and Methods

7.6.5 Keyword Arguments in Generic Functions and Methods
--------------------------------------------------------

When a generic function or any of its methods mentions ‘&key’ in a
lambda list, the specific set of keyword arguments accepted by the
generic function varies according to the applicable methods.  The set of
keyword arguments accepted by the generic function for a particular call
is the union of the keyword arguments accepted by all applicable methods
and the keyword arguments mentioned after ‘&key’ in the generic function
definition, if any.  A method that has ‘&rest’ but not ‘&key’ does not
affect the set of acceptable keyword arguments.  If the lambda list of
any applicable method or of the generic function definition contains
‘&allow-other-keys’, all keyword arguments are accepted by the generic
function.

The lambda list congruence rules require that each method accept all of
the keyword arguments mentioned after ‘&key’ in the generic function
definition, by accepting them explicitly, by specifying
‘&allow-other-keys’, or by specifying ‘&rest’ but not ‘&key’.  Each
method can accept additional keyword arguments of its own, in addition
to the keyword arguments mentioned in the generic function definition.

If a generic function is passed a keyword argument that no applicable
method accepts, an error should be signaled; see *note Section 3.5
(Error Checking in Function Calls): Error Checking in Function Calls.

7.6.5.1 Examples of Keyword Arguments in Generic Functions and Methods
......................................................................

For example, suppose there are two methods defined for ‘width’ as
follows:

      (defmethod width ((c character-class) &key font) ...)

      (defmethod width ((p picture-class) &key pixel-size) ...)

Assume that there are no other methods and no generic function
definition for ‘width’.  The evaluation of the following form should
signal an error because the keyword argument :pixel-size is not accepted
by the applicable method.

      (width (make-instance `character-class :char #\Q)
             :font 'baskerville :pixel-size 10)

The evaluation of the following form should signal an error.

      (width (make-instance `picture-class :glyph (glyph #\Q))
             :font 'baskerville :pixel-size 10)

The evaluation of the following form will not signal an error if the
class named ‘character-picture-class’ is a subclass of both
‘picture-class’ and ‘character-class’.

      (width (make-instance `character-picture-class :char #\Q)
             :font 'baskerville :pixel-size 10)


File: ansicl,  Node: Method Selection and Combination,  Next: Inheritance of Methods,  Prev: Keyword Arguments in Generic Functions and Methods,  Up: Generic Functions and Methods

7.6.6 Method Selection and Combination
--------------------------------------

When a generic function is called with particular arguments, it must
determine the code to execute.  This code is called the “effective
method” for those arguments.  The effective method is a combination of
the applicable methods in the generic function that calls some or all of
the methods.

If a generic function is called and no methods are applicable, the
generic function ‘no-applicable-method’ is invoked, with the results
from that call being used as the results of the call to the original
generic function.  Calling ‘no-applicable-method’ takes precedence over
checking for acceptable keyword arguments; see *note Section 7.6.5
(Keyword Arguments in Generic Functions and Methods): Keyword Arguments
in Generic Functions and Methods.

When the effective method has been determined, it is invoked with the
same arguments as were passed to the generic function.  Whatever values
it returns are returned as the values of the generic function.

7.6.6.1 Determining the Effective Method
........................................

The effective method is determined by the following three-step
procedure:

  1. Select the applicable methods.

  2. Sort the applicable methods by precedence order, putting the most
     specific method first.

  3. Apply method combination to the sorted list of applicable methods,
     producing the effective method.

7.6.6.1.1 Selecting the Applicable Methods
..........................................

This step is described in *note Section 7.6.2 (Introduction to Methods):
Introduction to Methods.

7.6.6.1.2 Sorting the Applicable Methods by Precedence Order
............................................................

To compare the precedence of two methods, their parameter specializers
are examined in order.  The default examination order is from left to
right, but an alternative order may be specified by the
:argument-precedence-order option to ‘defgeneric’ or to any of the other
operators that specify generic function options.

The corresponding parameter specializers from each method are compared.
When a pair of parameter specializers agree, the next pair are compared
for agreement.  If all corresponding parameter specializers agree, the
two methods must have different qualifiers; in this case, either method
can be selected to precede the other.  For information about agreement,
see *note Section 7.6.3 (Agreement on Parameter Specializers and
Qualifiers): Agreement on Parameter Specializers and Qualifiers.

If some corresponding parameter specializers do not agree, the first
pair of parameter specializers that do not agree determines the
precedence.  If both parameter specializers are classes, the more
specific of the two methods is the method whose parameter specializer
appears earlier in the class precedence list of the corresponding
argument.  Because of the way in which the set of applicable methods is
chosen, the parameter specializers are guaranteed to be present in the
class precedence list of the class of the argument.

If just one of a pair of corresponding parameter specializers is ‘(eql
object)’, the method with that parameter specializer precedes the other
method.  If both parameter specializers are ‘eql’ expressions, the
specializers must agree (otherwise the two methods would not both have
been applicable to this argument).

The resulting list of applicable methods has the most specific method
first and the least specific method last.

7.6.6.1.3 Applying method combination to the sorted list of applicable methods
..............................................................................

In the simple case—if standard method combination is used and all
applicable methods are primary methods—the effective method is the most
specific method.  That method can call the next most specific method by
using the function ‘call-next-method’.  The method that
‘call-next-method’ will call is referred to as the “next method”.  The
predicate ‘next-method-p’ tests whether a next method exists.  If
‘call-next-method’ is called and there is no next most specific method,
the generic function ‘no-next-method’ is invoked.

In general, the effective method is some combination of the applicable
methods.  It is described by a form that contains calls to some or all
of the applicable methods, returns the value or values that will be
returned as the value or values of the generic function, and optionally
makes some of the methods accessible by means of ‘call-next-method’.

The role of each method in the effective method is determined by its
qualifiers and the specificity of the method.  A qualifier serves to
mark a method, and the meaning of a qualifier is determined by the way
that these marks are used by this step of the procedure.  If an
applicable method has an unrecognized qualifier, this step signals an
error and does not include that method in the effective method.

When standard method combination is used together with qualified
methods, the effective method is produced as described in *note Section
7.6.6.2 (Standard Method Combination): StdMethComb.

Another type of method combination can be specified by using the
:method-combination option of ‘defgeneric’ or of any of the other
operators that specify generic function options.  In this way this step
of the procedure can be customized.

New types of method combination can be defined by using the
‘define-method-combination’ macro.

7.6.6.2 Standard Method Combination
...................................

Standard method combination is supported by the class
‘standard-generic-function’.  It is used if no other type of method
combination is specified or if the built-in method combination type
standard is specified.

Primary methods define the main action of the effective method, while
auxiliary methods modify that action in one of three ways.  A primary
method has no method qualifiers.

An auxiliary method is a method whose qualifier is :before, :after, or
:around.  Standard method combination allows no more than one qualifier
per method; if a method definition specifies more than one qualifier per
method, an error is signaled.

   • A before method has the keyword :before as its only qualifier.  A
     before method specifies code that is to be run before any primary
     methods.

   • An after method has the keyword :after as its only qualifier.  An
     after method specifies code that is to be run after primary
     methods.

   • An around method has the keyword :around as its only qualifier.  An
     around method specifies code that is to be run instead of other
     applicable methods, but which might contain explicit code which
     calls some of those shadowed methods (via ‘call-next-method’).

The semantics of standard method combination is as follows:

   • If there are any around methods, the most specific around method is
     called.  It supplies the value or values of the generic function.

   • Inside the body of an around method, ‘call-next-method’ can be used
     to call the next method.  When the next method returns, the around
     method can execute more code, perhaps based on the returned value
     or values.  The generic function ‘no-next-method’ is invoked if
     ‘call-next-method’ is used and there is no applicable method to
     call.  The function ‘next-method-p’ may be used to determine
     whether a next method exists.

   • If an around method invokes ‘call-next-method’, the next most
     specific around method is called, if one is applicable.  If there
     are no around methods or if ‘call-next-method’ is called by the
     least specific around method, the other methods are called as
     follows:

        – All the before methods are called, in most-specific-first
          order.  Their values are ignored.  An error is signaled if
          ‘call-next-method’ is used in a before method.

        – The most specific primary method is called.  Inside the body
          of a primary method, ‘call-next-method’ may be used to call
          the next most specific primary method.  When that method
          returns, the previous primary method can execute more code,
          perhaps based on the returned value or values.  The generic
          function ‘no-next-method’ is invoked if ‘call-next-method’ is
          used and there are no more applicable primary methods.  The
          function ‘next-method-p’ may be used to determine whether a
          next method exists.  If ‘call-next-method’ is not used, only
          the most specific primary method is called.

        – All the after methods are called in most-specific-last order.
          Their values are ignored.  An error is signaled if
          ‘call-next-method’ is used in an after method.

   • If no around methods were invoked, the most specific primary method
     supplies the value or values returned by the generic function.  The
     value or values returned by the invocation of ‘call-next-method’ in
     the least specific around method are those returned by the most
     specific primary method.

In standard method combination, if there is an applicable method but no
applicable primary method, an error is signaled.

The before methods are run in most-specific-first order while the after
methods are run in least-specific-first order.  The design rationale for
this difference can be illustrated with an example.  Suppose class
Csuperclass, CWhether the behavior of the class Cdirectly by methods on
Cdoes not affect the relative order of invocation of methods on
instances of the class Cbefore method runs before all of class CClass C

By contrast, all around methods run before any other methods run.  Thus
a less specific around method runs before a more specific primary
method.

If only primary methods are used and if ‘call-next-method’ is not used,
only the most specific method is invoked; that is, more specific methods
shadow more general ones.

7.6.6.3 Declarative Method Combination
......................................

The macro ‘define-method-combination’ defines new forms of method
combination.  It provides a mechanism for customizing the production of
the effective method.  The default procedure for producing an effective
method is described in *note Section 7.6.6.1 (Determining the Effective
Method): DeterminingtheEffectiveMethod.  There are two forms of
‘define-method-combination’.  The short form is a simple facility while
the long form is more powerful and more verbose.  The long form
resembles ‘defmacro’ in that the body is an expression that computes a
Lisp form; it provides mechanisms for implementing arbitrary control
structures within method combination and for arbitrary processing of
method qualifiers.

7.6.6.4 Built-in Method Combination Types
.........................................

The object system provides a set of built-in method combination types.
To specify that a generic function is to use one of these method
combination types, the name of the method combination type is given as
the argument to the :method-combination option to ‘defgeneric’ or to the
:method-combination option to any of the other operators that specify
generic function options.

The names of the built-in method combination types are listed in the
next figure.

+     append   max   nconc   progn
and   list     min   or      standard

Figure 7.2: Built-in Method Combination Types

The semantics of the standard built-in method combination type is
described in *note Section 7.6.6.2 (Standard Method Combination):
StdMethComb.  The other built-in method combination types are called
simple built-in method combination types.

The simple built-in method combination types act as though they were
defined by the short form of ‘define-method-combination’.  They
recognize two roles for methods:

   • An around method has the keyword symbol :around as its sole
     qualifier.  The meaning of :around methods is the same as in
     standard method combination.  Use of the functions
     ‘call-next-method’ and ‘next-method-p’ is supported in around
     methods.

   • A primary method has the name of the method combination type as its
     sole qualifier.  For example, the built-in method combination type
     ‘and’ recognizes methods whose sole qualifier is ‘and’; these are
     primary methods.  Use of the functions ‘call-next-method’ and
     ‘next-method-p’ is not supported in primary methods.

The semantics of the simple built-in method combination types is as
follows:

   • If there are any around methods, the most specific around method is
     called.  It supplies the value or values of the generic function.

   • Inside the body of an around method, the function
     ‘call-next-method’ can be used to call the next method.  The
     generic function ‘no-next-method’ is invoked if ‘call-next-method’
     is used and there is no applicable method to call.  The function
     ‘next-method-p’ may be used to determine whether a next method
     exists.  When the next method returns, the around method can
     execute more code, perhaps based on the returned value or values.

   • If an around method invokes ‘call-next-method’, the next most
     specific around method is called, if one is applicable.  If there
     are no around methods or if ‘call-next-method’ is called by the
     least specific around method, a Lisp form derived from the name of
     the built-in method combination type and from the list of
     applicable primary methods is evaluated to produce the value of the
     generic function.  Suppose the name of the method combination type
     is operator and the call to the generic function is of the form

          (generic-function a

   • Let Min order; then the derived Lisp form is

          (operator 〈 M aM

   • If the expression 〈 M

The simple built-in method combination types require exactly one
qualifier per method.  An error is signaled if there are applicable
methods with no qualifiers or with qualifiers that are not supported by
the method combination type.  An error is signaled if there are
applicable around methods and no applicable primary methods.


File: ansicl,  Node: Inheritance of Methods,  Prev: Method Selection and Combination,  Up: Generic Functions and Methods

7.6.7 Inheritance of Methods
----------------------------

A subclass inherits methods in the sense that any method applicable to
all instances of a class is also applicable to all instances of any
subclass of that class.

The inheritance of methods acts the same way regardless of which of the
method-defining operators created the methods.

The inheritance of methods is described in detail in *note Section 7.6.6
(Method Selection and Combination): Method Selection and Combination.


File: ansicl,  Node: function-keywords,  Next: ensure-generic-function,  Prev: Generic Functions and Methods,  Up: Objects

function-keywords (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: function-keywords method → keys,
          allow-other-keys-p

Method Signatures:
..................

function-keywords (METHOD ‘standard-method’)

Arguments and Values:
.....................

METHOD—a method.

KEYS—a list.

ALLOW-OTHER-KEYS-P—a generalized boolean.

Description:
............

Returns the keyword parameter specifiers for a METHOD.

Two values are returned: a list of the explicitly named keywords and a
generalized boolean that states whether ‘&allow-other-keys’ had been
specified in the METHOD definition.

Examples:
.........

      (defmethod gf1 ((a integer) &optional (b 2)
                      &key (c 3) ((:dee d) 4) e ((eff f)))
        (list a b c d e f))
     → #<STANDARD-METHOD GF1 (INTEGER) 36324653>
      (find-method #'gf1 '() (list (find-class 'integer)))
     → #<STANDARD-METHOD GF1 (INTEGER) 36324653>
      (function-keywords *)
     → (:C :DEE :E EFF), false
      (defmethod gf2 ((a integer))
        (list a b c d e f))
     → #<STANDARD-METHOD GF2 (INTEGER) 42701775>
      (function-keywords (find-method #'gf1 '() (list (find-class 'integer))))
     → (), false
      (defmethod gf3 ((a integer) &key b c d &allow-other-keys)
        (list a b c d e f))
      (function-keywords *)
     → (:B :C :D), true

Affected By:
............

‘defmethod’

See Also:
.........

*note defmethod::


File: ansicl,  Node: ensure-generic-function,  Next: allocate-instance,  Prev: function-keywords,  Up: Objects

ensure-generic-function (Function)
==================================

Syntax:
.......

 -- Function: ensure-generic-function function-name &key
          argument-precedence-order declare documentation environment
          generic-function-class lambda-list
          method-class method-combination → generic-function

Arguments and Values:
.....................

FUNCTION-NAME—a function name.

The keyword arguments correspond to the OPTION arguments of
‘defgeneric’, except that the :method-class and :generic-function-class
arguments can be class objects as well as names.

‘Method-combination’—method combination object.

‘Environment’—the same as the ‘&environment’ argument to macro expansion
functions and is used to distinguish between compile-time and run-time
environments.

GENERIC-FUNCTION—a generic function object.

Description:
............

The function ‘ensure-generic-function’ is used to define a globally
named generic function with no methods or to specify or modify options
and declarations that pertain to a globally named generic function as a
whole.

If FUNCTION-NAME is not fbound in the global environment, a new generic
function is created.  If ‘(fdefinition FUNCTION-NAME)’ is an ordinary
function, a macro, or a special operator, an error is signaled.

If FUNCTION-NAME is a list, it must be of the form ‘(setf SYMBOL)’.  If
FUNCTION-NAME specifies a generic function that has a different value
for any of the following arguments, the generic function is modified to
have the new value: :argument-precedence-order, :declare,
:documentation, :method-combination.

If FUNCTION-NAME specifies a generic function that has a different value
for the :lambda-list argument, and the new value is congruent with the
lambda lists of all existing methods or there are no methods, the value
is changed; otherwise an error is signaled.

If FUNCTION-NAME specifies a generic function that has a different value
for the :generic-function-class argument and if the new generic function
class is compatible with the old, ‘change-class’ is called to change the
class of the generic function; otherwise an error is signaled.

If FUNCTION-NAME specifies a generic function that has a different value
for the :method-class argument, the value is changed, but any existing
methods are not changed.

Affected By:
............

Existing function binding of FUNCTION-NAME.

Exceptional Situations:
.......................

If ‘(fdefinition FUNCTION-NAME)’ is an ordinary function, a macro, or a
special operator, an error of type ‘error’ is signaled.

If FUNCTION-NAME specifies a generic function that has a different value
for the :lambda-list argument, and the new value is not congruent with
the lambda list of any existing method, an error of type ‘error’ is
signaled.

If FUNCTION-NAME specifies a generic function that has a different value
for the :generic-function-class argument and if the new generic function
class not is compatible with the old, an error of type ‘error’ is
signaled.

See Also:
.........

*note defgeneric::


File: ansicl,  Node: allocate-instance,  Next: reinitialize-instance,  Prev: ensure-generic-function,  Up: Objects

allocate-instance (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: allocate-instance class &rest initargs &key
          &allow-other-keys → new-instance

Method Signatures:
..................

allocate-instance (CLASS ‘standard-class’) &rest initargs

allocate-instance (CLASS ‘structure-class’) &rest initargs

Arguments and Values:
.....................

CLASS—a class.

INITARGS—a list of keyword/value pairs (initialization argument names
and values).

NEW-INSTANCE—an object whose class is CLASS.

Description:
............

The generic function ‘allocate-instance’ creates and returns a new
instance of the CLASS, without initializing it.  When the CLASS is a
standard class, this means that the slots are unbound; when the class is
a structure class, this means the slots’ values are unspecified.

The caller of ‘allocate-instance’ is expected to have already checked
the initialization arguments.

The generic function ‘allocate-instance’ is called by ‘make-instance’,
as described in *note Section 7.1 (Object Creation and Initialization):
Object Creation and Initialization.

See Also:
.........

*note defclass::, *note make-instance::, *note class-of::, *note Section
7.1 (Object Creation and Initialization): Object Creation and
Initialization.

Notes:
......

The consequences of adding methods to ‘allocate-instance’ is
unspecified.  This capability might be added by the Metaobject Protocol.


File: ansicl,  Node: reinitialize-instance,  Next: shared-initialize (Standard Generic Function),  Prev: allocate-instance,  Up: Objects

reinitialize-instance (Standard Generic Function)
=================================================

Syntax:
.......

 -- Generic Function: reinitialize-instance instance &rest initargs &key
          &allow-other-keys → instance

Method Signatures:
..................

reinitialize-instance (INSTANCE ‘standard-object’) &rest initargs

Arguments and Values:
.....................

INSTANCE—an object.

INITARGS—an initialization argument list.

Description:
............

The generic function ‘reinitialize-instance’ can be used to change the
values of local slots of an INSTANCE according to INITARGS.  This
generic function can be called by users.

The system-supplied primary method for ‘reinitialize-instance’ checks
the validity of INITARGS and signals an error if an INITARG is supplied
that is not declared as valid.  The method then calls the generic
function ‘shared-initialize’ with the following arguments: the INSTANCE,
‘nil’ (which means no slots should be initialized according to their
initforms), and the INITARGS it received.

Side Effects:
.............

The generic function ‘reinitialize-instance’ changes the values of local
slots.

Exceptional Situations:
.......................

The system-supplied primary method for ‘reinitialize-instance’ signals
an error if an INITARG is supplied that is not declared as valid.

See Also:
.........

*note initialize-instance (Standard Generic Function)::, *note
shared-initialize (Standard Generic Function)::, *note
update-instance-for-redefined-class::, *note
update-instance-for-different-class::, *note slot-boundp::, *note
slot-makunbound::, *note Section 7.3 (Reinitializing an Instance):
Reinitializing an Instance, *note Section 7.1.4 (Rules for
Initialization Arguments): Rules for Initialization Arguments, *note
Section 7.1.2 (Declaring the Validity of Initialization Arguments):
Declaring the Validity of Initialization Arguments.

Notes:
......

INITARGS are declared as valid by using the :initarg option to
‘defclass’, or by defining methods for ‘reinitialize-instance’ or
‘shared-initialize’.  The keyword name of each keyword parameter
specifier in the lambda list of any method defined on
‘reinitialize-instance’ or ‘shared-initialize’ is declared as a valid
initialization argument name for all classes for which that method is
applicable.


File: ansicl,  Node: shared-initialize (Standard Generic Function),  Next: update-instance-for-different-class,  Prev: reinitialize-instance,  Up: Objects

shared-initialize (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: shared-initialize instance slot-names &rest
          initargs &key &allow-other-keys → instance

Method Signatures:
..................

shared-initialize (INSTANCE ‘standard-object’) slot-names &rest initargs

Arguments and Values:
.....................

INSTANCE—an object.

SLOT-NAMES—a list or ‘t’.

INITARGS—a list of keyword/value pairs (of initialization argument names
and values).

Description:
............

The generic function ‘shared-initialize’ is used to fill the slots of an
INSTANCE using INITARGS and :initform forms.  It is called when an
instance is created, when an instance is re-initialized, when an
instance is updated to conform to a redefined class, and when an
instance is updated to conform to a different class.  The generic
function ‘shared-initialize’ is called by the system-supplied primary
method for ‘initialize-instance’, ‘reinitialize-instance’,
‘update-instance-for-redefined-class’, and
‘update-instance-for-different-class’.

The generic function ‘shared-initialize’ takes the following arguments:
the INSTANCE to be initialized, a specification of a set of SLOT-NAMES
accessible in that INSTANCE, and any number of INITARGS.  The arguments
after the first two must form an initialization argument list.  The
system-supplied primary method on ‘shared-initialize’ initializes the
slots with values according to the INITARGS and supplied :initform
forms.  SLOT-NAMES indicates which slots should be initialized according
to their :initform forms if no INITARGS are provided for those slots.

The system-supplied primary method behaves as follows, regardless of
whether the slots are local or shared:

   • If an INITARG in the initialization argument list specifies a value
     for that slot, that value is stored into the slot, even if a value
     has already been stored in the slot before the method is run.

   • Any slots indicated by SLOT-NAMES that are still unbound at this
     point are initialized according to their :initform forms.  For any
     such slot that has an :initform form, that form is evaluated in the
     lexical environment of its defining ‘defclass’ form and the result
     is stored into the slot.  For example, if a before method stores a
     value in the slot, the :initform form will not be used to supply a
     value for the slot.

   • The rules mentioned in *note Section 7.1.4 (Rules for
     Initialization Arguments): Rules for Initialization Arguments. are
     obeyed.

The SLOTS-NAMES argument specifies the slots that are to be initialized
according to their :initform forms if no initialization arguments apply.
It can be a list of slot names, which specifies the set of those slot
names; or it can be the symbol ‘t’, which specifies the set of all of
the slots.

See Also:
.........

*note initialize-instance (Standard Generic Function)::, *note
reinitialize-instance::, *note update-instance-for-redefined-class::,
*note update-instance-for-different-class::, *note slot-boundp::, *note
slot-makunbound::, *note Section 7.1 (Object Creation and
Initialization): Object Creation and Initialization, *note Section 7.1.4
(Rules for Initialization Arguments): Rules for Initialization
Arguments, *note Section 7.1.2 (Declaring the Validity of Initialization
Arguments): Declaring the Validity of Initialization Arguments.

Notes:
......

INITARGS are declared as valid by using the :initarg option to
‘defclass’, or by defining methods for ‘shared-initialize’.  The keyword
name of each keyword parameter specifier in the lambda list of any
method defined on ‘shared-initialize’ is declared as a valid INITARG
name for all classes for which that method is applicable.

Implementations are permitted to optimize :initform forms that neither
produce nor depend on side effects, by evaluating these forms and
storing them into slots before running any ‘initialize-instance’
methods, rather than by handling them in the primary
‘initialize-instance’ method.  (This optimization might be implemented
by having the ‘allocate-instance’ method copy a prototype instance.)

Implementations are permitted to optimize default initial value forms
for INITARGS associated with slots by not actually creating the complete
initialization argument list when the only method that would receive the
complete list is the method on ‘standard-object’.  In this case default
initial value forms can be treated like :initform forms.  This
optimization has no visible effects other than a performance
improvement.


File: ansicl,  Node: update-instance-for-different-class,  Next: update-instance-for-redefined-class,  Prev: shared-initialize (Standard Generic Function),  Up: Objects

update-instance-for-different-class (Standard Generic Function)
===============================================================

Syntax:
.......

 -- Generic Function: update-instance-for-different-class previous
          current &rest initargs &key &allow-other-keys →
          implementation-dependent

Method Signatures:
..................

update-instance-for-different-class (PREVIOUS ‘standard-object’)
(CURRENT ‘standard-object’) &rest initargs

Arguments and Values:
.....................

PREVIOUS—a copy of the original instance.

CURRENT—the original instance (altered).

INITARGS—an initialization argument list.

Description:
............

The generic function ‘update-instance-for-different-class’ is not
intended to be called by programmers.  Programmers may write methods for
it.  The function ‘update-instance-for-different-class’ is called only
by the function ‘change-class’.

The system-supplied primary method on
‘update-instance-for-different-class’ checks the validity of INITARGS
and signals an error if an INITARG is supplied that is not declared as
valid.  This method then initializes slots with values according to the
INITARGS, and initializes the newly added slots with values according to
their :initform forms.  It does this by calling the generic function
‘shared-initialize’ with the following arguments: the instance
(CURRENT), a list of names of the newly added slots, and the INITARGS it
received.  Newly added slots are those local slots for which no slot of
the same name exists in the PREVIOUS class.

Methods for ‘update-instance-for-different-class’ can be defined to
specify actions to be taken when an instance is updated.  If only after
methods for ‘update-instance-for-different-class’ are defined, they will
be run after the system-supplied primary method for initialization and
therefore will not interfere with the default behavior of
‘update-instance-for-different-class’.

Methods on ‘update-instance-for-different-class’ can be defined to
initialize slots differently from ‘change-class’.  The default behavior
of ‘change-class’ is described in *note Section 7.2 (Changing the Class
of an Instance): Changing the Class of an Instance.

The arguments to ‘update-instance-for-different-class’ are computed by
‘change-class’.  When ‘change-class’ is invoked on an instance, a copy
of that instance is made; ‘change-class’ then destructively alters the
original instance.  The first argument to
‘update-instance-for-different-class’, PREVIOUS, is that copy; it holds
the old slot values temporarily.  This argument has dynamic extent
within ‘change-class’; if it is referenced in any way once
‘update-instance-for-different-class’ returns, the results are
undefined.  The second argument to
‘update-instance-for-different-class’, CURRENT, is the altered original
instance.  The intended use of PREVIOUS is to extract old slot values by
using ‘slot-value’ or ‘with-slots’ or by invoking a reader generic
function, or to run other methods that were applicable to instances of
the original class.

Examples:
.........

See the example for the function ‘change-class’.

Exceptional Situations:
.......................

The system-supplied primary method on
‘update-instance-for-different-class’ signals an error if an
initialization argument is supplied that is not declared as valid.

See Also:
.........

*note change-class::, *note shared-initialize (Standard Generic
Function)::, *note Section 7.2 (Changing the Class of an Instance):
Changing the Class of an Instance, *note Section 7.1.4 (Rules for
Initialization Arguments): Rules for Initialization Arguments, *note
Section 7.1.2 (Declaring the Validity of Initialization Arguments):
Declaring the Validity of Initialization Arguments.

Notes:
......

INITARGS are declared as valid by using the :initarg option to
‘defclass’, or by defining methods for
‘update-instance-for-different-class’ or ‘shared-initialize’.  The
keyword name of each keyword parameter specifier in the lambda list of
any method defined on ‘update-instance-for-different-class’ or
‘shared-initialize’ is declared as a valid INITARG name for all classes
for which that method is applicable.

The value returned by ‘update-instance-for-different-class’ is ignored
by ‘change-class’.


File: ansicl,  Node: update-instance-for-redefined-class,  Next: change-class,  Prev: update-instance-for-different-class,  Up: Objects

update-instance-for-redefined-class (Standard Generic Function)
===============================================================

Syntax:
.......

 -- Generic Function: update-instance-for-redefined-class instance
          added-slots discarded-slots property-list
          &rest initargs &key &allow-other-keys → {result}*

Method Signatures:
..................

update-instance-for-redefined-class (INSTANCE ‘standard-object’)
added-slots discarded-slots property-list &rest initargs

Arguments and Values:
.....................

INSTANCE—an object.

ADDED-SLOTS—a list.

DISCARDED-SLOTS—a list.

PROPERTY-LIST—a list.

INITARGS—an initialization argument list.

RESULT—an object.

Description:
............

The generic function ‘update-instance-for-redefined-class’ is not
intended to be called by programmers.  Programmers may write methods for
it.  The generic function ‘update-instance-for-redefined-class’ is
called by the mechanism activated by ‘make-instances-obsolete’.

The system-supplied primary method on
‘update-instance-for-redefined-class’ checks the validity of INITARGS
and signals an error if an INITARG is supplied that is not declared as
valid.  This method then initializes slots with values according to the
INITARGS, and initializes the newly ADDED-SLOTS with values according to
their :initform forms.  It does this by calling the generic function
‘shared-initialize’ with the following arguments: the INSTANCE, a list
of names of the newly ADDED-SLOTS to INSTANCE, and the INITARGS it
received.  Newly ADDED-SLOTS are those local slots for which no slot of
the same name exists in the old version of the class.

When ‘make-instances-obsolete’ is invoked or when a class has been
redefined and an instance is being updated, a PROPERTY-LIST is created
that captures the slot names and values of all the DISCARDED-SLOTS with
values in the original INSTANCE.  The structure of the INSTANCE is
transformed so that it conforms to the current class definition.  The
arguments to ‘update-instance-for-redefined-class’ are this transformed
INSTANCE, a list of ADDED-SLOTS to the INSTANCE, a list DISCARDED-SLOTS
from the INSTANCE, and the PROPERTY-LIST containing the slot names and
values for slots that were discarded and had values.  Included in this
list of discarded slots are slots that were local in the old class and
are shared in the new class.

The value returned by ‘update-instance-for-redefined-class’ is ignored.

Examples:
.........


      (defclass position () ())

      (defclass x-y-position (position)
          ((x :initform 0 :accessor position-x)
           (y :initform 0 :accessor position-y)))

     ;;; It turns out polar coordinates are used more than Cartesian
     ;;; coordinates, so the representation is altered and some new
     ;;; accessor methods are added.

      (defmethod update-instance-for-redefined-class :before
         ((pos x-y-position) added deleted plist &key)
        ;; Transform the x-y coordinates to polar coordinates
        ;; and store into the new slots.
        (let ((x (getf plist 'x))
              (y (getf plist 'y)))
          (setf (position-rho pos) (sqrt (+ (* x x) (* y y)))
                (position-theta pos) (atan y x))))

      (defclass x-y-position (position)
          ((rho :initform 0 :accessor position-rho)
           (theta :initform 0 :accessor position-theta)))

     ;;; All instances of the old x-y-position class will be updated
     ;;; automatically.

     ;;; The new representation is given the look and feel of the old one.

      (defmethod position-x ((pos x-y-position))
         (with-slots (rho theta) pos (* rho (cos theta))))

      (defmethod (setf position-x) (new-x (pos x-y-position))
         (with-slots (rho theta) pos
           (let ((y (position-y pos)))
             (setq rho (sqrt (+ (* new-x new-x) (* y y)))
                   theta (atan y new-x))
             new-x)))

      (defmethod position-y ((pos x-y-position))
         (with-slots (rho theta) pos (* rho (sin theta))))

      (defmethod (setf position-y) (new-y (pos x-y-position))
         (with-slots (rho theta) pos
           (let ((x (position-x pos)))
             (setq rho (sqrt (+ (* x x) (* new-y new-y)))
                   theta (atan new-y x))
             new-y)))


Exceptional Situations:
.......................

The system-supplied primary method on
‘update-instance-for-redefined-class’ signals an error if an INITARG is
supplied that is not declared as valid.

See Also:
.........

*note make-instances-obsolete::, *note shared-initialize (Standard
Generic Function)::, *note Section 4.3.6 (Redefining Classes):
Redefining Classes, *note Section 7.1.4 (Rules for Initialization
Arguments): Rules for Initialization Arguments, *note Section 7.1.2
(Declaring the Validity of Initialization Arguments): Declaring the
Validity of Initialization Arguments.

Notes:
......

INITARGS are declared as valid by using the :initarg option to
‘defclass’, or by defining methods for
‘update-instance-for-redefined-class’ or ‘shared-initialize’.  The
keyword name of each keyword parameter specifier in the lambda list of
any method defined on ‘update-instance-for-redefined-class’ or
‘shared-initialize’ is declared as a valid INITARG name for all classes
for which that method is applicable.


File: ansicl,  Node: change-class,  Next: slot-boundp,  Prev: update-instance-for-redefined-class,  Up: Objects

change-class (Standard Generic Function)
========================================

Syntax:
.......

 -- Generic Function: change-class instance new-class &key
          &allow-other-keys → instance

Method Signatures:
..................

change-class (INSTANCE ‘standard-object’) (NEW-CLASS ‘standard-class’)
&rest initargs

change-class (INSTANCE ‘t’) (NEW-CLASS ‘symbol’) &rest initargs

Arguments and Values:
.....................

INSTANCE—an object.

NEW-CLASS—a class designator.

INITARGS—an initialization argument list.

Description:
............

The generic function ‘change-class’ changes the class of an INSTANCE to
NEW-CLASS.  It destructively modifies and returns the INSTANCE.

If in the old class there is any slot of the same name as a local slot
in the NEW-CLASS, the value of that slot is retained.  This means that
if the slot has a value, the value returned by ‘slot-value’ after
‘change-class’ is invoked is ‘eql’ to the value returned by ‘slot-value’
before ‘change-class’ is invoked.  Similarly, if the slot was unbound,
it remains unbound.  The other slots are initialized as described in
*note Section 7.2 (Changing the Class of an Instance): Changing the
Class of an Instance.

After completing all other actions, ‘change-class’ invokes
‘update-instance-for-different-class’.  The generic function
‘update-instance-for-different-class’ can be used to assign values to
slots in the transformed instance.  See *note Section 7.2.2
(Initializing Newly Added Local Slots): Initializing Newly Added Local
Slots.

If the second of the above methods is selected, that method invokes
‘change-class’ on INSTANCE, ‘(find-class NEW-CLASS)’, and the INITARGS.

Examples:
.........


      (defclass position () ())

      (defclass x-y-position (position)
          ((x :initform 0 :initarg :x)
           (y :initform 0 :initarg :y)))

      (defclass rho-theta-position (position)
          ((rho :initform 0)
           (theta :initform 0)))

      (defmethod update-instance-for-different-class :before ((old x-y-position)
                                                              (new rho-theta-position)
                                                              &key)
        ;; Copy the position information from old to new to make new
        ;; be a rho-theta-position at the same position as old.
        (let ((x (slot-value old 'x))
              (y (slot-value old 'y)))
          (setf (slot-value new 'rho) (sqrt (+ (* x x) (* y y)))
                (slot-value new 'theta) (atan y x))))

     ;;; At this point an instance of the class x-y-position can be
     ;;; changed to be an instance of the class rho-theta-position using
     ;;; change-class:

      (setq p1 (make-instance 'x-y-position :x 2 :y 0))

      (change-class p1 'rho-theta-position)

     ;;; The result is that the instance bound to p1 is now an instance of
     ;;; the class rho-theta-position.   The update-instance-for-different-class
     ;;; method performed the initialization of the rho and theta slots based
     ;;; on the value of the x and y slots, which were maintained by
     ;;; the old instance.


See Also:
.........

*note update-instance-for-different-class::, *note Section 7.2 (Changing
the Class of an Instance): Changing the Class of an Instance.

Notes:
......

The generic function ‘change-class’ has several semantic difficulties.
First, it performs a destructive operation that can be invoked within a
method on an instance that was used to select that method.  When
multiple methods are involved because methods are being combined, the
methods currently executing or about to be executed may no longer be
applicable.  Second, some implementations might use compiler
optimizations of slot access, and when the class of an instance is
changed the assumptions the compiler made might be violated.  This
implies that a programmer must not use ‘change-class’ inside a method if
any methods for that generic function access any slots, or the results
are undefined.

