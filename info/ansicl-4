This is ansicl, produced by makeinfo version 6.7 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: slot-boundp,  Next: slot-exists-p,  Prev: change-class,  Up: Objects

slot-boundp (Function)
======================

Syntax:
.......

 -- Function: slot-boundp instance slot-name → generalized-boolean

Arguments and Values:
.....................

INSTANCE—an object.

SLOT-NAME—a symbol naming a slot of INSTANCE.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if the slot named SLOT-NAME in INSTANCE is bound;
otherwise, returns false.

Exceptional Situations:
.......................

If no slot of the name SLOT-NAME exists in the INSTANCE, ‘slot-missing’
is called as follows:

      (slot-missing (class-of instance)
                    instance
                    slot-name
                    'slot-boundp)

(If ‘slot-missing’ is invoked and returns a value, a boolean equivalent
to its primary value is returned by ‘slot-boundp’.)

The specific behavior depends on INSTANCE’s metaclass.  An error is
never signaled if INSTANCE has metaclass ‘standard-class’.  An error is
always signaled if INSTANCE has metaclass ‘built-in-class’.  The
consequences are undefined if INSTANCE has any other metaclass—an error
might or might not be signaled in this situation.  Note in particular
that the behavior for conditions and structures is not specified.

See Also:
.........

*note slot-makunbound::, *note slot-missing::

Notes:
......

The function ‘slot-boundp’ allows for writing after methods on
‘initialize-instance’ in order to initialize only those slots that have
not already been bound.

Although no implementation is required to do so, implementors are
strongly encouraged to implement the function ‘slot-boundp’ using the
function ‘slot-boundp-using-class’ described in the Metaobject Protocol.


File: ansicl,  Node: slot-exists-p,  Next: slot-makunbound,  Prev: slot-boundp,  Up: Objects

slot-exists-p (Function)
========================

Syntax:
.......

 -- Function: slot-exists-p object slot-name → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

SLOT-NAME—a symbol.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if the OBJECT has a slot named SLOT-NAME.

Affected By:
............

‘defclass’, ‘defstruct’

See Also:
.........

*note defclass::, *note slot-missing::

Notes:
......

Although no implementation is required to do so, implementors are
strongly encouraged to implement the function ‘slot-exists-p’ using the
function ‘slot-exists-p-using-class’ described in the Metaobject
Protocol.


File: ansicl,  Node: slot-makunbound,  Next: slot-missing,  Prev: slot-exists-p,  Up: Objects

slot-makunbound (Function)
==========================

Syntax:
.......

 -- Function: slot-makunbound instance slot-name → instance

Arguments and Values:
.....................

INSTANCE—instance.

SLOT-NAME—a symbol.

Description:
............

The function ‘slot-makunbound’ restores a slot of the name SLOT-NAME in
an INSTANCE to the unbound state.

Exceptional Situations:
.......................

If no slot of the name SLOT-NAME exists in the INSTANCE, ‘slot-missing’
is called as follows:

     (slot-missing (class-of instance)
                   instance
                   slot-name
                   'slot-makunbound)

(Any values returned by ‘slot-missing’ in this case are ignored by
‘slot-makunbound’.)

The specific behavior depends on INSTANCE’s metaclass.  An error is
never signaled if INSTANCE has metaclass ‘standard-class’.  An error is
always signaled if INSTANCE has metaclass ‘built-in-class’.  The
consequences are undefined if INSTANCE has any other metaclass—an error
might or might not be signaled in this situation.  Note in particular
that the behavior for conditions and structures is not specified.

See Also:
.........

*note slot-boundp::, *note slot-missing::

Notes:
......

Although no implementation is required to do so, implementors are
strongly encouraged to implement the function ‘slot-makunbound’ using
the function ‘slot-makunbound-using-class’ described in the Metaobject
Protocol.


File: ansicl,  Node: slot-missing,  Next: slot-unbound,  Prev: slot-makunbound,  Up: Objects

slot-missing (Standard Generic Function)
========================================

Syntax:
.......

 -- Generic Function: slot-missing class object slot-name operation
          &optional new-value → {result}*

Method Signatures:
..................

slot-missing (CLASS ‘t’) object slot-name operation &optional new-value

Arguments and Values:
.....................

CLASS—the class of OBJECT.

OBJECT—an object.

SLOT-NAME—a symbol (the name of a would-be slot).

OPERATION—one of the symbols ‘setf’, ‘slot-boundp’, ‘slot-makunbound’,
or ‘slot-value’.

NEW-VALUE—an object.

RESULT—an object.

Description:
............

The generic function ‘slot-missing’ is invoked when an attempt is made
to access a slot in an OBJECT whose metaclass is ‘standard-class’ and
the slot of the name SLOT-NAME is not a name of a slot in that class.
The default method signals an error.

The generic function ‘slot-missing’ is not intended to be called by
programmers.  Programmers may write methods for it.

The generic function ‘slot-missing’ may be called during evaluation of
‘slot-value’, ‘(setf slot-value)’, ‘slot-boundp’, and ‘slot-makunbound’.
For each of these operations the corresponding symbol for the OPERATION
argument is slot-value, setf, slot-boundp, and slot-makunbound
respectively.

The optional NEW-VALUE argument to ‘slot-missing’ is used when the
operation is attempting to set the value of the slot.

If ‘slot-missing’ returns, its values will be treated as follows:

   • If the OPERATION is setf or slot-makunbound, any values will be
     ignored by the caller.

   • If the OPERATION is slot-value, only the primary value will be used
     by the caller, and all other values will be ignored.

   • If the OPERATION is slot-boundp, any boolean equivalent of the
     primary value of the method might be is used, and all other values
     will be ignored.

Exceptional Situations:
.......................

The default method on ‘slot-missing’ signals an error of type ‘error’.

See Also:
.........

*note defclass::, *note slot-exists-p::, *note slot-value::

Notes:
......

The set of arguments (including the class of the instance) facilitates
defining methods on the metaclass for ‘slot-missing’.


File: ansicl,  Node: slot-unbound,  Next: slot-value,  Prev: slot-missing,  Up: Objects

slot-unbound (Standard Generic Function)
========================================

Syntax:
.......

 -- Generic Function: slot-unbound class instance slot-name → {result}*

Method Signatures:
..................

slot-unbound (CLASS ‘t’) instance slot-name

Arguments and Values:
.....................

CLASS—the class of the INSTANCE.

INSTANCE—the INSTANCE in which an attempt was made to read the unbound
slot.

SLOT-NAME—the name of the unbound slot.

RESULT—an object.

Description:
............

The generic function ‘slot-unbound’ is called when an unbound slot is
read in an INSTANCE whose metaclass is ‘standard-class’.  The default
method signals an error of type ‘unbound-slot’.  The name slot of the
‘unbound-slot’ condition is initialized to the name of the offending
variable, and the instance slot of the ‘unbound-slot’ condition is
initialized to the offending instance.

The generic function ‘slot-unbound’ is not intended to be called by
programmers.  Programmers may write methods for it.  The function
‘slot-unbound’ is called only indirectly by ‘slot-value’.

If ‘slot-unbound’ returns, only the primary value will be used by the
caller, and all other values will be ignored.

Exceptional Situations:
.......................

The default method on ‘slot-unbound’ signals an error of type
‘unbound-slot’.

See Also:
.........

*note slot-makunbound::

Notes:
......

An unbound slot may occur if no :initform form was specified for the
slot and the slot value has not been set, or if ‘slot-makunbound’ has
been called on the slot.


File: ansicl,  Node: slot-value,  Next: method-qualifiers,  Prev: slot-unbound,  Up: Objects

slot-value (Function)
=====================

Syntax:
.......

 -- Function: slot-value object slot-name → value

Arguments and Values:
.....................

OBJECT—an object.

NAME—a symbol.

VALUE—an object.

Description:
............

The function ‘slot-value’ returns the value of the slot named SLOT-NAME
in the OBJECT.  If there is no slot named SLOT-NAME, ‘slot-missing’ is
called.  If the slot is unbound, ‘slot-unbound’ is called.

The macro ‘setf’ can be used with ‘slot-value’ to change the value of a
slot.

Examples:
.........

      (defclass foo ()
        ((a :accessor foo-a :initarg :a :initform 1)
         (b :accessor foo-b :initarg :b)
         (c :accessor foo-c :initform 3)))
     → #<STANDARD-CLASS FOO 244020371>
      (setq foo1 (make-instance 'foo :a 'one :b 'two))
     → #<FOO 36325624>
      (slot-value foo1 'a) → ONE
      (slot-value foo1 'b) → TWO
      (slot-value foo1 'c) → 3
      (setf (slot-value foo1 'a) 'uno) → UNO
      (slot-value foo1 'a) → UNO
      (defmethod foo-method ((x foo))
        (slot-value x 'a))
     → #<STANDARD-METHOD FOO-METHOD (FOO) 42720573>
      (foo-method foo1) → UNO

Exceptional Situations:
.......................

If an attempt is made to read a slot and no slot of the name SLOT-NAME
exists in the OBJECT, ‘slot-missing’ is called as follows:

      (slot-missing (class-of instance)
                    instance
                    slot-name
                    'slot-value)

(If ‘slot-missing’ is invoked, its primary value is returned by
‘slot-value’.)

If an attempt is made to write a slot and no slot of the name SLOT-NAME
exists in the OBJECT, ‘slot-missing’ is called as follows:

      (slot-missing (class-of instance)
                    instance
                    slot-name
                    'setf
                    new-value)

(If ‘slot-missing’ returns in this case, any values are ignored.)

The specific behavior depends on OBJECT’s metaclass.  An error is never
signaled if OBJECT has metaclass ‘standard-class’.  An error is always
signaled if OBJECT has metaclass ‘built-in-class’.  The consequences are
unspecified if OBJECT has any other metaclass—an error might or might
not be signaled in this situation.  Note in particular that the behavior
for conditions and structures is not specified.

See Also:
.........

*note slot-missing::, *note slot-unbound::, *note with-slots::

Notes:
......

Although no implementation is required to do so, implementors are
strongly encouraged to implement the function ‘slot-value’ using the
function ‘slot-value-using-class’ described in the Metaobject Protocol.

Implementations may optimize ‘slot-value’ by compiling it inline.


File: ansicl,  Node: method-qualifiers,  Next: no-applicable-method,  Prev: slot-value,  Up: Objects

method-qualifiers (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: method-qualifiers method → qualifiers

Method Signatures:
..................

method-qualifiers (METHOD ‘standard-method’)

Arguments and Values:
.....................

METHOD—a method.

QUALIFIERS—a proper list.

Description:
............

Returns a list of the qualifiers of the METHOD.

Examples:
.........

      (defmethod some-gf :before ((a integer)) a)
     → #<STANDARD-METHOD SOME-GF (:BEFORE) (INTEGER) 42736540>
      (method-qualifiers *) → (:BEFORE)

See Also:
.........

*note define-method-combination::


File: ansicl,  Node: no-applicable-method,  Next: no-next-method,  Prev: method-qualifiers,  Up: Objects

no-applicable-method (Standard Generic Function)
================================================

Syntax:
.......

 -- Generic Function: no-applicable-method generic-function &rest
          function-arguments → {result}*

Method Signatures:
..................

no-applicable-method (GENERIC-FUNCTION ‘t’) &rest function-arguments

Arguments and Values:
.....................

GENERIC-FUNCTION—a generic function on which no applicable method was
found.

FUNCTION-ARGUMENTS—arguments to the GENERIC-FUNCTION.

RESULT—an object.

Description:
............

The generic function ‘no-applicable-method’ is called when a generic
function is invoked and no method on that generic function is
applicable.  The default method signals an error.

The generic function ‘no-applicable-method’ is not intended to be called
by programmers.  Programmers may write methods for it.

Exceptional Situations:
.......................

The default method signals an error of type ‘error’.

See Also:
.........


File: ansicl,  Node: no-next-method,  Next: remove-method,  Prev: no-applicable-method,  Up: Objects

no-next-method (Standard Generic Function)
==========================================

Syntax:
.......

 -- Generic Function: no-next-method generic-function method &rest args
          → {result}*

Method Signatures:
..................

no-next-method (GENERIC-FUNCTION ‘standard-generic-function’)
(METHOD ‘standard-method’) &rest args

Arguments and Values:
.....................

GENERIC-FUNCTION—generic function to which METHOD belongs.

METHOD—method that contained the call to ‘call-next-method’ for which
there is no next method.

ARGS—arguments to ‘call-next-method’.

RESULT—an object.

Description:
............

The generic function ‘no-next-method’ is called by ‘call-next-method’
when there is no next method.

The generic function ‘no-next-method’ is not intended to be called by
programmers.  Programmers may write methods for it.

Exceptional Situations:
.......................

The system-supplied method on ‘no-next-method’ signals an error of type
‘error’.

See Also:
.........

*note call-next-method::


File: ansicl,  Node: remove-method,  Next: make-instance,  Prev: no-next-method,  Up: Objects

remove-method (Standard Generic Function)
=========================================

Syntax:
.......

 -- Generic Function: remove-method generic-function method →
          generic-function

Method Signatures:
..................

remove-method (GENERIC-FUNCTION ‘standard-generic-function’) method

Arguments and Values:
.....................

GENERIC-FUNCTION—a generic function.

METHOD—a method.

Description:
............

The generic function ‘remove-method’ removes a method from
GENERIC-FUNCTION by modifying the GENERIC-FUNCTION (if necessary).

‘remove-method’ must not signal an error if the method is not one of the
methods on the GENERIC-FUNCTION.

See Also:
.........

*note find-method::


File: ansicl,  Node: make-instance,  Next: make-instances-obsolete,  Prev: remove-method,  Up: Objects

make-instance (Standard Generic Function)
=========================================

Syntax:
.......

 -- Generic Function: make-instance class &rest initargs &key
          &allow-other-keys → instance

Method Signatures:
..................

make-instance (CLASS ‘standard-class’) &rest initargs

make-instance (CLASS ‘symbol’) &rest initargs

Arguments and Values:
.....................

CLASS—a class, or a symbol that names a class.

INITARGS—an initialization argument list.

INSTANCE—a fresh instance of class CLASS.

Description:
............

The generic function ‘make-instance’ creates and returns a new instance
of the given CLASS.

If the second of the above methods is selected, that method invokes
‘make-instance’ on the arguments ‘(find-class CLASS)’ and INITARGS.

The initialization arguments are checked within ‘make-instance’.

The generic function ‘make-instance’ may be used as described in *note
Section 7.1 (Object Creation and Initialization): Object Creation and
Initialization.

Exceptional Situations:
.......................

If any of the initialization arguments has not been declared as valid,
an error of type ‘error’ is signaled.

See Also:
.........

*note defclass::, *note class-of::, *note allocate-instance::, *note
initialize-instance (Standard Generic Function)::, *note Section 7.1
(Object Creation and Initialization): Object Creation and
Initialization.


File: ansicl,  Node: make-instances-obsolete,  Next: make-load-form,  Prev: make-instance,  Up: Objects

make-instances-obsolete (Standard Generic Function)
===================================================

Syntax:
.......

 -- Generic Function: make-instances-obsolete class → class

Method Signatures:
..................

make-instances-obsolete (CLASS ‘standard-class’)

make-instances-obsolete (CLASS ‘symbol’)

Arguments and Values:
.....................

CLASS—a class designator.

Description:
............

The function ‘make-instances-obsolete’ has the effect of initiating the
process of updating the instances of the class.  During updating, the
generic function ‘update-instance-for-redefined-class’ will be invoked.

The generic function ‘make-instances-obsolete’ is invoked automatically
by the system when ‘defclass’ has been used to redefine an existing
standard class and the set of local slots accessible in an instance is
changed or the order of slots in storage is changed.  It can also be
explicitly invoked by the user.

If the second of the above methods is selected, that method invokes
‘make-instances-obsolete’ on ‘(find-class CLASS)’.

Examples:
.........

See Also:
.........

*note update-instance-for-redefined-class::, *note Section 4.3.6
(Redefining Classes): Redefining Classes.


File: ansicl,  Node: make-load-form,  Next: make-load-form-saving-slots,  Prev: make-instances-obsolete,  Up: Objects

make-load-form (Standard Generic Function)
==========================================

Syntax:
.......

 -- Generic Function: make-load-form object &optional environment →
          creation-form[, initialization-form]

Method Signatures:
..................

make-load-form (OBJECT ‘standard-object’) &optional environment
make-load-form (OBJECT ‘structure-object’) &optional environment
make-load-form (OBJECT ‘condition’) &optional environment make-load-form
(OBJECT ‘class’) &optional environment

Arguments and Values:
.....................

OBJECT—an object.

ENVIRONMENT—an environment object.

CREATION-FORM—a form.

INITIALIZATION-FORM—a form.

Description:
............

The generic function ‘make-load-form’ creates and returns one or two
forms, a CREATION-FORM and an INITIALIZATION-FORM, that enable ‘load’ to
construct an object equivalent to OBJECT.  ENVIRONMENT is an environment
object corresponding to the lexical environment in which the forms will
be processed.

The file compiler calls ‘make-load-form’ to process certain classes of
literal objects; see *note Section 3.2.4.4 (Additional Constraints on
Externalizable Objects): CallingMakeLoadForm.

Conforming programs may call ‘make-load-form’ directly, providing OBJECT
is a generalized instance of ‘standard-object’, ‘structure-object’, or
‘condition’.

The creation form is a form that, when evaluated at ‘load’ time, should
return an object that is equivalent to OBJECT.  The exact meaning of
equivalent depends on the type of object and is up to the programmer who
defines a method for ‘make-load-form’; see *note Section 3.2.4 (Literal
Objects in Compiled Files): Literal Objects in Compiled Files.

The initialization form is a form that, when evaluated at ‘load’ time,
should perform further initialization of the object.  The value returned
by the initialization form is ignored.  If ‘make-load-form’ returns only
one value, the initialization form is ‘nil’, which has no effect.  If
OBJECT appears as a constant in the initialization form, at ‘load’ time
it will be replaced by the equivalent object constructed by the creation
form; this is how the further initialization gains access to the object.

Both the CREATION-FORM and the INITIALIZATION-FORM may contain
references to any externalizable object.  However, there must not be any
circular dependencies in creation forms.  An example of a circular
dependency is when the creation form for the object ‘X’ contains a
reference to the object ‘Y’, and the creation form for the object ‘Y’
contains a reference to the object ‘X’.  Initialization forms are not
subject to any restriction against circular dependencies, which is the
reason that initialization forms exist; see the example of circular data
structures below.

The creation form for an object is always evaluated before the
initialization form for that object.  When either the creation form or
the initialization form references other objects that have not been
referenced earlier in the file being compiled, the compiler ensures that
all of the referenced objects have been created before evaluating the
referencing form.  When the referenced object is of a type which the
file compiler processes using ‘make-load-form’, this involves evaluating
the creation form returned for it.  (This is the reason for the
prohibition against circular references among creation forms).

Each initialization form is evaluated as soon as possible after its
associated creation form, as determined by data flow.  If the
initialization form for an object does not reference any other objects
not referenced earlier in the file and processed by the file compiler
using ‘make-load-form’, the initialization form is evaluated immediately
after the creation form.  If a creation or initialization form F does
contain references to such objects, the creation forms for those other
objects are evaluated before F, and the initialization forms for those
other objects are also evaluated before F whenever they do not depend on
the object created or initialized by F. Where these rules do not
uniquely determine an order of evaluation between two
creation/initialization forms, the order of evaluation is unspecified.

While these creation and initialization forms are being evaluated, the
objects are possibly in an uninitialized state, analogous to the state
of an object between the time it has been created by ‘allocate-instance’
and it has been processed fully by ‘initialize-instance’.  Programmers
writing methods for ‘make-load-form’ must take care in manipulating
objects not to depend on slots that have not yet been initialized.

It is implementation-dependent whether ‘load’ calls ‘eval’ on the forms
or does some other operation that has an equivalent effect.  For
example, the forms might be translated into different but equivalent
forms and then evaluated, they might be compiled and the resulting
functions called by ‘load’, or they might be interpreted by a
special-purpose function different from ‘eval’.  All that is required is
that the effect be equivalent to evaluating the forms.

The method specialized on ‘class’ returns a creation form using the name
of the class if the class has a proper name in ENVIRONMENT, signaling an
error of type ‘error’ if it does not have a proper name.  Evaluation of
the creation form uses the name to find the class with that name, as if
by calling ‘find-class’.  If a class with that name has not been
defined, then a class may be computed in an implementation-defined
manner.  If a class cannot be returned as the result of evaluating the
creation form, then an error of type ‘error’ is signaled.

Both conforming implementations and conforming programs may further
specialize ‘make-load-form’.

Examples:
.........

      (defclass obj ()
         ((x :initarg :x :reader obj-x)
          (y :initarg :y :reader obj-y)
          (dist :accessor obj-dist)))
     → #<STANDARD-CLASS OBJ 250020030>
      (defmethod shared-initialize :after ((self obj) slot-names &rest keys)
        (declare (ignore slot-names keys))
        (unless (slot-boundp self 'dist)
          (setf (obj-dist self)
                (sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2))))))
     → #<STANDARD-METHOD SHARED-INITIALIZE (:AFTER) (OBJ T) 26266714>
      (defmethod make-load-form ((self obj) &optional environment)
        (declare (ignore environment))
        ;; Note that this definition only works because X and Y do not
        ;; contain information which refers back to the object itself.
        ;; For a more general solution to this problem, see revised example below.
        `(make-instance ',(class-of self)
                        :x ',(obj-x self) :y ',(obj-y self)))
     → #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532>
      (setq obj1 (make-instance 'obj :x 3.0 :y 4.0)) → #<OBJ 26274136>
      (obj-dist obj1) → 5.0
      (make-load-form obj1) → (MAKE-INSTANCE 'OBJ :X '3.0 :Y '4.0)

In the above example, an equivalent instance of ‘obj’ is reconstructed
by using the values of two of its slots.  The value of the third slot is
derived from those two values.

 

 

Another way to write the ‘make-load-form’ method in that example is to
use ‘make-load-form-saving-slots’.  The code it generates might yield a
slightly different result from the ‘make-load-form’ method shown above,
but the operational effect will be the same.  For example:

 

      ;; Redefine method defined above.
      (defmethod make-load-form ((self obj) &optional environment)
         (make-load-form-saving-slots self
                                      :slot-names '(x y)
                                      :environment environment))
     → #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655>
      ;; Try MAKE-LOAD-FORM on object created above.
      (make-load-form obj1)
     → (ALLOCATE-INSTANCE '#<STANDARD-CLASS OBJ 250020030>),
         (PROGN
           (SETF (SLOT-VALUE '#<OBJ 26274136> 'X) '3.0)
           (SETF (SLOT-VALUE '#<OBJ 26274136> 'Y) '4.0)
           (INITIALIZE-INSTANCE '#<OBJ 26274136>))

 

 

In the following example, instances of ‘my-frob’ are “interned” in some
way.  An equivalent instance is reconstructed by using the value of the
name slot as a key for searching existing objects.  In this case the
programmer has chosen to create a new object if no existing object is
found; alternatively an error could have been signaled in that case.

 

      (defclass my-frob ()
         ((name :initarg :name :reader my-name)))
      (defmethod make-load-form ((self my-frob) &optional environment)
        (declare (ignore environment))
        `(find-my-frob ',(my-name self) :if-does-not-exist :create))

 

 

In the following example, the data structure to be dumped is circular,
because each parent has a list of its children and each child has a
reference back to its parent.  If ‘make-load-form’ is called on one
object in such a structure, the creation form creates an equivalent
object and fills in the children slot, which forces creation of
equivalent objects for all of its children, grandchildren, etc.  At this
point none of the parent slots have been filled in.  The initialization
form fills in the parent slot, which forces creation of an equivalent
object for the parent if it was not already created.  Thus the entire
tree is recreated at ‘load’ time.  At compile time, ‘make-load-form’ is
called once for each object in the tree.  All of the creation forms are
evaluated, in implementation-dependent order, and then all of the
initialization forms are evaluated, also in implementation-dependent
order.

 

      (defclass tree-with-parent () ((parent :accessor tree-parent)
                                     (children :initarg :children)))
      (defmethod make-load-form ((x tree-with-parent) &optional environment)
        (declare (ignore environment))
        (values
          ;; creation form
          `(make-instance ',(class-of x) :children ',(slot-value x 'children))
          ;; initialization form
          `(setf (tree-parent ',x) ',(slot-value x 'parent))))

 

 

In the following example, the data structure to be dumped has no special
properties and an equivalent structure can be reconstructed simply by
reconstructing the slots’ contents.

 

      (defstruct my-struct a b c)
      (defmethod make-load-form ((s my-struct) &optional environment)
         (make-load-form-saving-slots s :environment environment))

Exceptional Situations:
.......................

The methods specialized on ‘standard-object’, ‘structure-object’, and
‘condition’ all signal an error of type ‘error’.

It is implementation-dependent whether calling ‘make-load-form’ on a
generalized instance of a system class signals an error or returns
creation and initialization forms.

See Also:
.........

*note compile-file::, *note make-load-form-saving-slots::, *note Section
3.2.4.4 (Additional Constraints on Externalizable Objects):
CallingMakeLoadForm. *note Section 3.1 (Evaluation): Evaluation, *note
Section 3.2 (Compilation): Compilation.

Notes:
......

The file compiler calls ‘make-load-form’ in specific circumstances
detailed in *note Section 3.2.4.4 (Additional Constraints on
Externalizable Objects): CallingMakeLoadForm.

Some implementations may provide facilities for defining new subclasses
of classes which are specified as system classes.  (Some likely
candidates include ‘generic-function’, ‘method’, and ‘stream’).  Such
implementations should document how the file compiler processes
instances of such classes when encountered as literal objects, and
should document any relevant methods for ‘make-load-form’.


File: ansicl,  Node: make-load-form-saving-slots,  Next: with-accessors,  Prev: make-load-form,  Up: Objects

make-load-form-saving-slots (Function)
======================================

Syntax:
.......

 -- Function: make-load-form-saving-slots object &key slot-names
          environment → creation-form, initialization-form

Arguments and Values:
.....................

OBJECT—an object.

SLOT-NAMES—a list.

ENVIRONMENT—an environment object.

CREATION-FORM—a form.

INITIALIZATION-FORM—a form.

Description:
............

Returns forms that, when evaluated, will construct an object equivalent
to OBJECT, without executing initialization forms.  The slots in the new
object that correspond to initialized slots in OBJECT are initialized
using the values from OBJECT.  Uninitialized slots in OBJECT are not
initialized in the new object.  ‘make-load-form-saving-slots’ works for
any instance of ‘standard-object’ or ‘structure-object’.

SLOT-NAMES is a list of the names of the slots to preserve.  If
SLOT-NAMES is not supplied, its value is all of the local slots.

‘make-load-form-saving-slots’ returns two values, thus it can deal with
circular structures.  Whether the result is useful in an application
depends on whether the OBJECT’s type and slot contents fully capture the
application’s idea of the OBJECT’s state.

ENVIRONMENT is the environment in which the forms will be processed.

See Also:
.........

*note make-load-form::, *note make-instance::, *note setf::, *note
slot-value::, *note slot-makunbound::

Notes:
......

‘make-load-form-saving-slots’ can be useful in user-written
‘make-load-form’ methods.

When the object is an instance of ‘standard-object’,
‘make-load-form-saving-slots’ could return a creation form that calls
‘allocate-instance’ and an initialization form that contains calls to
‘setf’ of ‘slot-value’ and ‘slot-makunbound’, though other functions of
similar effect might actually be used.


File: ansicl,  Node: with-accessors,  Next: with-slots,  Prev: make-load-form-saving-slots,  Up: Objects

with-accessors (Macro)
======================

Syntax:
.......

 -- Macro: with-accessors ({slot-entry}*) instance-form {declaration}*
          {form}* → {result}*

SLOT-ENTRY::=
     (variable-name accessor-name)

Arguments and Values:
.....................

VARIABLE-NAME—a variable name; not evaluated.

ACCESSOR-NAME—a function name; not evaluated.

INSTANCE-FORM—a form; evaluated.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—the values returned by the FORMS.

Description:
............

Creates a lexical environment in which the slots specified by SLOT-ENTRY
are lexically available through their accessors as if they were
variables.  The macro ‘with-accessors’ invokes the appropriate accessors
to ACCESS the slots specified by SLOT-ENTRY.  Both ‘setf’ and ‘setq’ can
be used to set the value of the slot.

Examples:
.........

      (defclass thing ()
                ((x :initarg :x :accessor thing-x)
                 (y :initarg :y :accessor thing-y)))
     → #<STANDARD-CLASS THING 250020173>
      (defmethod (setf thing-x) :before (new-x (thing thing))
        (format t "~&Changing X from ~D to ~D in ~S.~%"
                (thing-x thing) new-x thing))
      (setq thing1 (make-instance 'thing :x 1 :y 2)) → #<THING 43135676>
      (setq thing2 (make-instance 'thing :x 7 :y 8)) → #<THING 43147374>
      (with-accessors ((x1 thing-x) (y1 thing-y))
                      thing1
        (with-accessors ((x2 thing-x) (y2 thing-y))
                        thing2
          (list (list x1 (thing-x thing1) y1 (thing-y thing1)
                      x2 (thing-x thing2) y2 (thing-y thing2))
                (setq x1 (+ y1 x2))
                (list x1 (thing-x thing1) y1 (thing-y thing1)
                      x2 (thing-x thing2) y2 (thing-y thing2))
                (setf (thing-x thing2) (list x1))
                (list x1 (thing-x thing1) y1 (thing-y thing1)
                      x2 (thing-x thing2) y2 (thing-y thing2)))))
     ▷ Changing X from 1 to 9 in #<THING 43135676>.
     ▷ Changing X from 7 to (9) in #<THING 43147374>.
     → ((1 1 2 2 7 7 8 8)
          9
          (9 9 2 2 7 7 8 8)
          (9)
          (9 9 2 2 (9) (9) 8 8))

Affected By:
............

‘defclass’

Exceptional Situations:
.......................

The consequences are undefined if any ACCESSOR-NAME is not the name of
an accessor for the INSTANCE.

See Also:
.........

*note with-slots::, *note symbol-macrolet::

Notes:
......

A ‘with-accessors’ expression of the form:

     (with-accessors (SLOT-ENTRYINSTANCE-FORM FORM

expands into the equivalent of

     (let ((in INSTANCE-FORM))
       (symbol-macrolet (Q

where Q

     (VARIABLE-NAME


File: ansicl,  Node: with-slots,  Next: defclass,  Prev: with-accessors,  Up: Objects

with-slots (Macro)
==================

Syntax:
.......

 -- Macro: with-slots ({slot-entry}*) instance-form {declaration}*
          {form}* → {result}*

SLOT-ENTRY::=
     slot-name | (variable-name slot-name)

Arguments and Values:
.....................

SLOT-NAME—a slot name; not evaluated.

VARIABLE-NAME—a variable name; not evaluated.

INSTANCE-FORM—a form; evaluted to produce INSTANCE.

INSTANCE—an object.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—the values returned by the FORMS.

Description:
............

The macro ‘with-slots’ establishes a lexical environment for referring
to the slots in the INSTANCE named by the given SLOT-NAMES as though
they were variables.  Within such a context the value of the slot can be
specified by using its slot name, as if it were a lexically bound
variable.  Both ‘setf’ and ‘setq’ can be used to set the value of the
slot.

The macro ‘with-slots’ translates an appearance of the slot name as a
variable into a call to ‘slot-value’.

Examples:
.........

      (defclass thing ()
                ((x :initarg :x :accessor thing-x)
                 (y :initarg :y :accessor thing-y)))
     → #<STANDARD-CLASS THING 250020173>
      (defmethod (setf thing-x) :before (new-x (thing thing))
        (format t "~&Changing X from ~D to ~D in ~S.~%"
                (thing-x thing) new-x thing))
      (setq thing (make-instance 'thing :x 0 :y 1)) → #<THING 62310540>
      (with-slots (x y) thing (incf x) (incf y)) → 2
      (values (thing-x thing) (thing-y thing)) → 1, 2
      (setq thing1 (make-instance 'thing :x 1 :y 2)) → #<THING 43135676>
      (setq thing2 (make-instance 'thing :x 7 :y 8)) → #<THING 43147374>
      (with-slots ((x1 x) (y1 y))
                  thing1
        (with-slots ((x2 x) (y2 y))
                    thing2
          (list (list x1 (thing-x thing1) y1 (thing-y thing1)
                      x2 (thing-x thing2) y2 (thing-y thing2))
                (setq x1 (+ y1 x2))
                (list x1 (thing-x thing1) y1 (thing-y thing1)
                      x2 (thing-x thing2) y2 (thing-y thing2))
                (setf (thing-x thing2) (list x1))
                (list x1 (thing-x thing1) y1 (thing-y thing1)
                      x2 (thing-x thing2) y2 (thing-y thing2)))))
     ▷ Changing X from 7 to (9) in #<THING 43147374>.
     → ((1 1 2 2 7 7 8 8)
          9
          (9 9 2 2 7 7 8 8)
          (9)
          (9 9 2 2 (9) (9) 8 8))

Affected By:
............

‘defclass’

Exceptional Situations:
.......................

The consequences are undefined if any SLOT-NAME is not the name of a
slot in the INSTANCE.

See Also:
.........

*note with-accessors::, *note slot-value::, *note symbol-macrolet::

Notes:
......

A ‘with-slots’ expression of the form:

     (with-accessors (SLOT-ENTRYINSTANCE-FORM FORM

expands into the equivalent of

     (let ((in INSTANCE-FORM))
       (symbol-macrolet (Q

where Q

     (SLOT-ENTRY

if SLOT-ENTRY

     (VARIABLE-NAME

if SLOT-ENTRY

     (VARIABLE-NAME


File: ansicl,  Node: defclass,  Next: defgeneric,  Prev: with-slots,  Up: Objects

defclass (Macro)
================

Syntax:
.......

 -- Macro: defclass CLASS-NAME ({SUPERCLASS-NAME}*) ({slot-specifier}*)
          [[↓class-option]] → new-class

slot-specifier::=
     slot-name | (slot-name 〚↓slot-option〛)

slot-name::= symbol

slot-option::=
     {:reader reader-function-name}* |
     {:writer writer-function-name}* |
     {:accessor reader-function-name}* |
     {:allocation allocation-type} |
     {:initarg initarg-name}* |
     {:initform form} |
     {:type type-specifier} |
     {:documentation string}

function-name::= {symbol | (setf symbol)}

class-option::=
     (:default-initargs .  initarg-list) |
     (:documentation string) |
     (:metaclass class-name)

Arguments and Values:
.....................

CLASS-NAME—a non-nil symbol.

SUPERCLASS-NAME—a non-nil symbol.

SLOT-NAME—a symbol.  The SLOT-NAME argument is a symbol that is
syntactically valid for use as a variable name.

READER-FUNCTION-NAME—a non-nil symbol.  :reader can be supplied more
than once for a given slot.

WRITER-FUNCTION-NAME—a generic function name.  :writer can be supplied
more than once for a given slot.

READER-FUNCTION-NAME—a non-nil symbol.  :accessor can be supplied more
than once for a given slot.

ALLOCATION-TYPE—(member :instance :class).  :allocation can be supplied
once at most for a given slot.

INITARG-NAME—a symbol.  :initarg can be supplied more than once for a
given slot.

FORM—a form.  :init-form can be supplied once at most for a given slot.

TYPE-SPECIFIER—a type specifier.  :type can be supplied once at most for
a given slot.

CLASS-OPTION— refers to the class as a whole or to all class slots.

INITARG-LIST—a list of alternating initialization argument names and
default initial value forms.  :default-initargs can be supplied at most
once.

CLASS-NAME—a non-nil symbol.  :metaclass can be supplied once at most.

NEW-CLASS—the new class object.

Description:
............

The macro ‘defclass’ defines a new named class.  It returns the new
class object as its result.

The syntax of ‘defclass’ provides options for specifying initialization
arguments for slots, for specifying default initialization values for
slots, and for requesting that methods on specified generic functions be
automatically generated for reading and writing the values of slots.  No
reader or writer functions are defined by default; their generation must
be explicitly requested.  However, slots can always be accessed using
‘slot-value’.

Defining a new class also causes a type of the same name to be defined.
The predicate ‘(typep OBJECT CLASS-NAME)’ returns true if the class of
the given OBJECT is the class named by CLASS-NAME itself or a subclass
of the class CLASS-NAME.  A class object can be used as a type
specifier.  Thus ‘(typep OBJECT CLASS)’ returns true if the class of the
OBJECT is CLASS itself or a subclass of CLASS.

The CLASS-NAME argument specifies the proper name of the new class.  If
a class with the same proper name already exists and that class is an
instance of ‘standard-class’, and if the ‘defclass’ form for the
definition of the new class specifies a class of class ‘standard-class’,
the existing class is redefined, and instances of it (and its
subclasses) are updated to the new definition at the time that they are
next accessed.  For details, see *note Section 4.3.6 (Redefining
Classes): Redefining Classes.

Each SUPERCLASS-NAME argument specifies a direct superclass of the new
class.  If the superclass list is empty, then the superclass defaults
depending on the metaclass, with ‘standard-object’ being the default for
‘standard-class’.

The new class will inherit slots and methods from each of its direct
superclasses, from their direct superclasses, and so on.  For a
discussion of how slots and methods are inherited, see *note Section
4.3.4 (Inheritance): Inheritance.

The following slot options are available:

   • The :reader slot option specifies that an unqualified method is to
     be defined on the generic function named READER-FUNCTION-NAME to
     read the value of the given slot.

   • The :writer slot option specifies that an unqualified method is to
     be defined on the generic function named WRITER-FUNCTION-NAME to
     write the value of the slot.

   • The :accessor slot option specifies that an unqualified method is
     to be defined on the generic function named READER-FUNCTION-NAME to
     read the value of the given slot and that an unqualified method is
     to be defined on the generic function named ‘(setf
     READER-FUNCTION-NAME)’ to be used with ‘setf’ to modify the value
     of the slot.

   • The :allocation slot option is used to specify where storage is to
     be allocated for the given slot.  Storage for a slot can be located
     in each instance or in the class object itself.  The value of the
     ALLOCATION-TYPE argument can be either the keyword :instance or the
     keyword :class.  If the :allocation slot option is not specified,
     the effect is the same as specifying ‘:allocation :instance’.

        – If ALLOCATION-TYPE is :instance, a local slot of the name
          SLOT-NAME is allocated in each instance of the class.

        – If ALLOCATION-TYPE is :class, a shared slot of the given name
          is allocated in the class object created by this ‘defclass’
          form.  The value of the slot is shared by all instances of the
          class.  If a class Csubclass CCfor Csuperclass of Clist of C

   • The :initform slot option is used to provide a default initial
     value form to be used in the initialization of the slot.  This form
     is evaluated every time it is used to initialize the slot.  The
     lexical environment in which this form is evaluated is the lexical
     environment in which the ‘defclass’ form was evaluated.  Note that
     the lexical environment refers both to variables and to functions.
     For local slots, the dynamic environment is the dynamic environment
     in which ‘make-instance’ is called; for shared slots, the dynamic
     environment is the dynamic environment in which the ‘defclass’ form
     was evaluated.  See *note Section 7.1 (Object Creation and
     Initialization): Object Creation and Initialization.

     No implementation is permitted to extend the syntax of ‘defclass’
     to allow ‘(SLOT-NAME FORM)’ as an abbreviation for ‘(SLOT-NAME
     :initform FORM)’.

   • The :initarg slot option declares an initialization argument named
     INITARG-NAME and specifies that this initialization argument
     initializes the given slot.  If the initialization argument has a
     value in the call to ‘initialize-instance’, the value will be
     stored into the given slot, and the slot’s :initform slot option,
     if any, is not evaluated.  If none of the initialization arguments
     specified for a given slot has a value, the slot is initialized
     according to the :initform slot option, if specified.

   • The :type slot option specifies that the contents of the slot will
     always be of the specified data type.  It effectively declares the
     result type of the reader generic function when applied to an
     object of this class.  The consequences of attempting to store in a
     slot a value that does not satisfy the type of the slot are
     undefined.  The :type slot option is further discussed in *note
     Section 7.5.3 (Inheritance of Slots and Slot Options): Inheritance
     of Slots and Slot Options.

   • The :documentation slot option provides a documentation string for
     the slot.  :documentation can be supplied once at most for a given
     slot.

Each class option is an option that refers to the class as a whole.  The
following class options are available:

   • The :default-initargs class option is followed by a list of
     alternating initialization argument names and default initial value
     forms.  If any of these initialization arguments does not appear in
     the initialization argument list supplied to ‘make-instance’, the
     corresponding default initial value form is evaluated, and the
     initialization argument name and the form’s value are added to the
     end of the initialization argument list before the instance is
     created; see *note Section 7.1 (Object Creation and
     Initialization): Object Creation and Initialization.  The default
     initial value form is evaluated each time it is used.  The lexical
     environment in which this form is evaluated is the lexical
     environment in which the ‘defclass’ form was evaluated.  The
     dynamic environment is the dynamic environment in which
     ‘make-instance’ was called.  If an initialization argument name
     appears more than once in a :default-initargs class option, an
     error is signaled.

   • The :documentation class option causes a documentation string to be
     attached with the class object, and attached with kind type to the
     CLASS-NAME.  :documentation can be supplied once at most.

   • The :metaclass class option is used to specify that instances of
     the class being defined are to have a different metaclass than the
     default provided by the system (the class ‘standard-class’).

Note the following rules of ‘defclass’ for standard classes:

   • It is not required that the superclasses of a class be defined
     before the ‘defclass’ form for that class is evaluated.

   • All the superclasses of a class must be defined before an instance
     of the class can be made.

   • A class must be defined before it can be used as a parameter
     specializer in a ‘defmethod’ form.

The object system can be extended to cover situations where these rules
are not obeyed.

Some slot options are inherited by a class from its superclasses, and
some can be shadowed or altered by providing a local slot description.
No class options except :default-initargs are inherited.  For a detailed
description of how slots and slot options are inherited, see *note
Section 7.5.3 (Inheritance of Slots and Slot Options): Inheritance of
Slots and Slot Options.

The options to ‘defclass’ can be extended.  It is required that all
implementations signal an error if they observe a class option or a slot
option that is not implemented locally.

It is valid to specify more than one reader, writer, accessor, or
initialization argument for a slot.  No other slot option can appear
more than once in a single slot description, or an error is signaled.

If no reader, writer, or accessor is specified for a slot, the slot can
only be accessed by the function ‘slot-value’.

If a ‘defclass’ form appears as a top level form, the compiler must make
the class name be recognized as a valid type name in subsequent
declarations (as for ‘deftype’) and be recognized as a valid class name
for ‘defmethod’ parameter specializers and for use as the :metaclass
option of a subsequent ‘defclass’.  The compiler must make the class
definition available to be returned by ‘find-class’ when its ENVIRONMENT
argument is a value received as the environment parameter of a macro.

Exceptional Situations:
.......................

If there are any duplicate slot names, an error of type ‘program-error’
is signaled.

If an initialization argument name appears more than once in
:default-initargs class option, an error of type ‘program-error’ is
signaled.

If any of the following slot options appears more than once in a single
slot description, an error of type ‘program-error’ is signaled:
:allocation, :initform, :type, :documentation.

It is required that all implementations signal an error of type
‘program-error’ if they observe a class option or a slot option that is
not implemented locally.

See Also:
.........

*note documentation::, *note initialize-instance (Standard Generic
Function)::, *note make-instance::, *note slot-value::, *note Section
4.3 (Classes): Classes, *note Section 4.3.4 (Inheritance): Inheritance,
*note Section 4.3.6 (Redefining Classes): Redefining Classes, *note
Section 4.3.5 (Determining the Class Precedence List): Determining the
Class Precedence List, *note Section 7.1 (Object Creation and
Initialization): Object Creation and Initialization.


File: ansicl,  Node: defgeneric,  Next: defmethod,  Prev: defclass,  Up: Objects

defgeneric (Macro)
==================

Syntax:
.......

 -- Macro: defgeneric function-name gf-lambda-list 〚↓option |
          {↓method-description}*〛 → new-generic

OPTION::=
     (:argument-precedence-order {PARAMETER-NAME}+) |
     (declare {GF-DECLARATION}+) |
     (:documentation GF-DOCUMENTATION) |
     (:method-combination METHOD-COMBINATION
     {method-combination-argument}*) |
     (:generic-function-class GENERIC-FUNCTION-CLASS) |
     (:method-class METHOD-CLASS)
METHOD-DESCRIPTION::=
     (:method {method-qualifier}* SPECIALIZED-LAMBDA-LIST
     〚{declaration}* | documentation〛 {form}*)

Arguments and Values:
.....................

FUNCTION-NAME—a function name.

GENERIC-FUNCTION-CLASS—a non-nil symbol naming a class.

GF-DECLARATION—an ‘optimize’ declaration specifier; other declaration
specifiers are not permitted.

GF-DOCUMENTATION—a string; not evaluated.

GF-LAMBDA-LIST—a generic function lambda list.

METHOD-CLASS—a non-nil symbol naming a class.

METHOD-COMBINATION-ARGUMENT—an object.

METHOD-COMBINATION-NAME—a symbol naming a method combination type.

METHOD-QUALIFIERS, SPECIALIZED-LAMBDA-LIST, DECLARATIONS, DOCUMENTATION,
FORMS—as per ‘defmethod’.

NEW-GENERIC—the generic function object.

PARAMETER-NAME—a symbol that names a required parameter in the
LAMBDA-LIST.  (If the :argument-precedence-order option is specified,
each required parameter in the LAMBDA-LIST must be used exactly once as
a PARAMETER-NAME.)

Description:
............

The macro ‘defgeneric’ is used to define a generic function or to
specify options and declarations that pertain to a generic function as a
whole.

If FUNCTION-NAME is a list it must be of the form ‘(setf symbol)’.  If
‘(fboundp FUNCTION-NAME)’ is false, a new generic function is created.
If ‘(fdefinition FUNCTION-NAME)’ is a generic function, that generic
function is modified.  If FUNCTION-NAME names an ordinary function, a
macro, or a special operator, an error is signaled.

The effect of the ‘defgeneric’ macro is as if the following three steps
were performed: first, methods defined by previous ‘defgeneric’ forms
are removed;

second, ‘ensure-generic-function’ is called; and finally, methods
specified by the current ‘defgeneric’ form are added to the generic
function.

Each METHOD-DESCRIPTION defines a method on the generic function.  The
lambda list of each method must be congruent with the lambda list
specified by the GF-LAMBDA-LIST option.  If no method descriptions are
specified and a generic function of the same name does not already
exist, a generic function with no methods is created.

The GF-LAMBDA-LIST argument of ‘defgeneric’ specifies the shape of
lambda lists for the methods on this generic function.  All methods on
the resulting generic function must have lambda lists that are congruent
with this shape.  If a ‘defgeneric’ form is evaluated and some methods
for that generic function have lambda lists that are not congruent with
that given in the ‘defgeneric’ form, an error is signaled.  For further
details on method congruence, see *note Section 7.6.4 (Congruent
Lambda-lists for all Methods of a Generic Function): Congruent
Lambda-lists for all Methods of a Generic Function.

The generic function passes to the method all the argument values passed
to it, and only those; default values are not supported.  Note that
optional and keyword arguments in method definitions, however, can have
default initial value forms and can use supplied-p parameters.

The following options are provided.  Except as otherwise noted, a given
option may occur only once.

   • The :argument-precedence-order option is used to specify the order
     in which the required arguments in a call to the generic function
     are tested for specificity when selecting a particular method.
     Each required argument, as specified in the GF-LAMBDA-LIST
     argument, must be included exactly once as a PARAMETER-NAME so that
     the full and unambiguous precedence order is supplied.  If this
     condition is not met, an error is signaled.

   • The declare option is used to specify declarations that pertain to
     the generic function.

     An ‘optimize’ declaration specifier is allowed.  It specifies
     whether method selection should be optimized for speed or space,
     but it has no effect on methods.  To control how a method is
     optimized, an ‘optimize’ declaration must be placed directly in the
     ‘defmethod’ form or method description.  The optimization qualities
     speed and space are the only qualities this standard requires, but
     an implementation can extend the object system to recognize other
     qualities.  A simple implementation that has only one method
     selection technique and ignores ‘optimize’ declaration specifiers
     is valid.

     The ‘special’, ‘ftype’, ‘function’, ‘inline’, ‘notinline’, and
     ‘declaration’ declarations are not permitted.  Individual
     implementations can extend the declare option to support additional
     declarations.

     If an implementation notices a declaration specifier that it does
     not support and that has not been proclaimed as a non-standard
     declaration identifier name in a ‘declaration’ proclamation, it
     should issue a warning.

     The declare option may be specified more than once.  The effect is
     the same as if the lists of declaration specifiers had been
     appended together into a single list and specified as a single
     declare option.

   • The :documentation argument is a documentation string to be
     attached to the generic function object, and to be attached with
     kind function to the FUNCTION-NAME.

   • The :generic-function-class option may be used to specify that the
     generic function is to have a different class than the default
     provided by the system (the class ‘standard-generic-function’).
     The CLASS-NAME argument is the name of a class that can be the
     class of a generic function.  If FUNCTION-NAME specifies an
     existing generic function that has a different value for the
     :generic-function-class argument and the new generic function class
     is compatible with the old, ‘change-class’ is called to change the
     class of the generic function; otherwise an error is signaled.

   • The :method-class option is used to specify that all methods on
     this generic function are to have a different class from the
     default provided by the system (the class ‘standard-method’).  The
     CLASS-NAME argument is the name of a class that is capable of being
     the class of a method.

   • The :method-combination option is followed by a symbol that names a
     type of method combination.  The arguments (if any) that follow
     that symbol depend on the type of method combination.  Note that
     the standard method combination type does not support any
     arguments.  However, all types of method combination defined by the
     short form of ‘define-method-combination’ accept an optional
     argument named ORDER, defaulting to :most-specific-first, where a
     value of :most-specific-last reverses the order of the primary
     methods without affecting the order of the auxiliary methods.

The METHOD-DESCRIPTION arguments define methods that will be associated
with the generic function.  The METHOD-QUALIFIER and
SPECIALIZED-LAMBDA-LIST arguments in a method description are the same
as for ‘defmethod’.

The FORM arguments specify the method body.  The body of the method is
enclosed in an implicit block.  If FUNCTION-NAME is a symbol, this block
bears the same name as the generic function.  If FUNCTION-NAME is a list
of the form ‘(setf SYMBOL)’, the name of the block is SYMBOL.

Implementations can extend ‘defgeneric’ to include other options.  It is
required that an implementation signal an error if it observes an option
that is not implemented locally.

‘defgeneric’ is not required to perform any compile-time side effects.
In particular, the methods are not installed for invocation during
compilation.  An implementation may choose to store information about
the generic function for the purposes of compile-time error-checking
(such as checking the number of arguments on calls, or noting that a
definition for the function name has been seen).

Examples:
.........

Exceptional Situations:
.......................

If FUNCTION-NAME names an ordinary function, a macro, or a special
operator, an error of type ‘program-error’ is signaled.

Each required argument, as specified in the GF-LAMBDA-LIST argument,
must be included exactly once as a PARAMETER-NAME, or an error of type
‘program-error’ is signaled.

The lambda list of each method specified by a METHOD-DESCRIPTION must be
congruent with the lambda list specified by the GF-LAMBDA-LIST option,
or an error of type ‘error’ is signaled.

If a ‘defgeneric’ form is evaluated and some methods for that generic
function have lambda lists that are not congruent with that given in the
‘defgeneric’ form, an error of type ‘error’ is signaled.

A given OPTION may occur only once, or an error of type ‘program-error’
is signaled.

If FUNCTION-NAME specifies an existing generic function that has a
different value for the :generic-function-class argument and the new
generic function class is compatible with the old, ‘change-class’ is
called to change the class of the generic function; otherwise an error
of type ‘error’ is signaled.

Implementations can extend ‘defgeneric’ to include other options.  It is
required that an implementation signal an error of type ‘program-error’
if it observes an option that is not implemented locally.

See Also:
.........

*note defmethod::, *note documentation::, *note
ensure-generic-function::, *note generic-function::, *note Section 7.6.4
(Congruent Lambda-lists for all Methods of a Generic Function):
Congruent Lambda-lists for all Methods of a Generic Function.


File: ansicl,  Node: defmethod,  Next: find-class,  Prev: defgeneric,  Up: Objects

defmethod (Macro)
=================

Syntax:
.......

 -- Macro: defmethod
          function-name {method-qualifier}* specialized-lambda-list
          〚{declaration}* | documentation〛 {form}* → new-method

function-name::= {symbol | (setf symbol)}

method-qualifier::= non-list

specialized-lambda-list::=
     ({var | (var parameter-specializer-name)}*
     [&optional {var | (var [initform [supplied-p-parameter]])}*] [&rest
     var]
     [&key { var | (var [initfom [supplied-p-parameter]])}*
     [‘&allow-other-keys’]]
     [&aux {var |
     (var [initform])}*])

parameter-specializer-name::=
     symbol | (eql eql-specializer-form)

Arguments and Values:
.....................

DECLARATION—a declare expression; not evaluated.

DOCUMENTATION—a string; not evaluated.

VAR—a variable name.

EQL-SPECIALIZER-FORM—a form.

FORM—a form.

INITFORM—a form.

SUPPLIED-P-PARAMETER—variable name.

NEW-METHOD—the new method object.

Description:
............

The macro ‘defmethod’ defines a method on a generic function.

If ‘(fboundp function-name)’ is ‘nil’, a generic function is created
with default values for the argument precedence order (each argument is
more specific than the arguments to its right in the argument list), for
the generic function class (the class ‘standard-generic-function’), for
the method class (the class ‘standard-method’), and for the method
combination type (the standard method combination type).  The lambda
list of the generic function is congruent with the lambda list of the
method being defined; if the ‘defmethod’ form mentions keyword
arguments, the lambda list of the generic function will mention ‘&key’
(but no keyword arguments).  If function-name names an ordinary
function, a macro, or a special operator, an error is signaled.

If a generic function is currently named by function-name, the lambda
list of the method must be congruent with the lambda list of the generic
function.  If this condition does not hold, an error is signaled.  For a
definition of congruence in this context, see *note Section 7.6.4
(Congruent Lambda-lists for all Methods of a Generic Function):
Congruent Lambda-lists for all Methods of a Generic Function.

Each method-qualifier argument is an object that is used by method
combination to identify the given method.  The method combination type
might further restrict what a method qualifier can be.  The standard
method combination type allows for unqualified methods and methods whose
sole qualifier is one of the keywords :before, :after, or :around.

The specialized-lambda-list argument is like an ordinary lambda list
except that the names of required parameters can be replaced by
specialized parameters.  A specialized parameter is a list of the form
‘(VAR parameter-specializer-name)’.  Only required parameters can be
specialized.  If parameter-specializer-name is a symbol it names a
class; if it is a list, it is of the form ‘(eql EQL-SPECIALIZER-FORM)’.
The parameter specializer name ‘(eql EQL-SPECIALIZER-FORM)’ indicates
that the corresponding argument must be ‘eql’ to the object that is the
value of EQL-SPECIALIZER-FORM for the method to be applicable.  The
EQL-SPECIALIZER-FORM is evaluated at the time that the expansion of the
‘defmethod’ macro is evaluated.  If no parameter specializer name is
specified for a given required parameter, the parameter specializer
defaults to the class ‘t’.  For further discussion, see *note Section
7.6.2 (Introduction to Methods): Introduction to Methods.

The FORM arguments specify the method body.  The body of the method is
enclosed in an implicit block.  If function-name is a symbol, this block
bears the same name as the generic function.  If function-name is a list
of the form ‘(setf symbol)’, the name of the block is symbol.

The class of the method object that is created is that given by the
method class option of the generic function on which the method is
defined.

If the generic function already has a method that agrees with the method
being defined on parameter specializers and qualifiers, ‘defmethod’
replaces the existing method with the one now being defined.  For a
definition of agreement in this context.  see *note Section 7.6.3
(Agreement on Parameter Specializers and Qualifiers): Agreement on
Parameter Specializers and Qualifiers.

The parameter specializers are derived from the parameter specializer
names as described in *note Section 7.6.2 (Introduction to Methods):
Introduction to Methods.

The expansion of the ‘defmethod’ macro “refers to” each specialized
parameter (see the description of ‘ignore’ within the description of
declare).  This includes parameters that have an explicit parameter
specializer name of ‘t’.  This means that a compiler warning does not
occur if the body of the method does not refer to a specialized
parameter, while a warning might occur if the body of the method does
not refer to an unspecialized parameter.  For this reason, a parameter
that specializes on ‘t’ is not quite synonymous with an unspecialized
parameter in this context.

Declarations at the head of the method body that apply to the method’s
lambda variables are treated as bound declarations whose scope is the
same as the corresponding bindings.

Declarations at the head of the method body that apply to the functional
bindings of ‘call-next-method’ or ‘next-method-p’ apply to references to
those functions within the method body FORMS.  Any outer bindings of the
function names ‘call-next-method’ and ‘next-method-p’, and declarations
associated with such bindings are shadowed

The scope of free declarations at the head of the method body is the
entire method body, which includes any implicit local function
definitions but excludes initialization forms for the lambda variables.

‘defmethod’ is not required to perform any compile-time side effects.
In particular, the methods are not installed for invocation during
compilation.  An implementation may choose to store information about
the generic function for the purposes of compile-time error-checking
(such as checking the number of arguments on calls, or noting that a
definition for the function name has been seen).

DOCUMENTATION is attached as a documentation string to the method
object.

Affected By:
............

The definition of the referenced generic function.

Exceptional Situations:
.......................

If function-name names an ordinary function, a macro, or a special
operator, an error of type ‘error’ is signaled.

If a generic function is currently named by function-name, the lambda
list of the method must be congruent with the lambda list of the generic
function, or an error of type ‘error’ is signaled.

See Also:
.........

*note defgeneric::, *note documentation::, *note Section 7.6.2
(Introduction to Methods): Introduction to Methods, *note Section 7.6.4
(Congruent Lambda-lists for all Methods of a Generic Function):
Congruent Lambda-lists for all Methods of a Generic Function, *note
Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers):
Agreement on Parameter Specializers and Qualifiers, *note Section 3.4.11
(Syntactic Interaction of Documentation Strings and Declarations):
Syntactic Interaction of Documentation Strings and Declarations.


File: ansicl,  Node: find-class,  Next: next-method-p,  Prev: defmethod,  Up: Objects

find-class (Accessor)
=====================

Syntax:
.......

 -- Function: find-class symbol &optional errorp environment → class
(setf (find-class symbol &optional errorp environment) new-class)

Arguments and Values:
.....................

SYMBOL—a symbol.

ERRORP—a generalized boolean.  The default is true.

ENVIRONMENT—same as the ‘&environment’ argument to macro expansion
functions and is used to distinguish between compile-time and run-time
environments.  The ‘&environment’ argument has dynamic extent; the
consequences are undefined if the ‘&environment’ argument is referred to
outside the dynamic extent of the macro expansion function.

CLASS—a class object, or ‘nil’.

Description:
............

Returns the class object named by the SYMBOL in the ENVIRONMENT.  If
there is no such class, ‘nil’ is returned if ERRORP is false; otherwise,
if ERRORP is true, an error is signaled.

The class associated with a particular symbol can be changed by using
‘setf’ with ‘find-class’; or, if the new class given to ‘setf’ is ‘nil’,
the class association is removed (but the class object itself is not
affected).  The results are undefined if the user attempts to change or
remove the class associated with a symbol that is defined as a type
specifier in this standard.  See *note Section 4.3.7 (Integrating Types
and Classes): Integrating Types and Classes.

When using ‘setf’ of ‘find-class’, any errorp argument is evaluated for
effect, but any values it returns are ignored; the ERRORP parameter is
permitted primarily so that the ENVIRONMENT parameter can be used.

The ENVIRONMENT might be used to distinguish between a compile-time and
a run-time environment.

Exceptional Situations:
.......................

If there is no such class and ERRORP is true, ‘find-class’ signals an
error of type ‘error’.

See Also:
.........

*note defmacro::, *note Section 4.3.7 (Integrating Types and Classes):
Integrating Types and Classes.


File: ansicl,  Node: next-method-p,  Next: call-method; make-method,  Prev: find-class,  Up: Objects

next-method-p (Local Function)
==============================

Syntax:
.......

 -- Function: next-method-p <no arguments> → generalized-boolean

Arguments and Values:
.....................

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

The locally defined function ‘next-method-p’ can be used within the body
forms (but not the lambda list) defined by a method-defining form to
determine whether a next method exists.

The function ‘next-method-p’ has lexical scope and indefinite extent.

Whether or not ‘next-method-p’ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ‘next-method-p’ are the same as for symbols in the
‘COMMON-LISP’ package which are fbound in the global environment.  The
consequences of attempting to use ‘next-method-p’ outside of a
method-defining form are undefined.

See Also:
.........

*note call-next-method::, *note defmethod::, *note call-method::


File: ansicl,  Node: call-method; make-method,  Next: call-next-method,  Prev: next-method-p,  Up: Objects

call-method, make-method (Local Macro)
======================================

Syntax:
.......

 -- Macro: call-method method &optional next-method-list → {result}*
 -- Macro: make-method form → method-object

Arguments and Values:
.....................

METHOD—a method object, or a list (see below); not evaluated.

METHOD-OBJECT—a method object.

NEXT-METHOD-LIST—a list of METHOD objects; not evaluated.

RESULTS—the values returned by the method invocation.

Description:
............

The macro ‘call-method’ is used in method combination.  It hides the
implementation-dependent details of how methods are called.  The macro
‘call-method’ has lexical scope and can only be used within an effective
method form.

Whether or not ‘call-method’ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ‘call-method’ are the same as for symbols in the
‘COMMON-LISP’ package which are fbound in the global environment.  The
consequences of attempting to use ‘call-method’ outside of an effective
method form are undefined.

The macro ‘call-method’ invokes the specified method, supplying it with
arguments and with definitions for ‘call-next-method’ and for
‘next-method-p’.  If the invocation of ‘call-method’ is lexically inside
of a ‘make-method’, the arguments are those that were supplied to that
method.  Otherwise the arguments are those that were supplied to the
generic function.  The definitions of ‘call-next-method’ and
‘next-method-p’ rely on the specified NEXT-METHOD-LIST.

If METHOD is a list, the first element of the list must be the symbol
‘make-method’ and the second element must be a form.  Such a list
specifies a method object whose method function has a body that is the
given form.

NEXT-METHOD-LIST can contain method objects or lists, the first element
of which must be the symbol ‘make-method’ and the second element of
which must be a form.

Those are the only two places where ‘make-method’ can be used.  The form
used with ‘make-method’ is evaluated in the null lexical environment
augmented with a local macro definition for ‘call-method’ and with
bindings named by symbols not accessible from the ‘COMMON-LISP-USER’
package.

The ‘call-next-method’ function available to METHOD will call the first
method in NEXT-METHOD-LIST.  The ‘call-next-method’ function available
in that method, in turn, will call the second method in
NEXT-METHOD-LIST, and so on, until the list of next methods is
exhausted.

If NEXT-METHOD-LIST is not supplied, the ‘call-next-method’ function
available to METHOD signals an error of type ‘control-error’ and the
‘next-method-p’ function available to METHOD returns ‘nil’.

Examples:
.........

See Also:
.........

*note call-next-method::, *note define-method-combination::, *note
next-method-p::


File: ansicl,  Node: call-next-method,  Next: compute-applicable-methods,  Prev: call-method; make-method,  Up: Objects

call-next-method (Local Function)
=================================

Syntax:
.......

 -- Function: call-next-method &rest args → {result}*

Arguments and Values:
.....................

ARG—an object.

RESULTS—the values returned by the method it calls.

Description:
............

The function ‘call-next-method’ can be used within the body forms (but
not the lambda list) of a method defined by a method-defining form to
call the next method.

If there is no next method, the generic function ‘no-next-method’ is
called.

The type of method combination used determines which methods can invoke
‘call-next-method’.  The standard method combination type allows
‘call-next-method’ to be used within primary methods and around methods.
For generic functions using a type of method combination defined by the
short form of ‘define-method-combination’, ‘call-next-method’ can be
used in around methods only.

When ‘call-next-method’ is called with no arguments, it passes the
current method’s original arguments to the next method.  Neither
argument defaulting, nor using ‘setq’, nor rebinding variables with the
same names as parameters of the method affects the values
‘call-next-method’ passes to the method it calls.

When ‘call-next-method’ is called with arguments, the next method is
called with those arguments.

If ‘call-next-method’ is called with arguments but omits optional
arguments, the next method called defaults those arguments.

The function ‘call-next-method’ returns any values that are returned by
the next method.

The function ‘call-next-method’ has lexical scope and indefinite extent
and can only be used within the body of a method defined by a
method-defining form.

Whether or not ‘call-next-method’ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ‘call-next-method’ are the same as for symbols in the
‘COMMON-LISP’ package which are fbound in the global environment.  The
consequences of attempting to use ‘call-next-method’ outside of a
method-defining form are undefined.

Affected By:
............

‘defmethod’, ‘call-method’, ‘define-method-combination’.

Exceptional Situations:
.......................

When providing arguments to ‘call-next-method’, the following rule must
be satisfied or an error of type ‘error’ should be signaled: the ordered
set of applicable methods for a changed set of arguments for
‘call-next-method’ must be the same as the ordered set of applicable
methods for the original arguments to the generic function.
Optimizations of the error checking are possible, but they must not
change the semantics of ‘call-next-method’.

See Also:
.........

*note define-method-combination::, *note defmethod::, *note
next-method-p::, *note no-next-method::, *note call-method::, *note
Section 7.6.6 (Method Selection and Combination): Method Selection and
Combination, *note Section 7.6.6.2 (Standard Method Combination):
StdMethComb, *note Section 7.6.6.4 (Built-in Method Combination Types):
BuiltInMethCombTypes.


File: ansicl,  Node: compute-applicable-methods,  Next: define-method-combination,  Prev: call-next-method,  Up: Objects

compute-applicable-methods (Standard Generic Function)
======================================================

Syntax:
.......

 -- Generic Function: compute-applicable-methods generic-function
          function-arguments → methods

Method Signatures:
..................

compute-applicable-methods (GENERIC-FUNCTION
‘standard-generic-function’)

Arguments and Values:
.....................

GENERIC-FUNCTION—a generic function.

FUNCTION-ARGUMENTS—a list of arguments for the GENERIC-FUNCTION.

METHODS—a list of method objects.

Description:
............

Given a GENERIC-FUNCTION and a set of FUNCTION-ARGUMENTS, the function
‘compute-applicable-methods’ returns the set of methods that are
applicable for those arguments sorted according to precedence order.
See *note Section 7.6.6 (Method Selection and Combination): Method
Selection and Combination.

Affected By:
............

‘defmethod’

See Also:
.........

*note Section 7.6.6 (Method Selection and Combination): Method Selection
and Combination.


File: ansicl,  Node: define-method-combination,  Next: find-method,  Prev: compute-applicable-methods,  Up: Objects

define-method-combination (Macro)
=================================

Syntax:
.......

 -- Macro: define-method-combination name 〚↓short-form-option〛 → name

 -- Macro: define-method-combination name lambda-list
          ({method-group-specifier}*) [(:arguments . args-lambda-list)]
          [(:generic-function  generic-function-symbol)]
          〚{declaration}* | documentation〛 {form}* → name

SHORT-FORM-OPTION::=
     :documentation DOCUMENTATION |
     :identity-with-one-argument IDENTITY-WITH-ONE-ARGUMENT |
     :operator OPERATOR
METHOD-GROUP-SPECIFIER::=
     (name {{QUALIFIER-PATTERN}+ | predicate} 〚↓long-form-option〛)
LONG-FORM-OPTION::=
     :description DESCRIPTION |
     :order ORDER |
     :required REQUIRED-P

Arguments and Values:
.....................

ARGS-LAMBDA-LIST— a define-method-combination arguments lambda list.

DECLARATION—a declare expression; not evaluated.

DESCRIPTION—a format control.

DOCUMENTATION—a string; not evaluated.

FORMS—an implicit progn that must compute and return the form that
specifies how the methods are combined, that is, the effective method.

GENERIC-FUNCTION-SYMBOL—a symbol.

IDENTITY-WITH-ONE-ARGUMENT—a generalized boolean.

LAMBDA-LIST—ordinary lambda list.

NAME—a symbol.  Non-keyword, non-nil symbols are usually used.

OPERATOR—an operator.  NAME and OPERATOR are often the same symbol.
This is the default, but it is not required.

ORDER—:most-specific-first or :most-specific-last; evaluated.

PREDICATE—a symbol that names a function of one argument that returns a
generalized boolean.

QUALIFIER-PATTERN—a list, or the symbol *.

REQUIRED-P—a generalized boolean.

Description:
............

The macro ‘define-method-combination’ is used to define new types of
method combination.

There are two forms of ‘define-method-combination’.  The short form is a
simple facility for the cases that are expected to be most commonly
needed.  The long form is more powerful but more verbose.  It resembles
‘defmacro’ in that the body is an expression, usually using backquote,
that computes a form.  Thus arbitrary control structures can be
implemented.  The long form also allows arbitrary processing of method
qualifiers.

Short Form

     The short form syntax of ‘define-method-combination’ is recognized
     when the second subform is a non-nil symbol or is not present.
     When the short form is used, NAME is defined as a type of method
     combination that produces a Lisp form ‘(OPERATOR METHOD-CALL
     METHOD-CALL ...)’.  The OPERATOR is a symbol that can be the name
     of a function, macro, or special operator.  The OPERATOR can be
     supplied by a keyword option; it defaults to NAME.

     Keyword options for the short form are the following:

        • The :documentation option is used to document the
          method-combination type; see description of long form below.

        • The :identity-with-one-argument option enables an optimization
          when its value is true (the default is false).  If there is
          exactly one applicable method and it is a primary method, that
          method serves as the effective method and OPERATOR is not
          called.  This optimization avoids the need to create a new
          effective method and avoids the overhead of a function call.
          This option is designed to be used with operators such as
          ‘progn’, ‘and’, ‘+’, and ‘max’.

        • The :operator option specifies the name of the operator.  The
          OPERATOR argument is a symbol that can be the name of a
          function, macro, or special form.

     These types of method combination require exactly one qualifier per
     method.  An error is signaled if there are applicable methods with
     no qualifiers or with qualifiers that are not supported by the
     method combination type.

     A method combination procedure defined in this way recognizes two
     roles for methods.  A method whose one qualifier is the symbol
     naming this type of method combination is defined to be a primary
     method.  At least one primary method must be applicable or an error
     is signaled.  A method with :around as its one qualifier is an
     auxiliary method that behaves the same as an around method in
     standard method combination.  The function ‘call-next-method’ can
     only be used in around methods; it cannot be used in primary
     methods defined by the short form of the
     ‘define-method-combination’ macro.

     A method combination procedure defined in this way accepts an
     optional argument named ORDER, which defaults to
     :most-specific-first.  A value of :most-specific-last reverses the
     order of the primary methods without affecting the order of the
     auxiliary methods.

     The short form automatically includes error checking and support
     for around methods.

     For a discussion of built-in method combination types, see *note
     Section 7.6.6.4 (Built-in Method Combination Types):
     BuiltInMethCombTypes.

Long Form

     The long form syntax of ‘define-method-combination’ is recognized
     when the second subform is a list.

     The LAMBDA-LIST receives any arguments provided after the name of
     the method combination type in the :method-combination option to
     ‘defgeneric’.

     A list of method group specifiers follows.  Each specifier selects
     a subset of the applicable methods to play a particular role,
     either by matching their qualifiers against some patterns or by
     testing their qualifiers with a PREDICATE.  These method group
     specifiers define all method qualifiers that can be used with this
     type of method combination.

     The car of each METHOD-GROUP-SPECIFIER is a symbol which names a
     variable.  During the execution of the forms in the body of
     ‘define-method-combination’, this variable is bound to a list of
     the methods in the method group.  The methods in this list occur in
     the order specified by the :order option.

     If QUALIFIER-PATTERN is a symbol it must be *.  A method matches a
     QUALIFIER-PATTERN if the method’s list of qualifiers is ‘equal’ to
     the QUALIFIER-PATTERN (except that the symbol * in a
     QUALIFIER-PATTERN matches anything).  Thus a QUALIFIER-PATTERN can
     be one of the following: the empty list, which matches unqualified
     methods; the symbol *, which matches all methods; a true list,
     which matches methods with the same number of qualifiers as the
     length of the list when each qualifier matches the corresponding
     list element; or a dotted list that ends in the symbol * (the *
     matches any number of additional qualifiers).

     Each applicable method is tested against the QUALIFIER-PATTERNS and
     PREDICATES in left-to-right order.  As soon as a QUALIFIER-PATTERN
     matches or a PREDICATE returns true, the method becomes a member of
     the corresponding method group and no further tests are made.  Thus
     if a method could be a member of more than one method group, it
     joins only the first such group.  If a method group has more than
     one QUALIFIER-PATTERN, a method need only satisfy one of the
     QUALIFIER-PATTERNS to be a member of the group.

     The name of a PREDICATE function can appear instead of
     QUALIFIER-PATTERNS in a method group specifier.  The PREDICATE is
     called for each method that has not been assigned to an earlier
     method group; it is called with one argument, the method’s
     qualifier list.  The PREDICATE should return true if the method is
     to be a member of the method group.  A PREDICATE can be
     distinguished from a QUALIFIER-PATTERN because it is a symbol other
     than ‘nil’ or *.

     If there is an applicable method that does not fall into any method
     group, the function ‘invalid-method-error’ is called.

     Method group specifiers can have keyword options following the
     qualifier patterns or predicate.  Keyword options can be
     distinguished from additional qualifier patterns because they are
     neither lists nor the symbol *.  The keyword options are as
     follows:

        • The :description option is used to provide a description of
          the role of methods in the method group.  Programming
          environment tools use ‘(apply #'format stream FORMAT-CONTROL
          (method-qualifiers METHOD))’ to print this description, which
          is expected to be concise.  This keyword option allows the
          description of a method qualifier to be defined in the same
          module that defines the meaning of the method qualifier.  In
          most cases, FORMAT-CONTROL will not contain any ‘format’
          directives, but they are available for generality.  If
          :description is not supplied, a default description is
          generated based on the variable name and the qualifier
          patterns and on whether this method group includes the
          unqualified methods.

        • The :order option specifies the order of methods.  The ORDER
          argument is a form that evaluates to :most-specific-first or
          :most-specific-last.  If it evaluates to any other value, an
          error is signaled.  If :order is not supplied, it defaults to
          :most-specific-first.

        • The :required option specifies whether at least one method in
          this method group is required.  If its value is true and the
          method group is empty (that is, no applicable methods match
          the qualifier patterns or satisfy the predicate), an error is
          signaled.  If :required is not supplied, it defaults to ‘nil’.

     The use of method group specifiers provides a convenient syntax to
     select methods, to divide them among the possible roles, and to
     perform the necessary error checking.  It is possible to perform
     further filtering of methods in the body forms by using normal
     list-processing operations and the functions ‘method-qualifiers’
     and ‘invalid-method-error’.  It is permissible to use ‘setq’ on the
     variables named in the method group specifiers and to bind
     additional variables.  It is also possible to bypass the method
     group specifier mechanism and do everything in the body forms.
     This is accomplished by writing a single method group with * as its
     only QUALIFIER-PATTERN; the variable is then bound to a list of all
     of the applicable methods, in most-specific-first order.

     The body FORMS compute and return the form that specifies how the
     methods are combined, that is, the effective method.  The effective
     method is evaluated in the null lexical environment augmented with
     a local macro definition for ‘call-method’ and with bindings named
     by symbols not accessible from the ‘COMMON-LISP-USER’ package.
     Given a method object in one of the lists produced by the method
     group specifiers and a list of next methods, ‘call-method’ will
     invoke the method such that ‘call-next-method’ has available the
     next methods.

     When an effective method has no effect other than to call a single
     method, some implementations employ an optimization that uses the
     single method directly as the effective method, thus avoiding the
     need to create a new effective method.  This optimization is active
     when the effective method form consists entirely of an invocation
     of the ‘call-method’ macro whose first subform is a method object
     and whose second subform is ‘nil’ or unsupplied.  Each
     ‘define-method-combination’ body is responsible for stripping off
     redundant invocations of ‘progn’, ‘and’, ‘multiple-value-prog1’,
     and the like, if this optimization is desired.

     The list ‘(:arguments . LAMBDA-LIST)’ can appear before any
     declarations or documentation string.  This form is useful when the
     method combination type performs some specific behavior as part of
     the combined method and that behavior needs access to the arguments
     to the generic function.  Each parameter variable defined by
     LAMBDA-LIST is bound to a form that can be inserted into the
     effective method.  When this form is evaluated during execution of
     the effective method, its value is the corresponding argument to
     the generic function; the consequences of using such a form as the
     PLACE in a ‘setf’ form are undefined.  Argument correspondence is
     computed by dividing the :arguments LAMBDA-LIST and the generic
     function LAMBDA-LIST into three sections: the required parameters,
     the optional parameters, and the keyword and rest parameters.  The
     arguments supplied to the generic function for a particular call
     are also divided into three sections; the required arguments
     section contains as many arguments as the generic function has
     required parameters, the optional arguments section contains as
     many arguments as the generic function has optional parameters, and
     the keyword/rest arguments section contains the remaining
     arguments.  Each parameter in the required and optional sections of
     the :arguments LAMBDA-LIST accesses the argument at the same
     position in the corresponding section of the arguments.  If the
     section of the :arguments LAMBDA-LIST is shorter, extra arguments
     are ignored.  If the section of the :arguments LAMBDA-LIST is
     longer, excess required parameters are bound to forms that evaluate
     to ‘nil’  and excess optional parameters are bound to their
     initforms.  The keyword parameters and rest parameters in the
     :arguments LAMBDA-LIST access the keyword/rest section of the
     arguments.  If the :arguments LAMBDA-LIST contains ‘&key’, it
     behaves as if it also contained ‘&allow-other-keys’.

     In addition, ‘&whole’ VAR can be placed first in the :arguments
     LAMBDA-LIST.  It causes VAR to be bound to a form that evaluates to
     a list of all of the arguments supplied to the generic function.
     This is different from ‘&rest’ because it accesses all of the
     arguments, not just the keyword/rest arguments.

     Erroneous conditions detected by the body should be reported with
     ‘method-combination-error’ or ‘invalid-method-error’; these
     functions add any necessary contextual information to the error
     message and will signal the appropriate error.

     The body FORMS are evaluated inside of the bindings created by the
     lambda list and method group specifiers.

     Declarations at the head of the body are positioned directly inside
     of bindings created by the lambda list and outside of the bindings
     of the method group variables.  Thus method group variables cannot
     be declared in this way.  ‘locally’ may be used around the body,
     however.

     Within the body FORMS, GENERIC-FUNCTION-SYMBOL is bound to the
     generic function object.

     DOCUMENTATION is attached as a documentation string to NAME (as
     kind ‘method-combination’) and to the method combination object.

     Note that two methods with identical specializers, but with
     different qualifiers, are not ordered by the algorithm described in
     Step 2 of the method selection and combination process described in
     *note Section 7.6.6 (Method Selection and Combination): Method
     Selection and Combination.  Normally the two methods play different
     roles in the effective method because they have different
     qualifiers, and no matter how they are ordered in the result of
     Step 2, the effective method is the same.  If the two methods play
     the same role and their order matters,

     an error is signaled.  This happens as part of the qualifier
     pattern matching in ‘define-method-combination’.

If a ‘define-method-combination’ form appears as a top level form, the
compiler must make the method combination name be recognized as a valid
method combination name in subsequent ‘defgeneric’ forms.  However, the
method combination is executed no earlier than when the
‘define-method-combination’ form is executed, and possibly as late as
the time that generic functions that use the method combination are
executed.

Examples:
.........

Most examples of the long form of ‘define-method-combination’ also
illustrate the use of the related functions that are provided as part of
the declarative method combination facility.

     ;;; Examples of the short form of define-method-combination

      (define-method-combination and :identity-with-one-argument t)

      (defmethod func and ((x class1) y) ...)

     ;;; The equivalent of this example in the long form is:

      (define-method-combination and
              (&optional (order :most-specific-first))
              ((around (:around))
               (primary (and) :order order :required t))
        (let ((form (if (rest primary)
                        `(and ,@(mapcar #'(lambda (method)
                                            `(call-method ,method))
                                        primary))
                        `(call-method ,(first primary)))))
          (if around
              `(call-method ,(first around)
                            (,@(rest around)
                             (make-method ,form)))
              form)))

     ;;; Examples of the long form of define-method-combination

     ;The default method-combination technique
      (define-method-combination standard ()
              ((around (:around))
               (before (:before))
               (primary () :required t)
               (after (:after)))
        (flet ((call-methods (methods)
                 (mapcar #'(lambda (method)
                             `(call-method ,method))
                         methods)))
          (let ((form (if (or before after (rest primary))
                          `(multiple-value-prog1
                             (progn ,@(call-methods before)
                                    (call-method ,(first primary)
                                                 ,(rest primary)))
                             ,@(call-methods (reverse after)))
                          `(call-method ,(first primary)))))
            (if around
                `(call-method ,(first around)
                              (,@(rest around)
                               (make-method ,form)))
                form))))

     ;A simple way to try several methods until one returns non-nil
      (define-method-combination or ()
              ((methods (or)))
        `(or ,@(mapcar #'(lambda (method)
                           `(call-method ,method))
                       methods)))

     ;A more complete version of the preceding
      (define-method-combination or
              (&optional (order ':most-specific-first))
              ((around (:around))
               (primary (or)))
        ;; Process the order argument
        (case order
          (:most-specific-first)
          (:most-specific-last (setq primary (reverse primary)))
          (otherwise (method-combination-error "~S is an invalid order.~@
          :most-specific-first and :most-specific-last are the possible values."
                                               order)))
        ;; Must have a primary method
        (unless primary
          (method-combination-error "A primary method is required."))
        ;; Construct the form that calls the primary methods
        (let ((form (if (rest primary)
                        `(or ,@(mapcar #'(lambda (method)
                                           `(call-method ,method))
                                       primary))
                        `(call-method ,(first primary)))))
          ;; Wrap the around methods around that form
          (if around
              `(call-method ,(first around)
                            (,@(rest around)
                             (make-method ,form)))
              form)))

     ;The same thing, using the :order and :required keyword options
      (define-method-combination or
              (&optional (order ':most-specific-first))
              ((around (:around))
               (primary (or) :order order :required t))
        (let ((form (if (rest primary)
                        `(or ,@(mapcar #'(lambda (method)
                                           `(call-method ,method))
                                       primary))
                        `(call-method ,(first primary)))))
          (if around
              `(call-method ,(first around)
                            (,@(rest around)
                             (make-method ,form)))
              form)))

     ;This short-form call is behaviorally identical to the preceding
      (define-method-combination or :identity-with-one-argument t)

     ;Order methods by positive integer qualifiers
     ;:around methods are disallowed to keep the example small
      (define-method-combination example-method-combination ()
              ((methods positive-integer-qualifier-p))
        `(progn ,@(mapcar #'(lambda (method)
                              `(call-method ,method))
                          (stable-sort methods #'<
                            :key #'(lambda (method)
                                     (first (method-qualifiers method)))))))

      (defun positive-integer-qualifier-p (method-qualifiers)
        (and (= (length method-qualifiers) 1)
             (typep (first method-qualifiers) '(integer 0 *))))

     ;;; Example of the use of :arguments
      (define-method-combination progn-with-lock ()
              ((methods ()))
        (:arguments object)
        `(unwind-protect
             (progn (lock (object-lock ,object))
                    ,@(mapcar #'(lambda (method)
                                  `(call-method ,method))
                              methods))
           (unlock (object-lock ,object))))


Side Effects:
.............

The compiler is not required to perform any compile-time side-effects.

Exceptional Situations:
.......................

Method combination types defined with the short form require exactly one
qualifier per method.  An error of type ‘error’ is signaled if there are
applicable methods with no qualifiers or with qualifiers that are not
supported by the method combination type.  At least one primary method
must be applicable or an error of type ‘error’ is signaled.

If an applicable method does not fall into any method group, the system
signals an error of type ‘error’ indicating that the method is invalid
for the kind of method combination in use.

If the value of the :required option is true and the method group is
empty (that is, no applicable methods match the qualifier patterns or
satisfy the predicate), an error of type ‘error’ is signaled.

If the :order option evaluates to a value other than
:most-specific-first or :most-specific-last, an error of type ‘error’ is
signaled.

See Also:
.........

*note call-method::, *note call-next-method::, *note documentation::,
*note method-qualifiers::, *note method-combination-error::, *note
invalid-method-error::, *note defgeneric::, *note Section 7.6.6 (Method
Selection and Combination): Method Selection and Combination, *note
Section 7.6.6.4 (Built-in Method Combination Types):
BuiltInMethCombTypes, *note Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations): Syntactic Interaction of
Documentation Strings and Declarations.

Notes:
......

The :method-combination option of ‘defgeneric’ is used to specify that a
generic function should use a particular method combination type.  The
first argument to the :method-combination option is the name of a method
combination type and the remaining arguments are options for that type.


File: ansicl,  Node: find-method,  Next: add-method,  Prev: define-method-combination,  Up: Objects

find-method (Standard Generic Function)
=======================================

Syntax:
.......

 -- Generic Function: find-method generic-function method-qualifiers
          specializers &optional errorp → method

Method Signatures:
..................

find-method (GENERIC-FUNCTION ‘standard-generic-function’)
method-qualifiers specializers &optional errorp

Arguments and Values:
.....................

GENERIC-FUNCTION—a generic function.

METHOD-QUALIFIERS—a list.

SPECIALIZERS—a list.

ERRORP—a generalized boolean.  The default is true.

METHOD—a method object, or ‘nil’.

Description:
............

The generic function ‘find-method’ takes a generic function and returns
the method object that agrees on qualifiers and parameter specializers
with the METHOD-QUALIFIERS and SPECIALIZERS arguments of ‘find-method’.
METHOD-QUALIFIERS contains the method qualifiers for the method.  The
order of the method qualifiers is significant.  For a definition of
agreement in this context, see *note Section 7.6.3 (Agreement on
Parameter Specializers and Qualifiers): Agreement on Parameter
Specializers and Qualifiers.

The SPECIALIZERS argument contains the parameter specializers for the
method.  It must correspond in length to the number of required
arguments of the generic function, or an error is signaled.  This means
that to obtain the default method on a given GENERIC-FUNCTION, a list
whose elements are the class ‘t’ must be given.

If there is no such method and ERRORP is true, ‘find-method’ signals an
error.  If there is no such method and ERRORP is false, ‘find-method’
returns ‘nil’.

Examples:
.........

      (defmethod some-operation ((a integer) (b float)) (list a b))
     → #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>
      (find-method #'some-operation '() (mapcar #'find-class '(integer float)))
     → #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>
      (find-method #'some-operation '() (mapcar #'find-class '(integer integer)))
     ▷ Error: No matching method
      (find-method #'some-operation '() (mapcar #'find-class '(integer integer)) nil)
     → NIL

Affected By:
............

‘add-method’, ‘defclass’, ‘defgeneric’, ‘defmethod’

Exceptional Situations:
.......................

If the SPECIALIZERS argument does not correspond in length to the number
of required arguments of the GENERIC-FUNCTION, an an error of type
‘error’ is signaled.

If there is no such method and ERRORP is true, ‘find-method’ signals an
error of type ‘error’.

See Also:
.........

*note Section 7.6.3 (Agreement on Parameter Specializers and
Qualifiers): Agreement on Parameter Specializers and Qualifiers.


File: ansicl,  Node: add-method,  Next: initialize-instance (Standard Generic Function),  Prev: find-method,  Up: Objects

add-method (Standard Generic Function)
======================================

Syntax:
.......

 -- Generic Function: add-method generic-function method →
          generic-function

Method Signatures:
..................

add-method (GENERIC-FUNCTION ‘standard-generic-function’)
(METHOD ‘method’)

Arguments and Values:
.....................

GENERIC-FUNCTION—a generic function object.

METHOD—a method object.

Description:
............

The generic function ‘add-method’ adds a method to a generic function.

If METHOD agrees with an existing method of GENERIC-FUNCTION on
parameter specializers and qualifiers, the existing method is replaced.

Exceptional Situations:
.......................

The lambda list of the method function of METHOD must be congruent with
the lambda list of GENERIC-FUNCTION, or an error of type ‘error’ is
signaled.

If METHOD is a method object of another generic function, an error of
type ‘error’ is signaled.

See Also:
.........

*note defmethod::, *note defgeneric::, *note find-method::, *note
remove-method::, *note Section 7.6.3 (Agreement on Parameter
Specializers and Qualifiers): Agreement on Parameter Specializers and
Qualifiers.


File: ansicl,  Node: initialize-instance (Standard Generic Function),  Next: class-name,  Prev: add-method,  Up: Objects

initialize-instance (Standard Generic Function)
===============================================

Syntax:
.......

 -- Generic Function: initialize-instance instance &rest initargs &key
          &allow-other-keys → instance

Method Signatures:
..................

initialize-instance (INSTANCE ‘standard-object’) &rest initargs

Arguments and Values:
.....................

INSTANCE—an object.

INITARGS—a defaulted initialization argument list.

Description:
............

Called by ‘make-instance’ to initialize a newly created instance.  The
generic function is called with the new INSTANCE and the defaulted
initialization argument list.

The system-supplied primary method on ‘initialize-instance’ initializes
the slots of the INSTANCE with values according to the INITARGS and the
:initform forms of the slots.  It does this by calling the generic
function ‘shared-initialize’ with the following arguments: the INSTANCE,
‘t’ (this indicates that all slots for which no initialization arguments
are provided should be initialized according to their :initform forms),
and the INITARGS.

Programmers can define methods for ‘initialize-instance’ to specify
actions to be taken when an instance is initialized.  If only after
methods are defined, they will be run after the system-supplied primary
method for initialization and therefore will not interfere with the
default behavior of ‘initialize-instance’.

See Also:
.........

*note shared-initialize (Standard Generic Function)::, *note
make-instance::, *note slot-boundp::, *note slot-makunbound::, *note
Section 7.1 (Object Creation and Initialization): Object Creation and
Initialization, *note Section 7.1.4 (Rules for Initialization
Arguments): Rules for Initialization Arguments, *note Section 7.1.2
(Declaring the Validity of Initialization Arguments): Declaring the
Validity of Initialization Arguments.


File: ansicl,  Node: class-name,  Next: setf class-name,  Prev: initialize-instance (Standard Generic Function),  Up: Objects

class-name (Standard Generic Function)
======================================

Syntax:
.......

 -- Generic Function: class-name class → name

Method Signatures:
..................

class-name (CLASS ‘class’)

Arguments and Values:
.....................

CLASS—a class object.

NAME—a symbol.

Description:
............

Returns the name of the given CLASS.

See Also:
.........

*note find-class::, *note Section 4.3 (Classes): Classes.

Notes:
......

If S is a symbol such that S =‘(class-name C)’ and C =‘(find-class S)’,
then S is the proper name of C. For further discussion, see *note
Section 4.3 (Classes): Classes.

The name of an anonymous class is ‘nil’.


File: ansicl,  Node: setf class-name,  Next: class-of,  Prev: class-name,  Up: Objects

(setf class-name) (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: (setf class-name) new-value class → new-value

Method Signatures:
..................

(setf class-name) new-value (CLASS ‘class’)

Arguments and Values:
.....................

NEW-VALUE—a symbol.

CLASS—a class.

Description:
............

The generic function ‘(setf class-name)’ sets the name of a CLASS
object.

See Also:
.........

*note find-class::, proper name, *note Section 4.3 (Classes): Classes.


File: ansicl,  Node: class-of,  Next: unbound-slot,  Prev: setf class-name,  Up: Objects

class-of (Function)
===================

Syntax:
.......

 -- Function: class-of object → class

Arguments and Values:
.....................

OBJECT—an object.

CLASS—a class object.

Description:
............

Returns the class of which the OBJECT is a direct instance.

Examples:
.........

      (class-of 'fred) → #<BUILT-IN-CLASS SYMBOL 610327300>
      (class-of 2/3) → #<BUILT-IN-CLASS RATIO 610326642>

      (defclass book () ()) → #<STANDARD-CLASS BOOK 33424745>
      (class-of (make-instance 'book)) → #<STANDARD-CLASS BOOK 33424745>

      (defclass novel (book) ()) → #<STANDARD-CLASS NOVEL 33424764>
      (class-of (make-instance 'novel)) → #<STANDARD-CLASS NOVEL 33424764>

      (defstruct kons kar kdr) → KONS
      (class-of (make-kons :kar 3 :kdr 4)) → #<STRUCTURE-CLASS KONS 250020317>

See Also:
.........

*note make-instance::, *note type-of::


File: ansicl,  Node: unbound-slot,  Next: unbound-slot-instance,  Prev: class-of,  Up: Objects

unbound-slot (Condition Type)
=============================

Class Precedence List:
......................

‘unbound-slot’, ‘cell-error’, ‘error’, ‘serious-condition’, ‘condition’,
‘t’

Description:
............

The object having the unbound slot is initialized by the :instance
initialization argument to ‘make-condition’, and is accessed by the
function ‘unbound-slot-instance’.

The name of the cell (see ‘cell-error’) is the name of the slot.

See Also:
.........

*note cell-error-name::, *note unbound-slot-instance::, *note Section
9.1 (Condition System Concepts): Condition System Concepts.


File: ansicl,  Node: unbound-slot-instance,  Prev: unbound-slot,  Up: Objects

unbound-slot-instance (Function)
================================

Syntax:
.......

 -- Function: unbound-slot-instance condition → instance

Arguments and Values:
.....................

CONDITION—a condition of type ‘unbound-slot’.

INSTANCE—an object.

Description:
............

Returns the instance which had the unbound slot in the situation
represented by the CONDITION.

See Also:
.........

*note cell-error-name::, *note unbound-slot::, *note Section 9.1
(Condition System Concepts): Condition System Concepts.


File: ansicl,  Node: Structures,  Next: Conditions,  Prev: Objects,  Up: Top

8 Structures
************

* Menu:


Dictionary

* defstruct::
* copy-structure::


File: ansicl,  Node: defstruct,  Next: copy-structure,  Up: Structures

defstruct (Macro)
=================

Syntax:
.......

 -- Macro: defstruct name-and-options [documentation]
          {↓slot-description}* → structure-name

NAME-AND-OPTIONS::=
     structure-name | (structure-name 〚↓options〛)
OPTIONS::=
     ↓conc-name-option |
     {↓constructor-option}* |
     ↓copier-option |
     ↓include-option |
     ↓initial-offset-option |
     ↓named-option |
     ↓predicate-option |
     ↓printer-option |
     ↓type-option
CONC-NAME-OPTION::=
     :conc-name | (:conc-name) | (:conc-name CONC-NAME)
CONSTRUCTOR-OPTION::=
     :constructor |
     (:constructor) |
     (:constructor CONSTRUCTOR-NAME) |
     (:constructor CONSTRUCTOR-NAME CONSTRUCTOR-ARGLIST)
COPIER-OPTION::=
     :copier | (:copier) | (:copier COPIER-NAME)
PREDICATE-OPTION::=
     :predicate | (:predicate) | (:predicate PREDICATE-NAME)
INCLUDE-OPTION::=
     (:include INCLUDED-STRUCTURE-NAME {↓slot-description}*)
PRINTER-OPTION::=
     ↓print-object-option | ↓print-function-option
PRINT-OBJECT-OPTION::=
     (:print-object PRINTER-NAME) | (:print-object)
PRINT-FUNCTION-OPTION::=
     (:print-function PRINTER-NAME) | (:print-function)
TYPE-OPTION::=
     (:type TYPE)
NAMED-OPTION::=
     :named
INITIAL-OFFSET-OPTION::=
     (:initial-offset INITIAL-OFFSET)
SLOT-DESCRIPTION::=
     SLOT-NAME |
     (SLOT-NAME [SLOT-INITFORM 〚↓slot-option〛])
SLOT-OPTION::=
     :type SLOT-TYPE |
     :read-only SLOT-READ-ONLY-P

Arguments and Values:
.....................

CONC-NAME—a string designator.

CONSTRUCTOR-ARGLIST—a boa lambda list.

CONSTRUCTOR-NAME—a symbol.

COPIER-NAME—a symbol.

INCLUDED-STRUCTURE-NAME—an already-defined structure name.  Note that a
derived type is not permissible, even if it would expand into a
structure name.

INITIAL-OFFSET—a non-negative integer.

PREDICATE-NAME—a symbol.

PRINTER-NAME—a function name or a lambda expression.

SLOT-NAME—a symbol.

SLOT-INITFORM—a form.

SLOT-READ-ONLY-P—a generalized boolean.

STRUCTURE-NAME—a symbol.

TYPE—one of the type specifiers ‘list’, ‘vector’, or ‘(vector SIZE)’, or
some other type specifier defined by the implementation to be
appropriate.

DOCUMENTATION—a string; not evaluated.

Description:
............

‘defstruct’ defines a structured type, named STRUCTURE-TYPE, with named
slots as specified by the SLOT-OPTIONS.

‘defstruct’ defines readers for the slots and arranges for ‘setf’ to
work properly on such reader functions.  Also, unless overridden, it
defines a predicate named ‘NAME-p’, defines a constructor function named
‘make-CONSTRUCTOR-NAME’, and defines a copier function named
‘copy-CONSTRUCTOR-NAME’.  All names of automatically created functions
might automatically be declared ‘inline’ (at the discretion of the
implementation).

If DOCUMENTATION is supplied, it is attached to STRUCTURE-NAME as a
documentation string of kind structure, and unless :type is used, the
DOCUMENTATION is also attached to STRUCTURE-NAME as a documentation
string of kind type and as a documentation string to the class object
for the class named STRUCTURE-NAME.

‘defstruct’ defines a constructor function that is used to create
instances of the structure created by ‘defstruct’.  The default name is
‘make-STRUCTURE-NAME’.  A different name can be supplied by giving the
name as the argument to the CONSTRUCTOR option.  ‘nil’ indicates that no
constructor function will be created.

After a new structure type has been defined, instances of that type
normally can be created by using the constructor function for the type.
A call to a constructor function is of the following form:

      (constructor-function-name
       slot-keyword1 form-1
       slot-keyword2 form-2
       ...)

The arguments to the constructor function are all keyword arguments.
Each slot keyword argument must be a keyword whose name corresponds to
the name of a structure slot.  All the KEYWORDS and FORMS are evaluated.
If a slot is not initialized in this way, it is initialized by
evaluating SLOT-INITFORM in the slot description at the time the
constructor function is called.  If no SLOT-INITFORM is supplied, the
consequences are undefined if an attempt is later made to read the
slot’s value before a value is explicitly assigned.

Each SLOT-INITFORM supplied for a ‘defstruct’ component, when used by
the constructor function for an otherwise unsupplied component, is
re-evaluated on every call to the constructor function.  The
SLOT-INITFORM is not evaluated unless it is needed in the creation of a
particular structure instance.  If it is never needed, there can be no
type-mismatch error, even if the type of the slot is specified; no
warning should be issued in this case.  For example, in the following
sequence, only the last call is an error.

      (defstruct person (name 007 :type string))
      (make-person :name "James")
      (make-person)

It is as if the SLOT-INITFORMS were used as initialization forms for the
keyword parameters of the constructor function.

The symbols which name the slots must not be used by the implementation
as the names for the lambda variables in the constructor function, since
one or more of those symbols might have been proclaimed ‘special’ or
might be defined as the name of a constant variable.  The slot default
init forms are evaluated in the lexical environment in which the
‘defstruct’ form itself appears and in the dynamic environment in which
the call to the constructor function appears.

For example, if the form ‘(gensym)’ were used as an initialization form,
either in the constructor-function call or as the default initialization
form in ‘defstruct’, then every call to the constructor function would
call ‘gensym’ once to generate a new symbol.

Each SLOT-DESCRIPTION in ‘defstruct’ can specify zero or more
SLOT-OPTIONS.  A SLOT-OPTION consists of a pair of a keyword and a value
(which is not a form to be evaluated, but the value itself).  For
example:

      (defstruct ship
        (x-position 0.0 :type short-float)
        (y-position 0.0 :type short-float)
        (x-velocity 0.0 :type short-float)
        (y-velocity 0.0 :type short-float)
        (mass *default-ship-mass* :type short-float :read-only t))

This specifies that each slot always contains a short float, and that
the last slot cannot be altered once a ship is constructed.

The available slot-options are:

‘:type TYPE’

     This specifies that the contents of the slot is always of type
     TYPE.  This is entirely analogous to the declaration of a variable
     or function; it effectively declares the result type of the reader
     function.  It is implementation-dependent whether the type is
     checked when initializing a slot or when assigning to it.  TYPE is
     not evaluated; it must be a valid type specifier.

‘:read-only X’

     When X is true, this specifies that this slot cannot be altered; it
     will always contain the value supplied at construction time.
     ‘setf’ will not accept the reader function for this slot.  If X is
     false, this slot-option has no effect.  X is not evaluated.

     When this option is false or unsupplied, it is
     implementation-dependent whether the ability to write the slot is
     implemented by a setf function or a setf expander.

The following keyword options are available for use with ‘defstruct’.  A
‘defstruct’ option can be either a keyword or a list of a keyword and
arguments for that keyword; specifying the keyword by itself is
equivalent to specifying a list consisting of the keyword and no
arguments.  The syntax for ‘defstruct’ options differs from the pair
syntax used for slot-options.  No part of any of these options is
evaluated.

:conc-name

     This provides for automatic prefixing of names of reader (or
     access) functions.  The default behavior is to begin the names of
     all the reader functions of a structure with the name of the
     structure followed by a hyphen.

     :conc-name supplies an alternate prefix to be used.  If a hyphen is
     to be used as a separator, it must be supplied as part of the
     prefix.  If :conc-name is ‘nil’ or no argument is supplied, then no
     prefix is used; then the names of the reader functions are the same
     as the slot names.  If a non-nil prefix is given, the name of the
     reader function for each slot is constructed by concatenating that
     prefix and the name of the slot, and interning the resulting symbol
     in the package that is current at the time the ‘defstruct’ form is
     expanded.

     Note that no matter what is supplied for :conc-name, slot keywords
     that match the slot names with no prefix attached are used with a
     constructor function.  The reader function name is used in
     conjunction with ‘setf’.  Here is an example:

           (defstruct (door (:conc-name dr-)) knob-color width material) → DOOR
           (setq my-door (make-door :knob-color 'red :width 5.0))
          → #S(DOOR :KNOB-COLOR RED :WIDTH 5.0 :MATERIAL NIL)
           (dr-width my-door) → 5.0
           (setf (dr-width my-door) 43.7) → 43.7
           (dr-width my-door) → 43.7

     Whether or not the :conc-name option is explicitly supplied, the
     following rule governs name conflicts of generated reader (or
     accessor) names: For any structure type Shaving a reader function
     named R for a slot named Xthat is inherited by another structure
     type Sthat would have a reader function with the same name R for a
     slot named Xno definition for R is generated by the definition of
     Sinstead, the definition of R is inherited from the definition of
     S(In such a case, if Xthe implementation might signal a style
     warning.)

:constructor

     This option takes zero, one, or two arguments.  If at least one
     argument is supplied and the first argument is not ‘nil’, then that
     argument is a symbol which specifies the name of the constructor
     function.  If the argument is not supplied (or if the option itself
     is not supplied), the name of the constructor is produced by
     concatenating the string ‘"MAKE-"’ and the name of the structure,
     interning the name in whatever package is current at the time
     ‘defstruct’ is expanded.  If the argument is provided and is ‘nil’,
     no constructor function is defined.

     If :constructor is given as ‘(:constructor NAME ARGLIST)’, then
     instead of making a keyword driven constructor function,
     ‘defstruct’ defines a “positional” constructor function, taking
     arguments whose meaning is determined by the argument’s position
     and possibly by keywords.  ARGLIST is used to describe what the
     arguments to the constructor will be.  In the simplest case
     something like ‘(:constructor make-foo (a b c))’ defines ‘make-foo’
     to be a three-argument constructor function whose arguments are
     used to initialize the slots named ‘a’, ‘b’, and ‘c’.

     Because a constructor of this type operates “By Order of
     Arguments,” it is sometimes known as a “boa constructor.”

     For information on how the ARGLIST for a “boa constructor” is
     processed, see *note Section 3.4.6 (Boa Lambda Lists): Boa Lambda
     Lists.

     It is permissible to use the :constructor option more than once, so
     that you can define several different constructor functions, each
     taking different parameters.

     ‘defstruct’ creates the default-named keyword constructor function
     only if no explicit :constructor options are specified, or if the
     :constructor option is specified without a NAME argument.

     ‘(:constructor nil)’ is meaningful only when there are no other
     :constructor options specified.  It prevents ‘defstruct’ from
     generating any constructors at all.

     Otherwise, ‘defstruct’ creates a constructor function corresponding
     to each supplied :constructor option.  It is permissible to specify
     multiple keyword constructor functions as well as multiple “boa
     constructors”.

:copier

     This option takes one argument, a symbol, which specifies the name
     of the copier function.  If the argument is not provided or if the
     option itself is not provided, the name of the copier is produced
     by concatenating the string ‘"COPY-"’ and the name of the
     structure, interning the name in whatever package is current at the
     time ‘defstruct’ is expanded.  If the argument is provided and is
     ‘nil’, no copier function is defined.

     The automatically defined copier function is a function of one
     argument, which must be of the structure type being defined.  The
     copier function creates a fresh structure that has the same type as
     its argument, and that has the same component values as the
     original structure; that is, the component values are not copied
     recursively.  If the ‘defstruct’ :type option was not used, the
     following equivalence applies:

           (COPIER-NAME x) = (copy-structure (the STRUCTURE-NAME x))

:include

     This option is used for building a new structure definition as an
     extension of another structure definition.  For example:

           (defstruct person name age sex)

     To make a new structure to represent an astronaut that has the
     attributes of name, age, and sex, and functions that operate on
     ‘person’ structures, ‘astronaut’ is defined with :include as
     follows:

           (defstruct (astronaut (:include person)
                                 (:conc-name astro-))
              helmet-size
              (favorite-beverage 'tang))

     :include causes the structure being defined to have the same slots
     as the included structure.  This is done in such a way that the
     reader functions for the included structure also work on the
     structure being defined.  In this example, an ‘astronaut’ therefore
     has five slots: the three defined in ‘person’ and the two defined
     in ‘astronaut’ itself.  The reader functions defined by the
     ‘person’ structure can be applied to instances of the ‘astronaut’
     structure, and they work correctly.  Moreover, ‘astronaut’ has its
     own reader functions for components defined by the ‘person’
     structure.  The following examples illustrate the use of
     ‘astronaut’ structures:

           (setq x (make-astronaut :name 'buzz
                                   :age 45.
                                   :sex t
                                   :helmet-size 17.5))
           (person-name x) → BUZZ
           (astro-name x) → BUZZ
           (astro-favorite-beverage x) → TANG

           (reduce #'+ astros :key #'person-age) ; obtains the total of the ages
                                                 ; of the possibly empty
                                                 ; sequence of astros

     The difference between the reader functions ‘person-name’ and
     ‘astro-name’ is that ‘person-name’ can be correctly applied to any
     ‘person’, including an ‘astronaut’, while ‘astro-name’ can be
     correctly applied only to an ‘astronaut’.  An implementation might
     check for incorrect use of reader functions.

     At most one :include can be supplied in a single ‘defstruct’.  The
     argument to :include is required and must be the name of some
     previously defined structure.  If the structure being defined has
     no :type option, then the included structure must also have had no
     :type option supplied for it.  If the structure being defined has a
     :type option, then the included structure must have been declared
     with a :type option specifying the same representation type.

     If no :type option is involved, then the structure name of the
     including structure definition becomes the name of a data type, and
     therefore a valid type specifier recognizable by ‘typep’; it
     becomes a subtype of the included structure.  In the above example,
     ‘astronaut’ is a subtype of ‘person’; hence

           (typep (make-astronaut) 'person) → true

     indicating that all operations on persons also work on astronauts.

     The structure using :include can specify default values or
     slot-options for the included slots different from those the
     included structure specifies, by giving the :include option as:

           (:include INCLUDED-STRUCTURE-NAME {slot-description}*)

     Each SLOT-DESCRIPTION must have a SLOT-NAME that is the same as
     that of some slot in the included structure.  If a SLOT-DESCRIPTION
     has no SLOT-INITFORM, then in the new structure the slot has no
     initial value.  Otherwise its initial value form is replaced by the
     SLOT-INITFORM in the SLOT-DESCRIPTION.  A normally writable slot
     can be made read-only.  If a slot is read-only in the included
     structure, then it must also be so in the including structure.  If
     a type is supplied for a slot, it must be a subtype of the type
     specified in the included structure.

     For example, if the default age for an astronaut is ‘45’, then

           (defstruct (astronaut (:include person (age 45)))
              helmet-size
              (favorite-beverage 'tang))

     If :include is used with the :type option, then the effect is first
     to skip over as many representation elements as needed to represent
     the included structure, then to skip over any additional elements
     supplied by the :initial-offset option, and then to begin
     allocation of elements from that point.  For example:

           (defstruct (binop (:type list) :named (:initial-offset 2))
             (operator '? :type symbol)
             operand-1
             operand-2) → BINOP
           (defstruct (annotated-binop (:type list)
                                       (:initial-offset 3)
                                       (:include binop))
            commutative associative identity) → ANNOTATED-BINOP
           (make-annotated-binop :operator '*
                                 :operand-1 'x
                                 :operand-2 5
                                 :commutative t
                                 :associative t
                                 :identity 1)
             → (NIL NIL BINOP * X 5 NIL NIL NIL T T 1)

     The first two ‘nil’ elements stem from the :initial-offset of ‘2’
     in the definition of ‘binop’.  The next four elements contain the
     structure name and three slots for ‘binop’.  The next three
     ‘nil’ elements stem from the :initial-offset of ‘3’ in the
     definition of ‘annotated-binop’.  The last three list elements
     contain the additional slots for an ‘annotated-binop’.

:initial-offset

     :initial-offset instructs ‘defstruct’ to skip over a certain number
     of slots before it starts allocating the slots described in the
     body.  This option’s argument is the number of slots ‘defstruct’
     should skip.  :initial-offset can be used only if :type is also
     supplied.

     :initial-offset allows slots to be allocated beginning at a
     representational element other than the first.  For example, the
     form

           (defstruct (binop (:type list) (:initial-offset 2))
             (operator '? :type symbol)
             operand-1
             operand-2) → BINOP

     would result in the following behavior for ‘make-binop’:

           (make-binop :operator '+ :operand-1 'x :operand-2 5)
          → (NIL NIL + X 5)
           (make-binop :operand-2 4 :operator '*)
          → (NIL NIL * NIL 4)

     The selector functions ‘binop-operator’, ‘binop-operand-1’, and
     ‘binop-operand-2’ would be essentially equivalent to ‘third’,
     ‘fourth’, and ‘fifth’, respectively.  Similarly, the form

           (defstruct (binop (:type list) :named (:initial-offset 2))
             (operator '? :type symbol)
             operand-1
             operand-2) → BINOP

     would result in the following behavior for ‘make-binop’:

           (make-binop :operator '+ :operand-1 'x :operand-2 5) → (NIL NIL BINOP + X 5)
           (make-binop :operand-2 4 :operator '*) → (NIL NIL BINOP * NIL 4)

     The first two ‘nil’ elements stem from the :initial-offset of ‘2’
     in the definition of ‘binop’.  The next four elements contain the
     structure name and three slots for ‘binop’.

:named

     :named specifies that the structure is named.  If no :type is
     supplied, then the structure is always named.

     For example:

           (defstruct (binop (:type list))
             (operator '? :type symbol)
             operand-1
             operand-2) → BINOP

     This defines a constructor function ‘make-binop’ and three selector
     functions, namely ‘binop-operator’, ‘binop-operand-1’, and
     ‘binop-operand-2’.  (It does not, however, define a predicate
     ‘binop-p’, for reasons explained below.)

     The effect of ‘make-binop’ is simply to construct a list of length
     three:

           (make-binop :operator '+ :operand-1 'x :operand-2 5) → (+ X 5)
           (make-binop :operand-2 4 :operator '*) → (* NIL 4)

     It is just like the function ‘list’ except that it takes keyword
     arguments and performs slot defaulting appropriate to the ‘binop’
     conceptual data type.  Similarly, the selector functions
     ‘binop-operator’, ‘binop-operand-1’, and ‘binop-operand-2’ are
     essentially equivalent to ‘car’, ‘cadr’, and ‘caddr’, respectively.
     They might not be completely equivalent because, for example, an
     implementation would be justified in adding error-checking code to
     ensure that the argument to each selector function is a length-3
     list.

     ‘binop’ is a conceptual data type in that it is not made a part of
     the Common Lisp type system.  ‘typep’ does not recognize ‘binop’ as
     a type specifier, and ‘type-of’ returns ‘list’ when given a ‘binop’
     structure.  There is no way to distinguish a data structure
     constructed by ‘make-binop’ from any other list that happens to
     have the correct structure.

     There is not any way to recover the structure name ‘binop’ from a
     structure created by ‘make-binop’.  This can only be done if the
     structure is named.  A named structure has the property that, given
     an instance of the structure, the structure name (that names the
     type) can be reliably recovered.  For structures defined with no
     :type option, the structure name actually becomes part of the
     Common Lisp data-type system.  ‘type-of’, when applied to such a
     structure, returns the structure name as the type of the object;
     ‘typep’ recognizes the structure name as a valid type specifier.

     For structures defined with a :type option, ‘type-of’ returns a
     type specifier such as ‘list’ or ‘(vector t)’, depending on the
     type supplied to the :type option.  The structure name does not
     become a valid type specifier.  However, if the :named option is
     also supplied, then the first component of the structure (as
     created by a ‘defstruct’ constructor function) always contains the
     structure name.  This allows the structure name to be recovered
     from an instance of the structure and allows a reasonable predicate
     for the conceptual type to be defined: the automatically defined
     NAME-P predicate for the structure operates by first checking that
     its argument is of the proper type (‘list’, ‘(vector t)’, or
     whatever) and then checking whether the first component contains
     the appropriate type name.

     Consider the ‘binop’ example shown above, modified only to include
     the :named option:

           (defstruct (binop (:type list) :named)
             (operator '? :type symbol)
             operand-1
             operand-2) → BINOP

     As before, this defines a constructor function ‘make-binop’ and
     three selector functions ‘binop-operator’, ‘binop-operand-1’, and
     ‘binop-operand-2’.  It also defines a predicate ‘binop-p’.  The
     effect of ‘make-binop’ is now to construct a list of length four:

           (make-binop :operator '+ :operand-1 'x :operand-2 5) → (BINOP + X 5)
           (make-binop :operand-2 4 :operator '*) → (BINOP * NIL 4)

     The structure has the same layout as before except that the
     structure name ‘binop’ is included as the first list element.  The
     selector functions ‘binop-operator’, ‘binop-operand-1’, and
     ‘binop-operand-2’ are essentially equivalent to ‘cadr’, ‘caddr’,
     and ‘cadddr’, respectively.  The predicate ‘binop-p’ is more or
     less equivalent to this definition:

           (defun binop-p (x)
             (and (consp x) (eq (car x) 'binop))) → BINOP-P

     The name ‘binop’ is still not a valid type specifier recognizable
     to ‘typep’, but at least there is a way of distinguishing ‘binop’
     structures from other similarly defined structures.

:predicate

     This option takes one argument, which specifies the name of the
     type predicate.  If the argument is not supplied or if the option
     itself is not supplied, the name of the predicate is made by
     concatenating the name of the structure to the string ‘"-P"’,
     interning the name in whatever package is current at the time
     ‘defstruct’ is expanded.  If the argument is provided and is ‘nil’,
     no predicate is defined.  A predicate can be defined only if the
     structure is named; if :type is supplied and :named is not
     supplied, then :predicate must either be unsupplied or have the
     value ‘nil’.

:print-function, :print-object

     The :print-function and :print-object options specify that a
     ‘print-object’ method for structures of type STRUCTURE-NAME should
     be generated.  These options are not synonyms, but do perform a
     similar service; the choice of which option (:print-function or
     :print-object) is used affects how the function named PRINTER-NAME
     is called.  Only one of these options may be used, and these
     options may be used only if :type is not supplied.

     If the :print-function option is used, then when a structure of
     type STRUCTURE-NAME is to be printed, the designated printer
     function is called on three arguments:

        – the structure to be printed (a generalized instance of
          STRUCTURE-NAME).

        – a stream to print to.

        – an integer indicating the current depth.  The magnitude of
          this integer may vary between implementations; however, it can
          reliably be compared against ‘*print-level*’ to determine
          whether depth abbreviation is appropriate.

     Specifying ‘(:print-function PRINTER-NAME)’ is approximately
     equivalent to specifying:

           (defmethod print-object ((object STRUCTURE-NAME) stream)
             (funcall (function PRINTER-NAME) object stream «CURRENT-PRINT-DEPTH»))

     where the «CURRENT-PRINT-DEPTH» represents the printer’s belief of
     how deep it is currently printing.  It is implementation-dependent
     whether «CURRENT-PRINT-DEPTH» is always 0 and *PRINT-LEVEL*, if
     non-nil, is re-bound to successively smaller values as printing
     descends recursively, or whether CURRENT-PRINT-DEPTH varies in
     value as printing descends recursively and *PRINT-LEVEL* remains
     constant during the same traversal.

     If the :print-object option is used, then when a structure of type
     STRUCTURE-NAME is to be printed, the designated printer function is
     called on two arguments:

        – the structure to be printed.

        – the stream to print to.

     Specifying ‘(:print-object PRINTER-NAME)’ is equivalent to
     specifying:

           (defmethod print-object ((object STRUCTURE-NAME) stream)
             (funcall (function PRINTER-NAME) object stream))

     If no :type option is supplied, and if either a :print-function or
     a :print-object option is supplied, and if no PRINTER-NAME is
     supplied, then a ‘print-object’ method specialized for
     STRUCTURE-NAME is generated that calls a function that implements
     the default printing behavior for structures using ‘#S’ notation;
     see *note Section 22.1.3.12 (Printing Structures):
     PrintingStructures.

     If neither a :print-function nor a :print-object option is
     supplied, then ‘defstruct’ does not generate a ‘print-object’
     method specialized for STRUCTURE-NAME and some default behavior is
     inherited either from a structure named in an :include option or
     from the default behavior for printing structures; see the function
     *note print-object:: and *note Section 22.1.3.12 (Printing
     Structures): PrintingStructures.

     When ‘*print-circle*’ is true, a user-defined print function can
     print objects to the supplied stream using ‘write’, ‘prin1’,
     ‘princ’, or ‘format’ and expect circularities to be detected and
     printed using the ‘#n#’ syntax.  This applies to methods on
     ‘print-object’ in addition to :print-function options.  If a
     user-defined print function prints to a stream other than the one
     that was supplied, then circularity detection starts over for that
     stream.  See the variable *note *print-circle*::.

:type

     :type explicitly specifies the representation to be used for the
     structure.  Its argument must be one of these types:

     ‘vector’

          This produces the same result as specifying ‘(vector t)’.  The
          structure is represented as a general vector, storing
          components as vector elements.  The first component is vector
          element 1 if the structure is :named, and element 0 otherwise.

     ‘(vector ELEMENT-TYPE)’

          The structure is represented as a (possibly specialized)
          vector, storing components as vector elements.  Every
          component must be of a type that can be stored in a vector of
          the type specified.  The first component is vector element 1
          if the structure is :named, and element 0 otherwise.  The
          structure can be :named only if the type ‘symbol’ is a subtype
          of the supplied ELEMENT-TYPE.

     ‘list’

          The structure is represented as a list.  The first component
          is the cadr if the structure is :named, and the car if it is
          not :named.

     Specifying this option has the effect of forcing a specific
     representation and of forcing the components to be stored in the
     order specified in ‘defstruct’ in corresponding successive elements
     of the specified representation.  It also prevents the structure
     name from becoming a valid type specifier recognizable by ‘typep’.

     For example:

           (defstruct (quux (:type list) :named) x y)

     should make a constructor that builds a list exactly like the one
     that ‘list’ produces, with ‘quux’ as its car.

     If this type is defined:

           (deftype quux () '(satisfies quux-p))

     then this form

           (typep (make-quux) 'quux)

     should return precisely what this one does

           (typep (list 'quux nil nil) 'quux)

     If :type is not supplied, the structure is represented as an object
     of type ‘structure-object’.

     ‘defstruct’ without a :type option defines a class with the
     structure name as its name.  The metaclass of structure instances
     is ‘structure-class’.

The consequences of redefining a ‘defstruct’ structure are undefined.

In the case where no ‘defstruct’ options have been supplied, the
following functions are automatically defined to operate on instances of
the new structure:

Predicate

     A predicate with the name ‘STRUCTURE-NAME-p’ is defined to test
     membership in the structure type.  The predicate ‘(STRUCTURE-NAME-p
     OBJECT)’ is true if an OBJECT is of this type; otherwise it is
     false.  ‘typep’ can also be used with the name of the new type to
     test whether an object belongs to the type.  Such a function call
     has the form ‘(typep OBJECT 'STRUCTURE-NAME)’.

Component reader functions

     Reader functions are defined to read the components of the
     structure.  For each slot name, there is a corresponding reader
     function with the name ‘STRUCTURE-NAME-SLOT-NAME’.  This function
     reads the contents of that slot.  Each reader function takes one
     argument, which is an instance of the structure type.  ‘setf’ can
     be used with any of these reader functions to alter the slot
     contents.

Constructor function

     A constructor function with the name ‘make-STRUCTURE-NAME’ is
     defined.  This function creates and returns new instances of the
     structure type.

Copier function

     A copier function with the name ‘copy-STRUCTURE-NAME’ is defined.
     The copier function takes an object of the structure type and
     creates a new object of the same type that is a copy of the first.
     The copier function creates a new structure with the same component
     entries as the original.  Corresponding components of the two
     structure instances are ‘eql’.

If a ‘defstruct’ form appears as a top level form, the compiler must
make the structure type name recognized as a valid type name in
subsequent declarations (as for ‘deftype’) and make the structure slot
readers known to ‘setf’.  In addition, the compiler must save enough
information about the structure type so that further ‘defstruct’
definitions can use :include in a subsequent ‘deftype’ in the same file
to refer to the structure type name.  The functions which ‘defstruct’
generates are not defined in the compile time environment, although the
compiler may save enough information about the functions to code
subsequent calls inline.  The ‘#S’ reader macro might or might not
recognize the newly defined structure type name at compile time.

Examples:
.........

An example of a structure definition follows:

      (defstruct ship
        x-position
        y-position
        x-velocity
        y-velocity
        mass)

This declares that every ‘ship’ is an object with five named components.
The evaluation of this form does the following:

  1. It defines ‘ship-x-position’ to be a function of one argument, a
     ship, that returns the ‘x-position’ of the ship; ‘ship-y-position’
     and the other components are given similar function definitions.
     These functions are called the access functions, as they are used
     to access elements of the structure.

  2. ‘ship’ becomes the name of a type of which instances of ships are
     elements.  ‘ship’ becomes acceptable to ‘typep’, for example;
     ‘(typep x 'ship)’ is true if ‘x’ is a ship and false if ‘x’ is any
     object other than a ship.

  3. A function named ‘ship-p’ of one argument is defined; it is a
     predicate that is true if its argument is a ship and is false
     otherwise.

  4. A function called ‘make-ship’ is defined that, when invoked,
     creates a data structure with five components, suitable for use
     with the access functions.  Thus executing

           (setq ship2 (make-ship))

     sets ‘ship2’ to a newly created ‘ship’ object.  One can supply the
     initial values of any desired component in the call to ‘make-ship’
     by using keyword arguments in this way:

           (setq ship2 (make-ship :mass *default-ship-mass*
                                  :x-position 0
                                  :y-position 0))

     This constructs a new ship and initializes three of its components.
     This function is called the “constructor function” because it
     constructs a new structure.

  5. A function called ‘copy-ship’ of one argument is defined that, when
     given a ‘ship’ object, creates a new ‘ship’ object that is a copy
     of the given one.  This function is called the “copier function.”

‘setf’ can be used to alter the components of a ‘ship’:

      (setf (ship-x-position ship2) 100)

This alters the ‘x-position’ of ‘ship2’ to be ‘100’.  This works because
‘defstruct’ behaves as if it generates an appropriate ‘defsetf’ for each
access function.

     ;;;
     ;;; Example 1
     ;;; define town structure type
     ;;; area, watertowers, firetrucks, population, elevation are its components
     ;;;
      (defstruct town
                  area
                  watertowers
                  (firetrucks 1 :type fixnum)    ;an initialized slot
                  population
                  (elevation 5128 :read-only t)) ;a slot that can't be changed
     → TOWN
     ;create a town instance
      (setq town1 (make-town :area 0 :watertowers 0)) → #S(TOWN...)
     ;town's predicate recognizes the new instance
      (town-p town1) → true
     ;new town's area is as specified by make-town
      (town-area town1) → 0
     ;new town's elevation has initial value
      (town-elevation town1) → 5128
     ;setf recognizes reader function
      (setf (town-population town1) 99) → 99
      (town-population town1) → 99
     ;copier function makes a copy of town1
      (setq town2 (copy-town town1)) → #S(TOWN...)
      (= (town-population town1) (town-population town2))  → true
     ;since elevation is a read-only slot, its value can be set only
     ;when the structure is created
      (setq town3 (make-town :area 0 :watertowers 3 :elevation 1200))
     → #S(TOWN...)
     ;;;
     ;;; Example 2
     ;;; define clown structure type
     ;;; this structure uses a nonstandard prefix
     ;;;
      (defstruct (clown (:conc-name bozo-))
                  (nose-color 'red)
                  frizzy-hair-p polkadots) → CLOWN
      (setq funny-clown (make-clown)) → #S(CLOWN)
     ;use non-default reader name
      (bozo-nose-color funny-clown) → RED
      (defstruct (klown (:constructor make-up-klown) ;similar def using other
                  (:copier clone-klown)              ;customizing keywords
                  (:predicate is-a-bozo-p))
                  nose-color frizzy-hair-p polkadots) → klown
     ;custom constructor now exists
      (fboundp 'make-up-klown) → true
     ;;;
     ;;; Example 3
     ;;; define a vehicle structure type
     ;;; then define a truck structure type that includes
     ;;; the vehicle structure
     ;;;
      (defstruct vehicle name year (diesel t :read-only t)) → VEHICLE
      (defstruct (truck (:include vehicle (year 79)))
                  load-limit
                  (axles 6)) → TRUCK
      (setq x (make-truck :name 'mac :diesel t :load-limit 17))
     → #S(TRUCK...)
     ;vehicle readers work on trucks
      (vehicle-name x)
     → MAC
     ;default taken from :include clause
      (vehicle-year x)
     → 79
      (defstruct (pickup (:include truck))     ;pickup type includes truck
                  camper long-bed four-wheel-drive) → PICKUP
      (setq x (make-pickup :name 'king :long-bed t)) → #S(PICKUP...)
     ;:include default inherited
      (pickup-year x) → 79
     ;;;
     ;;; Example 4
     ;;; use of BOA constructors
     ;;;
      (defstruct (dfs-boa                      ;BOA constructors
                    (:constructor make-dfs-boa (a b c))
                    (:constructor create-dfs-boa
                      (a &optional b (c 'cc) &rest d &aux e (f 'ff))))
                  a b c d e f) → DFS-BOA
     ;a, b, and c set by position, and the rest are uninitialized
      (setq x (make-dfs-boa 1 2 3)) → #(DFS-BOA...)
      (dfs-boa-a x) → 1
     ;a and b set, c and f defaulted
      (setq x (create-dfs-boa 1 2)) → #(DFS-BOA...)
      (dfs-boa-b x) → 2
      (eq (dfs-boa-c x) 'cc) → true
     ;a, b, and c set, and the rest are collected into d
      (setq x (create-dfs-boa 1 2 3 4 5 6)) → #(DFS-BOA...)
      (dfs-boa-d x) → (4 5 6)

Exceptional Situations:
.......................

If any two slot names (whether present directly or inherited by the
:include option) are the same under ‘string=’, ‘defstruct’ should signal
an error of type ‘program-error’.

The consequences are undefined if the INCLUDED-STRUCTURE-NAME does not
name a structure type.

See Also:
.........

*note documentation::, *note print-object::, *note setf::, *note
subtypep::, *note type-of::, *note typep::, *note Section 3.2
(Compilation): Compilation.

Notes:
......

The PRINTER-NAME should observe the values of such printer-control
variables as ‘*print-escape*’.

The restriction against issuing a warning for type mismatches between a
SLOT-INITFORM and the corresponding slot’s :type option is necessary
because a SLOT-INITFORM must be specified in order to specify slot
options; in some cases, no suitable default may exist.

The mechanism by which ‘defstruct’ arranges for slot accessors to be
usable with ‘setf’ is implementation-dependent; for example, it may use
setf functions, setf expanders, or some other implementation-dependent
mechanism known to that implementation’s code for ‘setf’.


File: ansicl,  Node: copy-structure,  Prev: defstruct,  Up: Structures

copy-structure (Function)
=========================

Syntax:
.......

 -- Function: copy-structure structure → copy

Arguments and Values:
.....................

STRUCTURE—a structure.

COPY—a copy of the STRUCTURE.

Description:
............

Returns a copy

Only the STRUCTURE itself is copied; not the values of the slots.

See Also:
.........

the :copier option to *note defstruct::

Notes:
......

The COPY is the same as the given STRUCTURE under ‘equalp’, but not
under ‘equal’.


File: ansicl,  Node: Conditions,  Next: Symbols,  Prev: Structures,  Up: Top

9 Conditions
************

* Menu:

* Condition System Concepts::

Dictionary

* condition::
* warning::
* style-warning::
* serious-condition::
* error (Condition Type)::
* cell-error::
* cell-error-name::
* parse-error::
* storage-condition::
* assert::
* error (Function)::
* cerror::
* check-type::
* simple-error::
* invalid-method-error::
* method-combination-error::
* signal::
* simple-condition::
* simple-condition-format-control; simple-condition-format-arguments::
* warn::
* simple-warning::
* invoke-debugger::
* break::
* *debugger-hook*::
* *break-on-signals*::
* handler-bind::
* handler-case::
* ignore-errors::
* define-condition::
* make-condition::
* restart::
* compute-restarts::
* find-restart::
* invoke-restart::
* invoke-restart-interactively::
* restart-bind::
* restart-case::
* restart-name::
* with-condition-restarts::
* with-simple-restart::
* abort (Restart)::
* continue (Restart)::
* muffle-warning (Restart)::
* store-value (Restart)::
* use-value (Restart)::
* abort; continue; muffle-warning; store-value; use-value::


File: ansicl,  Node: Condition System Concepts,  Next: condition,  Up: Conditions

9.1 Condition System Concepts
=============================

Common Lisp constructs are described not only in terms of their behavior
in situations during which they are intended to be used (see the
“Description” part of each operator specification), but in all other
situations (see the “Exceptional Situations” part of each operator
specification).

A situation is the evaluation of an expression in a specific context.  A
condition is an object that represents a specific situation that has
been detected.  Conditions are generalized instances of the class
‘condition’.  A hierarchy of condition classes is defined in Common
Lisp.  A condition has slots that contain data relevant to the situation
that the condition represents.

An error is a situation in which normal program execution cannot
continue correctly without some form of intervention (either
interactively by the user or under program control).  Not all errors are
detected.  When an error goes undetected, the effects can be
implementation-dependent, implementation-defined, unspecified, or
undefined.  See *note Section 1.4 (Definitions): Definitions.  All
detected errors can be represented by conditions, but not all conditions
represent errors.

Signaling is the process by which a condition can alter the flow of
control in a program by raising the condition which can then be handled.
The functions ‘error’, ‘cerror’, ‘signal’, and ‘warn’ are used to signal
conditions.

The process of signaling involves the selection and invocation of a
handler from a set of active handlers.  A handler is a function of one
argument (the condition) that is invoked to handle a condition.  Each
handler is associated with a condition type, and a handler will be
invoked only on a condition of the handler’s associated type.

Active handlers are established dynamically (see ‘handler-bind’ or
‘handler-case’).  Handlers are invoked in a dynamic environment
equivalent to that of the signaler, except that the set of active
handlers is bound in such a way as to include only those that were
active at the time the handler being invoked was established.  Signaling
a condition has no side-effect on the condition, and there is no dynamic
state contained in a condition.

If a handler is invoked, it can address the situation in one of three
ways:

Decline

     It can decline to handle the condition.  It does this by simply
     returning rather than transferring control.  When this happens, any
     values returned by the handler are ignored and the next most
     recently established handler is invoked.  If there is no such
     handler and the signaling function is ‘error’ or ‘cerror’, the
     debugger is entered in the dynamic environment of the signaler.  If
     there is no such handler and the signaling function is either
     ‘signal’ or ‘warn’, the signaling function simply returns ‘nil’.

Handle

     It can handle the condition by performing a non-local transfer of
     control.  This can be done either primitively by using ‘go’,
     ‘return’, ‘throw’ or more abstractly by using a function such as
     ‘abort’ or ‘invoke-restart’.

Defer

     It can put off a decision about whether to handle or decline, by
     any of a number of actions, but most commonly by signaling another
     condition, resignaling the same condition, or forcing entry into
     the debugger.

* Menu:

* Condition Types::
* Creating Conditions::
* Printing Conditions::
* Signaling and Handling Conditions::
* Assertions::
* Notes about the Condition System's Background::


File: ansicl,  Node: Condition Types,  Next: Creating Conditions,  Up: Condition System Concepts

9.1.1 Condition Types
---------------------

The next figure lists the standardized condition types.  Additional
condition types can be defined by using ‘define-condition’.

arithmetic-error                   floating-point-overflow    simple-type-error
cell-error                         floating-point-underflow   simple-warning
condition                          package-error              storage-condition
control-error                      parse-error                stream-error
division-by-zero                   print-not-readable         style-warning
end-of-file                        program-error              type-error
error                              reader-error               unbound-slot
file-error                         serious-condition          unbound-variable
floating-point-inexact             simple-condition           undefined-function
floating-point-invalid-operation   simple-error               warning

Figure 9.1: Standardized Condition Types

All condition types are subtypes of type ‘condition’.  That is,

      (typep C 'condition) → true

if and only if C is a condition.

Implementations must define all specified subtype relationships.  Except
where noted, all subtype relationships indicated in this document are
not mutually exclusive.  A condition inherits the structure of its
supertypes.

The metaclass of the class ‘condition’ is not specified.  Names of
condition types may be used to specify supertype relationships in
‘define-condition’, but the consequences are not specified if an attempt
is made to use a condition type as a superclass in a ‘defclass’ form.

The next figure shows operators that define condition types and creating
conditions.

define-condition   make-condition

Figure 9.2: Operators that define and create conditions.

The next figure shows operators that read the value of condition slots.

arithmetic-error-operands    simple-condition-format-arguments
arithmetic-error-operation   simple-condition-format-control
cell-error-name              stream-error-stream
file-error-pathname          type-error-datum
package-error-package        type-error-expected-type
print-not-readable-object    unbound-slot-instance

Figure 9.3: Operators that read condition slots.

9.1.1.1 Serious Conditions
..........................

A serious condition is a condition serious enough to require interactive
intervention if not handled.  Serious conditions are typically signaled
with ‘error’ or ‘cerror’; non-serious conditions are typically signaled
with ‘signal’ or ‘warn’.


File: ansicl,  Node: Creating Conditions,  Next: Printing Conditions,  Prev: Condition Types,  Up: Condition System Concepts

9.1.2 Creating Conditions
-------------------------

The function ‘make-condition’ can be used to construct a condition
object explicitly.  Functions such as ‘error’, ‘cerror’, ‘signal’, and
‘warn’ operate on conditions and might create condition objects
implicitly.  Macros such as ‘ccase’, ‘ctypecase’, ‘ecase’, ‘etypecase’,
‘check-type’, and ‘assert’ might also implicitly create (and signal)
conditions.

9.1.2.1 Condition Designators
.............................

A number of the functions in the condition system take arguments which
are identified as “condition designators”.  By convention, those
arguments are notated as

 DATUM &rest ARGUMENTS

Taken together, the DATUM and the ARGUMENTS are “designators for a
condition of default type DEFAULT-TYPE.” How the denoted condition is
computed depends on the type of the DATUM:

   • If the DATUM is a symbol naming a condition type ...

     The denoted condition is the result of

           (apply #'make-condition DATUM ARGUMENTS)

   • If the DATUM is a format control ...

     The denoted condition is the result of

           (make-condition DEFAULTED-TYPE
                           :format-control DATUM
                           :format-arguments ARGUMENTS)

     where the DEFAULTED-TYPE is a subtype of DEFAULT-TYPE.

   • If the DATUM is a condition ...

     The denoted condition is the DATUM itself.  In this case, unless
     otherwise specified by the description of the operator in question,
     the arguments must be null; that is, the consequences are undefined
     if any ARGUMENTS were supplied.

Note that the DEFAULT-TYPE gets used only in the case where the DATUM
string is supplied.  In the other situations, the resulting condition is
not necessarily of type DEFAULT-TYPE.

Here are some illustrations of how different condition designators can
denote equivalent condition objects:

     (let ((c (make-condition 'arithmetic-error :operator '/ :operands '(7 0))))
       (error c))
     ≡ (error 'arithmetic-error :operator '/ :operands '(7 0))

     (error "Bad luck.")
     ≡ (error 'simple-error :format-control "Bad luck." :format-arguments '())


File: ansicl,  Node: Printing Conditions,  Next: Signaling and Handling Conditions,  Prev: Creating Conditions,  Up: Condition System Concepts

9.1.3 Printing Conditions
-------------------------

If the :report argument to ‘define-condition’ is used, a print function
is defined that is called whenever the defined condition is printed
while the value of ‘*print-escape*’ is false.  This function is called
the “condition reporter”; the text which it outputs is called a “report
message”.

When a condition is printed and ‘*print-escape*’ is false, the condition
reporter for the condition is invoked.  Conditions are printed
automatically by functions such as ‘invoke-debugger’, ‘break’, and
‘warn’.

When ‘*print-escape*’ is true, the object should print in an abbreviated
fashion according to the style of the implementation (e.g., by
‘print-unreadable-object’).  It is not required that a condition can be
recreated by reading its printed representation.

No function is provided for directly accessing or invoking condition
reporters.

9.1.3.1 Recommended Style in Condition Reporting
................................................

In order to ensure a properly aesthetic result when presenting report
messages to the user, certain stylistic conventions are recommended.

There are stylistic recommendations for the content of the messages
output by condition reporters, but there are no formal requirements on
those programs.  If a program violates the recommendations for some
message, the display of that message might be less aesthetic than if the
guideline had been observed, but the program is still considered a
conforming program.

The requirements on a program or implementation which invokes a
condition reporter are somewhat stronger.  A conforming program must be
permitted to assume that if these style guidelines are followed, proper
aesthetics will be maintained.  Where appropriate, any specific
requirements on such routines are explicitly mentioned below.

9.1.3.1.1 Capitalization and Punctuation in Condition Reports
.............................................................

It is recommended that a report message be a complete sentences, in the
proper case and correctly punctuated.  In English, for example, this
means the first letter should be uppercase, and there should be a
trailing period.

      (error "This is a message")  ; Not recommended
      (error "this is a message.") ; Not recommended

      (error "This is a message.") ; Recommended instead

9.1.3.1.2 Leading and Trailing Newlines in Condition Reports
............................................................

It is recommended that a report message not begin with any introductory
text, such as “‘Error: ’” or “‘Warning: ’” or even just freshline or
newline.  Such text is added, if appropriate to the context, by the
routine invoking the condition reporter.

It is recommended that a report message not be followed by a trailing
freshline or newline.  Such text is added, if appropriate to the
context, by the routine invoking the condition reporter.

      (error "This is a message.~%")   ; Not recommended
      (error "~&This is a message.")   ; Not recommended
      (error "~&This is a message.~%") ; Not recommended

      (error "This is a message.")     ; Recommended instead

9.1.3.1.3 Embedded Newlines in Condition Reports
................................................

Especially if it is long, it is permissible and appropriate for a report
message to contain one or more embedded newlines.

If the calling routine conventionally inserts some additional prefix
(such as “‘Error: ’” or “‘;; Error: ’”) on the first line of the
message, it must also assure that an appropriate prefix will be added to
each subsequent line of the output, so that the left edge of the message
output by the condition reporter will still be properly aligned.

      (defun test ()
        (error "This is an error message.~%It has two lines."))

      ;; Implementation A
      (test)
      This is an error message.
      It has two lines.

      ;; Implementation B
      (test)
      ;; Error: This is an error message.
      ;;        It has two lines.

      ;; Implementation C
      (test)
      >> Error: This is an error message.
                It has two lines.

9.1.3.1.4 Note about Tabs in Condition Reports
..............................................

Because the indentation of a report message might be shifted to the
right or left by an arbitrary amount, special care should be taken with
the semi-standard character <Tab>  (in those implementations that
support such a character).  Unless the implementation specifically
defines its behavior in this context, its use should be avoided.

9.1.3.1.5 Mentioning Containing Function in Condition Reports
.............................................................

The name of the containing function should generally not be mentioned in
report messages.  It is assumed that the debugger will make this
information accessible in situations where it is necessary and
appropriate.


File: ansicl,  Node: Signaling and Handling Conditions,  Next: Assertions,  Prev: Printing Conditions,  Up: Condition System Concepts

9.1.4 Signaling and Handling Conditions
---------------------------------------

The operation of the condition system depends on the ordering of active
applicable handlers from most recent to least recent.

Each handler is associated with a type specifier that must designate a
subtype of type ‘condition’.  A handler is said to be applicable to a
condition if that condition is of the type designated by the associated
type specifier.

Active handlers are established by using ‘handler-bind’ (or an
abstraction based on ‘handler-bind’, such as ‘handler-case’ or
‘ignore-errors’).

Active handlers can be established within the dynamic scope of other
active handlers.  At any point during program execution, there is a set
of active handlers.  When a condition is signaled, the most recent
active applicable handler for that condition is selected from this set.
Given a condition, the order of recentness of active applicable handlers
is defined by the following two rules:

  1. Each handler in a set of active handlers Hmore recent than every
     handler in a set Hhandlers in Hestablished.

  2. Let hhandlers established by the same form.  Then hmore recent than
     hh

Once a handler in a handler binding form (such as ‘handler-bind’ or
‘handler-case’) has been selected, all handlers in that form become
inactive for the remainder of the signaling process.  While the selected
handler runs, no other handler established by that form is active.  That
is, if the handler declines, no other handler established by that form
will be considered for possible invocation.

The next figure shows operators relating to the handling of conditions.

handler-bind   handler-case   ignore-errors

Figure 9.4: Operators relating to handling conditions.

9.1.4.1 Signaling
.................

When a condition is signaled, the most recent applicable active handler
is invoked.  Sometimes a handler will decline by simply returning
without a transfer of control.  In such cases, the next most recent
applicable active handler is invoked.

If there are no applicable handlers for a condition that has been
signaled, or if all applicable handlers decline, the condition is
unhandled.

The functions ‘cerror’ and ‘error’ invoke the interactive condition
handler (the debugger) rather than return if the condition being
signaled, regardless of its type, is unhandled.  In contrast, ‘signal’
returns ‘nil’ if the condition being signaled, regardless of its type,
is unhandled.

The variable ‘*break-on-signals*’ can be used to cause the debugger to
be entered before the signaling process begins.

The next figure shows defined names relating to the signaling of
conditions.

*break-on-signals*   error    warn
cerror               signal

Figure 9.5: Defined names relating to signaling conditions.

9.1.4.1.1 Resignaling a Condition
.................................

During the dynamic extent of the signaling process for a particular
condition object, ‘signaling’ the same condition object again is
permitted if and only if the situation represented in both cases are the
same.

For example, a handler might legitimately signal the condition object
that is its argument in order to allow outer handlers first opportunity
to handle the condition.  (Such a handlers is sometimes called a
“default handler.”) This action is permitted because the situation which
the second signaling process is addressing is really the same situation.

On the other hand, in an implementation that implemented asynchronous
keyboard events by interrupting the user process with a call to
‘signal’, it would not be permissible for two distinct asynchronous
keyboard events to signal identical condition objects at the same time
for different situations.

9.1.4.2 Restarts
................

The interactive condition handler returns only through non-local
transfer of control to specially defined restarts that can be set up
either by the system or by user code.  Transferring control to a restart
is called “invoking” the restart.  Like handlers, active restarts are
established dynamically, and only active restarts can be invoked.  An
active restart can be invoked by the user from the debugger or by a
program by using ‘invoke-restart’.

A restart contains a function to be called when the restart is invoked,
an optional name that can be used to find or invoke the restart, and an
optional set of interaction information for the debugger to use to
enable the user to manually invoke a restart.

The name of a restart is used by ‘invoke-restart’.  Restarts that can be
invoked only within the debugger do not need names.

Restarts can be established by using ‘restart-bind’, ‘restart-case’, and
‘with-simple-restart’.  A restart function can itself invoke any other
restart that was active at the time of establishment of the restart of
which the function is part.

The restarts established by a ‘restart-bind’ form, a ‘restart-case’
form, or a ‘with-simple-restart’ form have dynamic extent which extends
for the duration of that form’s execution.

Restarts of the same name can be ordered from least recent to most
recent according to the following two rules:

  1. Each restart in a set of active restarts Rset Rin Restablished.

  2. Let rthe same name established by the same form.  Then rmore recent
     than rleft of r

If a restart is invoked but does not transfer control, the values
resulting from the restart function are returned by the function that
invoked the restart, either ‘invoke-restart’ or
‘invoke-restart-interactively’.

9.1.4.2.1 Interactive Use of Restarts
.....................................

For interactive handling, two pieces of information are needed from a
restart: a report function and an interactive function.

The report function is used by a program such as the debugger to present
a description of the action the restart will take.  The report function
is specified and established by the :report-function keyword to
‘restart-bind’ or the :report keyword to ‘restart-case’.

The interactive function, which can be specified using the
:interactive-function keyword to ‘restart-bind’ or :interactive keyword
to ‘restart-case’, is used when the restart is invoked interactively,
such as from the debugger, to produce a suitable list of arguments.

‘invoke-restart’ invokes the most recently established restart whose
name is the same as the first argument to ‘invoke-restart’.  If a
restart is invoked interactively by the debugger and does not transfer
control but rather returns values, the precise action of the debugger on
those values is implementation-defined.

9.1.4.2.2 Interfaces to Restarts
................................

Some restarts have functional interfaces, such as ‘abort’, ‘continue’,
‘muffle-warning’, ‘store-value’, and ‘use-value’.  They are ordinary
functions that use ‘find-restart’ and ‘invoke-restart’ internally, that
have the same name as the restarts they manipulate, and that are
provided simply for notational convenience.

The next figure shows defined names relating to restarts.

abort              invoke-restart-interactively   store-value
compute-restarts   muffle-warning                 use-value
continue           restart-bind                   with-simple-restart
find-restart       restart-case
invoke-restart     restart-name

Figure 9.6: Defined names relating to restarts.

9.1.4.2.3 Restart Tests
.......................

Each restart has an associated test, which is a function of one argument
(a condition or ‘nil’) which returns true if the restart should be
visible in the current situation.  This test is created by the
:test-function option to ‘restart-bind’ or the :test option to
‘restart-case’.

9.1.4.2.4 Associating a Restart with a Condition
................................................

A restart can be “associated with” a condition explicitly by
‘with-condition-restarts’, or implicitly by ‘restart-case’.  Such an
assocation has dynamic extent.

A single restart may be associated with several conditions at the same
time.  A single condition may have several associated restarts at the
same time.

Active restarts associated with a particular condition can be detected
by calling a function such as ‘find-restart’, supplying that condition
as the CONDITION argument.  Active restarts can also be detected without
regard to any associated condition by calling such a function without a
CONDITION argument, or by supplying a value of ‘nil’ for such an
argument.


File: ansicl,  Node: Assertions,  Next: Notes about the Condition System's Background,  Prev: Signaling and Handling Conditions,  Up: Condition System Concepts

9.1.5 Assertions
----------------

Conditional signaling of conditions based on such things as key match,
form evaluation, and type are handled by assertion operators.  The next
figure shows operators relating to assertions.

assert   check-type   ecase
ccase    ctypecase    etypecase

Figure 9.7: Operators relating to assertions.


File: ansicl,  Node: Notes about the Condition System's Background,  Prev: Assertions,  Up: Condition System Concepts

9.1.6 Notes about the Condition System’s Background
---------------------------------------------------

For a background reference to the abstract concepts detailed in this
section, see ‘Exceptional Situations in Lisp’.  The details of that
paper are not binding on this document, but may be helpful in
establishing a conceptual basis for understanding this material.


File: ansicl,  Node: condition,  Next: warning,  Prev: Condition System Concepts,  Up: Conditions

condition (Condition Type)
==========================

Class Precedence List:
......................

‘condition’, ‘t’

Description:
............

All types of conditions, whether error or non-error, must inherit from
this type.

No additional subtype relationships among the specified subtypes of type
‘condition’ are allowed, except when explicitly mentioned in the text;
however implementations are permitted to introduce additional types and
one of these types can be a subtype of any number of the subtypes of
type ‘condition’.

Whether a user-defined condition type has slots that are accessible by
with-slots is implementation-dependent.  Furthermore, even in an
implementation in which user-defined condition types would have slots,
it is implementation-dependent whether any condition types defined in
this document have such slots or, if they do, what their names might be;
only the reader functions documented by this specification may be relied
upon by portable code.

Conforming code must observe the following restrictions related to
conditions:

   • ‘define-condition’, not ‘defclass’, must be used to define new
     condition types.

   • ‘make-condition’, not ‘make-instance’, must be used to create
     condition objects explicitly.

   • The :report option of ‘define-condition’, not ‘defmethod’ for
     ‘print-object’, must be used to define a condition reporter.

   • ‘slot-value’, ‘slot-boundp’, ‘slot-makunbound’, and ‘with-slots’
     must not be used on condition objects.  Instead, the appropriate
     accessor functions (defined by ‘define-condition’) should be used.


File: ansicl,  Node: warning,  Next: style-warning,  Prev: condition,  Up: Conditions

warning (Condition Type)
========================

Class Precedence List:
......................

‘warning’, ‘condition’, ‘t’

Description:
............

The type ‘warning’ consists of all types of warnings.

See Also:
.........

*note style-warning::


File: ansicl,  Node: style-warning,  Next: serious-condition,  Prev: warning,  Up: Conditions

style-warning (Condition Type)
==============================

Class Precedence List:
......................

‘style-warning’, ‘warning’, ‘condition’, ‘t’

Description:
............

The type ‘style-warning’ includes those conditions that represent
situations involving code that is conforming code but that is
nevertheless considered to be faulty or substandard.

See Also:
.........

*note muffle-warning::

Notes:
......

An implementation might signal such a condition if it encounters code
that uses deprecated features or that appears unaesthetic or
inefficient.

An ‘unused variable’ warning must be of type ‘style-warning’.

In general, the question of whether code is faulty or substandard is a
subjective decision to be made by the facility processing that code.
The intent is that whenever such a facility wishes to complain about
code on such subjective grounds, it should use this condition type so
that any clients who wish to redirect or muffle superfluous warnings can
do so without risking that they will be redirecting or muffling other,
more serious warnings.


File: ansicl,  Node: serious-condition,  Next: error (Condition Type),  Prev: style-warning,  Up: Conditions

serious-condition (Condition Type)
==================================

Class Precedence List:
......................

‘serious-condition’, ‘condition’, ‘t’

Description:
............

All conditions serious enough to require interactive intervention if not
handled should inherit from the type ‘serious-condition’.  This
condition type is provided primarily so that it may be included as a
superclass of other condition types; it is not intended to be signaled
directly.

Notes:
......

Signaling a serious condition does not itself force entry into the
debugger.  However, except in the unusual situation where the programmer
can assure that no harm will come from failing to handle a serious
condition, such a condition is usually signaled with ‘error’ rather than
‘signal’ in order to assure that the program does not continue without
handling the condition.  (And conversely, it is conventional to use
‘signal’ rather than ‘error’ to signal conditions which are not serious
conditions, since normally the failure to handle a non-serious condition
is not reason enough for the debugger to be entered.)


File: ansicl,  Node: error (Condition Type),  Next: cell-error,  Prev: serious-condition,  Up: Conditions

error (Condition Type)
======================

Class Precedence List:
......................

‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘error’ consists of all conditions that represent errors.


File: ansicl,  Node: cell-error,  Next: cell-error-name,  Prev: error (Condition Type),  Up: Conditions

cell-error (Condition Type)
===========================

Class Precedence List:
......................

‘cell-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘cell-error’ consists of error conditions that occur during a
location access.  The name of the offending cell is initialized by the
:name initialization argument to ‘make-condition’, and is accessed by
the function ‘cell-error-name’.

See Also:
.........

*note cell-error-name::


File: ansicl,  Node: cell-error-name,  Next: parse-error,  Prev: cell-error,  Up: Conditions

cell-error-name (Function)
==========================

Syntax:
.......

 -- Function: cell-error-name condition → name

Arguments and Values:
.....................

CONDITION—a condition of type ‘cell-error’.

NAME—an object.

Description:
............

Returns the name of the offending cell involved in the situation
represented by CONDITION.

The nature of the result depends on the specific type of CONDITION.  For
example, if the CONDITION is of type ‘unbound-variable’, the result is
the name of the unbound variable which was being accessed, if the
CONDITION is of type ‘undefined-function’, this is the name of the
undefined function which was being accessed, and if the CONDITION is of
type ‘unbound-slot’, this is the name of the slot which was being
accessed.

See Also:
.........

*note cell-error::, *note unbound-slot::, *note unbound-variable::,
*note undefined-function::, *note Section 9.1 (Condition System
Concepts): Condition System Concepts.


File: ansicl,  Node: parse-error,  Next: storage-condition,  Prev: cell-error-name,  Up: Conditions

parse-error (Condition Type)
============================

Class Precedence List:
......................

‘parse-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘parse-error’ consists of error conditions that are related to
parsing.

See Also:
.........

*note parse-namestring::, *note reader-error::


File: ansicl,  Node: storage-condition,  Next: assert,  Prev: parse-error,  Up: Conditions

storage-condition (Condition Type)
==================================

Class Precedence List:
......................

‘storage-condition’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘storage-condition’ consists of serious conditions that relate
to problems with memory management that are potentially due to
implementation-dependent limits rather than semantic errors in
conforming programs, and that typically warrant entry to the debugger if
not handled.  Depending on the details of the implementation, these
might include such problems as stack overflow, memory region overflow,
and storage exhausted.

Notes:
......

While some Common Lisp operations might signal storage-condition because
they are defined to create objects, it is unspecified whether operations
that are not defined to create objects create them anyway and so might
also signal ‘storage-condition’.  Likewise, the evaluator itself might
create objects and so might signal ‘storage-condition’.  (The natural
assumption might be that such object creation is naturally inefficient,
but even that is implementation-dependent.)  In general, the entire
question of how storage allocation is done is implementation-dependent,
and so any operation might signal ‘storage-condition’ at any time.
Because such a condition is indicative of a limitation of the
implementation or of the image rather than an error in a program,
objects of type ‘storage-condition’ are not of type ‘error’.


File: ansicl,  Node: assert,  Next: error (Function),  Prev: storage-condition,  Up: Conditions

assert (Macro)
==============

Syntax:
.......

 -- Macro: assert test-form [({place}*) [datum-form {argument-form}*]] →
          ‘nil’

Arguments and Values:
.....................

TEST-FORM—a form; always evaluated.

PLACE—a place; evaluated if an error is signaled.

DATUM-FORM—a form that evaluates to a DATUM.  Evaluated each time an
error is to be signaled, or not at all if no error is to be signaled.

ARGUMENT-FORM—a form that evaluates to an ARGUMENT.  Evaluated each time
an error is to be signaled, or not at all if no error is to be signaled.

DATUM, ARGUMENTS—designators for a condition of default type ‘error’.
(These designators are the result of evaluating DATUM-FORM and each of
the ARGUMENT-FORMS.)

Description:
............

‘assert’ assures that TEST-FORM evaluates to true.  If TEST-FORM
evaluates to false, ‘assert’ signals a correctable error (denoted by
DATUM and ARGUMENTS).  Continuing from this error using the ‘continue’
restart makes it possible for the user to alter the values of the PLACES
before ‘assert’ evaluates TEST-FORM again.  If the value of TEST-FORM is
non-nil, ‘assert’ returns ‘nil’.

The PLACES are generalized references to data upon which TEST-FORM
depends, whose values can be changed by the user in attempting to
correct the error.  Subforms of each PLACE are only evaluated if an
error is signaled, and might be re-evaluated if the error is re-signaled
(after continuing without actually fixing the problem).  The order of
evaluation of the PLACES is not specified; see *note Section 5.1.1.1
(Evaluation of Subforms to Places): GenRefSubFormEval.  If a PLACE form
is supplied that produces more values than there are store variables,
the extra values are ignored.  If the supplied form produces fewer
values than there are store variables, the missing values are set to
‘nil’.

Examples:
.........

      (setq x (make-array '(3 5) :initial-element 3))
     → #2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3))
      (setq y (make-array '(3 5) :initial-element 7))
     → #2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7))
      (defun matrix-multiply (a b)
        (let ((*print-array* nil))
          (assert (and (= (array-rank a) (array-rank b) 2)
                       (= (array-dimension a 1) (array-dimension b 0)))
                  (a b)
                  "Cannot multiply ~S by ~S." a b)
                 (really-matrix-multiply a b))) → MATRIX-MULTIPLY
      (matrix-multiply x y)
     ▷ Correctable error in MATRIX-MULTIPLY:
     ▷ Cannot multiply #<ARRAY ...> by #<ARRAY ...>.
     ▷ Restart options:
     ▷  1: You will be prompted for one or more new values.
     ▷  2: Top level.
     ▷ Debug> :continue 1
     ▷ Value for A: x
     ▷ Value for B: (make-array '(5 3) :initial-element 6)
     → #2A((54 54 54 54 54)
            (54 54 54 54 54)
            (54 54 54 54 54)
            (54 54 54 54 54)
            (54 54 54 54 54))

      (defun double-safely (x) (assert (numberp x) (x)) (+ x x))
      (double-safely 4)
     → 8

      (double-safely t)
     ▷ Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL.
     ▷ Restart options:
     ▷  1: You will be prompted for one or more new values.
     ▷  2: Top level.
     ▷ Debug> :continue 1
     ▷ Value for X: 7
     → 14

Affected By:
............

‘*break-on-signals*’

The set of active condition handlers.

See Also:
.........

*note check-type::, *note error (Function)::, *note Section 5.1
(Generalized Reference): Generalized Reference.

Notes:
......

The debugger need not include the TEST-FORM in the error message, and
the PLACES should not be included in the message, but they should be
made available for the user’s perusal.  If the user gives the “continue”
command, the values of any of the references can be altered.  The
details of this depend on the implementation’s style of user interface.


File: ansicl,  Node: error (Function),  Next: cerror,  Prev: assert,  Up: Conditions

error (Function)
================

Syntax:
.......

 -- Function: error datum &rest arguments →|

Arguments and Values:
.....................

DATUM, ARGUMENTS—designators for a condition of default type
‘simple-error’.

Description:
............

‘error’ effectively invokes ‘signal’ on the denoted condition.

If the condition is not handled, ‘(invoke-debugger condition)’ is done.
As a consequence of calling ‘invoke-debugger’, ‘error’ cannot directly
return; the only exit from ‘error’ can come by non-local transfer of
control in a handler or by use of an interactive debugging command.

Examples:
.........

      (defun factorial (x)
        (cond ((or (not (typep x 'integer)) (minusp x))
               (error "~S is not a valid argument to FACTORIAL." x))
              ((zerop x) 1)
              (t (* x (factorial (- x 1))))))
     → FACTORIAL
     (factorial 20)
     → 2432902008176640000
     (factorial -1)
     ▷ Error: -1 is not a valid argument to FACTORIAL.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Return to Lisp Toplevel.
     ▷ Debug>

      (setq a 'fred)
     → FRED
      (if (numberp a) (1+ a) (error "~S is not a number." A))
     ▷ Error: FRED is not a number.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Return to Lisp Toplevel.
     ▷ Debug> :Continue 1
     ▷ Return to Lisp Toplevel.

      (define-condition not-a-number (error)
                        ((argument :reader not-a-number-argument :initarg :argument))
        (:report (lambda (condition stream)
                   (format stream "~S is not a number."
                           (not-a-number-argument condition)))))
     → NOT-A-NUMBER

      (if (numberp a) (1+ a) (error 'not-a-number :argument a))
     ▷ Error: FRED is not a number.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Return to Lisp Toplevel.
     ▷ Debug> :Continue 1
     ▷ Return to Lisp Toplevel.

Side Effects:
.............

Handlers for the specified condition, if any, are invoked and might have
side effects.  Program execution might stop, and the debugger might be
entered.

Affected By:
............

Existing handler bindings.

‘*break-on-signals*’

Signals an error of type ‘type-error’ if DATUM and ARGUMENTS are not
designators for a condition

See Also:
.........

*note cerror::, *note signal::, *note format::, *note ignore-errors::,
*note *break-on-signals*::, *note handler-bind::, *note Section 9.1
(Condition System Concepts): Condition System Concepts.

Notes:
......

Some implementations may provide debugger commands for interactively
returning from individual stack frames.  However, it should be possible
for the programmer to feel confident about writing code like:

      (defun wargames:no-win-scenario ()
        (if (error "pushing the button would be stupid."))
        (push-the-button))

In this scenario, there should be no chance that ‘error’ will return and
the button will get pushed.

While the meaning of this program is clear and it might be proven ‘safe’
by a formal theorem prover, such a proof is no guarantee that the
program is safe to execute.  Compilers have been known to have bugs,
computers to have signal glitches, and human beings to manually
intervene in ways that are not always possible to predict.  Those kinds
of errors, while beyond the scope of the condition system to formally
model, are not beyond the scope of things that should seriously be
considered when writing code that could have the kinds of sweeping
effects hinted at by this example.


File: ansicl,  Node: cerror,  Next: check-type,  Prev: error (Function),  Up: Conditions

cerror (Function)
=================

Syntax:
.......

 -- Function: cerror continue-format-control datum &rest arguments →
          ‘nil’

Arguments and Values:
.....................

CONTINUE-FORMAT-CONTROL—a format control.

DATUM, ARGUMENTS—designators for a condition of default type
‘simple-error’.

Description:
............

‘cerror’ effectively invokes ‘error’ on the condition named by DATUM.
As with any function that implicitly calls ‘error’, if the condition is
not handled, ‘(invoke-debugger condition)’ is executed.  While signaling
is going on, and while in the debugger if it is reached, it is possible
to continue code execution (i.e., to return from ‘cerror’) using the
‘continue’ restart.

If DATUM is a condition, ARGUMENTS can be supplied, but are used only in
conjunction with the CONTINUE-FORMAT-CONTROL.

Examples:
.........

      (defun real-sqrt (n)
        (when (minusp n)
          (setq n (- n))
          (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
        (sqrt n))

      (real-sqrt 4)
     → 2.0

      (real-sqrt -9)
     ▷ Correctable error in REAL-SQRT: Tried to take sqrt(-9).
     ▷ Restart options:
     ▷  1: Return sqrt(9) instead.
     ▷  2: Top level.
     ▷ Debug> :continue 1
     → 3.0

      (define-condition not-a-number (error)
        ((argument :reader not-a-number-argument :initarg :argument))
        (:report (lambda (condition stream)
                   (format stream "~S is not a number."
                           (not-a-number-argument condition)))))

      (defun assure-number (n)
        (loop (when (numberp n) (return n))
              (cerror "Enter a number."
                      'not-a-number :argument n)
              (format t "~&Type a number: ")
              (setq n (read))
              (fresh-line)))

      (assure-number 'a)
     ▷ Correctable error in ASSURE-NUMBER: A is not a number.
     ▷ Restart options:
     ▷  1: Enter a number.
     ▷  2: Top level.
     ▷ Debug> :continue 1
     ▷ Type a number: 1/2
     → 1/2

      (defun assure-large-number (n)
        (loop (when (and (numberp n) (> n 73)) (return n))
              (cerror "Enter a number~:[~; a bit larger than ~D~]."
                      "~*~A is not a large number."
                      (numberp n) n)
              (format t "~&Type a large number: ")
              (setq n (read))
              (fresh-line)))

      (assure-large-number 10000)
     → 10000

      (assure-large-number 'a)
     ▷ Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
     ▷ Restart options:
     ▷  1: Enter a number.
     ▷  2: Top level.
     ▷ Debug> :continue 1
     ▷ Type a large number: 88
     → 88

      (assure-large-number 37)
     ▷ Correctable error in ASSURE-LARGE-NUMBER: 37 is not a large number.
     ▷ Restart options:
     ▷  1: Enter a number a bit larger than 37.
     ▷  2: Top level.
     ▷ Debug> :continue 1
     ▷ Type a large number: 259
     → 259

      (define-condition not-a-large-number (error)
        ((argument :reader not-a-large-number-argument :initarg :argument))
        (:report (lambda (condition stream)
                   (format stream "~S is not a large number."
                           (not-a-large-number-argument condition)))))

      (defun assure-large-number (n)
        (loop (when (and (numberp n) (> n 73)) (return n))
              (cerror "Enter a number~3*~:[~; a bit larger than ~*~D~]."
                      'not-a-large-number
                      :argument n
                      :ignore (numberp n)
                      :ignore n
                      :allow-other-keys t)
              (format t "~&Type a large number: ")
              (setq n (read))
              (fresh-line)))


      (assure-large-number 'a)
     ▷ Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
     ▷ Restart options:
     ▷  1: Enter a number.
     ▷  2: Top level.
     ▷ Debug> :continue 1
     ▷ Type a large number: 88
     → 88

      (assure-large-number 37)
     ▷ Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
     ▷ Restart options:
     ▷  1: Enter a number a bit larger than 37.
     ▷  2: Top level.
     ▷ Debug> :continue 1
     ▷ Type a large number: 259
     → 259

Affected By:
............

‘*break-on-signals*’.

Existing handler bindings.

See Also:
.........

*note error (Function)::, *note format::, *note handler-bind::, *note
*break-on-signals*::, *note simple-type-error::

Notes:
......

If DATUM is a condition type rather than a string, the ‘format’
directive ‘~*’ may be especially useful in the CONTINUE-FORMAT-CONTROL
in order to ignore the keywords in the initialization argument list.
For example:

     (cerror "enter a new value to replace ~*~s"
             'not-a-number
             :argument a)


File: ansicl,  Node: check-type,  Next: simple-error,  Prev: cerror,  Up: Conditions

check-type (Macro)
==================

Syntax:
.......

 -- Macro: check-type place typespec [STRING] → ‘nil’

Arguments and Values:
.....................

PLACE—a place.

TYPESPEC—a type specifier.

STRING—a string; evaluated.

Description:
............

‘check-type’ signals a correctable error of type ‘type-error’ if the
contents of PLACE are not of the type TYPESPEC.

‘check-type’ can return only if the ‘store-value’ restart is invoked,
either explicitly from a handler or implicitly as one of the options
offered by the debugger.  If the ‘store-value’ restart is invoked,
‘check-type’ stores the new value that is the argument to the restart
invocation (or that is prompted for interactively by the debugger) in
PLACE and starts over, checking the type of the new value and signaling
another error if it is still not of the desired type.

The first time PLACE is evaluated, it is evaluated by normal evaluation
rules.  It is later evaluated as a place if the type check fails and the
‘store-value’ restart is used; see *note Section 5.1.1.1 (Evaluation of
Subforms to Places): GenRefSubFormEval.

string should be an English description of the type, starting with an
indefinite article (“a” or “an”).  If string is not supplied, it is
computed automatically from TYPESPEC.  The automatically generated
message mentions PLACE, its contents, and the desired type.  An
implementation may choose to generate a somewhat differently worded
error message if it recognizes that PLACE is of a particular form, such
as one of the arguments to the function that called ‘check-type’.
string is allowed because some applications of ‘check-type’ may require
a more specific description of what is wanted than can be generated
automatically from TYPESPEC.

Examples:
.........

      (setq aardvarks '(sam harry fred))
     → (SAM HARRY FRED)
      (check-type aardvarks (array * (3)))
     ▷ Error: The value of AARDVARKS, (SAM HARRY FRED),
     ▷        is not a 3-long array.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Specify a value to use instead.
     ▷  2: Return to Lisp Toplevel.
     ▷ Debug> :CONTINUE 1
     ▷ Use Value: #(SAM FRED HARRY)
     → NIL
      aardvarks
     → #<ARRAY-T-3 13571>
      (map 'list #'identity aardvarks)
     → (SAM FRED HARRY)
      (setq aardvark-count 'foo)
     → FOO
      (check-type aardvark-count (integer 0 *) "A positive integer")
     ▷ Error: The value of AARDVARK-COUNT, FOO, is not a positive integer.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Specify a value to use instead.
     ▷  2: Top level.
     ▷ Debug> :CONTINUE 2

      (defmacro define-adder (name amount)
        (check-type name (and symbol (not null)) "a name for an adder function")
        (check-type amount integer)
        `(defun ,name (x) (+ x ,amount)))

      (macroexpand '(define-adder add3 3))
     → (defun add3 (x) (+ x 3))

      (macroexpand '(define-adder 7 7))
     ▷ Error: The value of NAME, 7, is not a name for an adder function.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Specify a value to use instead.
     ▷  2: Top level.
     ▷ Debug> :Continue 1
     ▷ Specify a value to use instead.
     ▷ Type a form to be evaluated and used instead: 'ADD7
     → (defun add7 (x) (+ x 7))

      (macroexpand '(define-adder add5 something))
     ▷ Error: The value of AMOUNT, SOMETHING, is not an integer.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Specify a value to use instead.
     ▷  2: Top level.
     ▷ Debug> :Continue 1
     ▷ Type a form to be evaluated and used instead: 5
     → (defun add5 (x) (+ x 5))


Control is transferred to a handler.

Side Effects:
.............

The debugger might be entered.

Affected By:
............

‘*break-on-signals*’

The implementation.

See Also:
.........

*note Section 9.1 (Condition System Concepts): Condition System
Concepts.

Notes:
......

      (check-type PLACE TYPESPEC)
      ≡ (assert (typep PLACE 'TYPESPEC) (PLACE)
                 'type-error :datum PLACE :expected-type 'TYPESPEC)


File: ansicl,  Node: simple-error,  Next: invalid-method-error,  Prev: check-type,  Up: Conditions

simple-error (Condition Type)
=============================

Class Precedence List:
......................

‘simple-error’, ‘simple-condition’, ‘error’, ‘serious-condition’,
‘condition’, ‘t’

Description:
............

The type ‘simple-error’ consists of conditions that are signaled by
‘error’ or ‘cerror’ when a format control is supplied as the function’s
first argument.


File: ansicl,  Node: invalid-method-error,  Next: method-combination-error,  Prev: simple-error,  Up: Conditions

invalid-method-error (Function)
===============================

Syntax:
.......

 -- Function: invalid-method-error method format-control &rest args →
          implementation-dependent

Arguments and Values:
.....................

METHOD—a method.

FORMAT-CONTROL—a format control.

ARGS—format arguments for the FORMAT-CONTROL.

Description:
............

The function ‘invalid-method-error’ is used to signal an error of type
‘error’ when there is an applicable method whose qualifiers are not
valid for the method combination type.  The error message is constructed
by using the FORMAT-CONTROL suitable for ‘format’ and any ARGS to it.
Because an implementation may need to add additional contextual
information to the error message, ‘invalid-method-error’ should be
called only within the dynamic extent of a method combination function.

The function ‘invalid-method-error’ is called automatically when a
method fails to satisfy every qualifier pattern and predicate in a
‘define-method-combination’ form.  A method combination function that
imposes additional restrictions should call ‘invalid-method-error’
explicitly if it encounters a method it cannot accept.

Whether ‘invalid-method-error’ returns to its caller or exits via
‘throw’ is implementation-dependent.

Side Effects:
.............

The debugger might be entered.

Affected By:
............

‘*break-on-signals*’

See Also:
.........

*note define-method-combination::


File: ansicl,  Node: method-combination-error,  Next: signal,  Prev: invalid-method-error,  Up: Conditions

method-combination-error (Function)
===================================

Syntax:
.......

 -- Function: method-combination-error format-control &rest args →
          implementation-dependent

Arguments and Values:
.....................

FORMAT-CONTROL—a format control.

ARGS—format arguments for FORMAT-CONTROL.

Description:
............

The function ‘method-combination-error’ is used to signal an error in
method combination.

The error message is constructed by using a FORMAT-CONTROL suitable for
‘format’ and any ARGS to it.  Because an implementation may need to add
additional contextual information to the error message,
‘method-combination-error’ should be called only within the dynamic
extent of a method combination function.

Whether ‘method-combination-error’ returns to its caller or exits via
‘throw’ is implementation-dependent.

Side Effects:
.............

The debugger might be entered.

Affected By:
............

‘*break-on-signals*’

See Also:
.........

*note define-method-combination::


File: ansicl,  Node: signal,  Next: simple-condition,  Prev: method-combination-error,  Up: Conditions

signal (Function)
=================

Syntax:
.......

 -- Function: signal datum &rest arguments → ‘nil’

Arguments and Values:
.....................

DATUM, ARGUMENTS—designators for a condition of default type
‘simple-condition’.

Description:
............

Signals the condition denoted by the given DATUM and ARGUMENTS.  If the
condition is not handled, ‘signal’ returns ‘nil’.

Examples:
.........

      (defun handle-division-conditions (condition)
        (format t "Considering condition for division condition handling~%")
        (when (and (typep condition 'arithmetic-error)
                   (eq '/ (arithmetic-error-operation condition)))
          (invoke-debugger condition)))
     HANDLE-DIVISION-CONDITIONS
      (defun handle-other-arithmetic-errors (condition)
        (format t "Considering condition for arithmetic condition handling~%")
        (when (typep condition 'arithmetic-error)
          (abort)))
     HANDLE-OTHER-ARITHMETIC-ERRORS
      (define-condition a-condition-with-no-handler (condition) ())
     A-CONDITION-WITH-NO-HANDLER
      (signal 'a-condition-with-no-handler)
     NIL
      (handler-bind ((condition #'handle-division-conditions)
                       (condition #'handle-other-arithmetic-errors))
        (signal 'a-condition-with-no-handler))
     Considering condition for division condition handling
     Considering condition for arithmetic condition handling
     NIL
      (handler-bind ((arithmetic-error #'handle-division-conditions)
                       (arithmetic-error #'handle-other-arithmetic-errors))
        (signal 'arithmetic-error :operation '* :operands '(1.2 b)))
     Considering condition for division condition handling
     Considering condition for arithmetic condition handling
     Back to Lisp Toplevel

Side Effects:
.............

The debugger might be entered due to ‘*break-on-signals*’.

Handlers for the condition being signaled might transfer control.

Affected By:
............

Existing handler bindings.

‘*break-on-signals*’

See Also:
.........

*note *break-on-signals*::, *note error (Function)::, *note
simple-condition::, *note Section 9.1.4 (Signaling and Handling
Conditions): Signaling and Handling Conditions.

Notes:
......

If ‘(typep DATUM *break-on-signals*)’ yields true, the debugger is
entered prior to beginning the signaling process.  the ‘continue’
restart can be used to continue with the signaling process.  This is
also true for all other functions and macros that should, might, or must
signal conditions.


File: ansicl,  Node: simple-condition,  Next: simple-condition-format-control; simple-condition-format-arguments,  Prev: signal,  Up: Conditions

simple-condition (Condition Type)
=================================

Class Precedence List:
......................

‘simple-condition’, ‘condition’, ‘t’

Description:
............

The type ‘simple-condition’ represents conditions that are signaled by
‘signal’ whenever a FORMAT-CONTROL is supplied as the function’s first
argument.  The format control and format arguments are initialized with
the initialization arguments named :format-control and :format-arguments
to ‘make-condition’, and are accessed by the functions
‘simple-condition-format-control’ and
‘simple-condition-format-arguments’.  If format arguments are not
supplied to ‘make-condition’, ‘nil’ is used as a default.

See Also:
.........

*note simple-condition-format-control::, *note
simple-condition-format-arguments::


File: ansicl,  Node: simple-condition-format-control; simple-condition-format-arguments,  Next: warn,  Prev: simple-condition,  Up: Conditions

simple-condition-format-control, simple-condition-format-arguments (Function)
=============================================================================

Syntax:
.......

 -- Function: simple-condition-format-control condition → format-control
 -- Function: simple-condition-format-arguments condition →
          format-arguments

Arguments and Values:
.....................

CONDITION—a condition of type ‘simple-condition’.

FORMAT-CONTROL—a format control.

FORMAT-ARGUMENTS—a list.

Description:
............

‘simple-condition-format-control’ returns the format control needed to
process the CONDITION’s format arguments.

‘simple-condition-format-arguments’ returns a list of format arguments
needed to process the CONDITION’s format control.

Examples:
.........

      (setq foo (make-condition 'simple-condition
                               :format-control "Hi ~S"
                               :format-arguments '(ho)))
     → #<SIMPLE-CONDITION 26223553>
      (apply #'format nil (simple-condition-format-control foo)
                          (simple-condition-format-arguments foo))
     → "Hi HO"

See Also:
.........

*note simple-condition::, *note Section 9.1 (Condition System Concepts):
Condition System Concepts.


File: ansicl,  Node: warn,  Next: simple-warning,  Prev: simple-condition-format-control; simple-condition-format-arguments,  Up: Conditions

warn (Function)
===============

Syntax:
.......

 -- Function: warn datum &rest arguments → ‘nil’

Arguments and Values:
.....................

DATUM, ARGUMENTS—designators for a condition of default type
‘simple-warning’.

Description:
............

Signals a condition of type ‘warning’.  If the condition is not handled,
reports the condition to error output.

The precise mechanism for warning is as follows:

The warning condition is signaled

     While the ‘warning’ condition is being signaled, the
     ‘muffle-warning’ restart is established for use by a handler.  If
     invoked, this restart bypasses further action by ‘warn’, which in
     turn causes ‘warn’ to immediately return ‘nil’.

If no handler for the warning condition is found

     If no handlers for the warning condition are found, or if all such
     handlers decline, then the condition is reported to error output by
     ‘warn’ in an implementation-dependent format.

‘nil’ is returned

     The value returned by ‘warn’ if it returns is ‘nil’.

Examples:
.........

       (defun foo (x)
         (let ((result (* x 2)))
           (if (not (typep result 'fixnum))
               (warn "You're using very big numbers."))
           result))
     → FOO

       (foo 3)
     → 6

       (foo most-positive-fixnum)
     ▷ Warning: You're using very big numbers.
     → 4294967294

       (setq *break-on-signals* t)
     → T

       (foo most-positive-fixnum)
     ▷ Break: Caveat emptor.
     ▷ To continue, type :CONTINUE followed by an option number.
     ▷  1: Return from Break.
     ▷  2: Abort to Lisp Toplevel.
     ▷ Debug> :continue 1
     ▷ Warning: You're using very big numbers.
     → 4294967294

Side Effects:
.............

A warning is issued.  The debugger might be entered.

Affected By:
............

Existing handler bindings.

‘*break-on-signals*’, ‘*error-output*’.

Exceptional Situations:
.......................

If DATUM is a condition and if the condition is not of type ‘warning’,
or ARGUMENTS is non-nil, an error of type ‘type-error’ is signaled.

If DATUM is a condition type, the result of ‘(apply #'make-condition
datum arguments)’ must be of type ‘warning’ or an error of type
‘type-error’ is signaled.

See Also:
.........

*note *break-on-signals*::, *note muffle-warning::, *note signal::


File: ansicl,  Node: simple-warning,  Next: invoke-debugger,  Prev: warn,  Up: Conditions

simple-warning (Condition Type)
===============================

Class Precedence List:
......................

‘simple-warning’, ‘simple-condition’, ‘warning’, ‘condition’, ‘t’

Description:
............

The type ‘simple-warning’ represents conditions that are signaled by
‘warn’ whenever a format control is supplied as the function’s first
argument.


File: ansicl,  Node: invoke-debugger,  Next: break,  Prev: simple-warning,  Up: Conditions

invoke-debugger (Function)
==========================

Syntax:
.......

 -- Function: invoke-debugger condition →|

Arguments and Values:
.....................

CONDITION—a condition object.

Description:
............

‘invoke-debugger’ attempts to enter the debugger with CONDITION.

If ‘*debugger-hook*’ is not ‘nil’, it should be a function (or the name
of a function) to be called prior to entry to the standard debugger.
The function is called with ‘*debugger-hook*’ bound to ‘nil’, and the
function must accept two arguments: the CONDITION and the value of
‘*debugger-hook*’ prior to binding it to ‘nil’.  If the function returns
normally, the standard debugger is entered.

The standard debugger never directly returns.  Return can occur only by
a non-local transfer of control, such as the use of a restart function.

Examples:
.........

      (ignore-errors ;Normally, this would suppress debugger entry
        (handler-bind ((error #'invoke-debugger)) ;But this forces debugger entry
          (error "Foo.")))
     Debug: Foo.
     To continue, type :CONTINUE followed by an option number:
      1: Return to Lisp Toplevel.
     Debug>

Side Effects:
.............

‘*debugger-hook*’ is bound to ‘nil’, program execution is discontinued,
and the debugger is entered.

Affected By:
............

‘*debug-io*’ and ‘*debugger-hook*’.

See Also:
.........

*note error (Function)::, *note break::


File: ansicl,  Node: break,  Next: *debugger-hook*,  Prev: invoke-debugger,  Up: Conditions

break (Function)
================

Syntax:
.......

 -- Function: break &optional format-control &rest format-arguments →
          ‘nil’

Arguments and Values:
.....................

FORMAT-CONTROL—a format control.  The default is
implementation-dependent.

FORMAT-ARGUMENTS—format arguments for the FORMAT-CONTROL.

Description:
............

‘break’ formats FORMAT-CONTROL and FORMAT-ARGUMENTS and then goes
directly into the debugger without allowing any possibility of
interception by programmed error-handling facilities.

If the ‘continue’ restart is used while in the debugger, ‘break’
immediately returns ‘nil’ without taking any unusual recovery action.

‘break’ binds ‘*debugger-hook*’ to ‘nil’  before attempting to enter the
debugger.

Examples:
.........

      (break "You got here with arguments: ~:S." '(FOO 37 A))
     ▷ BREAK: You got here with these arguments: FOO, 37, A.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Return from BREAK.
     ▷  2: Top level.
     ▷ Debug> :CONTINUE 1
     ▷ Return from BREAK.
     → NIL


Side Effects:
.............

The debugger is entered.

Affected By:
............

‘*debug-io*’.

See Also:
.........

*note error (Function)::, *note invoke-debugger::.

Notes:
......

‘break’ is used as a way of inserting temporary debugging “breakpoints”
in a program, not as a way of signaling errors.  For this reason,
‘break’ does not take the CONTINUE-FORMAT-CONTROL argument that ‘cerror’
takes.  This and the lack of any possibility of interception by
condition handling are the only program-visible differences between
‘break’ and ‘cerror’.

The user interface aspects of ‘break’ and ‘cerror’ are permitted to vary
more widely, in order to accomodate the interface needs of the
implementation.  For example, it is permissible for a Lisp
read-eval-print loop to be entered by ‘break’ rather than the
conventional debugger.

‘break’ could be defined by:

      (defun break (&optional (format-control "Break") &rest format-arguments)
        (with-simple-restart (continue "Return from BREAK.")
          (let ((*debugger-hook* nil))
            (invoke-debugger
                (make-condition 'simple-condition
                                :format-control format-control
                                :format-arguments format-arguments))))
        nil)


File: ansicl,  Node: *debugger-hook*,  Next: *break-on-signals*,  Prev: break,  Up: Conditions

*debugger-hook* (Variable)
==========================

Value Type:
...........

a designator for a function of two arguments (a condition and the value
of ‘*debugger-hook*’ at the time the debugger was entered), or ‘nil’.

Initial Value:
..............

‘nil’.

Description:
............

When the value of ‘*debugger-hook*’ is non-nil, it is called prior to
normal entry into the debugger, either due to a call to
‘invoke-debugger’ or due to automatic entry into the debugger from a
call to ‘error’ or ‘cerror’ with a condition that is not handled.  The
function may either handle the condition (transfer control) or return
normally (allowing the standard debugger to run).  To minimize recursive
errors while debugging, ‘*debugger-hook*’ is bound to ‘nil’ by
‘invoke-debugger’ prior to calling the function.

Examples:
.........

      (defun one-of (choices &optional (prompt "Choice"))
        (let ((n (length choices)) (i))
          (do ((c choices (cdr c)) (i 1 (+ i 1)))
              ((null c))
            (format t "~&[~D] ~A~%" i (car c)))
          (do () ((typep i `(integer 1 ,n)))
            (format t "~&~A: " prompt)
            (setq i (read))
            (fresh-line))
          (nth (- i 1) choices)))

      (defun my-debugger (condition me-or-my-encapsulation)
        (format t "~&Fooey: ~A" condition)
        (let ((restart (one-of (compute-restarts))))
          (if (not restart) (error "My debugger got an error."))
          (let ((*debugger-hook* me-or-my-encapsulation))
            (invoke-restart-interactively restart))))

      (let ((*debugger-hook* #'my-debugger))
        (+ 3 'a))
     ▷ Fooey: The argument to +, A, is not a number.
     ▷  [1] Supply a replacement for A.
     ▷  [2] Return to Cloe Toplevel.
     ▷ Choice: 1
     ▷  Form to evaluate and use: (+ 5 'b)
     ▷  Fooey: The argument to +, B, is not a number.
     ▷  [1] Supply a replacement for B.
     ▷  [2] Supply a replacement for A.
     ▷  [3] Return to Cloe Toplevel.
     ▷ Choice: 1
     ▷  Form to evaluate and use: 1
     → 9

Affected By:
............

‘invoke-debugger’

Notes:
......

When evaluating code typed in by the user interactively, it is sometimes
useful to have the hook function bind ‘*debugger-hook*’ to the function
that was its second argument so that recursive errors can be handled
using the same interactive facility.


File: ansicl,  Node: *break-on-signals*,  Next: handler-bind,  Prev: *debugger-hook*,  Up: Conditions

*break-on-signals* (Variable)
=============================

Value Type:
...........

a type specifier.

Initial Value:
..............

‘nil’.

Description:
............

When ‘(typep condition *break-on-signals*)’ returns true, calls to
‘signal’, and to other operators such as ‘error’ that implicitly call
‘signal’, enter the debugger prior to signaling the condition.

the ‘continue’ restart can be used to continue with the normal signaling
process when a break occurs process due to ‘*break-on-signals*’.

Examples:
.........

      *break-on-signals* → NIL
      (ignore-errors (error 'simple-error :format-control "Fooey!"))
     → NIL, #<SIMPLE-ERROR 32207172>

      (let ((*break-on-signals* 'error))
        (ignore-errors (error 'simple-error :format-control "Fooey!")))
     ▷ Break: Fooey!
     ▷ BREAK entered because of *BREAK-ON-SIGNALS*.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Continue to signal.
     ▷  2: Top level.
     ▷ Debug> :CONTINUE 1
     ▷ Continue to signal.
     → NIL, #<SIMPLE-ERROR 32212257>

      (let ((*break-on-signals* 'error))
        (error 'simple-error :format-control "Fooey!"))
     ▷ Break: Fooey!
     ▷ BREAK entered because of *BREAK-ON-SIGNALS*.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Continue to signal.
     ▷  2: Top level.
     ▷ Debug> :CONTINUE 1
     ▷ Continue to signal.
     ▷ Error: Fooey!
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Top level.
     ▷ Debug> :CONTINUE 1
     ▷ Top level.

See Also:
.........

*note break::, *note signal::, *note warn::, *note error (Function)::,
*note typep::, *note Section 9.1 (Condition System Concepts): Condition
System Concepts.

Notes:
......

‘*break-on-signals*’ is intended primarily for use in debugging code
that does signaling.  When setting ‘*break-on-signals*’, the user is
encouraged to choose the most restrictive specification that suffices.
Setting ‘*break-on-signals*’ effectively violates the modular handling
of condition signaling.  In practice, the complete effect of setting
‘*break-on-signals*’ might be unpredictable in some cases since the user
might not be aware of the variety or number of calls to ‘signal’ that
are used in code called only incidentally.

‘*break-on-signals*’ enables an early entry to the debugger but such an
entry does not preclude an additional entry to the debugger in the case
of operations such as ‘error’ and ‘cerror’.


File: ansicl,  Node: handler-bind,  Next: handler-case,  Prev: *break-on-signals*,  Up: Conditions

handler-bind (Macro)
====================

Syntax:
.......

 -- Macro: handler-bind ({↓binding}*) {form}* → {result}*

BINDING::=
     (type handler)

Arguments and Values:
.....................

TYPE—a type specifier.

HANDLER—a form; evaluated to produce a HANDLER-FUNCTION.

HANDLER-FUNCTION—a designator for a function of one argument.

FORMS—an implicit progn.

RESULTS—the values returned by the forms.

Description:
............

Executes FORMS in a dynamic environment where the indicated HANDLER
bindings are in effect.

Each HANDLER should evaluate to a handler-function, which is used to
handle conditions of the given TYPE during execution of the FORMS.  This
function should take a single argument, the condition being signaled.

If more than one HANDLER binding is supplied, the HANDLER bindings are
searched sequentially from top to bottom in search of a match (by visual
analogy with ‘typecase’).  If an appropriate type is found, the
associated handler is run in a dynamic environment where none of these
HANDLER bindings are visible (to avoid recursive errors).  If the
handler declines, the search continues for another handler.

If no appropriate handler is found, other handlers are sought from
dynamically enclosing contours.  If no handler is found outside, then
‘signal’ returns or ‘error’ enters the debugger.

Examples:
.........

In the following code, if an unbound variable error is signaled in the
body (and not handled by an intervening handler), the first function is
called.

      (handler-bind ((unbound-variable #'(lambda ...))
                     (error #'(lambda ...)))
        ...)

If any other kind of error is signaled, the second function is called.
In either case, neither handler is active while executing the code in
the associated function.

      (defun trap-error-handler (condition)
        (format *error-output* "~&~A~&" condition)
        (throw 'trap-errors nil))

      (defmacro trap-errors (&rest forms)
        `(catch 'trap-errors
           (handler-bind ((error #'trap-error-handler))
             ,@forms)))

      (list (trap-errors (signal "Foo.") 1)
            (trap-errors (error  "Bar.") 2)
            (+ 1 2))
     ▷ Bar.
     → (1 NIL 3)

Note that “Foo.” is not printed because the condition made by ‘signal’
is a simple condition, which is not of type ‘error’, so it doesn’t
trigger the handler for ‘error’ set up by ‘trap-errors’.

See Also:
.........

*note handler-case::


File: ansicl,  Node: handler-case,  Next: ignore-errors,  Prev: handler-bind,  Up: Conditions

handler-case (Macro)
====================

Syntax:
.......

 -- Macro: handler-case EXPRESSION 〚{↓error-clause}* |
          ↓no-error-clause〛 → {result}*

CLAUSE::=
     ↓error-clause | ↓no-error-clause
ERROR-CLAUSE::=
     (typespec ([var]) {declaration}* {form}*)
NO-ERROR-CLAUSE::=
     (:no-error LAMBDA-LIST {declaration}* {form}*)

Arguments and Values:
.....................

EXPRESSION—a form.

TYPESPEC—a type specifier.

VAR—a variable name.

LAMBDA-LIST—an ordinary lambda list.

DECLARATION—a declare expression; not evaluated.

FORM—a form.

RESULTS—In the normal situation, the values returned are those that
result from the evaluation of EXPRESSION; in the exceptional situation
when control is transferred to a CLAUSE, the value of the last FORM in
that CLAUSE is returned.

Description:
............

‘handler-case’ executes EXPRESSION in a dynamic environment where
various handlers are active.  Each error-clause specifies how to handle
a condition matching the indicated TYPESPEC.  A no-error-clause allows
the specification of a particular action if control returns normally.

If a condition is signaled for which there is an appropriate
error-clause during the execution of EXPRESSION (i.e., one for which
‘(typep condition 'TYPESPEC)’ returns true) and if there is no
intervening handler for a condition of that type, then control is
transferred to the body of the relevant error-clause.  In this case, the
dynamic state is unwound appropriately (so that the handlers established
around the EXPRESSION are no longer active), and VAR is bound to the
condition that had been signaled.  If more than one case is provided,
those cases are made accessible in parallel.  That is, in

       (handler-case form
         (typespec1 (var1) form1)
         (typespec2 (var2) form2))

if the first clause (containing form1) has been selected, the handler
for the second is no longer visible (or vice versa).

The clauses are searched sequentially from top to bottom.  If there is
type overlap between TYPESPECS, the earlier of the clauses is selected.

If VAR is not needed, it can be omitted.  That is, a clause such as:

       (TYPESPEC (VAR) (declare (ignore VAR)) FORM)

can be written ‘(TYPESPEC () FORM)’.

If there are no FORMS in a selected clause, the case, and therefore
‘handler-case’, returns ‘nil’.  If execution of EXPRESSION returns
normally and no no-error-clause exists, the values returned by
EXPRESSION are returned by ‘handler-case’.  If execution of EXPRESSION
returns normally and a no-error-clause does exist, the values returned
are used as arguments to the function described by constructing ‘(lambda
LAMBDA-LIST {form}*)’ from the no-error-clause, and the values of that
function call are returned by ‘handler-case’.  The handlers which were
established around the EXPRESSION are no longer active at the time of
this call.

Examples:
.........

      (defun assess-condition (condition)
        (handler-case (signal condition)
          (warning () "Lots of smoke, but no fire.")
          ((or arithmetic-error control-error cell-error stream-error)
             (condition)
            (format nil "~S looks especially bad." condition))
          (serious-condition (condition)
            (format nil "~S looks serious." condition))
          (condition () "Hardly worth mentioning.")))
     → ASSESS-CONDITION
      (assess-condition (make-condition 'stream-error :stream *terminal-io*))
     → "#<STREAM-ERROR 12352256> looks especially bad."
      (define-condition random-condition (condition) ()
        (:report (lambda (condition stream)
                   (declare (ignore condition))
                   (princ "Yow" stream))))
     → RANDOM-CONDITION
      (assess-condition (make-condition 'random-condition))
     → "Hardly worth mentioning."

See Also:
.........

*note handler-bind::, *note ignore-errors::, *note Section 9.1
(Condition System Concepts): Condition System Concepts.

Notes:
......

      (handler-case form
        (type1 (var1) . body1)
        (type2 (var2) . body2) ...)

is approximately equivalent to:

      (block #1=#:g0001
        (let ((#2=#:g0002 nil))
          (tagbody
            (handler-bind ((type1 #'(lambda (temp)
                                            (setq #1# temp)
                                            (go #3=#:g0003)))
                           (type2 #'(lambda (temp)
                                            (setq #2# temp)
                                            (go #4=#:g0004))) ...)
            (return-from #1# form))
              #3# (return-from #1# (let ((var1 #2#)) . body1))
              #4# (return-from #1# (let ((var2 #2#)) . body2)) ...)))

      (handler-case form
        (type1 (var1) . body1)
        ...
        (:no-error (varN-1 varN-2 ...) . bodyN))

is approximately equivalent to:


      (block #1=#:error-return
       (multiple-value-call #'(lambda (varN-1 varN-2 ...) . bodyN)
          (block #2=#:normal-return
            (return-from #1#
              (handler-case (return-from #2# form)
                (type1 (var1) . body1) ...)))))


File: ansicl,  Node: ignore-errors,  Next: define-condition,  Prev: handler-case,  Up: Conditions

ignore-errors (Macro)
=====================

Syntax:
.......

 -- Macro: ignore-errors {form}* → {result}*

Arguments and Values:
.....................

FORMS—an implicit progn.

RESULTS—In the normal situation, the values of the forms are returned;
in the exceptional situation, two values are returned: ‘nil’ and the
condition.

Description:
............

‘ignore-errors’ is used to prevent conditions of type ‘error’ from
causing entry into the debugger.

Specifically, ‘ignore-errors’ executes forms in a dynamic environment
where a handler for conditions of type ‘error’ has been established; if
invoked, it handles such conditions by returning two values, ‘nil’ and
the condition that was signaled, from the ‘ignore-errors’ form.

If a normal return from the forms occurs, any values returned are
returned by ‘ignore-errors’.

Examples:
.........

      (defun load-init-file (program)
        (let ((win nil))
          (ignore-errors ;if this fails, don't enter debugger
            (load (merge-pathnames (make-pathname :name program :type :lisp)
                                   (user-homedir-pathname)))
            (setq win t))
          (unless win (format t "~&Init file failed to load.~%"))
          win))

      (load-init-file "no-such-program")
     ▷ Init file failed to load.
     NIL

See Also:
.........

*note handler-case::, *note Section 9.1 (Condition System Concepts):
Condition System Concepts.

Notes:
......

      (ignore-errors . forms)

is equivalent to:

      (handler-case (progn . forms)
        (error (condition) (values nil condition)))

Because the second return value is a condition in the exceptional case,
it is common (but not required) to arrange for the second return value
in the normal case to be missing or ‘nil’ so that the two situations can
be distinguished.


File: ansicl,  Node: define-condition,  Next: make-condition,  Prev: ignore-errors,  Up: Conditions

define-condition (Macro)
========================

Syntax:
.......

 -- Macro: define-condition name ({parent-type}*) ({↓slot-spec}*)
          {option}* → name

SLOT-SPEC::=
     slot-name | (slot-name ↓slot-option)
SLOT-OPTION::=
     〚 {:reader symbol}* |
     {:writer ↓function-name}* |
     {:accessor symbol}* |
     {:allocation ↓allocation-type} |
     {:initarg symbol}* |
     {:initform form} |
     {:type TYPE-SPECIFIER} 〛
OPTION::=
     〚 (:default-initargs ‘.’  INITARG-LIST) |
     (:documentation string) |
     (:report report-name) 〛
FUNCTION-NAME::=
     {symbol | ‘(setf symbol)’}
ALLOCATION-TYPE::=
     :instance | :class
REPORT-NAME::=
     string | symbol | lambda expression

Arguments and Values:
.....................

NAME—a symbol.

PARENT-TYPE—a symbol naming a condition type.  If no PARENT-TYPES are
supplied, the PARENT-TYPES default to ‘(condition)’.

DEFAULT-INITARGS—a list of keyword/value pairs.

SLOT-SPEC—the name of a slot or a list consisting of the SLOT-NAME
followed by zero or more SLOT-OPTIONS.

SLOT-NAME—a slot name (a symbol), the list of a slot name, or the list
of slot name/slot form pairs.

OPTION—Any of the following:

:reader

     :reader can be supplied more than once for a given slot and cannot
     be ‘nil’.

:writer

     :writer can be supplied more than once for a given slot and must
     name a generic function.

:accessor

     :accessor can be supplied more than once for a given slot and
     cannot be ‘nil’.

:allocation

     :allocation can be supplied once at most for a given slot.  The
     default if :allocation is not supplied is :instance.

:initarg

     :initarg can be supplied more than once for a given slot.

:initform

     :initform can be supplied once at most for a given slot.

:type

     :type can be supplied once at most for a given slot.

:documentation

     :documentation can be supplied once at most for a given slot.

:report

     :report can be supplied once at most.

Description:
............

‘define-condition’ defines a new condition type called NAME, which is a
subtype of the type or types named by PARENT-TYPE.  Each PARENT-TYPE
argument specifies a direct supertype of the new condition.  The new
condition inherits slots and methods from each of its direct supertypes,
and so on.

If a slot name/slot form pair is supplied, the slot form is a form that
can be evaluated by ‘make-condition’ to produce a default value when an
explicit value is not provided.  If no slot form is supplied, the
contents of the SLOT is initialized in an implementation-dependent way.

If the type being defined and some other type from which it inherits
have a slot by the same name, only one slot is allocated in the
condition, but the supplied slot form overrides any slot form that might
otherwise have been inherited from a PARENT-TYPE.  If no slot form is
supplied, the inherited slot form (if any) is still visible.

Accessors are created according to the same rules as used by ‘defclass’.

A description of SLOT-OPTIONS follows:

:reader

     The :reader slot option specifies that an unqualified method is to
     be defined on the generic function named by the argument to :reader
     to read the value of the given slot.

•
     The :initform slot option is used to provide a default initial
     value form to be used in the initialization of the slot.  This form
     is evaluated every time it is used to initialize the slot.  The
     lexical environment in which this form is evaluated is the lexical
     environment in which the ‘define-condition’ form was evaluated.
     Note that the lexical environment refers both to variables and to
     functions.  For local slots, the dynamic environment is the dynamic
     environment in which ‘make-condition’ was called; for shared slots,
     the dynamic environment is the dynamic environment in which the
     ‘define-condition’ form was evaluated.

     No implementation is permitted to extend the syntax of
     ‘define-condition’ to allow ‘(SLOT-NAME FORM)’ as an abbreviation
     for ‘(SLOT-NAME :initform FORM)’.

:initarg

     The :initarg slot option declares an initialization argument named
     by its symbol argument and specifies that this initialization
     argument initializes the given slot.  If the initialization
     argument has a value in the call to ‘initialize-instance’, the
     value is stored into the given slot, and the slot’s :initform slot
     option, if any, is not evaluated.  If none of the initialization
     arguments specified for a given slot has a value, the slot is
     initialized according to the :initform slot option, if specified.

:type

     The :type slot option specifies that the contents of the slot is
     always of the specified type.  It effectively declares the result
     type of the reader generic function when applied to an object of
     this condition type.  The consequences of attempting to store in a
     slot a value that does not satisfy the type of the slot is
     undefined.

:default-initargs

     This option is treated the same as it would be ‘defclass’.

:documentation

     The :documentation slot option provides a documentation string for
     the slot.

:report

     Condition reporting is mediated through the ‘print-object’ method
     for the condition type in question, with ‘*print-escape*’ always
     being ‘nil’.  Specifying ‘(:report REPORT-NAME)’ in the definition
     of a condition type ‘C’ is equivalent to:

           (defmethod print-object ((x c) stream)
             (if *print-escape* (call-next-method) (REPORT-NAME x stream)))

     If the value supplied by the argument to :report (REPORT-NAME) is a
     symbol or a lambda expression, it must be acceptable to ‘function’.
     ‘(function REPORT-NAME)’ is evaluated in the current lexical
     environment.  It should return a function of two arguments, a
     condition and a stream, that prints on the stream a description of
     the condition.  This function is called whenever the condition is
     printed while ‘*print-escape*’ is ‘nil’.

     If REPORT-NAME is a string, it is a shorthand for

           (lambda (condition stream)
             (declare (ignore condition))
             (write-string REPORT-NAME stream))

     This option is processed after the new condition type has been
     defined, so use of the SLOT accessors within the :report function
     is permitted.  If this option is not supplied, information about
     how to report this type of condition is inherited from the
     PARENT-TYPE.

The consequences are unspecifed if an attempt is made to read a SLOT
that has not been explicitly initialized and that has not been given a
default value.

The consequences are unspecified if an attempt is made to assign the
SLOTS by using ‘setf’.

If a ‘define-condition’ form appears as a top level form, the compiler
must make NAME recognizable as a valid type name, and it must be
possible to reference the condition type as the PARENT-TYPE of another
condition type in a subsequent ‘define-condition’ form in the file being
compiled.

Examples:
.........

The following form defines a condition of type ‘peg/hole-mismatch’ which
inherits from a condition type called ‘blocks-world-error’:

     (define-condition peg/hole-mismatch
                       (blocks-world-error)
                       ((peg-shape  :initarg :peg-shape
                                    :reader peg/hole-mismatch-peg-shape)
                        (hole-shape :initarg :hole-shape
                                    :reader peg/hole-mismatch-hole-shape))
       (:report (lambda (condition stream)
                  (format stream "A ~A peg cannot go in a ~A hole."
                          (peg/hole-mismatch-peg-shape  condition)
                          (peg/hole-mismatch-hole-shape condition)))))

The new type has slots ‘peg-shape’ and ‘hole-shape’, so ‘make-condition’
accepts ‘:peg-shape’ and ‘:hole-shape’ keywords.  The readers
‘peg/hole-mismatch-peg-shape’ and ‘peg/hole-mismatch-hole-shape’ apply
to objects of this type, as illustrated in the :report information.

The following form defines a condition type named ‘machine-error’ which
inherits from ‘error’:

     (define-condition machine-error
                       (error)
                       ((machine-name :initarg :machine-name
                                      :reader machine-error-machine-name))
       (:report (lambda (condition stream)
                  (format stream "There is a problem with ~A."
                          (machine-error-machine-name condition)))))

Building on this definition, a new error condition can be defined which
is a subtype of ‘machine-error’ for use when machines are not available:

     (define-condition machine-not-available-error (machine-error) ()
       (:report (lambda (condition stream)
                  (format stream "The machine ~A is not available."
                          (machine-error-machine-name condition)))))

This defines a still more specific condition, built upon
‘machine-not-available-error’, which provides a slot initialization form
for ‘machine-name’ but which does not provide any new slots or report
information.  It just gives the ‘machine-name’ slot a default
initialization:

     (define-condition my-favorite-machine-not-available-error
                       (machine-not-available-error)
       ((machine-name :initform "mc.lcs.mit.edu")))

Note that since no :report clause was given, the information inherited
from ‘machine-not-available-error’ is used to report this type of
condition.

      (define-condition ate-too-much (error)
          ((person :initarg :person :reader ate-too-much-person)
           (weight :initarg :weight :reader ate-too-much-weight)
           (kind-of-food :initarg :kind-of-food
                         :reader :ate-too-much-kind-of-food)))
     → ATE-TOO-MUCH
      (define-condition ate-too-much-ice-cream (ate-too-much)
        ((kind-of-food :initform 'ice-cream)
         (flavor       :initarg :flavor
                       :reader ate-too-much-ice-cream-flavor
                       :initform 'vanilla ))
        (:report (lambda (condition stream)
                   (format stream "~A ate too much ~A ice-cream"
                           (ate-too-much-person condition)
                           (ate-too-much-ice-cream-flavor condition)))))
     → ATE-TOO-MUCH-ICE-CREAM
      (make-condition 'ate-too-much-ice-cream
                      :person 'fred
                      :weight 300
                      :flavor 'chocolate)
     → #<ATE-TOO-MUCH-ICE-CREAM 32236101>
      (format t "~A" *)
     ▷ FRED ate too much CHOCOLATE ice-cream
     → NIL

See Also:
.........

*note make-condition::, *note defclass::, *note Section 9.1 (Condition
System Concepts): Condition System Concepts.


File: ansicl,  Node: make-condition,  Next: restart,  Prev: define-condition,  Up: Conditions

make-condition (Function)
=========================

Syntax:
.......

 -- Function: make-condition type &rest slot-initializations → condition

Arguments and Values:
.....................

TYPE—a type specifier (for a subtype of ‘condition’).

SLOT-INITIALIZATIONS—an initialization argument list.

CONDITION—a condition.

Description:
............

Constructs and returns a condition of type TYPE using
SLOT-INITIALIZATIONS for the initial values of the slots.  The newly
created condition is returned.

Examples:
.........

      (defvar *oops-count* 0)

      (setq a (make-condition 'simple-error
                              :format-control "This is your ~:R error."
                              :format-arguments (list (incf *oops-count*))))
     → #<SIMPLE-ERROR 32245104>

      (format t "~&~A~%" a)
     ▷ This is your first error.
     → NIL

      (error a)
     ▷ Error: This is your first error.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Return to Lisp Toplevel.
     ▷ Debug>

Affected By:
............

The set of defined condition types.

See Also:
.........

*note define-condition::, *note Section 9.1 (Condition System Concepts):
Condition System Concepts.


File: ansicl,  Node: restart,  Next: compute-restarts,  Prev: make-condition,  Up: Conditions

restart (System Class)
======================

Class Precedence List:
......................

‘restart’, ‘t’

Description:
............

An object of type ‘restart’ represents a function that can be called to
perform some form of recovery action, usually a transfer of control to
an outer point in the running program.

An implementation is free to implement a restart in whatever manner is
most convenient; a restart has only dynamic extent relative to the scope
of the binding form which establishes it.


File: ansicl,  Node: compute-restarts,  Next: find-restart,  Prev: restart,  Up: Conditions

compute-restarts (Function)
===========================

Syntax:
.......

 -- Function: compute-restarts &optional condition → restarts

Arguments and Values:
.....................

CONDITION—a condition object, or ‘nil’.

RESTARTS—a list of restarts.

Description:
............

‘compute-restarts’ uses the dynamic state of the program to compute a
list of the restarts which are currently active.

The resulting list is ordered so that the innermost (more-recently
established) restarts are nearer the head of the list.

When CONDITION is non-nil, only those restarts are considered that are
either explicitly associated with that CONDITION, or not associated with
any condition; that is, the excluded restarts are those that are
associated with a non-empty set of conditions of which the given
CONDITION is not an element.  If CONDITION is ‘nil’, all restarts are
considered.

‘compute-restarts’ returns all applicable restarts, including anonymous
ones, even if some of them have the same name as others and would
therefore not be found by ‘find-restart’ when given a symbol argument.

Implementations are permitted, but not required, to return distinct
lists from repeated calls to ‘compute-restarts’ while in the same
dynamic environment.  The consequences are undefined if the list
returned by ‘compute-restarts’ is every modified.

Examples:
.........

      ;; One possible way in which an interactive debugger might present
      ;; restarts to the user.
      (defun invoke-a-restart ()
        (let ((restarts (compute-restarts)))
          (do ((i 0 (+ i 1)) (r restarts (cdr r))) ((null r))
            (format t "~&~D: ~A~%" i (car r)))
          (let ((n nil) (k (length restarts)))
            (loop (when (and (typep n 'integer) (>= n 0) (< n k))
                    (return t))
                  (format t "~&Option: ")
                  (setq n (read))
                  (fresh-line))
            (invoke-restart-interactively (nth n restarts)))))

      (restart-case (invoke-a-restart)
        (one () 1)
        (two () 2)
        (nil () :report "Who knows?" 'anonymous)
        (one () 'I)
        (two () 'II))
     ▷ 0: ONE
     ▷ 1: TWO
     ▷ 2: Who knows?
     ▷ 3: ONE
     ▷ 4: TWO
     ▷ 5: Return to Lisp Toplevel.
     ▷ Option: 4
     → II

      ;; Note that in addition to user-defined restart points, COMPUTE-RESTARTS
      ;; also returns information about any system-supplied restarts, such as
      ;; the "Return to Lisp Toplevel" restart offered above.


Affected By:
............

Existing restarts.

See Also:
.........

*note find-restart::, *note invoke-restart::, *note restart-bind::


File: ansicl,  Node: find-restart,  Next: invoke-restart,  Prev: compute-restarts,  Up: Conditions

find-restart (Function)
=======================

Syntax:
.......

 -- Function: find-restart identifier &optional condition → restart

Arguments and Values:
.....................

IDENTIFIER—a non-nil symbol, or a restart.

CONDITION—a condition object, or ‘nil’.

RESTART—a restart or ‘nil’.

Description:
............

‘find-restart’ searches for a particular restart in the current dynamic
environment.

When CONDITION is non-nil, only those restarts are considered that are
either explicitly associated with that CONDITION, or not associated with
any condition; that is, the excluded restarts are those that are
associated with a non-empty set of conditions of which the given
CONDITION is not an element.  If CONDITION is ‘nil’, all restarts are
considered.

If IDENTIFIER is a symbol, then the innermost (most recently
established) applicable restart with that name is returned.  ‘nil’ is
returned if no such restart is found.

If IDENTIFIER is a currently active restart, then it is returned.
Otherwise, ‘nil’ is returned.

Examples:
.........

      (restart-case
          (let ((r (find-restart 'my-restart)))
            (format t "~S is named ~S" r (restart-name r)))
        (my-restart () nil))
     ▷ #<RESTART 32307325> is named MY-RESTART
     → NIL
      (find-restart 'my-restart)
     → NIL

Affected By:
............

Existing restarts.

‘restart-case’, ‘restart-bind’, ‘with-condition-restarts’.

See Also:
.........

*note compute-restarts::

Notes:
......

      (find-restart IDENTIFIER)
      ≡ (find IDENTIFIER (compute-restarts) :key :restart-name)

Although anonymous restarts have a name of ‘nil’, the consequences are
unspecified if ‘nil’ is given as an IDENTIFIER.  Occasionally,
programmers lament that ‘nil’ is not permissible as an IDENTIFIER
argument.  In most such cases, ‘compute-restarts’ can probably be used
to simulate the desired effect.


File: ansicl,  Node: invoke-restart,  Next: invoke-restart-interactively,  Prev: find-restart,  Up: Conditions

invoke-restart (Function)
=========================

Syntax:
.......

 -- Function: invoke-restart restart &rest arguments → {result}*

Arguments and Values:
.....................

RESTART—a restart designator.

ARGUMENT—an object.

RESULTS—the values returned by the function associated with RESTART, if
that function returns.

Description:
............

Calls the function associated with RESTART, passing ARGUMENTS to it.
RESTART must be valid in the current dynamic environment.

Examples:
.........

      (defun add3 (x) (check-type x number) (+ x 3))

      (foo 'seven)
     ▷ Error: The value SEVEN was not of type NUMBER.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Specify a different value to use.
     ▷  2: Return to Lisp Toplevel.
     ▷ Debug> (invoke-restart 'store-value 7)
     → 10

Side Effects:
.............

A non-local transfer of control might be done by the restart.

Affected By:
............

Existing restarts.

Exceptional Situations:
.......................

If RESTART is not valid, an error of type ‘control-error’ is signaled.

See Also:
.........

*note find-restart::, *note restart-bind::, *note restart-case::, *note
invoke-restart-interactively::

Notes:
......

The most common use for ‘invoke-restart’ is in a handler.  It might be
used explicitly, or implicitly through ‘invoke-restart-interactively’ or
a restart function.

Restart functions call ‘invoke-restart’, not vice versa.  That is,
invoke-restart provides primitive functionality, and restart functions
are non-essential “syntactic sugar.”


File: ansicl,  Node: invoke-restart-interactively,  Next: restart-bind,  Prev: invoke-restart,  Up: Conditions

invoke-restart-interactively (Function)
=======================================

Syntax:
.......

 -- Function: invoke-restart-interactively restart → {result}*

Arguments and Values:
.....................

RESTART—a restart designator.

RESULTS—the values returned by the function associated with RESTART, if
that function returns.

Description:
............

‘invoke-restart-interactively’ calls the function associated with
RESTART, prompting for any necessary arguments.  If RESTART is a name,
it must be valid in the current dynamic environment.

‘invoke-restart-interactively’ prompts for arguments by executing the
code provided in the :interactive keyword to ‘restart-case’ or
:interactive-function keyword to ‘restart-bind’.

If no such options have been supplied in the corresponding
‘restart-bind’ or ‘restart-case’, then the consequences are undefined if
the RESTART takes required arguments.  If the arguments are optional, an
argument list of ‘nil’ is used.

Once the arguments have been determined, ‘invoke-restart-interactively’
executes the following:

      (apply #'invoke-restart restart arguments)

Examples:
.........

      (defun add3 (x) (check-type x number) (+ x 3))

      (add3 'seven)
     ▷ Error: The value SEVEN was not of type NUMBER.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Specify a different value to use.
     ▷  2: Return to Lisp Toplevel.
     ▷ Debug> (invoke-restart-interactively 'store-value)
     ▷ Type a form to evaluate and use: 7
     → 10

Side Effects:
.............

If prompting for arguments is necesary, some typeout may occur (on query
I/O).

A non-local transfer of control might be done by the restart.

Affected By:
............

‘*query-io*’, active restarts

Exceptional Situations:
.......................

If RESTART is not valid, an error of type ‘control-error’ is signaled.

See Also:
.........

*note find-restart::, *note invoke-restart::, *note restart-case::,
*note restart-bind::

Notes:
......

‘invoke-restart-interactively’ is used internally by the debugger and
may also be useful in implementing other portable, interactive debugging
tools.


File: ansicl,  Node: restart-bind,  Next: restart-case,  Prev: invoke-restart-interactively,  Up: Conditions

restart-bind (Macro)
====================

Syntax:
.......

 -- Macro: restart-bind ({(name function {↓key-val-pair}*)}) {form}* →
          {result}*

KEY-VAL-PAIR::=
     :interactive-function interactive-function |
     :report-function report-function |
     :test-function test-function

Arguments and Values:
.....................

NAME—a symbol; not evaluated.

FUNCTION—a form; evaluated.

FORMS—an implicit progn.

INTERACTIVE-FUNCTION—a form; evaluated.

REPORT-FUNCTION—a form; evaluated.

TEST-FUNCTION—a form; evaluated.

RESULTS—the values returned by the forms.

Description:
............

‘restart-bind’ executes the body of FORMS in a dynamic environment where
restarts with the given NAMES are in effect.

If a NAME is ‘nil’, it indicates an anonymous restart; if a NAME is a
non-nil symbol, it indicates a named restart.

The FUNCTION, INTERACTIVE-FUNCTION, and REPORT-FUNCTION are
unconditionally evaluated in the current lexical and dynamic environment
prior to evaluation of the body.  Each of these forms must evaluate to a
function.

If ‘invoke-restart’ is done on that restart, the function which resulted
from evaluating FUNCTION is called, in the dynamic environment of the
‘invoke-restart’, with the arguments given to ‘invoke-restart’.  The
function may either perform a non-local transfer of control or may
return normally.

If the restart is invoked interactively from the debugger (using
‘invoke-restart-interactively’), the arguments are defaulted by calling
the function which resulted from evaluating INTERACTIVE-FUNCTION.  That
function may optionally prompt interactively on query I/O, and should
return a list of arguments to be used by ‘invoke-restart-interactively’
when invoking the restart.

If a restart is invoked interactively but no INTERACTIVE-FUNCTION is
used, then an argument list of ‘nil’ is used.  In that case, the
function must be compatible with an empty argument list.

If the restart is presented interactively (e.g., by the debugger), the
presentation is done by calling the function which resulted from
evaluating REPORT-FUNCTION.  This function must be a function of one
argument, a stream.  It is expected to print a description of the action
that the restart takes to that stream.  This function is called any time
the restart is printed while ‘*print-escape*’ is ‘nil’.

In the case of interactive invocation, the result is dependent on the
value of :interactive-function as follows.

:interactive-function

     VALUE is evaluated in the current lexical environment and should
     return a function of no arguments which constructs a list of
     arguments to be used by ‘invoke-restart-interactively’ when
     invoking this restart.  The function may prompt interactively using
     query I/O if necessary.

:report-function

     VALUE is evaluated in the current lexical environment and should
     return a function of one argument, a stream, which prints on the
     stream a summary of the action that this restart takes.  This
     function is called whenever the restart is reported (printed while
     ‘*print-escape*’ is ‘nil’).  If no :report-function option is
     provided, the manner in which the restart is reported is
     implementation-dependent.

:test-function

     VALUE is evaluated in the current lexical environment and should
     return a function of one argument, a condition, which returns true
     if the restart is to be considered visible.

Affected By:
............

‘*query-io*’.

See Also:
.........

*note restart-case::, *note with-simple-restart::

Notes:
......

‘restart-bind’ is primarily intended to be used to implement
‘restart-case’ and might be useful in implementing other macros.
Programmers who are uncertain about whether to use ‘restart-case’ or
‘restart-bind’ should prefer ‘restart-case’ for the cases where it is
powerful enough, using ‘restart-bind’ only in cases where its full
generality is really needed.


File: ansicl,  Node: restart-case,  Next: restart-name,  Prev: restart-bind,  Up: Conditions

restart-case (Macro)
====================

Syntax:
.......

 -- Macro: restart-case restartable-form {↓clause} → {result}*

CLAUSE::=
     ( case-name lambda-list
      〚:interactive interactive-expression | :report report-expression
     | :test test-expression〛
      {declaration}* {form}*)

Arguments and Values:
.....................

RESTARTABLE-FORM—a form.

CASE-NAME—a symbol or ‘nil’.

LAMBDA-LIST—an ordinary lambda list.

INTERACTIVE-EXPRESSION—a symbol or a lambda expression.

REPORT-EXPRESSION—a string, a symbol, or a lambda expression.

TEST-EXPRESSION—a symbol or a lambda expression.

DECLARATION—a declare expression; not evaluated.

FORM—a form.

RESULTS—the values resulting from the evaluation of RESTARTABLE-FORM, or
the values returned by the last FORM executed in a chosen clause, or
‘nil’.

Description:
............

‘restart-case’ evaluates RESTARTABLE-FORM in a dynamic environment where
the clauses have special meanings as points to which control may be
transferred.  If RESTARTABLE-FORM finishes executing and returns any
values, all values returned are returned by ‘restart-case’ and
processing has completed.  While RESTARTABLE-FORM is executing, any code
may transfer control to one of the clauses (see ‘invoke-restart’).  If a
transfer occurs, the forms in the body of that clause is evaluated and
any values returned by the last such form are returned by
‘restart-case’.  In this case, the dynamic state is unwound
appropriately (so that the restarts established around the
RESTARTABLE-FORM are no longer active) prior to execution of the clause.

If there are no FORMS in a selected clause, ‘restart-case’ returns
‘nil’.

If CASE-NAME is a symbol, it names this restart.

It is possible to have more than one clause use the same CASE-NAME.  In
this case, the first clause with that name is found by ‘find-restart’.
The other clauses are accessible using ‘compute-restarts’.

Each ARGLIST is an ordinary lambda list to be bound during the execution
of its corresponding FORMS.  These parameters are used by the
‘restart-case’ clause to receive any necessary data from a call to
‘invoke-restart’.

By default, ‘invoke-restart-interactively’ passes no arguments and all
arguments must be optional in order to accomodate interactive
restarting.  However, the arguments need not be optional if the
:interactive keyword has been used to inform
‘invoke-restart-interactively’ about how to compute a proper argument
list.

KEYWORD options have the following meaning.

:interactive

     The VALUE supplied by ‘:interactive VALUE’ must be a suitable
     argument to ‘function’.  ‘(function VALUE)’ is evaluated in the
     current lexical environment.  It should return a function of no
     arguments which returns arguments to be used by
     ‘invoke-restart-interactively’ when it is invoked.
     ‘invoke-restart-interactively’ is called in the dynamic environment
     available prior to any restart attempt, and uses query I/O for user
     interaction.

     If a restart is invoked interactively but no :interactive option
     was supplied, the argument list used in the invocation is the empty
     list.

:report

     If the VALUE supplied by ‘:report VALUE’ is a lambda expression or
     a symbol, it must be acceptable to ‘function’.  ‘(function VALUE)’
     is evaluated in the current lexical environment.  It should return
     a function of one argument, a stream, which prints on the stream a
     description of the restart.  This function is called whenever the
     restart is printed while ‘*print-escape*’ is ‘nil’.

     If VALUE is a string, it is a shorthand for

           (lambda (stream) (write-string value stream))

     If a named restart is asked to report but no report information has
     been supplied, the name of the restart is used in generating
     default report text.

     When ‘*print-escape*’ is ‘nil’, the printer uses the report
     information for a restart.  For example, a debugger might announce
     the action of typing a “continue” command by:

           (format t "~&~S -- ~A~%" ':continue some-restart)

     which might then display as something like:

           :CONTINUE -- Return to command level

     The consequences are unspecified if an unnamed restart is specified
     but no :report option is provided.

:test

     The VALUE supplied by ‘:test VALUE’ must be a suitable argument to
     ‘function’.  ‘(function VALUE)’ is evaluated in the current lexical
     environment.  It should return a function of one argument, the
     condition, that returns true if the restart is to be considered
     visible.

     The default for this option is equivalent to ‘(lambda (c) (declare
     (ignore c)) t)’.

If the RESTARTABLE-FORM is a list whose car is any of the symbols
‘signal’, ‘error’, ‘cerror’, or ‘warn’ (or is a macro form which
macroexpands into such a list), then ‘with-condition-restarts’ is used
implicitly to associate the indicated restarts with the condition to be
signaled.

Examples:
.........

      (restart-case
          (handler-bind ((error #'(lambda (c)
                                  (declare (ignore condition))
                                  (invoke-restart 'my-restart 7))))
            (error "Foo."))
        (my-restart (&optional v) v))
     → 7

      (define-condition food-error (error) ())
     → FOOD-ERROR
      (define-condition bad-tasting-sundae (food-error)
        ((ice-cream :initarg :ice-cream :reader bad-tasting-sundae-ice-cream)
         (sauce :initarg :sauce :reader bad-tasting-sundae-sauce)
         (topping :initarg :topping :reader bad-tasting-sundae-topping))
        (:report (lambda (condition stream)
                   (format stream "Bad tasting sundae with ~S, ~S, and ~S"
                           (bad-tasting-sundae-ice-cream condition)
                           (bad-tasting-sundae-sauce condition)
                           (bad-tasting-sundae-topping condition)))))
     → BAD-TASTING-SUNDAE
      (defun all-start-with-same-letter (symbol1 symbol2 symbol3)
        (let ((first-letter (char (symbol-name symbol1) 0)))
          (and (eql first-letter (char (symbol-name symbol2) 0))
               (eql first-letter (char (symbol-name symbol3) 0)))))
     → ALL-START-WITH-SAME-LETTER
      (defun read-new-value ()
        (format t "Enter a new value: ")
        (multiple-value-list (eval (read))))
     → READ-NEW-VALUE
      (defun verify-or-fix-perfect-sundae (ice-cream sauce topping)
        (do ()
           ((all-start-with-same-letter ice-cream sauce topping))
          (restart-case
            (error 'bad-tasting-sundae
                   :ice-cream ice-cream
                   :sauce sauce
                   :topping topping)
            (use-new-ice-cream (new-ice-cream)
              :report "Use a new ice cream."
              :interactive read-new-value
              (setq ice-cream new-ice-cream))
            (use-new-sauce (new-sauce)
              :report "Use a new sauce."
              :interactive read-new-value
              (setq sauce new-sauce))
            (use-new-topping (new-topping)
              :report "Use a new topping."
              :interactive read-new-value
              (setq topping new-topping))))
        (values ice-cream sauce topping))
     → VERIFY-OR-FIX-PERFECT-SUNDAE
      (verify-or-fix-perfect-sundae 'vanilla 'caramel 'cherry)
     ▷ Error: Bad tasting sundae with VANILLA, CARAMEL, and CHERRY.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Use a new ice cream.
     ▷  2: Use a new sauce.
     ▷  3: Use a new topping.
     ▷  4: Return to Lisp Toplevel.
     ▷ Debug> :continue 1
     ▷ Use a new ice cream.
     ▷ Enter a new ice cream: 'chocolate
     → CHOCOLATE, CARAMEL, CHERRY

See Also:
.........

*note restart-bind::, *note with-simple-restart::.

Notes:
......

      (restart-case expression
         (name1 arglist1 ...options1... . body1)
         (name2 arglist2 ...options2... . body2))

is essentially equivalent to

      (block #1=#:g0001
        (let ((#2=#:g0002 nil))
             (tagbody
             (restart-bind ((name1 #'(lambda (&rest temp)
                                     (setq #2# temp)
                                     (go #3=#:g0003))
                               ...slightly-transformed-options1...)
                            (name2 #'(lambda (&rest temp)
                                     (setq #2# temp)
                                     (go #4=#:g0004))
                               ...slightly-transformed-options2...))
             (return-from #1# expression))
               #3# (return-from #1#
                       (apply #'(lambda arglist1 . body1) #2#))
               #4# (return-from #1#
                       (apply #'(lambda arglist2 . body2) #2#)))))

Unnamed restarts are generally only useful interactively and an
interactive option which has no description is of little value.
Implementations are encouraged to warn if an unnamed restart is used and
no report information is provided at compilation time.  At runtime, this
error might be noticed when entering the debugger.  Since signaling an
error would probably cause recursive entry into the debugger (causing
yet another recursive error, etc.)  it is suggested that the debugger
print some indication of such problems when they occur but not actually
signal errors.

      (restart-case (signal fred)
        (a ...)
        (b ...))
      ≡
      (restart-case
          (with-condition-restarts fred
                                   (list (find-restart 'a)
                                         (find-restart 'b))
            (signal fred))
        (a ...)
        (b ...))


File: ansicl,  Node: restart-name,  Next: with-condition-restarts,  Prev: restart-case,  Up: Conditions

restart-name (Function)
=======================

Syntax:
.......

 -- Function: restart-name restart → name

Arguments and Values:
.....................

RESTART—a restart.

NAME—a symbol.

Description:
............

Returns the name of the RESTART, or ‘nil’ if the RESTART is not named.

Examples:
.........

      (restart-case
          (loop for restart in (compute-restarts)
                    collect (restart-name restart))
        (case1 () :report "Return 1." 1)
        (nil   () :report "Return 2." 2)
        (case3 () :report "Return 3." 3)
        (case1 () :report "Return 4." 4))
     → (CASE1 NIL CASE3 CASE1 ABORT)
      ;; In the example above the restart named ABORT was not created
      ;; explicitly, but was implicitly supplied by the system.

See Also:
.........

*note compute-restarts:: *note find-restart::


File: ansicl,  Node: with-condition-restarts,  Next: with-simple-restart,  Prev: restart-name,  Up: Conditions

with-condition-restarts (Macro)
===============================

Syntax:
.......

 -- Macro: with-condition-restarts condition-form restarts-form {form}*
          → {result}*

Arguments and Values:
.....................

CONDITION-FORM—a form; evaluated to produce a CONDITION.

CONDITION—a condition object resulting from the evaluation of
CONDITION-FORM.

RESTART-FORM—a form; evaluated to produce a RESTART-LIST.

RESTART-LIST—a list of restart objects resulting from the evaluation of
RESTART-FORM.

FORMS—an implicit progn; evaluated.

RESULTS—the values returned by FORMS.

Description:
............

First, the CONDITION-FORM and RESTARTS-FORM are evaluated in normal
left-to-right order; the primary values yielded by these evaluations are
respectively called the CONDITION and the RESTART-LIST.

Next, the FORMS are evaluated in a dynamic environment in which each
restart in RESTART-LIST is associated with the CONDITION.  See *note
Section 9.1.4.2.4 (Associating a Restart with a Condition):
AssocRestartWithCond.

See Also:
.........

*note restart-case::

Notes:
......

Usually this macro is not used explicitly in code, since ‘restart-case’
handles most of the common cases in a way that is syntactically more
concise.


File: ansicl,  Node: with-simple-restart,  Next: abort (Restart),  Prev: with-condition-restarts,  Up: Conditions

with-simple-restart (Macro)
===========================

Syntax:
.......

 -- Macro: with-simple-restart (name format-control {format-argument}*)
          {form}* → {result}*

Arguments and Values:
.....................

NAME—a symbol.

FORMAT-CONTROL—a format control.

FORMAT-ARGUMENT—an object (i.e., a format argument).

FORMS—an implicit progn.

RESULTS—in the normal situation, the values returned by the FORMS; in
the exceptional situation where the restart named NAME is invoked, two
values—‘nil’ and ‘t’.

Description:
............

‘with-simple-restart’ establishes a restart.

If the restart designated by NAME is not invoked while executing FORMS,
all values returned by the last of FORMS are returned.  If the restart
designated by NAME is invoked, control is transferred to
‘with-simple-restart’, which returns two values, ‘nil’ and ‘t’.

If NAME is ‘nil’, an anonymous restart is established.

The FORMAT-CONTROL and FORMAT-ARGUMENTS are used report the restart.

Examples:
.........

      (defun read-eval-print-loop (level)
        (with-simple-restart (abort "Exit command level ~D." level)
          (loop
            (with-simple-restart (abort "Return to command level ~D." level)
              (let ((form (prog2 (fresh-line) (read) (fresh-line))))
                (prin1 (eval form)))))))
     → READ-EVAL-PRINT-LOOP
      (read-eval-print-loop 1)
      (+ 'a 3)
     ▷ Error: The argument, A, to the function + was of the wrong type.
     ▷        The function expected a number.
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Specify a value to use this time.
     ▷  2: Return to command level 1.
     ▷  3: Exit command level 1.
     ▷  4: Return to Lisp Toplevel.

      (defun compute-fixnum-power-of-2 (x)
        (with-simple-restart (nil "Give up on computing 2^~D." x)
          (let ((result 1))
            (dotimes (i x result)
              (setq result (* 2 result))
              (unless (fixnump result)
                (error "Power of 2 is too large."))))))
     COMPUTE-FIXNUM-POWER-OF-2
      (defun compute-power-of-2 (x)
        (or (compute-fixnum-power-of-2 x) 'something big))
     COMPUTE-POWER-OF-2
      (compute-power-of-2 10)
     1024
      (compute-power-of-2 10000)
     ▷ Error: Power of 2 is too large.
     ▷ To continue, type :CONTINUE followed by an option number.
     ▷  1: Give up on computing 2^10000.
     ▷  2: Return to Lisp Toplevel
     ▷ Debug> :continue 1
     → SOMETHING-BIG

See Also:
.........

*note restart-case::

Notes:
......

‘with-simple-restart’ is shorthand for one of the most common uses of
‘restart-case’.

‘with-simple-restart’ could be defined by:

      (defmacro with-simple-restart ((restart-name format-control
                                                   &rest format-arguments)
                                     &body forms)
        `(restart-case (progn ,@forms)
           (,restart-name ()
               :report (lambda (stream)
                         (format stream ,format-control ,@format-arguments))
              (values nil t))))

Because the second return value is ‘t’ in the exceptional case, it is
common (but not required) to arrange for the second return value in the
normal case to be missing or ‘nil’ so that the two situations can be
distinguished.


File: ansicl,  Node: abort (Restart),  Next: continue (Restart),  Prev: with-simple-restart,  Up: Conditions

abort (Restart)
===============

Data Arguments Required:
........................

None.

Description:
............

The intent of the abort restart is to allow return to the innermost
“command level.” Implementors are encouraged to make sure that there is
always a restart named ‘abort’ around any user code so that user code
can call ‘abort’ at any time and expect something reasonable to happen;
exactly what the reasonable thing is may vary somewhat.  Typically, in
an interactive listener, the invocation of ‘abort’ returns to the Lisp
reader phase of the Lisp read-eval-print loop, though in some batch or
multi-processing situations there may be situations in which having it
kill the running process is more appropriate.

See Also:
.........

*note Section 9.1.4.2 (Restarts): Restarts, *note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *note invoke-restart::,
*note abort:: (function)


File: ansicl,  Node: continue (Restart),  Next: muffle-warning (Restart),  Prev: abort (Restart),  Up: Conditions

continue (Restart)
==================

Data Arguments Required:
........................

None.

Description:
............

the ‘continue’ restart is generally part of protocols where there is a
single “obvious” way to continue, such as in ‘break’ and ‘cerror’.  Some
user-defined protocols may also wish to incorporate it for similar
reasons.  In general, however, it is more reliable to design a special
purpose restart with a name that more directly suits the particular
application.

Examples:
.........

      (let ((x 3))
        (handler-bind ((error #'(lambda (c)
                                  (let ((r (find-restart 'continue c)))
                                    (when r (invoke-restart r))))))
          (cond ((not (floatp x))
                 (cerror "Try floating it." "~D is not a float." x)
                 (float x))
                (t x)))) → 3.0

See Also:
.........

*note Section 9.1.4.2 (Restarts): Restarts, *note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *note invoke-restart::,
*note continue:: (function), *note assert::, *note cerror::


File: ansicl,  Node: muffle-warning (Restart),  Next: store-value (Restart),  Prev: continue (Restart),  Up: Conditions

muffle-warning (Restart)
========================

Data Arguments Required:
........................

None.

Description:
............

This restart is established by ‘warn’ so that handlers of ‘warning’
conditions have a way to tell ‘warn’ that a warning has already been
dealt with and that no further action is warranted.

Examples:
.........

      (defvar *all-quiet* nil) → *ALL-QUIET*
      (defvar *saved-warnings* '()) → *SAVED-WARNINGS*
      (defun quiet-warning-handler (c)
        (when *all-quiet*
          (let ((r (find-restart 'muffle-warning c)))
            (when r
              (push c *saved-warnings*)
              (invoke-restart r)))))
     → CUSTOM-WARNING-HANDLER
      (defmacro with-quiet-warnings (&body forms)
        `(let ((*all-quiet* t)
               (*saved-warnings* '()))
           (handler-bind ((warning #'quiet-warning-handler))
             ,@forms
             *saved-warnings*)))
     → WITH-QUIET-WARNINGS
      (setq saved
        (with-quiet-warnings
          (warn "Situation #1.")
          (let ((*all-quiet* nil))
            (warn "Situation #2."))
          (warn "Situation #3.")))
     ▷ Warning: Situation #2.
     → (#<SIMPLE-WARNING 42744421> #<SIMPLE-WARNING 42744365>)
      (dolist (s saved) (format t "~&~A~%" s))
     ▷ Situation #3.
     ▷ Situation #1.
     → NIL

See Also:
.........

*note Section 9.1.4.2 (Restarts): Restarts, *note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *note invoke-restart::,
*note muffle-warning:: (function), *note warn::


File: ansicl,  Node: store-value (Restart),  Next: use-value (Restart),  Prev: muffle-warning (Restart),  Up: Conditions

store-value (Restart)
=====================

Data Arguments Required:
........................

a value to use instead (on an ongoing basis).

Description:
............

the ‘store-value’ restart is generally used by handlers trying to
recover from errors of types such as ‘cell-error’ or ‘type-error’, which
may wish to supply a replacement datum to be stored permanently.

Examples:
.........

      (defun type-error-auto-coerce (c)
        (when (typep c 'type-error)
          (let ((r (find-restart 'store-value c)))
            (handler-case (let ((v (coerce (type-error-datum c)
                                           (type-error-expected-type c))))
                            (invoke-restart r v))
              (error ()))))) → TYPE-ERROR-AUTO-COERCE
      (let ((x 3))
        (handler-bind ((type-error #'type-error-auto-coerce))
          (check-type x float)
          x)) → 3.0

See Also:
.........

*note Section 9.1.4.2 (Restarts): Restarts, *note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *note invoke-restart::,
*note store-value:: (function), *note ccase::, *note check-type::, *note
ctypecase::, *note use-value:: (function and restart)


File: ansicl,  Node: use-value (Restart),  Next: abort; continue; muffle-warning; store-value; use-value,  Prev: store-value (Restart),  Up: Conditions

use-value (Restart)
===================

Data Arguments Required:
........................

a value to use instead (once).

Description:
............

the ‘use-value’ restart is generally used by handlers trying to recover
from errors of types such as ‘cell-error’, where the handler may wish to
supply a replacement datum for one-time use.

See Also:
.........

*note Section 9.1.4.2 (Restarts): Restarts, *note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *note invoke-restart::,
*note use-value:: (function), *note store-value:: (function and restart)


File: ansicl,  Node: abort; continue; muffle-warning; store-value; use-value,  Prev: use-value (Restart),  Up: Conditions

abort, continue, muffle-warning, store-value, use-value (Function)
==================================================================

Syntax:
.......

 -- Function: abort &optional condition →|
 -- Function: continue &optional condition → ‘nil’
 -- Function: muffle-warning &optional condition →|
 -- Function: store-value value &optional condition → ‘nil’
 -- Function: use-value value &optional condition → ‘nil’

Arguments and Values:
.....................

VALUE—an object.

CONDITION—a condition object, or ‘nil’.

Description:
............

Transfers control to the most recently established applicable restart
having the same name as the function.  That is, the function ‘abort’
searches for an applicable abort restart, the function ‘continue’
searches for an applicable continue restart, and so on.

If no such restart exists, the functions ‘continue’, ‘store-value’, and
‘use-value’ return ‘nil’, and the functions ‘abort’ and ‘muffle-warning’
signal an error of type ‘control-error’.

When CONDITION is non-nil, only those restarts are considered that are
either explicitly associated with that CONDITION, or not associated with
any condition; that is, the excluded restarts are those that are
associated with a non-empty set of conditions of which the given
CONDITION is not an element.  If CONDITION is ‘nil’, all restarts are
considered.

Examples:
.........

     ;;; Example of the ABORT retart

      (defmacro abort-on-error (&body forms)
        `(handler-bind ((error #'abort))
           ,@forms)) → ABORT-ON-ERROR
      (abort-on-error (+ 3 5)) → 8
      (abort-on-error (error "You lose."))
     ▷ Returned to Lisp Top Level.

     ;;; Example of the CONTINUE restart

      (defun real-sqrt (n)
        (when (minusp n)
          (setq n (- n))
          (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
        (sqrt n))

      (real-sqrt 4) → 2
      (real-sqrt -9)
     ▷ Error: Tried to take sqrt(-9).
     ▷ To continue, type :CONTINUE followed by an option number:
     ▷  1: Return sqrt(9) instead.
     ▷  2: Return to Lisp Toplevel.
     ▷ Debug> (continue)
     ▷ Return sqrt(9) instead.
     → 3

      (handler-bind ((error #'(lambda (c) (continue))))
        (real-sqrt -9)) → 3

     ;;; Example of the MUFFLE-WARNING restart

      (defun count-down (x)
        (do ((counter x (1- counter)))
            ((= counter 0) 'done)
          (when (= counter 1)
            (warn "Almost done"))
          (format t "~&~D~%" counter)))
     → COUNT-DOWN
      (count-down 3)
     ▷ 3
     ▷ 2
     ▷ Warning: Almost done
     ▷ 1
     → DONE
      (defun ignore-warnings-while-counting (x)
        (handler-bind ((warning #'ignore-warning))
          (count-down x)))
     → IGNORE-WARNINGS-WHILE-COUNTING
      (defun ignore-warning (condition)
        (declare (ignore condition))
        (muffle-warning))
     → IGNORE-WARNING
      (ignore-warnings-while-counting 3)
     ▷ 3
     ▷ 2
     ▷ 1
     → DONE

     ;;; Example of the STORE-VALUE and USE-VALUE restarts

      (defun careful-symbol-value (symbol)
        (check-type symbol symbol)
        (restart-case (if (boundp symbol)
                          (return-from careful-symbol-value
                                       (symbol-value symbol))
                          (error 'unbound-variable
                                 :name symbol))
          (use-value (value)
            :report "Specify a value to use this time."
            value)
          (store-value (value)
            :report "Specify a value to store and use in the future."
            (setf (symbol-value symbol) value))))
      (setq a 1234) → 1234
      (careful-symbol-value 'a) → 1234
      (makunbound 'a) → A
      (careful-symbol-value 'a)
     ▷ Error: A is not bound.
     ▷ To continue, type :CONTINUE followed by an option number.
     ▷  1: Specify a value to use this time.
     ▷  2: Specify a value to store and use in the future.
     ▷  3: Return to Lisp Toplevel.
     ▷ Debug> (use-value 12)
     → 12
      (careful-symbol-value 'a)
     ▷ Error: A is not bound.
     ▷ To continue, type :CONTINUE followed by an option number.
     ▷   1: Specify a value to use this time.
     ▷   2: Specify a value to store and use in the future.
     ▷   3: Return to Lisp Toplevel.
     ▷ Debug> (store-value 24)
     → 24
      (careful-symbol-value 'a)
     → 24

     ;;; Example of the USE-VALUE restart

      (defun add-symbols-with-default (default &rest symbols)
        (handler-bind ((sys:unbound-symbol
                         #'(lambda (c)
                             (declare (ignore c))
                             (use-value default))))
          (apply #'+ (mapcar #'careful-symbol-value symbols))))
     → ADD-SYMBOLS-WITH-DEFAULT
      (setq x 1 y 2) → 2
      (add-symbols-with-default 3 'x 'y 'z) → 6



Side Effects:
.............

A transfer of control may occur if an appropriate restart is available,
or (in the case of the function ‘abort’ or the function
‘muffle-warning’) execution may be stopped.

Affected By:
............

Each of these functions can be affected by the presence of a restart
having the same name.

Exceptional Situations:
.......................

If an appropriate abort restart is not available for the function
‘abort’, or an appropriate muffle-warning restart is not available for
the function ‘muffle-warning’, an error of type ‘control-error’ is
signaled.

See Also:
.........

*note invoke-restart::, *note Section 9.1.4.2 (Restarts): Restarts,
*note Section 9.1.4.2.2 (Interfaces to Restarts): InterfacesToRestarts,
*note assert::, *note ccase::, *note cerror::, *note check-type::, *note
ctypecase::, *note use-value::, *note warn::

Notes:
......

      (abort condition) ≡ (invoke-restart 'abort)
      (muffle-warning)  ≡ (invoke-restart 'muffle-warning)
      (continue)        ≡ (let ((r (find-restart 'continue))) (if r (invoke-restart r)))
      (use-value X) ≡ (let ((r (find-restart 'use-value))) (if r (invoke-restart r X)))
      (store-value x) ≡ (let ((r (find-restart 'store-value))) (if r (invoke-restart r X)))

No functions defined in this specification are required to provide a
use-value restart.


File: ansicl,  Node: Symbols,  Next: Packages,  Prev: Conditions,  Up: Top

10 Symbols
**********

* Menu:

* Symbol Concepts::

Dictionary

* symbol::
* keyword::
* symbolp::
* keywordp::
* make-symbol::
* copy-symbol::
* gensym::
* *gensym-counter*::
* gentemp::
* symbol-function::
* symbol-name::
* symbol-package::
* symbol-plist::
* symbol-value::
* get::
* remprop::
* boundp::
* makunbound::
* set::
* unbound-variable::


File: ansicl,  Node: Symbol Concepts,  Next: symbol,  Up: Symbols

10.1 Symbol Concepts
====================

The next figure lists some defined names that are applicable to the
property lists of symbols.

get   remprop   symbol-plist

Figure 10.1: Property list defined names

The next figure lists some defined names that are applicable to the
creation of and inquiry about symbols.

copy-symbol   keywordp      symbol-package
gensym        make-symbol   symbol-value
gentemp       symbol-name

Figure 10.2: Symbol creation and inquiry defined names


File: ansicl,  Node: symbol,  Next: keyword,  Prev: Symbol Concepts,  Up: Symbols

symbol (System Class)
=====================

Class Precedence List:
......................

‘symbol’, ‘t’

Description:
............

Symbols are used for their object identity to name various entities in
Common Lisp, including (but not limited to) linguistic entities such as
variables and functions.

Symbols can be collected together into packages.  A symbol is said to be
interned in a package if it is accessible in that package; the same
symbol can be interned in more than one package.  If a symbol is not
interned in any package, it is called uninterned.

An interned symbol is uniquely identifiable by its name from any package
in which it is accessible.

Symbols have the following attributes.  For historical reasons, these
are sometimes referred to as cells, although the actual internal
representation of symbols and their attributes is
implementation-dependent.

Name

     The name of a symbol is a string used to identify the symbol.
     Every symbol has a name, and the consequences are undefined if that
     name is altered.  The name is used as part of the external, printed
     representation of the symbol; see *note Section 2.1 (Character
     Syntax): Character Syntax.  The function ‘symbol-name’ returns the
     name of a given symbol.  A symbol may have any character in its
     name.

Package

     The object in this cell is called the home package of the symbol.
     If the home package is ‘nil’, the symbol is sometimes said to have
     no home package.

     When a symbol is first created, it has no home package.  When it is
     first interned, the package in which it is initially interned
     becomes its home package.  The home package of a symbol can be
     accessed by using the function ‘symbol-package’.

     If a symbol is uninterned from the package which is its home
     package, its home package is set to ‘nil’.  Depending on whether
     there is another package in which the symbol is interned, the
     symbol might or might not really be an uninterned symbol.  A symbol
     with no home package is therefore called apparently uninterned.

     The consequences are undefined if an attempt is made to alter the
     home package of a symbol external in the ‘COMMON-LISP’ package or
     the ‘KEYWORD’ package.

Property list

     The property list of a symbol provides a mechanism for associating
     named attributes with that symbol.  The operations for adding and
     removing entries are destructive to the property list.  Common
     Lisp provides operators both for direct manipulation of property
     list objects (e.g., see ‘getf’, ‘remf’, and ‘symbol-plist’) and for
     implicit manipulation of a symbol’s property list by reference to
     the symbol (e.g., see ‘get’ and ‘remprop’).  The property list
     associated with a fresh symbol is initially null.

Value

     If a symbol has a value attribute, it is said to be bound, and that
     fact can be detected by the function ‘boundp’.  The object
     contained in the value cell of a bound symbol is the value of the
     global variable named by that symbol, and can be accessed by the
     function ‘symbol-value’.  A symbol can be made to be unbound by the
     function ‘makunbound’.

     The consequences are undefined if an attempt is made to change the
     value of a symbol that names a constant variable, or to make such a
     symbol be unbound.

Function

     If a symbol has a function attribute, it is said to be fbound, and
     that fact can be detected by the function ‘fboundp’.  If the symbol
     is the name of a function in the global environment, the function
     cell contains the function, and can be accessed by the function
     ‘symbol-function’.  If the symbol is the name of either a macro in
     the global environment (see ‘macro-function’) or a special operator
     (see ‘special-operator-p’), the symbol is fbound, and can be
     accessed by the function ‘symbol-function’, but the object which
     the function cell contains is of implementation-dependent type and
     purpose.  A symbol can be made to be funbound by the function
     ‘fmakunbound’.

     The consequences are undefined if an attempt is made to change the
     functional value of a symbol that names a special form.

Operations on a symbol’s value cell and function cell are sometimes
described in terms of their effect on the symbol itself, but the user
should keep in mind that there is an intimate relationship between the
contents of those cells and the global variable or global function
definition, respectively.

Symbols are used as identifiers for lexical variables and lexical
function definitions, but in that role, only their object identity is
significant.  Common Lisp provides no operation on a symbol that can
have any effect on a lexical variable or on a lexical function
definition.

See Also:
.........

*note Section 2.3.4 (Symbols as Tokens): Symbols as Tokens, *note
Section 2.3.1.1 (Potential Numbers as Tokens): PotentialNumbersAsTokens,
*note Section 22.1.3.3 (Printing Symbols): PrintingSymbols.

