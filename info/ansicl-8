This is ansicl, produced by makeinfo version 6.7 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: FORMAT Pretty Printer Operations,  Next: FORMAT Layout Control,  Prev: FORMAT Printer Operations,  Up: Formatted Output

22.3.5 FORMAT Pretty Printer Operations
---------------------------------------

The following constructs provide access to the pretty printer:

22.3.5.1 Tilde Underscore: Conditional Newline
..............................................

Without any modifiers, ‘~_’ is the same as ‘(pprint-newline :linear)’.
‘~@_’ is the same as ‘(pprint-newline :miser)’.  ‘~:_’ is the same as
‘(pprint-newline :fill)’.  ‘~:@_’ is the same as ‘(pprint-newline
:mandatory)’.

22.3.5.2 Tilde Less-Than-Sign: Logical Block
............................................

‘~<...~:>’

If ‘~:>’ is used to terminate a ‘~<...~>’, the directive is equivalent
to a call to ‘pprint-logical-block’.  The argument corresponding to the
‘~<...~:>’ directive is treated in the same way as the list argument to
‘pprint-logical-block’, thereby providing automatic support for non-list
arguments and the detection of circularity, sharing, and depth
abbreviation.  The portion of the CONTROL-STRING nested within the
‘~<...~:>’ specifies the :prefix (or :per-line-prefix), :suffix, and
body of the ‘pprint-logical-block’.

The CONTROL-STRING portion enclosed by ‘~<...~:>’ can be divided into
segments ‘~<PREFIX~;BODY~;SUFFIX~:>’ by ‘~;’ directives.  If the first
section is terminated by ‘~@;’, it specifies a per-line prefix rather
than a simple prefix.  The PREFIX and SUFFIX cannot contain format
directives.  An error is signaled if either the prefix or suffix fails
to be a constant string or if the enclosed portion is divided into more
than three segments.

If the enclosed portion is divided into only two segments, the SUFFIX
defaults to the null string.  If the enclosed portion consists of only a
single segment, both the PREFIX and the SUFFIX default to the null
string.  If the colon modifier is used (i.e., ‘~:<...~:>’), the PREFIX
and SUFFIX default to ‘"("’ and ‘")"’ (respectively) instead of the null
string.

The body segment can be any arbitrary format string.  This format string
is applied to the elements of the list corresponding to the ‘~<...~:>’
directive as a whole.  Elements are extracted from this list using
‘pprint-pop’, thereby providing automatic support for malformed lists,
and the detection of circularity, sharing, and length abbreviation.
Within the body segment, ‘~^’ acts like ‘pprint-exit-if-list-exhausted’.

‘~<...~:>’ supports a feature not supported by ‘pprint-logical-block’.
If ‘~:@>’ is used to terminate the directive (i.e., ‘~<...~:@>’), then a
fill-style conditional newline is automatically inserted after each
group of blanks immediately contained in the body (except for blanks
after a  <Newline> directive).  This makes it easy to achieve the
equivalent of paragraph filling.

If the at-sign modifier is used with ‘~<...~:>’, the entire remaining
argument list is passed to the directive as its argument.  All of the
remaining arguments are always consumed by ‘~@<...~:>’, even if they are
not all used by the format string nested in the directive.  Other than
the difference in its argument, ‘~@<...~:>’ is exactly the same as
‘~<...~:>’ except that circularity detection is not applied if
‘~@<...~:>’ is encountered at top level in a format string.  This
ensures that circularity detection is applied only to data lists, not to
format argument lists.

‘" . #N#"’ is printed if circularity or sharing has to be indicated for
its argument as a whole.

To a considerable extent, the basic form of the directive ‘~<...~>’ is
incompatible with the dynamic control of the arrangement of output by
‘~W’, ‘~_’, ‘~<...~:>’, ‘~I’, and ‘~:T’.  As a result, an error is
signaled if any of these directives is nested within ‘~<...~>’.  Beyond
this, an error is also signaled if the ‘~<...~:;...~>’ form of ‘~<...~>’
is used in the same format string with ‘~W’, ‘~_’, ‘~<...~:>’, ‘~I’, or
‘~:T’.

See also *note Section 22.3.6.2 (Tilde Less-Than-Sign.  Justification):
TildeLessThanJustification.

22.3.5.3 Tilde I: Indent
........................

‘~NI’ is the same as ‘(pprint-indent :block n)’.

‘~N:I’ is the same as ‘(pprint-indent :current n)’.  In both cases, N
defaults to zero, if it is omitted.

22.3.5.4 Tilde Slash: Call Function
...................................

‘~/NAME/’

User defined functions can be called from within a format string by
using the directive ‘~/NAME/’.  The colon modifier, the at-sign
modifier, and arbitrarily many parameters can be specified with the
‘~/NAME/’ directive.  NAME can be any arbitrary string that does not
contain a "/".  All of the characters in NAME are treated as if they
were upper case.  If NAME contains a single colon (‘:’) or double colon
(‘::’), then everything up to but not including the first ‘":"’ or
‘"::"’ is taken to be a string that names a package.  Everything after
the first ‘":"’ or ‘"::"’ (if any) is taken to be a string that names a
‘symbol’.  The function corresponding to a ‘~/name/’ directive is
obtained by looking up the symbol that has the indicated name in the
indicated package.  If NAME does not contain a ‘":"’ or ‘"::"’, then the
whole NAME string is looked up in the ‘COMMON-LISP-USER’ package.

When a ‘~/name/’ directive is encountered, the indicated function is
called with four or more arguments.  The first four arguments are: the
output stream, the format argument corresponding to the directive, a
generalized boolean that is true if the colon modifier was used, and a
generalized boolean that is true if the at-sign modifier was used.  The
remaining arguments consist of any parameters specified with the
directive.  The function should print the argument appropriately.  Any
values returned by the function are ignored.

The three functions ‘pprint-linear’, ‘pprint-fill’, and ‘pprint-tabular’
are specifically designed so that they can be called by ‘~/.../’ (i.e.,
‘~/pprint-linear/’, ‘~/pprint-fill/’, and ‘~/pprint-tabular/’).  In
particular they take colon and at-sign arguments.


File: ansicl,  Node: FORMAT Layout Control,  Next: FORMAT Control-Flow Operations,  Prev: FORMAT Pretty Printer Operations,  Up: Formatted Output

22.3.6 FORMAT Layout Control
----------------------------

22.3.6.1 Tilde T: Tabulate
..........................

This spaces over to a given column.  ‘~colnum,colincT’ will output
sufficient spaces to move the cursor to column colnum.  If the cursor is
already at or beyond column colnum, it will output spaces to move it to
column colnum+k*colinc for the smallest positive integer k possible,
unless colinc is zero, in which case no spaces are output if the cursor
is already at or beyond column colnum.  colnum and colinc default to
‘1’.

If for some reason the current absolute column position cannot be
determined by direct inquiry, ‘format’ may be able to deduce the current
column position by noting that certain directives (such as ‘~%’, or
‘~&’, or ‘~A’ with the argument being a string containing a newline)
cause the column position to be reset to zero, and counting the number
of characters emitted since that point.  If that fails, ‘format’ may
attempt a similar deduction on the riskier assumption that the
destination was at column zero when ‘format’ was invoked.  If even this
heuristic fails or is implementationally inconvenient, at worst the ‘~T’
operation will simply output two spaces.

‘~@T’ performs relative tabulation.  ‘~colrel,colinc@T’ outputs colrel
spaces and then outputs the smallest non-negative number of additional
spaces necessary to move the cursor to a column that is a multiple of
colinc.  For example, the directive ‘~3,8@T’ outputs three spaces and
then moves the cursor to a “standard multiple-of-eight tab stop” if not
at one already.  If the current output column cannot be determined,
however, then colinc is ignored, and exactly colrel spaces are output.

If the colon modifier is used with the ‘~T’ directive, the tabbing
computation is done relative to the horizontal position where the
section immediately containing the directive begins, rather than with
respect to a horizontal position of zero.  The numerical parameters are
both interpreted as being in units of ems and both default to ‘1’.
‘~N,M:T’ is the same as ‘(pprint-tab :section N M)’.  ‘~N,M:@T’ is the
same as ‘(pprint-tab :section-relative N M)’.

22.3.6.2 Tilde Less-Than-Sign: Justification
............................................

‘~mincol,colinc,minpad,padchar<str~>’

This justifies the text produced by processing str within a field at
least mincol columns wide.  str may be divided up into segments with
‘~;’, in which case the spacing is evenly divided between the text
segments.

With no modifiers, the leftmost text segment is left justified in the
field, and the rightmost text segment is right justified.  If there is
only one text element, as a special case, it is right justified.  The
‘:’ modifier causes spacing to be introduced before the first text
segment; the ‘@’ modifier causes spacing to be added after the last.
The minpad parameter (default ‘0’) is the minimum number of padding
characters to be output between each segment.  The padding character is
supplied by padchar, which defaults to the space character.  If the
total width needed to satisfy these constraints is greater than mincol,
then the width used is mincol+k*colinc for the smallest possible
non-negative integer value k.  colinc defaults to ‘1’, and mincol
defaults to ‘0’.

Note that str may include ‘format’ directives.  All the clauses in str
are processed in order; it is the resulting pieces of text that are
justified.

The ‘~^ ’ directive may be used to terminate processing of the clauses
prematurely, in which case only the completely processed clauses are
justified.

If the first clause of a ‘~<’ is terminated with ‘~:;’ instead of ‘~;’,
then it is used in a special way.  All of the clauses are processed
(subject to ‘~^ ’, of course), but the first one is not used in
performing the spacing and padding.  When the padded result has been
determined, then if it will fit on the current line of output, it is
output, and the text for the first clause is discarded.  If, however,
the padded text will not fit on the current line, then the text segment
for the first clause is output before the padded text.  The first clause
ought to contain a newline (such as a ‘~%’ directive).  The first clause
is always processed, and so any arguments it refers to will be used; the
decision is whether to use the resulting segment of text, not whether to
process the first clause.  If the ‘~:;’ has a prefix parameter n, then
the padded text must fit on the current line with n character positions
to spare to avoid outputting the first clause’s text.  For example, the
control string

      "~%;; ~{ ~<~%;; ~1:; ~S~>~^ ,~} .~%"

can be used to print a list of items separated by commas without
breaking items over line boundaries, beginning each line with ‘;; ’.
The prefix parameter ‘1’ in ‘~1:;’ accounts for the width of the comma
that will follow the justified item if it is not the last element in the
list, or the period if it is.  If ‘~:;’ has a second prefix parameter,
then it is used as the width of the line, thus overriding the natural
line width of the output stream.  To make the preceding example use a
line width of 50, one would write

      "~%;; ~{ ~<~%;; ~1,50:; ~S~>~^ ,~}  .~%"

If the second argument is not supplied, then ‘format’ uses the line
width of the DESTINATION output stream.  If this cannot be determined
(for example, when producing a string result), then ‘format’ uses ‘72’
as the line length.

See also *note Section 22.3.5.2 (Tilde Less-Than-Sign.  Logical Block):
TildeLessThanLogicalBlock.

22.3.6.3 Tilde Greater-Than-Sign: End of Justification
......................................................

‘~>’ terminates a ‘~<’.  The consequences of using it elsewhere are
undefined.


File: ansicl,  Node: FORMAT Control-Flow Operations,  Next: FORMAT Miscellaneous Operations,  Prev: FORMAT Layout Control,  Up: Formatted Output

22.3.7 FORMAT Control-Flow Operations
-------------------------------------

22.3.7.1 Tilde Asterisk: Go-To
..............................

The next arg is ignored.  ‘~n*’ ignores the next n arguments.

‘~:*’ backs up in the list of arguments so that the argument last
processed will be processed again.  ‘~n:*’ backs up n arguments.

When within a ‘~{’ construct (see below), the ignoring (in either
direction) is relative to the list of arguments being processed by the
iteration.

‘~n@*’ goes to the nth arg, where 0 means the first one; n defaults to
0, so ‘~@*’ goes back to the first arg.  Directives after a ‘~n@*’ will
take arguments in sequence beginning with the one gone to.  When within
a ‘~{’ construct, the “goto” is relative to the list of arguments being
processed by the iteration.

22.3.7.2 Tilde Left-Bracket: Conditional Expression
...................................................

‘~[str0~;str1~;...~;strn~]’

This is a set of control strings, called clauses, one of which is chosen
and used.  The clauses are separated by ‘~;’ and the construct is
terminated by ‘~]’.  For example,

‘"~[Siamese~;Manx~;Persian~] Cat"’

The argth clause is selected, where the first clause is number 0.  If a
prefix parameter is given (as ‘~n[’), then the parameter is used instead
of an argument.  If arg is out of range then no clause is selected and
no error is signaled.  After the selected alternative has been
processed, the control string continues after the ‘~]’.

‘~[str0~;str1~;...~;strn~:;default~]’ has a default case.  If the last
‘~;’ used to separate clauses is ‘~:;’ instead, then the last clause is
an else clause that is performed if no other clause is selected.  For
example:

‘"~[Siamese~;Manx~;Persian~:;Alley~] Cat"’

‘~:[ALTERNATIVE~;CONSEQUENT~]’ selects the ALTERNATIVE control string if
arg is false, and selects the CONSEQUENT control string otherwise.

‘~@[CONSEQUENT~]’ tests the argument.  If it is true, then the argument
is not used up by the ‘~[’ command but remains as the next one to be
processed, and the one clause CONSEQUENT is processed.  If the arg is
false, then the argument is used up, and the clause is not processed.
The clause therefore should normally use exactly one argument, and may
expect it to be non-nil.  For example:

      (setq *print-level* nil *print-length* 5)
      (format nil
             "~@[ print level = ~D~]~@[ print length = ~D~]"
             *print-level* *print-length*)
     →  " print length = 5"

Note also that

      (format STREAM "...~@[STR~]..." ...)
     ≡ (format STREAM "...~:[~;~:*STR~]..." ...)

The combination of ‘~[’ and ‘#’ is useful, for example, for dealing with
English conventions for printing lists:

      (setq foo "Items:~#[ none~; ~S~; ~S and ~S~
                ~:;~@{~#[~; and~] ~S~^ ,~}~].")
      (format nil foo) →  "Items: none."
      (format nil foo 'foo) →  "Items: FOO."
      (format nil foo 'foo 'bar) →  "Items: FOO and BAR."
      (format nil foo 'foo 'bar 'baz) →  "Items: FOO, BAR, and BAZ."
      (format nil foo 'foo 'bar 'baz 'quux) →  "Items: FOO, BAR, BAZ, and QUUX."

22.3.7.3 Tilde Right-Bracket: End of Conditional Expression
...........................................................

‘~]’ terminates a ‘~[’.  The consequences of using it elsewhere are
undefined.

22.3.7.4 Tilde Left-Brace: Iteration
....................................

‘~{str~}’

This is an iteration construct.  The argument should be a list, which is
used as a set of arguments as if for a recursive call to ‘format’.  The
string str is used repeatedly as the control string.  Each iteration can
absorb as many elements of the list as it likes as arguments; if str
uses up two arguments by itself, then two elements of the list will get
used up each time around the loop.  If before any iteration step the
list is empty, then the iteration is terminated.  Also, if a prefix
parameter n is given, then there will be at most n repetitions of
processing of str.  Finally, the ‘~^ ’ directive can be used to
terminate the iteration prematurely.

For example:

      (format nil "The winners are:~{ ~S~}."
              '(fred harry jill))
     → "The winners are: FRED HARRY JILL."
      (format nil "Pairs:~{ <~S,~S>~}."
              '(a 1 b 2 c 3))
     → "Pairs: <A,1> <B,2> <C,3>."

‘~:{ str~} ’ is similar, but the argument should be a list of sublists.
At each repetition step, one sublist is used as the set of arguments for
processing str; on the next repetition, a new sublist is used, whether
or not all of the last sublist had been processed.  For example:

      (format nil "Pairs:~:{ <~S,~S>~} ."
                      '((a 1) (b 2) (c 3)))
     → "Pairs: <A,1> <B,2> <C,3>."

‘~@{ str~} ’ is similar to ‘~{ str~} ’, but instead of using one
argument that is a list, all the remaining arguments are used as the
list of arguments for the iteration.  Example:

      (format nil "Pairs:~@{ <~S,~S>~} ." 'a 1 'b 2 'c 3)
     → "Pairs: <A,1> <B,2> <C,3>."

If the iteration is terminated before all the remaining arguments are
consumed, then any arguments not processed by the iteration remain to be
processed by any directives following the iteration construct.

‘~:@{ str~} ’ combines the features of ‘~:{ str~} ’ and ‘~@{ str~} ’.
All the remaining arguments are used, and each one must be a list.  On
each iteration, the next argument is used as a list of arguments to str.
Example:

      (format nil "Pairs:~:@{ <~S,~S>~} ."
                   '(a 1) '(b 2) '(c 3))
     → "Pairs: <A,1> <B,2> <C,3>."

Terminating the repetition construct with ‘~:} ’ instead of ‘~} ’ forces
str to be processed at least once, even if the initial list of arguments
is null.  However, this will not override an explicit prefix parameter
of zero.

If str is empty, then an argument is used as str.  It must be a format
control and precede any arguments processed by the iteration.  As an
example, the following are equivalent:

         (apply #'format stream string arguments)
      ≡ (format stream "~1{~:}" string arguments)

This will use ‘string’ as a formatting string.  The ‘~1{ ’ says it will
be processed at most once, and the ‘~:} ’ says it will be processed at
least once.  Therefore it is processed exactly once, using ‘arguments’
as the arguments.  This case may be handled more clearly by the ‘~?’
directive, but this general feature of ‘~{ ’ is more powerful than ‘~?’.

22.3.7.5 Tilde Right-Brace: End of Iteration
............................................

‘~}’ terminates a ‘~{’.  The consequences of using it elsewhere are
undefined.

22.3.7.6 Tilde Question-Mark: Recursive Processing
..................................................

The next arg must be a format control, and the one after it a list; both
are consumed by the ‘~?’ directive.  The two are processed as a
CONTROL-STRING, with the elements of the list as the arguments.  Once
the recursive processing has been finished, the processing of the
control string containing the ‘~?’ directive is resumed.  Example:

      (format nil "~? ~D" "<~A ~D>" '("Foo" 5) 7) → "<Foo 5> 7"
      (format nil "~? ~D" "<~A ~D>" '("Foo" 5 14) 7) → "<Foo 5> 7"

Note that in the second example three arguments are supplied to the
format string ‘"<~A ~D>"’, but only two are processed and the third is
therefore ignored.

With the ‘@’ modifier, only one arg is directly consumed.  The arg must
be a string; it is processed as part of the control string as if it had
appeared in place of the ‘~@?’ construct, and any directives in the
recursively processed control string may consume arguments of the
control string containing the ‘~@?’ directive.  Example:

      (format nil "~@? ~D" "<~A ~D>" "Foo" 5 7) → "<Foo 5> 7"
      (format nil "~@? ~D" "<~A ~D>" "Foo" 5 14 7) → "<Foo 5> 14"


File: ansicl,  Node: FORMAT Miscellaneous Operations,  Next: FORMAT Miscellaneous Pseudo-Operations,  Prev: FORMAT Control-Flow Operations,  Up: Formatted Output

22.3.8 FORMAT Miscellaneous Operations
--------------------------------------

22.3.8.1 Tilde Left-Paren: Case Conversion
..........................................

‘~(str~)’

The contained control string str is processed, and what it produces is
subject to case conversion.

With no flags, every uppercase character is converted to the
corresponding lowercase character.

‘~:(’ capitalizes all words, as if by ‘string-capitalize’.

‘~@(’ capitalizes just the first word and forces the rest to lower case.

‘~:@(’ converts every lowercase character to the corresponding uppercase
character.

In this example ‘~@(’ is used to cause the first word produced by ‘~@R’
to be capitalized:

      (format nil "~@R ~(~@R~)" 14 14)
     → "XIV xiv"
      (defun f (n) (format nil "~@(~R~) error~:P detected." n)) → F
      (f 0) → "Zero errors detected."
      (f 1) → "One error detected."
      (f 23) → "Twenty-three errors detected."

When case conversions appear nested, the outer conversion dominates, as
illustrated in the following example:

      (format nil "~@(how is ~:(BOB SMITH~)?~)")
      → "How is bob smith?"
      not→ "How is Bob Smith?"

22.3.8.2 Tilde Right-Paren: End of Case Conversion
..................................................

‘~)’ terminates a ‘~(’.  The consequences of using it elsewhere are
undefined.

22.3.8.3 Tilde P: Plural
........................

If arg is not ‘eql’ to the integer ‘1’, a lowercase ‘s’ is printed; if
arg is ‘eql’ to ‘1’, nothing is printed.  If arg is a floating-point
‘1.0’, the ‘s’ is printed.

‘~:P’ does the same thing, after doing a ‘~:*’ to back up one argument;
that is, it prints a lowercase ‘s’ if the previous argument was not ‘1’.

‘~@P’ prints ‘y’ if the argument is ‘1’, or ‘ies’ if it is not.  ‘~:@P’
does the same thing, but backs up first.

      (format nil "~D tr~:@P/~D win~:P" 7 1) → "7 tries/1 win"
      (format nil "~D tr~:@P/~D win~:P" 1 0) → "1 try/0 wins"
      (format nil "~D tr~:@P/~D win~:P" 1 3) → "1 try/3 wins"


File: ansicl,  Node: FORMAT Miscellaneous Pseudo-Operations,  Next: Additional Information about FORMAT Operations,  Prev: FORMAT Miscellaneous Operations,  Up: Formatted Output

22.3.9 FORMAT Miscellaneous Pseudo-Operations
---------------------------------------------

22.3.9.1 Tilde Semicolon: Clause Separator
..........................................

This separates clauses in ‘~[’ and ‘~<’ constructs.  The consequences of
using it elsewhere are undefined.

22.3.9.2 Tilde Circumflex: Escape Upward
........................................

‘~^ ’

This is an escape construct.  If there are no more arguments remaining
to be processed, then the immediately enclosing ‘~{ ’ or ‘~<’ construct
is terminated.  If there is no such enclosing construct, then the entire
formatting operation is terminated.  In the ‘~<’ case, the formatting is
performed, but no more segments are processed before doing the
justification.  ‘~^ ’ may appear anywhere in a ‘~{ ’ construct.

      (setq donestr "Done.~^ ~D warning~:P.~^ ~D error~:P.")
     → "Done.~^ ~D warning~:P.~^ ~D error~:P."
      (format nil donestr) → "Done."
      (format nil donestr 3) → "Done. 3 warnings."
      (format nil donestr 1 5) → "Done. 1 warning. 5 errors."

If a prefix parameter is given, then termination occurs if the parameter
is zero.  (Hence ‘~^’ is equivalent to ‘~#^’.)  If two parameters are
given, termination occurs if they are equal.  If three parameters are
given, termination occurs if the first is less than or equal to the
second and the second is less than or equal to the third.  Of course,
this is useless if all the prefix parameters are constants; at least one
of them should be a ‘#’ or a ‘V’ parameter.

If ‘~^’ is used within a ‘~:{ ’ construct, then it terminates the
current iteration step because in the standard case it tests for
remaining arguments of the current step only; the next iteration step
commences immediately.  ‘~:^’ is used to terminate the iteration
process.  ‘~:^’ may be used only if the command it would terminate is
‘~:{ ’ or ‘~:@{ ’.  The entire iteration process is terminated if and
only if the sublist that is supplying the arguments for the current
iteration step is the last sublist in the case of ‘~:{ ’, or the last
‘format’ argument in the case of ‘~:@{ ’.  ‘~:^’ is not equivalent to
‘~#:^’; the latter terminates the entire iteration if and only if no
arguments remain for the current iteration step.  For example:

      (format nil "~:{ ~@?~:^ ...~} " '(("a") ("b"))) → "a...b"

If ‘~^’ appears within a control string being processed under the
control of a ‘~?’ directive, but not within any ‘~{ ’ or ‘~<’ construct
within that string, then the string being processed will be terminated,
thereby ending processing of the ‘~?’ directive.  Processing then
continues within the string containing the ‘~?’ directive at the point
following that directive.

If ‘~^’ appears within a ‘~[’ or ‘~(’ construct, then all the commands
up to the ‘~^’ are properly selected or case-converted, the ‘~[’ or ‘~(’
processing is terminated, and the outward search continues for a ‘~{ ’
or ‘~<’ construct to be terminated.  For example:

      (setq tellstr "~@(~@[~R~]~^ ~A!~)")
     → "~@(~@[~R~]~^ ~A!~)"
      (format nil tellstr 23) → "Twenty-three!"
      (format nil tellstr nil "losers") → " Losers!"
      (format nil tellstr 23 "losers") → "Twenty-three losers!"

Following are examples of the use of ‘~^’ within a ‘~<’ construct.

      (format nil "~15<~S~;~^~S~;~^~S~>" 'foo)
     →  "            FOO"
      (format nil "~15<~S~;~^~S~;~^~S~>" 'foo 'bar)
     →  "FOO         BAR"
      (format nil "~15<~S~;~^~S~;~^~S~>" 'foo 'bar 'baz)
     →  "FOO   BAR   BAZ"

22.3.9.3 Tilde Newline: Ignored Newline
.......................................

Tilde immediately followed by a newline ignores the newline and any
following non-newline whitespaceWith a ‘:’, the newline is ignored, but
any following whitespaceWith an ‘@’, the newline is left in place, but
any following whitespaceFor example:

      (defun type-clash-error (fn nargs argnum right-type wrong-type)
        (format *error-output*
                "~&~S requires its ~:[~:R~;~*~]~
                argument to be of type ~S,~%but it was called ~
                with an argument of type ~S.~%"
                fn (eql nargs 1) argnum right-type wrong-type))
      (type-clash-error 'aref nil 2 'integer 'vector)  prints:
     AREF requires its second argument to be of type INTEGER,
     but it was called with an argument of type VECTOR.
     NIL
      (type-clash-error 'car 1 1 'list 'short-float)  prints:
     CAR requires its argument to be of type LIST,
     but it was called with an argument of type SHORT-FLOAT.
     NIL

Note that in this example newlines appear in the output only as
specified by the ‘~&’ and ‘~%’ directives; the actual newline characters
in the control string are suppressed because each is preceded by a
tilde.


File: ansicl,  Node: Additional Information about FORMAT Operations,  Next: Examples of FORMAT,  Prev: FORMAT Miscellaneous Pseudo-Operations,  Up: Formatted Output

22.3.10 Additional Information about FORMAT Operations
------------------------------------------------------

22.3.10.1 Nesting of FORMAT Operations
......................................

The case-conversion, conditional, iteration, and justification
constructs can contain other formatting constructs by bracketing them.
These constructs must nest properly with respect to each other.  For
example, it is not legitimate to put the start of a case-conversion
construct in each arm of a conditional and the end of the
case-conversion construct outside the conditional:

      (format nil "~:[abc~:@(def~;ghi~
     :@(jkl~]mno~)" x) ;Invalid!

This notation is invalid because the ‘~[...~;...~]’ and ‘~(...~)’
constructs are not properly nested.

The processing indirection caused by the ‘~?’ directive is also a kind
of nesting for the purposes of this rule of proper nesting.  It is not
permitted to start a bracketing construct within a string processed
under control of a ‘~?’ directive and end the construct at some point
after the ‘~?’ construct in the string containing that construct, or
vice versa.  For example, this situation is invalid:

      (format nil "~@?ghi~)" "abc~@(def") ;Invalid!

This notation is invalid because the ‘~?’ and ‘~(...~)’ constructs are
not properly nested.

22.3.10.2 Missing and Additional FORMAT Arguments
.................................................

The consequences are undefined if no ARG remains for a directive
requiring an argument.  However, it is permissible for one or more ARGS
to remain unprocessed by a directive; such ARGS are ignored.

22.3.10.3 Additional FORMAT Parameters
......................................

The consequences are undefined if a format directive is given more
parameters than it is described here as accepting.

22.3.10.4 Undefined FORMAT Modifier Combinations
................................................

The consequences are undefined if colon or at-sign modifiers are given
to a directive in a combination not specifically described here as being
meaningful.


File: ansicl,  Node: Examples of FORMAT,  Next: Notes about FORMAT,  Prev: Additional Information about FORMAT Operations,  Up: Formatted Output

22.3.11 Examples of FORMAT
--------------------------

      (format nil "foo") → "foo"
      (setq x 5) → 5
      (format nil "The answer is ~D." x) → "The answer is 5."
      (format nil "The answer is ~3D." x) → "The answer is   5."
      (format nil "The answer is ~3,'0D." x) → "The answer is 005."
      (format nil "The answer is ~:D." (expt 47 x))
     → "The answer is 229,345,007."
      (setq y "elephant") → "elephant"
      (format nil "Look at the ~A!" y) → "Look at the elephant!"
      (setq n 3) → 3
      (format nil "~D item~:P found." n) → "3 items found."
      (format nil "~R dog~:[s are~; is~] here." n (= n 1))
     → "three dogs are here."
      (format nil "~R dog~:*~[s are~; is~:;s are~] here." n)
     → "three dogs are here."
      (format nil "Here ~[are~;is~:;are~] ~:*~R pupp~:@P." n)
     → "Here are three puppies."

      (defun foo (x)
        (format nil "~6,2F|~6,2,1,'*F|~6,2,,'?F|~6F|~,2F|~F"
                x x x x x x)) → FOO
      (foo 3.14159)  → "  3.14| 31.42|  3.14|3.1416|3.14|3.14159"
      (foo -3.14159) → " -3.14|-31.42| -3.14|-3.142|-3.14|-3.14159"
      (foo 100.0)    → "100.00|******|100.00| 100.0|100.00|100.0"
      (foo 1234.0)   → "1234.00|******|??????|1234.0|1234.00|1234.0"
      (foo 0.006)    → "  0.01|  0.06|  0.01| 0.006|0.01|0.006"

      (defun foo (x)
         (format nil
                "~9,2,1,,'*E|~10,3,2,2,'?,,'$E|~
                 ~9,3,2,-2,'%@E|~9,2E"
                x x x x))
      (foo 3.14159)  → "  3.14E+0| 31.42$-01|+.003E+03|  3.14E+0"
      (foo -3.14159) → " -3.14E+0|-31.42$-01|-.003E+03| -3.14E+0"
      (foo 1100.0)   → "  1.10E+3| 11.00$+02|+.001E+06|  1.10E+3"
      (foo 1100.0L0) → "  1.10L+3| 11.00$+02|+.001L+06|  1.10L+3"
      (foo 1.1E13)   → "*********| 11.00$+12|+.001E+16| 1.10E+13"
      (foo 1.1L120)  → "*********|??????????|%%%%%%%%%|1.10L+120"
      (foo 1.1L1200) → "*********|??????????|%%%%%%%%%|1.10L+1200"

As an example of the effects of varying the scale factor, the code

      (dotimes (k 13)
        (format t "~%Scale factor ~2D: |~13,6,2,VE|"
                (- k 5) (- k 5) 3.14159))

produces the following output:

     Scale factor -5: | 0.000003E+06|
     Scale factor -4: | 0.000031E+05|
     Scale factor -3: | 0.000314E+04|
     Scale factor -2: | 0.003142E+03|
     Scale factor -1: | 0.031416E+02|
     Scale factor  0: | 0.314159E+01|
     Scale factor  1: | 3.141590E+00|
     Scale factor  2: | 31.41590E-01|
     Scale factor  3: | 314.1590E-02|
     Scale factor  4: | 3141.590E-03|
     Scale factor  5: | 31415.90E-04|
     Scale factor  6: | 314159.0E-05|
     Scale factor  7: | 3141590.E-06|

      (defun foo (x)
        (format nil "~9,2,1,,'*G|~9,3,2,3,'?,,'$G|~9,3,2,0,'%G|~9,2G"
               x x x x))
      (foo 0.0314159) → "  3.14E-2|314.2$-04|0.314E-01|  3.14E-2"
      (foo 0.314159)  → "  0.31   |0.314    |0.314    | 0.31    "
      (foo 3.14159)   → "   3.1   | 3.14    | 3.14    |  3.1    "
      (foo 31.4159)   → "   31.   | 31.4    | 31.4    |  31.    "
      (foo 314.159)   → "  3.14E+2| 314.    | 314.    |  3.14E+2"
      (foo 3141.59)   → "  3.14E+3|314.2$+01|0.314E+04|  3.14E+3"
      (foo 3141.59L0) → "  3.14L+3|314.2$+01|0.314L+04|  3.14L+3"
      (foo 3.14E12)   → "*********|314.0$+10|0.314E+13| 3.14E+12"
      (foo 3.14L120)  → "*********|?????????|%%%%%%%%%|3.14L+120"
      (foo 3.14L1200) → "*********|?????????|%%%%%%%%%|3.14L+1200"

      (format nil "~10<foo~;bar~>")   → "foo    bar"
      (format nil "~10:<foo~;bar~>")  → "  foo  bar"
      (format nil "~10<foobar~>")     → "    foobar"
      (format nil "~10:<foobar~>")    → "    foobar"
      (format nil "~10:@<foo~;bar~>") → "  foo bar "
      (format nil "~10@<foobar~>")    → "foobar    "
      (format nil "~10:@<foobar~>")   → "  foobar  "

       (FORMAT NIL "Written to ~A." #P"foo.bin")
       → "Written to foo.bin."


File: ansicl,  Node: Notes about FORMAT,  Prev: Examples of FORMAT,  Up: Formatted Output

22.3.12 Notes about FORMAT
--------------------------

Formatted output is performed not only by ‘format’, but by certain other
functions that accept a format control the way ‘format’ does.  For
example, error-signaling functions such as ‘cerror’ accept format
controls.

Note that the meaning of ‘nil’ and ‘t’ as destinations to ‘format’ are
different than those of ‘nil’ and ‘t’ as stream designators.

The ‘~^’ should appear only at the beginning of a ‘~<’ clause, because
it aborts the entire clause in which it appears (as well as all
following clauses).


File: ansicl,  Node: copy-pprint-dispatch,  Next: formatter,  Prev: Formatted Output,  Up: Printer

copy-pprint-dispatch (Function)
===============================

Syntax:
.......

 -- Function: copy-pprint-dispatch &optional table → new-table

Arguments and Values:
.....................

TABLE—a pprint dispatch table, or ‘nil’.

NEW-TABLE—a fresh pprint dispatch table.

Description:
............

Creates and returns a copy of the specified TABLE, or of the value of
‘*print-pprint-dispatch*’ if no TABLE is specified, or of the initial
value of ‘*print-pprint-dispatch*’ if ‘nil’ is specified.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if TABLE is not a pprint
dispatch table.


File: ansicl,  Node: formatter,  Next: pprint-dispatch,  Prev: copy-pprint-dispatch,  Up: Printer

formatter (Macro)
=================

Syntax:
.......

 -- Macro: formatter control-string → function

Arguments and Values:
.....................

CONTROL-STRING—a format string; not evaluated.

FUNCTION—a function.

Description:
............

Returns a function which has behavior equivalent to:

       #'(lambda (*standard-output* &rest arguments)
           (apply #'format t control-string arguments)
           arguments-tail)

where arguments-tail is either the tail of arguments which has as its
car the argument that would be processed next if there were more format
directives in the CONTROL-STRING, or else ‘nil’ if no more arguments
follow the most recently processed argument.

Examples:
.........

     (funcall (formatter "~&~A~A") *standard-output* 'a 'b 'c)
     ▷ AB
     → (C)

     (format t (formatter "~&~A~A") 'a 'b 'c)
     ▷ AB
     → NIL

Exceptional Situations:
.......................

Might signal an error (at macro expansion time or at run time) if the
argument is not a valid format string.

See Also:
.........

*note format::


File: ansicl,  Node: pprint-dispatch,  Next: pprint-exit-if-list-exhausted,  Prev: formatter,  Up: Printer

pprint-dispatch (Function)
==========================

Syntax:
.......

 -- Function: pprint-dispatch object &optional table → function, found-p

Arguments and Values:
.....................

OBJECT—an object.

TABLE—a pprint dispatch table, or ‘nil’.  The default is the value of
‘*print-pprint-dispatch*’.

FUNCTION—a function designator.

FOUND-P—a generalized boolean.

Description:
............

Retrieves the highest priority function in TABLE that is associated with
a type specifier that matches OBJECT.  The function is chosen by finding
all of the type specifiers in TABLE that match the OBJECT and selecting
the highest priority function associated with any of these type
specifiers.  If there is more than one highest priority function, an
arbitrary choice is made.  If no type specifiers match the OBJECT, a
function is returned that prints OBJECT using ‘print-object’.

The secondary value, FOUND-P, is true if a matching type specifier was
found in TABLE, or false otherwise.

If TABLE is ‘nil’, retrieval is done in the initial pprint dispatch
table.

Affected By:
............

The state of the TABLE.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if table is neither a
pprint-dispatch-table nor ‘nil’.

Notes:
......

     (let ((*print-pretty* t))
       (write object :stream s))
     ≡ (funcall (pprint-dispatch object) s object)


File: ansicl,  Node: pprint-exit-if-list-exhausted,  Next: pprint-fill; pprint-linear; pprint-tabular,  Prev: pprint-dispatch,  Up: Printer

pprint-exit-if-list-exhausted (Local Macro)
===========================================

Syntax:
.......

 -- Macro: pprint-exit-if-list-exhausted <no arguments> → ‘nil’

Description:
............

Tests whether or not the LIST passed to the lexically current logical
block has been exhausted; see *note Section 22.2.1.1 (Dynamic Control of
the Arrangement of Output): DynamicControlofOutput.  If this LIST has
been reduced to ‘nil’, ‘pprint-exit-if-list-exhausted’ terminates the
execution of the lexically current logical block except for the printing
of the suffix.  Otherwise ‘pprint-exit-if-list-exhausted’ returns ‘nil’.

Whether or not ‘pprint-exit-if-list-exhausted’ is fbound in the global
environment is implementation-dependent; however, the restrictions on
redefinition and shadowing of ‘pprint-exit-if-list-exhausted’ are the
same as for symbols in the ‘COMMON-LISP’ package which are fbound in the
global environment.  The consequences of attempting to use
‘pprint-exit-if-list-exhausted’ outside of ‘pprint-logical-block’ are
undefined.

Exceptional Situations:
.......................

An error is signaled (at macro expansion time or at run time) if
‘pprint-exit-if-list-exhausted’ is used anywhere other than lexically
within a call on ‘pprint-logical-block’.  Also, the consequences of
executing ‘pprint-if-list-exhausted’ outside of the dynamic extent of
the ‘pprint-logical-block’ which lexically contains it are undefined.

See Also:
.........

*note pprint-logical-block::, *note pprint-pop::.


File: ansicl,  Node: pprint-fill; pprint-linear; pprint-tabular,  Next: pprint-indent,  Prev: pprint-exit-if-list-exhausted,  Up: Printer

pprint-fill, pprint-linear, pprint-tabular (Function)
=====================================================

Syntax:
.......

 -- Function: pprint-fill stream object &optional colon-p at-sign-p →
          ‘nil’
 -- Function: pprint-linear stream object &optional colon-p at-sign-p →
          ‘nil’
 -- Function: pprint-tabular stream object &optional colon-p at-sign-p
          tabsize → ‘nil’

Arguments and Values:
.....................

STREAM—an output stream designator.

OBJECT—an object.

COLON-P—a generalized boolean.  The default is true.

AT-SIGN-P—a generalized boolean.  The default is
implementation-dependent.

TABSIZE—a non-negative integer.  The default is ‘16’.

Description:
............

The functions ‘pprint-fill’, ‘pprint-linear’, and ‘pprint-tabular’
specify particular ways of pretty printing a list to STREAM.  Each
function prints parentheses around the output if and only if COLON-P is
true.  Each function ignores its AT-SIGN-P argument.  (Both arguments
are included even though only one is needed so that these functions can
be used via ‘~/.../’ and as ‘set-pprint-dispatch’ functions, as well as
directly.)  Each function handles abbreviation and the detection of
circularity and sharing correctly, and uses ‘write’ to print OBJECT when
it is a non-list.

If OBJECT is a list and if the value of ‘*print-pretty*’ is false, each
of these functions prints OBJECT using a minimum of whitespace, as
described in *note Section 22.1.3.5 (Printing Lists and Conses):
PrintingListsAndConses.  Otherwise (if OBJECT is a list and if the value
of ‘*print-pretty*’ is true):

   • The function ‘pprint-linear’ prints a list either all on one line,
     or with each element on a separate line.

   • The function ‘pprint-fill’ prints a list with as many elements as
     possible on each line.

   • The function ‘pprint-tabular’ is the same as ‘pprint-fill’ except
     that it prints the elements so that they line up in columns.  The
     TABSIZE specifies the column spacing in ems, which is the total
     spacing from the leading edge of one column to the leading edge of
     the next.

Examples:
.........

Evaluating the following with a line length of ‘25’ produces the output
shown.

     (progn (princ "Roads ")
            (pprint-tabular *standard-output* '(elm main maple center) nil nil 8))
     Roads ELM     MAIN
           MAPLE   CENTER

Side Effects:
.............

Performs output to the indicated stream.

Affected By:
............

The cursor position on the indicated stream, if it can be determined.

Notes:
......

The function ‘pprint-tabular’ could be defined as follows:

     (defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))
       (declare (ignore at-sign-p))
       (when (null tabsize) (setq tabsize 16))
       (pprint-logical-block (s list :prefix (if colon-p "(" "")
                                     :suffix (if colon-p ")" ""))
         (pprint-exit-if-list-exhausted)
         (loop (write (pprint-pop) :stream s)
               (pprint-exit-if-list-exhausted)
               (write-char #\Space s)
               (pprint-tab :section-relative 0 tabsize s)
               (pprint-newline :fill s))))

Note that it would have been inconvenient to specify this function using
‘format’, because of the need to pass its TABSIZE argument through to a
‘~:T’ format directive nested within an iteration over a list.


File: ansicl,  Node: pprint-indent,  Next: pprint-logical-block,  Prev: pprint-fill; pprint-linear; pprint-tabular,  Up: Printer

pprint-indent (Function)
========================

Syntax:
.......

 -- Function: pprint-indent relative-to n &optional stream → ‘nil’

Arguments and Values:
.....................

RELATIVE-TO—either :block or :current.

N—a real.

STREAM—an output stream designator.  The default is standard output.

Description:
............

‘pprint-indent’ specifies the indentation to use in a logical block on
stream.  If STREAM is a pretty printing stream and the value of
‘*print-pretty*’ is true, ‘pprint-indent’ sets the indentation in the
innermost dynamically enclosing logical block; otherwise,
‘pprint-indent’ has no effect.

N specifies the indentation in ems.  If RELATIVE-TO is :block, the
indentation is set to the horizontal position of the first character in
the dynamically current logical block plus N ems.  If RELATIVE-TO is
:current, the indentation is set to the current output position plus N
ems.  (For robustness in the face of variable-width fonts, it is
advisable to use :current with an N of zero whenever possible.)

N can be negative; however, the total indentation cannot be moved left
of the beginning of the line or left of the end of the rightmost
per-line prefix—an attempt to move beyond one of these limits is treated
the same as an attempt to move to that limit.  Changes in indentation
caused by PPRINT-INDENT do not take effect until after the next line
break.  In addition, in miser mode all calls to ‘pprint-indent’ are
ignored, forcing the lines corresponding to the logical block to line up
under the first character in the block.

Exceptional Situations:
.......................

An error is signaled if RELATIVE-TO is any object other than :block or
:current.

See Also:
.........

*note Section 22.3.5.3 (Tilde I. Indent): TildeI.


File: ansicl,  Node: pprint-logical-block,  Next: pprint-newline,  Prev: pprint-indent,  Up: Printer

pprint-logical-block (Macro)
============================

Syntax:
.......

 -- Macro: pprint-logical-block
          (stream-symbol object  &key prefix per-line-prefix suffix)
          {declaration}* {form}* → ‘nil’

Arguments and Values:
.....................

STREAM-SYMBOL—a stream variable designator.

OBJECT—an object; evaluated.

:prefix—a string; evaluated.  Complicated defaulting behavior; see
below.

:per-line-prefix—a string; evaluated.  Complicated defaulting behavior;
see below.

:suffix—a string; evaluated.  The default is the null string.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

Description:
............

Causes printing to be grouped into a logical block.

The logical block is printed to the stream that is the value of the
variable denoted by STREAM-SYMBOL.  During the execution of the forms,
that variable is bound to a pretty printing stream that supports
decisions about the arrangement of output and then forwards the output
to the destination stream.  All the standard printing functions (e.g.,
‘write’, ‘princ’, and ‘terpri’) can be used to print output to the
pretty printing stream.  All and only the output sent to this pretty
printing stream is treated as being in the logical block.

The PREFIX specifies a prefix to be printed before the beginning of the
logical block.  The PER-LINE-PREFIX specifies a prefix that is printed
before the block and at the beginning of each new line in the block.
The :prefix and :pre-line-prefix arguments are mutually exclusive.  If
neither :prefix nor :per-line-prefix is specified, a PREFIX of the null
string is assumed.

The SUFFIX specifies a suffix that is printed just after the logical
block.

The OBJECT is normally a list that the body FORMS are responsible for
printing.  If OBJECT is not a list, it is printed using ‘write’.  (This
makes it easier to write printing functions that are robust in the face
of malformed arguments.)  If ‘*print-circle*’ is non-nil and OBJECT is a
circular (or shared) reference to a cons, then an appropriate “‘#n#’”
marker is printed.  (This makes it easy to write printing functions that
provide full support for circularity and sharing abbreviation.)  If
‘*print-level*’ is not ‘nil’ and the logical block is at a dynamic
nesting depth of greater than ‘*print-level*’ in logical blocks, “‘#’”
is printed.  (This makes easy to write printing functions that provide
full support for depth abbreviation.)

If either of the three conditions above occurs, the indicated output is
printed on STREAM-SYMBOL and the body FORMS are skipped along with the
printing of the :prefix and :suffix.  (If the body FORMS are not to be
responsible for printing a list, then the first two tests above can be
turned off by supplying ‘nil’ for the OBJECT argument.)

In addition to the OBJECT argument of ‘pprint-logical-block’, the
arguments of the standard printing functions (such as ‘write’, ‘print’,
‘prin1’, and ‘pprint’, as well as the arguments of the standard format
directives such as ‘~A’, ‘~S’, (and ‘~W’) are all checked (when
necessary) for circularity and sharing.  However, such checking is not
applied to the arguments of the functions ‘write-line’, ‘write-string’,
and ‘write-char’ or to the literal text output by ‘format’.  A
consequence of this is that you must use one of the latter functions if
you want to print some literal text in the output that is not supposed
to be checked for circularity or sharing.

The body FORMS of a ‘pprint-logical-block’ form must not perform any
side-effects on the surrounding environment; for example, no variables
must be assigned which have not been bound within its scope.

The ‘pprint-logical-block’ macro may be used regardless of the value of
‘*print-pretty*’.

Affected By:
............

‘*print-circle*’, ‘*print-level*’.

Exceptional Situations:
.......................

An error of type ‘type-error’ is signaled if any of the :suffix,
:prefix, or :per-line-prefix is supplied but does not evaluate to a
string.

An error is signaled if :prefix and :pre-line-prefix are both used.

‘pprint-logical-block’ and the pretty printing stream it creates have
dynamic extent.  The consequences are undefined if, outside of this
extent, output is attempted to the pretty printing stream it creates.

It is also unspecified what happens if, within this extent, any output
is sent directly to the underlying destination stream.

See Also:
.........

*note pprint-pop::, *note pprint-exit-if-list-exhausted::, *note Section
22.3.5.2 (Tilde Less-Than-Sign.  Logical Block):
TildeLessThanLogicalBlock.

Notes:
......

One reason for using the ‘pprint-logical-block’ macro when the value of
‘*print-pretty*’ is ‘nil’ would be to allow it to perform checking for
dotted lists, as well as (in conjunction with ‘pprint-pop’) checking for
‘*print-level*’ or ‘*print-length*’ being exceeded.

Detection of circularity and sharing is supported by the pretty printer
by in essence performing requested output twice.  On the first pass,
circularities and sharing are detected and the actual outputting of
characters is suppressed.  On the second pass, the appropriate “‘#N=’”
and “‘#N#’” markers are inserted and characters are output.  This is why
the restriction on side-effects is necessary.  Obeying this restriction
is facilitated by using ‘pprint-pop’, instead of an ordinary ‘pop’ when
traversing a list being printed by the body FORMS of the
‘pprint-logical-block’ form.)


File: ansicl,  Node: pprint-newline,  Next: pprint-pop,  Prev: pprint-logical-block,  Up: Printer

pprint-newline (Function)
=========================

Syntax:
.......

 -- Function: pprint-newline kind &optional stream → ‘nil’

Arguments and Values:
.....................

KIND—one of :linear, :fill, :miser, or :mandatory.

STREAM—a stream designator.  The default is standard output.

Description:
............

If STREAM is a pretty printing stream and the value of ‘*print-pretty*’
is true, a line break is inserted in the output when the appropriate
condition below is satisfied; otherwise, ‘pprint-newline’ has no effect.

KIND specifies the style of conditional newline.  This parameter is
treated as follows:

:linear

     This specifies a “linear-style” conditional newline.  A line break
     is inserted if and only if the immediately containing section
     cannot be printed on one line.  The effect of this is that line
     breaks are either inserted at every linear-style conditional
     newline in a logical block or at none of them.

:miser

     This specifies a “miser-style” conditional newline.  A line break
     is inserted if and only if the immediately containing section
     cannot be printed on one line and miser style is in effect in the
     immediately containing logical block.  The effect of this is that
     miser-style conditional newlines act like linear-style conditional
     newlines, but only when miser style is in effect.  Miser style is
     in effect for a logical block if and only if the starting position
     of the logical block is less than or equal to ‘*print-miser-width*’
     ems from the right margin.

:fill

     This specifies a “fill-style” conditional newline.  A line break is
     inserted if and only if either (a) the following section cannot be
     printed on the end of the current line, (b) the preceding section
     was not printed on a single line, or (c) the immediately containing
     section cannot be printed on one line and miser style is in effect
     in the immediately containing logical block.  If a logical block is
     broken up into a number of subsections by fill-style conditional
     newlines, the basic effect is that the logical block is printed
     with as many subsections as possible on each line.  However, if
     miser style is in effect, fill-style conditional newlines act like
     linear-style conditional newlines.

:mandatory

     This specifies a “mandatory-style” conditional newline.  A line
     break is always inserted.  This implies that none of the containing
     sections can be printed on a single line and will therefore trigger
     the insertion of line breaks at linear-style conditional newlines
     in these sections.

When a line break is inserted by any type of conditional newline, any
blanks that immediately precede the conditional newline are omitted from
the output and indentation is introduced at the beginning of the next
line.  By default, the indentation causes the following line to begin in
the same horizontal position as the first character in the immediately
containing logical block.  (The indentation can be changed via
‘pprint-indent’.)

There are a variety of ways unconditional newlines can be introduced
into the output (i.e., via ‘terpri’ or by printing a string containing a
newline character).  As with mandatory conditional newlines, this
prevents any of the containing sections from being printed on one line.
In general, when an unconditional newline is encountered, it is printed
out without suppression of the preceding blanks and without any
indentation following it.  However, if a per-line prefix has been
specified (see ‘pprint-logical-block’), this prefix will always be
printed no matter how a newline originates.

Examples:
.........

See *note Section 22.2.2 (Examples of using the Pretty Printer):
Examples of using the Pretty Printer.

Side Effects:
.............

Output to STREAM.

Affected By:
............

‘*print-pretty*’, ‘*print-miser*’.  The presence of containing logical
blocks.  The placement of newlines and conditional newlines.

Exceptional Situations:
.......................

An error of type ‘type-error’ is signaled if KIND is not one of :linear,
:fill, :miser, or :mandatory.

See Also:
.........

*note Section 22.3.5.1 (Tilde Underscore.  Conditional Newline):
TildeUnderscore, *note Section 22.2.2 (Examples of using the Pretty
Printer): Examples of using the Pretty Printer.


File: ansicl,  Node: pprint-pop,  Next: pprint-tab,  Prev: pprint-newline,  Up: Printer

pprint-pop (Local Macro)
========================

Syntax:
.......

 -- Macro: pprint-pop <no arguments> → object

Arguments and Values:
.....................

OBJECT—an element of the list being printed in the lexically current
logical block, or ‘nil’.

Description:
............

Pops one element from the list being printed in the lexically current
logical block, obeying ‘*print-length*’ and ‘*print-circle*’ as
described below.

Each time ‘pprint-pop’ is called, it pops the next value off the list
passed to the lexically current logical block and returns it.  However,
before doing this, it performs three tests:

   • If the remaining ‘list’ is not a list, “‘. ’” is printed followed
     by the remaining ‘list.’ (This makes it easier to write printing
     functions that are robust in the face of malformed arguments.)

   • If ‘*print-length*’ is non-nil, and ‘pprint-pop’ has already been
     called ‘*print-length*’ times within the immediately containing
     logical block, “‘...’” is printed.  (This makes it easy to write
     printing functions that properly handle ‘*print-length*’.)

   • If ‘*print-circle*’ is non-nil, and the remaining list is a
     circular (or shared) reference, then “‘. ’” is printed followed by
     an appropriate “‘#n#’” marker.  (This catches instances of cdr
     circularity and sharing in lists.)

If either of the three conditions above occurs, the indicated output is
printed on the pretty printing stream created by the immediately
containing ‘pprint-logical-block’ and the execution of the immediately
containing ‘pprint-logical-block’ is terminated except for the printing
of the suffix.

If ‘pprint-logical-block’ is given a ‘list’ argument of ‘nil’—because it
is not processing a list—‘pprint-pop’ can still be used to obtain
support for ‘*print-length*’.  In this situation, the first and third
tests above are disabled and ‘pprint-pop’ always returns ‘nil’.  See
*note Section 22.2.2 (Examples of using the Pretty Printer): Examples of
using the Pretty Printer.—specifically, the ‘pprint-vector’ example.

Whether or not ‘pprint-pop’ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ‘pprint-pop’ are the same as for symbols in the
‘COMMON-LISP’ package which are fbound in the global environment.  The
consequences of attempting to use ‘pprint-pop’ outside of
‘pprint-logical-block’ are undefined.

Side Effects:
.............

Might cause output to the pretty printing stream associated with the
lexically current logical block.

Affected By:
............

‘*print-length*’, ‘*print-circle*’.

Exceptional Situations:
.......................

An error is signaled (either at macro expansion time or at run time) if
a usage of ‘pprint-pop’ occurs where there is no lexically containing
‘pprint-logical-block’ form.

The consequences are undefined if ‘pprint-pop’ is executed outside of
the dynamic extent of this ‘pprint-logical-block’.

See Also:
.........

*note pprint-exit-if-list-exhausted::, *note pprint-logical-block::.

Notes:
......

It is frequently a good idea to call ‘pprint-exit-if-list-exhausted’
before calling ‘pprint-pop’.


File: ansicl,  Node: pprint-tab,  Next: print-object,  Prev: pprint-pop,  Up: Printer

pprint-tab (Function)
=====================

Syntax:
.......

 -- Function: pprint-tab kind colnum colinc &optional stream → ‘nil’

Arguments and Values:
.....................

KIND—one of :line, :section, :line-relative, or :section-relative.

COLNUM—a non-negative integer.

COLINC—a non-negative integer.

STREAM—an output stream designator.

Description:
............

Specifies tabbing to STREAM as performed by the standard ‘~T’ format
directive.  If STREAM is a pretty printing stream and the value of
‘*print-pretty*’ is true, tabbing is performed; otherwise, ‘pprint-tab’
has no effect.

The arguments COLNUM and COLINC correspond to the two PARAMETERS to ‘~T’
and are in terms of ems.  The KIND argument specifies the style of
tabbing.  It must be one of :line (tab as by ‘~T’), :section (tab as by
‘~:T’, but measuring horizontal positions relative to the start of the
dynamically enclosing section), :line-relative (tab as by ‘~@T’), or
:section-relative (tab as by ‘~:@T’, but measuring horizontal positions
relative to the start of the dynamically enclosing section).

Exceptional Situations:
.......................

An error is signaled if KIND is not one of :line, :section,
:line-relative, or :section-relative.

See Also:
.........

*note pprint-logical-block::


File: ansicl,  Node: print-object,  Next: print-unreadable-object,  Prev: pprint-tab,  Up: Printer

print-object (Standard Generic Function)
========================================

Syntax:
.......

 -- Generic Function: print-object object stream → object

Method Signatures:
..................

print-object (OBJECT standard-object) STREAM print-object (OBJECT
structure-object) STREAM

Arguments and Values:
.....................

OBJECT—an object.

STREAM—a stream.

Description:
............

The generic function ‘print-object’ writes the printed representation of
OBJECT to STREAM.  The function ‘print-object’ is called by the Lisp
printer; it should not be called by the user.

Each implementation is required to provide a method on the class
‘standard-object’ and on the class ‘structure-object’.  In addition,
each implementation must provide methods on enough other classes so as
to ensure that there is always an applicable method.  Implementations
are free to add methods for other classes.  Users may write methods for
‘print-object’ for their own classes if they do not wish to inherit an
implementation-dependent method.

The method on the class ‘structure-object’ prints the object in the
default ‘#S’ notation; see *note Section 22.1.3.12 (Printing
Structures): PrintingStructures.

Methods on ‘print-object’ are responsible for implementing their part of
the semantics of the printer control variables, as follows:

‘*print-readably*’

     All methods for ‘print-object’ must obey ‘*print-readably*’.  This
     includes both user-defined methods and implementation-defined
     methods.  Readable printing of structures and standard objects is
     controlled by their ‘print-object’ method, not by their
     ‘make-load-form’ method.  Similarity for these objects is
     application dependent and hence is defined to be whatever these
     methods do; see *note Section 3.2.4.2 (Similarity of Literal
     Objects): Similarity.

‘*print-escape*’

     Each method must implement ‘*print-escape*’.

‘*print-pretty*’

     The method may wish to perform specialized line breaking or other
     output conditional on the value of ‘*print-pretty*’.  For further
     information, see (for example) the macro ‘pprint-fill’.  See also
     *note Section 22.2.1.4 (Pretty Print Dispatch Tables):
     PPrintDispatchTables. and *note Section 22.2.2 (Examples of using
     the Pretty Printer): Examples of using the Pretty Printer.

‘*print-length*’

     Methods that produce output of indefinite length must obey
     ‘*print-length*’.  For further information, see (for example) the
     macros ‘pprint-logical-block’ and ‘pprint-pop’.  See also *note
     Section 22.2.1.4 (Pretty Print Dispatch Tables):
     PPrintDispatchTables. and *note Section 22.2.2 (Examples of using
     the Pretty Printer): Examples of using the Pretty Printer.

‘*print-level*’

     The printer takes care of ‘*print-level*’ automatically, provided
     that each method handles exactly one level of structure and calls
     ‘write’ (or an equivalent function) recursively if there are more
     structural levels.  The printer’s decision of whether an object has
     components (and therefore should not be printed when the printing
     depth is not less than ‘*print-level*’) is
     implementation-dependent.  In some implementations its
     ‘print-object’ method is not called; in others the method is
     called, and the determination that the object has components is
     based on what it tries to write to the STREAM.

‘*print-circle*’

     When the value of ‘*print-circle*’ is true, a user-defined
     ‘print-object’ method can print objects to the supplied stream
     using ‘write’, ‘prin1’, ‘princ’, or ‘format’ and expect
     circularities to be detected and printed using the ‘#n#’ syntax.
     If a user-defined ‘print-object’ method prints to a stream other
     than the one that was supplied, then circularity detection starts
     over for that stream.  See ‘*print-circle*’.

‘*print-base*’, ‘*print-radix*’, ‘*print-case*’, ‘*print-gensym*’, and ‘*print-array*’

     These printer control variables apply to specific types of objects
     and are handled by the methods for those objects.

If these rules are not obeyed, the results are undefined.

In general, the printer and the ‘print-object’ methods should not rebind
the print control variables as they operate recursively through the
structure, but this is implementation-dependent.

In some implementations the STREAM argument passed to a ‘print-object’
method is not the original stream, but is an intermediate stream that
implements part of the printer.  methods should therefore not depend on
the identity of this stream.

See Also:
.........

*note pprint-fill::, *note pprint-logical-block::, *note pprint-pop::,
*note write::, *note *print-readably*::, *note *print-escape*::, *note
*print-pretty*::, *note *print-length*::, *note Section 22.1.3 (Default
Print-Object Methods): Default Print-Object Methods, *note Section
22.1.3.12 (Printing Structures): PrintingStructures, *note Section
22.2.1.4 (Pretty Print Dispatch Tables): PPrintDispatchTables, *note
Section 22.2.2 (Examples of using the Pretty Printer): Examples of using
the Pretty Printer.


File: ansicl,  Node: print-unreadable-object,  Next: set-pprint-dispatch,  Prev: print-object,  Up: Printer

print-unreadable-object (Macro)
===============================

Syntax:
.......

 -- Macro: print-unreadable-object (object stream &key type identity)
          {form}* → ‘nil’

Arguments and Values:
.....................

OBJECT—an object; evaluated.

STREAM— a stream designator; evaluated.

TYPE—a generalized boolean; evaluated.

IDENTITY—a generalized boolean; evaluated.

FORMS—an implicit progn.

Description:
............

Outputs a printed representation of OBJECT on STREAM, beginning with
“‘#<’” and ending with “‘>’”.  Everything output to STREAM by the body
FORMS is enclosed in the the angle brackets.  If TYPE is true, the
output from FORMS is preceded by a brief description of the OBJECT’s
type and a space character.  If IDENTITY is true, the output from FORMS
is followed by a space character and a representation of the OBJECT’s
identity, typically a storage address.

If either TYPE or IDENTITY is not supplied, its value is false.  It is
valid to omit the body FORMS.  If TYPE and IDENTITY are both true and
there are no body FORMS, only one space character separates the type and
the identity.

Examples:
.........

;; Note that in this example, the precise form of the output ;; is
implementation-dependent.

      (defmethod print-object ((obj airplane) stream)
        (print-unreadable-object (obj stream :type t :identity t)
          (princ (tail-number obj) stream)))

      (prin1-to-string my-airplane)
     → "#<Airplane NW0773 36000123135>"
     or→ "#<FAA:AIRPLANE NW0773 17>"

Exceptional Situations:
.......................

If ‘*print-readably*’ is true, ‘print-unreadable-object’ signals an
error of type ‘print-not-readable’ without printing anything.


File: ansicl,  Node: set-pprint-dispatch,  Next: write; prin1; print; pprint; princ,  Prev: print-unreadable-object,  Up: Printer

set-pprint-dispatch (Function)
==============================

Syntax:
.......

 -- Function: set-pprint-dispatch type-specifier function &optional
          priority table → ‘nil’

Arguments and Values:
.....................

TYPE-SPECIFIER—a type specifier.

FUNCTION—a function, a function name, or ‘nil’.

PRIORITY—a real.  The default is ‘0’.

TABLE—a pprint dispatch table.  The default is the value of
‘*print-pprint-dispatch*’.

Description:
............

Installs an entry into the pprint dispatch table which is TABLE.

TYPE-SPECIFIER is the key of the entry.  The first action of
‘set-pprint-dispatch’ is to remove any pre-existing entry associated
with TYPE-SPECIFIER.  This guarantees that there will never be two
entries associated with the same type specifier in a given pprint
dispatch table.  Equality of type specifiers is tested by ‘equal’.

Two values are associated with each type specifier in a pprint dispatch
table: a FUNCTION and a PRIORITY.  The FUNCTION must accept two
arguments: the stream to which output is sent and the object to be
printed.  The FUNCTION should pretty print the object to the STREAM.
The FUNCTION can assume that object satisfies the type given by
type-specifier.  The FUNCTION must obey ‘*print-readably*’.  Any values
returned by the FUNCTION are ignored.

PRIORITY is a priority to resolve conflicts when an object matches more
than one entry.

It is permissible for FUNCTION to be ‘nil’.  In this situation, there
will be no TYPE-SPECIFIER entry in TABLE after ‘set-pprint-dispatch’
returns.

Exceptional Situations:
.......................

An error is signaled if PRIORITY is not a real.

Notes:
......

Since pprint dispatch tables are often used to control the pretty
printing of Lisp code, it is common for the TYPE-SPECIFIER to be an
expression of the form

      (cons CAR-TYPE CDR-TYPE)

This signifies that the corresponding object must be a cons cell whose
car matches the type specifier CAR-TYPE and whose cdr matches the type
specifier CDR-TYPE.  The CDR-TYPE can be omitted in which case it
defaults to t.


File: ansicl,  Node: write; prin1; print; pprint; princ,  Next: write-to-string; prin1-to-string; princ-to-string,  Prev: set-pprint-dispatch,  Up: Printer

write, prin1, print, pprint, princ (Function)
=============================================

Syntax:
.......

 -- Function: write OBJECT &key array base case circle escape gensym
     length level lines miser-width pprint-dispatch
     pretty radix readably right-margin stream
     → object

 -- Function: prin1 object &optional output-stream → object
 -- Function: princ object &optional output-stream → object
 -- Function: print object &optional output-stream → object
 -- Function: pprint object &optional output-stream → <no values>

Arguments and Values:
.....................

OBJECT—an object.

OUTPUT-STREAM—an output stream designator.  The default is standard
output.

ARRAY—a generalized boolean.

BASE—a radix.

CASE—a symbol of type ‘(member :upcase :downcase :capitalize)’.

CIRCLE—a generalized boolean.

ESCAPE—a generalized boolean.

GENSYM—a generalized boolean.

LENGTH—a non-negative integer, or ‘nil’.

LEVEL—a non-negative integer, or ‘nil’.

LINES—a non-negative integer, or ‘nil’.

MISER-WIDTH—a non-negative integer, or ‘nil’.

PPRINT-DISPATCH—a pprint dispatch table.

PRETTY—a generalized boolean.

RADIX—a generalized boolean.

READABLY—a generalized boolean.

RIGHT-MARGIN—a non-negative integer, or ‘nil’.

STREAM—an output stream designator.  The default is standard output.

Description:
............

‘write’, ‘prin1’, ‘princ’, ‘print’, and ‘pprint’ write the printed
representation of OBJECT to OUTPUT-STREAM.

‘write’ is the general entry point to the Lisp printer.  For each
explicitly supplied keyword parameter named in the next figure, the
corresponding printer control variable is dynamically bound to its value
while printing goes on; for each keyword parameter in the next
figure that is not explicitly supplied, the value of the corresponding
printer control variable is the same as it was at the time ‘write’ was
invoked.  Once the appropriate bindings are established, the object is
output by the Lisp printer.

Parameter         Corresponding Dynamic
                  Variable
----------------------------------------------
ARRAY             ‘*print-array*’
BASE              ‘*print-base*’
CASE              ‘*print-case*’
CIRCLE            ‘*print-circle*’
ESCAPE            ‘*print-escape*’
GENSYM            ‘*print-gensym*’
LENGTH            ‘*print-length*’
LEVEL             ‘*print-level*’
LINES             ‘*print-lines*’
MISER-WIDTH       ‘*print-miser-width*’
PPRINT-DISPATCH   ‘*print-pprint-dispatch*’
PRETTY            ‘*print-pretty*’
RADIX             ‘*print-radix*’
READABLY          ‘*print-readably*’
RIGHT-MARGIN      ‘*print-right-margin*’

Figure 22.7: Argument correspondences for the WRITE function.

‘prin1’, ‘princ’, ‘print’, and ‘pprint’ implicitly bind certain print
parameters to particular values.  The remaining parameter values are
taken from ‘*print-array*’, ‘*print-base*’, ‘*print-case*’,
‘*print-circle*’, ‘*print-escape*’, ‘*print-gensym*’, ‘*print-length*’,
‘*print-level*’, ‘*print-lines*’, ‘*print-miser-width*’,
‘*print-pprint-dispatch*’, ‘*print-pretty*’, ‘*print-radix*’, and
‘*print-right-margin*’.

‘prin1’ produces output suitable for input to ‘read’.  It binds
‘*print-escape*’ to true.

‘princ’ is just like ‘prin1’ except that the output has no escape
characters.  It binds ‘*print-escape*’ to false and ‘*print-readably*’
to false.  The general rule is that output from ‘princ’ is intended to
look good to people, while output from ‘prin1’ is intended to be
acceptable to ‘read’.

‘print’ is just like ‘prin1’ except that the printed representation of
OBJECT is preceded by a newline and followed by a space.

‘pprint’ is just like ‘print’ except that the trailing space is omitted
and OBJECT is printed with the ‘*print-pretty*’ flag non-nil to produce
pretty output.

OUTPUT-STREAM specifies the stream to which output is to be sent.

Affected By:
............

‘*standard-output*’, ‘*terminal-io*’, ‘*print-escape*’, ‘*print-radix*’,
‘*print-base*’, ‘*print-circle*’, ‘*print-pretty*’, ‘*print-level*’,
‘*print-length*’, ‘*print-case*’, ‘*print-gensym*’, ‘*print-array*’,
‘*read-default-float-format*’.

See Also:
.........

*note readtable-case::, *note Section 22.3.4 (FORMAT Printer
Operations): FORMAT Printer Operations.

Notes:
......

The functions ‘prin1’ and ‘print’ do not bind ‘*print-readably*’.

      (prin1 object output-stream)
     ≡ (write object :stream output-stream :escape t)

      (princ object output-stream)
     ≡ (write object stream output-stream :escape nil :readably nil)

      (print object output-stream)
     ≡ (progn (terpri output-stream)
                (write object :stream output-stream
                              :escape t)
                (write-char #\space output-stream))

      (pprint object output-stream)
     ≡ (write object :stream output-stream :escape t :pretty t)


File: ansicl,  Node: write-to-string; prin1-to-string; princ-to-string,  Next: *print-array*,  Prev: write; prin1; print; pprint; princ,  Up: Printer

write-to-string, prin1-to-string, princ-to-string (Function)
============================================================

Syntax:
.......

 -- Function: write-to-string object &key array base case circle escape
          gensym
     length level lines miser-width pprint-dispatch
     pretty radix readably right-margin
     → string

 -- Function: prin1-to-string object → string

 -- Function: princ-to-string object → string

Arguments and Values:
.....................

OBJECT—an object.

ARRAY—a generalized boolean.

BASE—a radix.

CASE—a symbol of type ‘(member :upcase :downcase :capitalize)’.

CIRCLE—a generalized boolean.

ESCAPE—a generalized boolean.

GENSYM—a generalized boolean.

LENGTH—a non-negative integer, or ‘nil’.

LEVEL—a non-negative integer, or ‘nil’.

LINES—a non-negative integer, or ‘nil’.

MISER-WIDTH—a non-negative integer, or ‘nil’.

PPRINT-DISPATCH—a pprint dispatch table.

PRETTY—a generalized boolean.

RADIX—a generalized boolean.

READABLY—a generalized boolean.

RIGHT-MARGIN—a non-negative integer, or ‘nil’.

STRING—a string.

Description:
............

‘write-to-string’, ‘prin1-to-string’, and ‘princ-to-string’ are used to
create a string consisting of the printed representation of OBJECT.
OBJECT is effectively printed as if by ‘write’, ‘prin1’, or ‘princ’,
respectively, and the characters that would be output are made into a
string.

‘write-to-string’ is the general output function.  It has the ability to
specify all the parameters applicable to the printing of OBJECT.

‘prin1-to-string’ acts like ‘write-to-string’ with ‘:escape t’, that is,
escape characters are written where appropriate.

‘princ-to-string’ acts like ‘write-to-string’ with ‘:escape nil
:readably nil’.  Thus no escape characters are written.

All other keywords that would be specified to ‘write-to-string’ are
default values when ‘prin1-to-string’ or ‘princ-to-string’ is invoked.

The meanings and defaults for the keyword arguments to ‘write-to-string’
are the same as those for ‘write’.

Examples:
.........

      (prin1-to-string "abc") → "\"abc\""
      (princ-to-string "abc") → "abc"

Affected By:
............

‘*print-escape*’, ‘*print-radix*’, ‘*print-base*’, ‘*print-circle*’,
‘*print-pretty*’, ‘*print-level*’, ‘*print-length*’, ‘*print-case*’,
‘*print-gensym*’, ‘*print-array*’, ‘*read-default-float-format*’.

See Also:
.........

*note write::

Notes:
......

      (write-to-string OBJECT {KEY ARGUMENT}*)
     ≡ (with-output-to-string (#1=#:string-stream)
          (write object :stream #1# {KEY ARGUMENT}*))

      (princ-to-string OBJECT)
     ≡ (with-output-to-string (string-stream)
          (princ OBJECT string-stream))

      (prin1-to-string OBJECT)
     ≡ (with-output-to-string (string-stream)
          (prin1 OBJECT string-stream))


File: ansicl,  Node: *print-array*,  Next: *print-base*; *print-radix*,  Prev: write-to-string; prin1-to-string; princ-to-string,  Up: Printer

*print-array* (Variable)
========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

implementation-dependent.

Description:
............

Controls the format in which arrays are printed.  If it is false, the
contents of arrays other than strings are never printed.  Instead,
arrays are printed in a concise form using ‘#<’ that gives enough
information for the user to be able to identify the array, but does not
include the entire array contents.  If it is true, non-string arrays are
printed using ‘#(...)’, ‘#*’, or ‘#nA’ syntax.

Affected By:
............

The implementation.

See Also:
.........

*note Section 2.4.8.3 (Sharpsign Left-Parenthesis): SharpsignLeftParen,
*note Section 2.4.8.20 (Sharpsign Less-Than-Sign): SharpsignLeftAngle.


File: ansicl,  Node: *print-base*; *print-radix*,  Next: *print-case*,  Prev: *print-array*,  Up: Printer

*print-base*, *print-radix* (Variable)
======================================

Value Type:
...........

‘*print-base*’—a radix.  ‘*print-radix*’—a generalized boolean.

Initial Value:
..............

The initial value of ‘*print-base*’ is ‘10’.  The initial value of
‘*print-radix*’ is false.

Description:
............

‘*print-base*’ and ‘*print-radix*’ control the printing of rationals.
The value of ‘*print-base*’ is called the “current output base”.

The value of ‘*print-base*’ is the radix in which the printer will print
rationals.  For radices above ‘10’, letters of the alphabet are used to
represent digits above ‘9’.

If the value of ‘*print-radix*’ is true, the printer will print a radix
specifier to indicate the radix in which it is printing a rational
number.  The radix specifier is always printed using lowercase letters.
If ‘*print-base*’ is ‘2’, ‘8’, or ‘16’, then the radix specifier used is
‘#b’, ‘#o’, or ‘#x’, respectively.  For integers, base ten is indicated
by a trailing decimal point instead of a leading radix specifier; for
ratios, ‘#10r’ is used.

Examples:
.........

      (let ((*print-base* 24.) (*print-radix* t))
        (print 23.))
     ▷ #24rN
     → 23
      (setq *print-base* 10) → 10
      (setq *print-radix* nil) → NIL
      (dotimes (i 35)
         (let ((*print-base* (+ i 2)))           ;print the decimal number 40
           (write 40)                            ;in each base from 2 to 36
           (if (zerop (mod i 10)) (terpri) (format t " "))))
     ▷ 101000
     ▷ 1111 220 130 104 55 50 44 40 37 34
     ▷ 31 2C 2A 28 26 24 22 20 1J 1I
     ▷ 1H 1G 1F 1E 1D 1C 1B 1A 19 18
     ▷ 17 16 15 14
     → NIL
      (dolist (pb '(2 3 8 10 16))
         (let ((*print-radix* t)                 ;print the integer 10 and
               (*print-base* pb))                ;the ratio 1/10 in bases 2,
          (format t "~&~S  ~S~%" 10 1/10)))        ;3, 8, 10, 16
     ▷ #b1010  #b1/1010
     ▷ #3r101  #3r1/101
     ▷ #o12  #o1/12
     ▷ 10.  #10r1/10
     ▷ #xA  #x1/A
     → NIL

Affected By:
............

Might be bound by ‘format’, and ‘write’, ‘write-to-string’.

See Also:
.........

*note format::, *note write::, *note write-to-string::


File: ansicl,  Node: *print-case*,  Next: *print-circle*,  Prev: *print-base*; *print-radix*,  Up: Printer

*print-case* (Variable)
=======================

Value Type:
...........

One of the symbols :upcase, :downcase, or :capitalize.

Initial Value:
..............

The symbol :upcase.

Description:
............

The value of ‘*print-case*’ controls the case (upper, lower, or mixed)
in which to print any uppercase characters in the names of symbols when
vertical-bar syntax is not used.

‘*print-case*’ has an effect at all times when the value of
‘*print-escape*’ is false.  ‘*print-case*’ also has an effect when the
value of ‘*print-escape*’ is true unless inside an escape context (i.e.,
unless between vertical-bars or after a slash).

Examples:
.........

      (defun test-print-case ()
        (dolist (*print-case* '(:upcase :downcase :capitalize))
          (format t "~&~S ~S~%" 'this-and-that '|And-something-elSE|)))
     → TEST-PC
     ;; Although the choice of which characters to escape is specified by
     ;; *PRINT-CASE*, the choice of how to escape those characters
     ;; (i.e., whether single escapes or multiple escapes are used)
     ;; is implementation-dependent.  The examples here show two of the
     ;; many valid ways in which escaping might appear.
      (test-print-case) ;Implementation A
     ▷ THIS-AND-THAT |And-something-elSE|
     ▷ this-and-that a\n\d-\s\o\m\e\t\h\i\n\g-\e\lse
     ▷ This-And-That A\n\d-\s\o\m\e\t\h\i\n\g-\e\lse
     → NIL
      (test-print-case) ;Implementation B
     ▷ THIS-AND-THAT |And-something-elSE|
     ▷ this-and-that a|nd-something-el|se
     ▷ This-And-That A|nd-something-el|se
     → NIL

See Also:
.........

*note write::

Notes:
......

‘read’ normally converts lowercase characters appearing in symbols to
corresponding uppercase characters, so that internally print names
normally contain only uppercase characters.

If ‘*print-escape*’ is true, lowercase characters in the name of a
symbol are always printed in lowercase, and are preceded by a single
escape character or enclosed by multiple escape characters; uppercase
characters in the name of a symbol are printed in upper case, in lower
case, or in mixed case so as to capitalize words, according to the value
of ‘*print-case*’.  The convention for what constitutes a “word” is the
same as for ‘string-capitalize’.


File: ansicl,  Node: *print-circle*,  Next: *print-escape*,  Prev: *print-case*,  Up: Printer

*print-circle* (Variable)
=========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

false.

Description:
............

Controls the attempt to detect circularity and sharing in an object
being printed.

If false, the printing process merely proceeds by recursive descent
without attempting to detect circularity and sharing.

If true, the printer will endeavor to detect cycles and sharing in the
structure to be printed, and to use ‘#n=’ and ‘#n#’ syntax to indicate
the circularities or shared components.

If true, a user-defined ‘print-object’ method can print objects to the
supplied stream using ‘write’, ‘prin1’, ‘princ’, or ‘format’ and expect
circularities and sharing to be detected and printed using the ‘#n#’
syntax.  If a user-defined ‘print-object’ method prints to a stream
other than the one that was supplied, then circularity detection starts
over for that stream.

Note that implementations should not use ‘#n#’ notation when the Lisp
reader would automatically assure sharing without it (e.g., as happens
with interned symbols).

Examples:
.........

      (let ((a (list 1 2 3)))
        (setf (cdddr a) a)
        (let ((*print-circle* t))
          (write a)
          :done))
     ▷ #1=(1 2 3 . #1#)
     → :DONE

See Also:
.........

*note write::

Notes:
......

An attempt to print a circular structure with ‘*print-circle*’ set to
‘nil’ may lead to looping behavior and failure to terminate.


File: ansicl,  Node: *print-escape*,  Next: *print-gensym*,  Prev: *print-circle*,  Up: Printer

*print-escape* (Variable)
=========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

true.

Description:
............

If false, escape characters and package prefixes are not output when an
expression is printed.

If true, an attempt is made to print an expression in such a way that it
can be read again to produce an ‘equal’ expression.  (This is only a
guideline; not a requirement.  See ‘*print-readably*’.)

For more specific details of how the value of ‘*print-escape*’ affects
the printing of certain types, see *note Section 22.1.3 (Default
Print-Object Methods): Default Print-Object Methods.

Examples:
.........

      (let ((*print-escape* t)) (write #\a))
     ▷ #\a
     → #\a
      (let ((*print-escape* nil)) (write #\a))
     ▷ a
     → #\a

Affected By:
............

‘princ’, ‘prin1’, ‘format’

See Also:
.........

*note write::, *note readtable-case::

Notes:
......

‘princ’ effectively binds ‘*print-escape*’ to false.  ‘prin1’
effectively binds ‘*print-escape*’ to true.


File: ansicl,  Node: *print-gensym*,  Next: *print-level*; *print-length*,  Prev: *print-escape*,  Up: Printer

*print-gensym* (Variable)
=========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

true.

Description:
............

Controls whether the prefix “‘#:’” is printed before apparently
uninterned symbols.  The prefix is printed before such symbols if and
only if the value of ‘*print-gensym*’ is true.

Examples:
.........

      (let ((*print-gensym* nil))
        (print (gensym)))
     ▷ G6040
     → #:G6040

See Also:
.........

*note write::, *note *print-escape*::


File: ansicl,  Node: *print-level*; *print-length*,  Next: *print-lines*,  Prev: *print-gensym*,  Up: Printer

*print-level*, *print-length* (Variable)
========================================

Value Type:
...........

a non-negative integer, or ‘nil’.

Initial Value:
..............

‘nil’.

Description:
............

‘*print-level*’ controls how many levels deep a nested object will
print.  If it is false, then no control is exercised.  Otherwise, it is
an integer indicating the maximum level to be printed.  An object to be
printed is at level ‘0’; its components (as of a list or vector) are at
level ‘1’; and so on.  If an object to be recursively printed has
components and is at a level equal to or greater than the value of
‘*print-level*’, then the object is printed as “‘#’”.

‘*print-length*’ controls how many elements at a given level are
printed.  If it is false, there is no limit to the number of components
printed.  Otherwise, it is an integer indicating the maximum number of
elements of an object to be printed.  If exceeded, the printer will
print “‘...’” in place of the other elements.  In the case of a dotted
list, if the list contains exactly as many elements as the value of
‘*print-length*’, the terminating atom is printed rather than printing
“‘...’”

‘*print-level*’ and ‘*print-length*’ affect the printing of an any
object printed with a list-like syntax.  They do not affect the printing
of symbols, strings, and bit vectors.

Examples:
.........

 

 

      (setq a '(1 (2 (3 (4 (5 (6))))))) → (1 (2 (3 (4 (5 (6))))))
      (dotimes (i 8)
        (let ((*print-level* i))
          (format t "~&~D -- ~S~%" i a)))
     ▷ 0 -- #
     ▷ 1 -- (1 #)
     ▷ 2 -- (1 (2 #))
     ▷ 3 -- (1 (2 (3 #)))
     ▷ 4 -- (1 (2 (3 (4 #))))
     ▷ 5 -- (1 (2 (3 (4 (5 #)))))
     ▷ 6 -- (1 (2 (3 (4 (5 (6))))))
     ▷ 7 -- (1 (2 (3 (4 (5 (6))))))
     → NIL
      
      
      (setq a '(1 2 3 4 5 6)) → (1 2 3 4 5 6)
      (dotimes (i 7)
        (let ((*print-length* i))
          (format t "~&~D -- ~S~%" i a)))
     ▷ 0 -- (...)
     ▷ 1 -- (1 ...)
     ▷ 2 -- (1 2 ...)
     ▷ 3 -- (1 2 3 ...)
     ▷ 4 -- (1 2 3 4 ...)
     ▷ 5 -- (1 2 3 4 5 6)
     ▷ 6 -- (1 2 3 4 5 6)
     → NIL
      
      
     (dolist (level-length '((0 1) (1 1) (1 2) (1 3) (1 4)
                             (2 1) (2 2) (2 3) (3 2) (3 3) (3 4)))
      (let ((*print-level*  (first  level-length))
            (*print-length* (second level-length)))
        (format t "~&~D ~D -- ~S~%"
                *print-level* *print-length*
                '(if (member x y) (+ (car x) 3) '(foo . #(a b c d "Baz"))))))
     ▷ 0 1 -- #
     ▷ 1 1 -- (IF ...)
     ▷ 1 2 -- (IF # ...)
     ▷ 1 3 -- (IF # # ...)
     ▷ 1 4 -- (IF # # #)
     ▷ 2 1 -- (IF ...)
     ▷ 2 2 -- (IF (MEMBER X ...) ...)
     ▷ 2 3 -- (IF (MEMBER X Y) (+ # 3) ...)
     ▷ 3 2 -- (IF (MEMBER X ...) ...)
     ▷ 3 3 -- (IF (MEMBER X Y) (+ (CAR X) 3) ...)
     ▷ 3 4 -- (IF (MEMBER X Y) (+ (CAR X) 3) '(FOO . #(A B C D ...)))
     → NIL

See Also:
.........

*note write::


File: ansicl,  Node: *print-lines*,  Next: *print-miser-width*,  Prev: *print-level*; *print-length*,  Up: Printer

*print-lines* (Variable)
========================

Value Type:
...........

a non-negative integer, or ‘nil’.

Initial Value:
..............

‘nil’.

Description:
............

When the value of ‘*print-lines*’ is other than ‘nil’, it is a limit on
the number of output lines produced when something is pretty printed.
If an attempt is made to go beyond that many lines, “‘..’” is printed at
the end of the last line followed by all of the suffixes (closing
delimiters) that are pending to be printed.

Examples:
.........

      (let ((*print-right-margin* 25) (*print-lines* 3))
        (pprint '(progn (setq a 1 b 2 c 3 d 4))))
     ▷ (PROGN (SETQ A 1
     ▷              B 2
     ▷              C 3 ..))
     → <no values>

Notes:
......

The “‘..’” notation is intentionally different than the “‘...’” notation
used for level abbreviation, so that the two different situations can be
visually distinguished.

This notation is used to increase the likelihood that the Lisp reader
will signal an error if an attempt is later made to read the abbreviated
output.  Note however that if the truncation occurs in a string, as in
‘"This string has been trunc.."’, the problem situation cannot be
detected later and no such error will be signaled.


File: ansicl,  Node: *print-miser-width*,  Next: *print-pprint-dispatch*,  Prev: *print-lines*,  Up: Printer

*print-miser-width* (Variable)
==============================

Value Type:
...........

a non-negative integer, or ‘nil’.

Initial Value:
..............

implementation-dependent

Description:
............

If it is not ‘nil’, the pretty printer switches to a compact style of
output (called miser style) whenever the width available for printing a
substructure is less than or equal to this many ems.


File: ansicl,  Node: *print-pprint-dispatch*,  Next: *print-pretty*,  Prev: *print-miser-width*,  Up: Printer

*print-pprint-dispatch* (Variable)
==================================

Value Type:
...........

a pprint dispatch table.

Initial Value:
..............

implementation-dependent, but the initial entries all use a special
class of priorities that have the property that they are less than every
priority that can be specified using ‘set-pprint-dispatch’, so that the
initial contents of any entry can be overridden.

Description:
............

The pprint dispatch table which currently controls the pretty printer.

See Also:
.........

*note *print-pretty*::, *note Section 22.2.1.4 (Pretty Print Dispatch
Tables): PPrintDispatchTables.

Notes:
......

The intent is that the initial value of this variable should cause
‘traditional’ pretty printing of code.  In general, however, you can put
a value in ‘*print-pprint-dispatch*’ that makes pretty-printed output
look exactly like non-pretty-printed output.  Setting ‘*print-pretty*’
to true just causes the functions contained in the current pprint
dispatch table to have priority over normal ‘print-object’ methods; it
has no magic way of enforcing that those functions actually produce
pretty output.  For details, see *note Section 22.2.1.4 (Pretty Print
Dispatch Tables): PPrintDispatchTables.


File: ansicl,  Node: *print-pretty*,  Next: *print-readably*,  Prev: *print-pprint-dispatch*,  Up: Printer

*print-pretty* (Variable)
=========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

implementation-dependent.

Description:
............

Controls whether the Lisp printer calls the pretty printer.

If it is false, the pretty printer is not used and a minimum of
whitespaceis output when printing an expression.

If it is true, the pretty printer is used, and the Lisp printer will
endeavor to insert extra whitespacemore readable.

‘*print-pretty*’ has an effect even when the value of ‘*print-escape*’
is false.

Examples:
.........

      (setq *print-pretty* 'nil) → NIL
      (progn (write '(let ((a 1) (b 2) (c 3)) (+ a b c))) nil)
     ▷ (LET ((A 1) (B 2) (C 3)) (+ A B C))
     → NIL
      (let ((*print-pretty* t))
        (progn (write '(let ((a 1) (b 2) (c 3)) (+ a b c))) nil))
     ▷ (LET ((A 1)
     ▷       (B 2)
     ▷       (C 3))
     ▷   (+ A B C))
     → NIL
     ;; Note that the first two expressions printed by this next form
     ;; differ from the second two only in whether escape characters are printed.
     ;; In all four cases, extra whitespace is inserted by the pretty printer.
      (flet ((test (x)
               (let ((*print-pretty* t))
                 (print x)
                 (format t "~%~S " x)
                 (terpri) (princ x) (princ " ")
                 (format t "~%~A " x))))
       (test '#'(lambda () (list "a" #\b 'c #'d))))
     ▷ #'(LAMBDA ()
     ▷     (LIST "a" #\b 'C #'D))
     ▷ #'(LAMBDA ()
     ▷     (LIST "a" #\b 'C #'D))
     ▷ #'(LAMBDA ()
     ▷     (LIST a b 'C #'D))
     ▷ #'(LAMBDA ()
     ▷     (LIST a b 'C #'D))
     → NIL

See Also:
.........

*note write::


File: ansicl,  Node: *print-readably*,  Next: *print-right-margin*,  Prev: *print-pretty*,  Up: Printer

*print-readably* (Variable)
===========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

false.

Description:
............

If ‘*print-readably*’ is true, some special rules for printing objects
go into effect.  Specifically, printing any object Orepresentation that,
when seen by the Lisp reader while the standard readtable is in effect,
will produce an object OThe printed representation produced might or
might not be the same as the printed representation produced when
‘*print-readably*’ is false.  If printing an object readably is not
possible, an error of type ‘print-not-readable’ is signaled rather than
using a syntax (e.g., the “‘#<’” syntax) that would not be readable by
the same implementation.  If the value of some other printer control
variable is such that these requirements would be violated, the value of
that other variable is ignored.

Specifically, if ‘*print-readably*’ is true, printing proceeds as if
‘*print-escape*’, ‘*print-array*’, and ‘*print-gensym*’ were also true,
and as if ‘*print-length*’, ‘*print-level*’, and ‘*print-lines*’ were
false.

If ‘*print-readably*’ is false, the normal rules for printing and the
normal interpretations of other printer control variables are in effect.

Individual methods for ‘print-object’, including user-defined methods,
are responsible for implementing these requirements.

If ‘*read-eval*’ is false and ‘*print-readably*’ is true, any such
method that would output a reference to the “‘#.’” reader macro will
either output something else or will signal an error (as described
above).

Examples:
.........

      (let ((x (list "a" '\a (gensym) '((a (b (c))) d e f g)))
            (*print-escape* nil)
            (*print-gensym* nil)
            (*print-level* 3)
            (*print-length* 3))
        (write x)
        (let ((*print-readably* t))
          (terpri)
          (write x)
          :done))
     ▷ (a a G4581 ((A #) D E ...))
     ▷ ("a" |a| #:G4581 ((A (B (C))) D E F G))
     → :DONE

     ;; This is setup code is shared between the examples
     ;; of three hypothetical implementations which follow.
      (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32005763>
      (setf (gethash table 1) 'one) → ONE
      (setf (gethash table 2) 'two) → TWO

     ;; Implementation A
      (let ((*print-readably* t)) (print table))
      Error: Can't print #<HASH-TABLE EQL 0/120 32005763> readably.

     ;; Implementation B
     ;; No standardized #S notation for hash tables is defined,
     ;; but there might be an implementation-defined notation.
      (let ((*print-readably* t)) (print table))
     ▷ #S(HASH-TABLE :TEST EQL :SIZE 120 :CONTENTS (1 ONE 2 TWO))
     → #<HASH-TABLE EQL 0/120 32005763>

     ;; Implementation C
     ;; Note that #. notation can only be used if *READ-EVAL* is true.
     ;; If *READ-EVAL* were false, this same implementation might have to
     ;; signal an error unless it had yet another printing strategy to fall
     ;; back on.
      (let ((*print-readably* t)) (print table))
     ▷ #.(LET ((HASH-TABLE (MAKE-HASH-TABLE)))
     ▷     (SETF (GETHASH 1 HASH-TABLE) ONE)
     ▷     (SETF (GETHASH 2 HASH-TABLE) TWO)
     ▷     HASH-TABLE)
     → #<HASH-TABLE EQL 0/120 32005763>

See Also:
.........

*note write::, *note print-unreadable-object::

Notes:
......

The rules for “similarity” imply that ‘#A’ or ‘#(’ syntax cannot be used
for arrays of element type other than ‘t’.  An implementation will have
to use another syntax or signal an error of type ‘print-not-readable’.


File: ansicl,  Node: *print-right-margin*,  Next: print-not-readable,  Prev: *print-readably*,  Up: Printer

*print-right-margin* (Variable)
===============================

Value Type:
...........

a non-negative integer, or ‘nil’.

Initial Value:
..............

‘nil’.

Description:
............

If it is non-nil, it specifies the right margin (as integer number of
ems) to use when the pretty printer is making layout decisions.

If it is ‘nil’, the right margin is taken to be the maximum line length
such that output can be displayed without wraparound or truncation.  If
this cannot be determined, an implementation-dependent value is used.

Notes:
......

This measure is in units of ems in order to be compatible with
implementation-defined variable-width fonts while still not requiring
the language to provide support for fonts.


File: ansicl,  Node: print-not-readable,  Next: print-not-readable-object,  Prev: *print-right-margin*,  Up: Printer

print-not-readable (Condition Type)
===================================

Class Precedence List:
......................

‘print-not-readable’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘print-not-readable’ consists of error conditions that occur
during output while ‘*print-readably*’ is true, as a result of
attempting to write a printed representation with the Lisp printer that
would not be correctly read back with the Lisp reader.  The object which
could not be printed is initialized by the :object initialization
argument to ‘make-condition’, and is accessed by the function
‘print-not-readable-object’.

See Also:
.........

*note print-not-readable-object::


File: ansicl,  Node: print-not-readable-object,  Next: format,  Prev: print-not-readable,  Up: Printer

print-not-readable-object (Function)
====================================

Syntax:
.......

 -- Function: print-not-readable-object condition → object

Arguments and Values:
.....................

CONDITION—a condition of type ‘print-not-readable’.

OBJECT—an object.

Description:
............

Returns the object that could not be printed readably in the situation
represented by CONDITION.

See Also:
.........

*note print-not-readable::, *note Chapter 9 (Conditions): Conditions.


File: ansicl,  Node: format,  Prev: print-not-readable-object,  Up: Printer

format (Function)
=================

Syntax:
.......

 -- Function: format destination control-string &rest args → result

Arguments and Values:
.....................

DESTINATION—‘nil’, ‘t’, a stream, or a string with a fill pointer.

CONTROL-STRING—a format control.

ARGS—format arguments for CONTROL-STRING.

RESULT—if DESTINATION is non-nil, then ‘nil’; otherwise, a string.

Description:
............

‘format’ produces formatted output by outputting the characters of
CONTROL-STRING and observing that a tilde introduces a directive.  The
character after the tilde, possibly preceded by prefix parameters and
modifiers, specifies what kind of formatting is desired.  Most
directives use one or more elements of ARGS to create their output.

If DESTINATION is a string, a stream, or ‘t’, then the RESULT is ‘nil’.
Otherwise, the RESULT is a string containing the ‘output.’

‘format’ is useful for producing nicely formatted text, producing
good-looking messages, and so on.  ‘format’ can generate and return a
string or output to DESTINATION.

For details on how the CONTROL-STRING is interpreted, see *note Section
22.3 (Formatted Output): Formatted Output.

Affected By:
............

‘*standard-output*’, ‘*print-escape*’, ‘*print-radix*’, ‘*print-base*’,
‘*print-circle*’, ‘*print-pretty*’, ‘*print-level*’, ‘*print-length*’,
‘*print-case*’, ‘*print-gensym*’, ‘*print-array*’.

Exceptional Situations:
.......................

If DESTINATION is a string with a fill pointer, the consequences are
undefined if destructive modifications are performed directly on the
string during the dynamic extent of the call.

See Also:
.........

*note write::, *note Section 13.1.10 (Documentation of
Implementation-Defined Scripts): Documentation of Implementation-Defined
Scripts.


File: ansicl,  Node: Reader,  Next: System Construction,  Prev: Printer,  Up: Top

23 Reader
*********

* Menu:

* Reader Concepts::

Dictionary

* readtable::
* copy-readtable::
* make-dispatch-macro-character::
* read; read-preserving-whitespace::
* read-delimited-list::
* read-from-string::
* readtable-case::
* readtablep::
* set-dispatch-macro-character; get-dispatch-macro-character::
* set-macro-character; get-macro-character::
* set-syntax-from-char::
* with-standard-io-syntax::
* *read-base*::
* *read-default-float-format*::
* *read-eval*::
* *read-suppress*::
* *readtable*::
* reader-error::


File: ansicl,  Node: Reader Concepts,  Next: readtable,  Up: Reader

23.1 Reader Concepts
====================

* Menu:

* Dynamic Control of the Lisp Reader::
* Effect of Readtable Case on the Lisp Reader::
* Argument Conventions of Some Reader Functions::


File: ansicl,  Node: Dynamic Control of the Lisp Reader,  Next: Effect of Readtable Case on the Lisp Reader,  Up: Reader Concepts

23.1.1 Dynamic Control of the Lisp Reader
-----------------------------------------

Various aspects of the Lisp reader can be controlled dynamically.  See
*note Section 2.1.1 (Readtables): Readtables. and *note Section 2.1.2
(Variables that affect the Lisp Reader): Variables that affect the Lisp
Reader.


File: ansicl,  Node: Effect of Readtable Case on the Lisp Reader,  Next: Argument Conventions of Some Reader Functions,  Prev: Dynamic Control of the Lisp Reader,  Up: Reader Concepts

23.1.2 Effect of Readtable Case on the Lisp Reader
--------------------------------------------------

The readtable case of the current readtable affects the Lisp reader in
the following ways:

:upcase

     When the readtable case is :upcase, unescaped constituent
     characters are converted to uppercase, as specified in *note
     Section 2.2 (Reader Algorithm): Reader Algorithm.

:downcase

     When the readtable case is :downcase, unescaped constituent
     characters are converted to lowercase.

:preserve

     When the readtable case is :preserve, the case of all characters
     remains unchanged.

:invert

     When the readtable case is :invert, then if all of the unescaped
     letters in the extended token are of the same case, those
     (unescaped) letters are converted to the opposite case.

23.1.2.1 Examples of Effect of Readtable Case on the Lisp Reader
................................................................

      (defun test-readtable-case-reading ()
        (let ((*readtable* (copy-readtable nil)))
          (format t "READTABLE-CASE  Input   Symbol-name~
                   ~%-----------------------------------~
                   ~%")
          (dolist (readtable-case '(:upcase :downcase :preserve :invert))
            (setf (readtable-case *readtable*) readtable-case)
            (dolist (input '("ZEBRA" "Zebra" "zebra"))
              (format t "~&:~A~16T~A~24T~A"
                      (string-upcase readtable-case)
                      input
                      (symbol-name (read-from-string input)))))))

The output from ‘(test-readtable-case-reading)’ should be as follows:

      READTABLE-CASE     Input Symbol-name
      -------------------------------------
         :UPCASE         ZEBRA   ZEBRA
         :UPCASE         Zebra   ZEBRA
         :UPCASE         zebra   ZEBRA
         :DOWNCASE       ZEBRA   zebra
         :DOWNCASE       Zebra   zebra
         :DOWNCASE       zebra   zebra
         :PRESERVE       ZEBRA   ZEBRA
         :PRESERVE       Zebra   Zebra
         :PRESERVE       zebra   zebra
         :INVERT         ZEBRA   zebra
         :INVERT         Zebra   Zebra
         :INVERT         zebra   ZEBRA


File: ansicl,  Node: Argument Conventions of Some Reader Functions,  Prev: Effect of Readtable Case on the Lisp Reader,  Up: Reader Concepts

23.1.3 Argument Conventions of Some Reader Functions
----------------------------------------------------

23.1.3.1 The EOF-ERROR-P argument
.................................

EOF-ERROR-P in input function calls controls what happens if input is
from a file (or any other input source that has a definite end) and the
end of the file is reached.  If EOF-ERROR-P is true (the default), an
error of type ‘end-of-file’ is signaled at end of file.  If it is false,
then no error is signaled, and instead the function returns EOF-VALUE.

Functions such as ‘read’ that read the representation of an object
rather than a single character always signals an error, regardless of
EOF-ERROR-P, if the file ends in the middle of an object representation.
For example, if a file does not contain enough right parentheses to
balance the left parentheses in it, ‘read’ signals an error.  If a file
ends in a symbol or a number immediately followed by end-of-file, ‘read’
reads the symbol or number successfully and when called again will act
according to EOF-ERROR-P.  Similarly, the function ‘read-line’
successfully reads the last line of a file even if that line is
terminated by end-of-file rather than the newline character.  Ignorable
text, such as lines containing only whitespaceare not considered to
begin an object; if ‘read’ begins to read an expression but sees only
such ignorable text, it does not consider the file to end in the middle
of an object.  Thus an EOF-ERROR-P argument controls what happens when
the file ends between objects.

23.1.3.2 The RECURSIVE-P argument
.................................

If RECURSIVE-P is supplied and not ‘nil’, it specifies that this
function call is not an outermost call to ‘read’ but an embedded call,
typically from a reader macro function.  It is important to distinguish
such recursive calls for three reasons.

  1. An outermost call establishes the context within which the ‘#N=’
     and ‘#N#’ syntax is scoped.  Consider, for example, the expression

           (cons '#3=(p q r) '(x y . #3#))

     If the single-quote reader macro were defined in this way:

           (set-macro-character #\'       ;incorrect
              #'(lambda (stream char)
                   (declare (ignore char))
                   (list 'quote (read stream))))

     then each call to the single-quote reader macro function would
     establish independent contexts for the scope of ‘read’ information,
     including the scope of identifications between markers like “‘#3=’”
     and “‘#3#’”.  However, for this expression, the scope was clearly
     intended to be determined by the outer set of parentheses, so such
     a definition would be incorrect.  The correct way to define the
     single-quote reader macro uses RECURSIVE-P:

           (set-macro-character #\'       ;correct
              #'(lambda (stream char)
                   (declare (ignore char))
                   (list 'quote (read stream t nil t))))

  2. A recursive call does not alter whether the reading process is to
     preserve whitespaceoutermost call was to ‘read’ or
     ‘read-preserving-whitespace’).  Suppose again that single-quote
     were to be defined as shown above in the incorrect definition.
     Then a call to ‘read-preserving-whitespace’ that read the
     expression ‘'foo<Space>’ would fail to preserve the space character
     following the symbol ‘foo’ because the single-quote reader macro
     function calls ‘read’, not ‘read-preserving-whitespace’, to read
     the following expression (in this case ‘foo’).  The correct
     definition, which passes the value true for RECURSIVE-P to ‘read’,
     allows the outermost call to determine whether whitespace

  3. When end-of-file is encountered and the EOF-ERROR-P argument is not
     ‘nil’, the kind of error that is signaled may depend on the value
     of RECURSIVE-P.  If RECURSIVE-P is true, then the end-of-file is
     deemed to have occurred within the middle of a printed
     representation; if RECURSIVE-P is false, then the end-of-file may
     be deemed to have occurred between objects rather than within the
     middle of one.


File: ansicl,  Node: readtable,  Next: copy-readtable,  Prev: Reader Concepts,  Up: Reader

readtable (System Class)
========================

Class Precedence List:
......................

‘readtable’, ‘t’

Description:
............

A readtable maps characters into syntax types for the Lisp reader; see
*note Chapter 2 (Syntax): Syntax.  A readtable also contains
associations between macro characters and their reader macro functions,
and records information about the case conversion rules to be used by
the Lisp reader when parsing symbols.

Each simple character must be representable in the readtable.  It is
implementation-defined whether non-simple characters can have syntax
descriptions in the readtable.

See Also:
.........

*note Section 2.1.1 (Readtables): Readtables, *note Section 22.1.3.13
(Printing Other Objects): PrintingOtherObjects.


File: ansicl,  Node: copy-readtable,  Next: make-dispatch-macro-character,  Prev: readtable,  Up: Reader

copy-readtable (Function)
=========================

Syntax:
.......

 -- Function: copy-readtable &optional from-readtable to-readtable →
          readtable

Arguments and Values:
.....................

FROM-READTABLE—a readtable designator.  The default is the current
readtable.

TO-READTABLE—a readtable or ‘nil’.  The default is ‘nil’.

READTABLE—the TO-READTABLE if it is non-nil, or else a fresh readtable.

Description:
............

‘copy-readtable’ copies FROM-READTABLE.

If TO-READTABLE is ‘nil’, a new readtable is created and returned.
Otherwise the readtable specified by TO-READTABLE is modified and
returned.

‘copy-readtable’ copies the setting of ‘readtable-case’.

Examples:
.........

      (setq zvar 123) → 123
      (set-syntax-from-char #\z #\' (setq table2 (copy-readtable))) → T
      zvar → 123
      (copy-readtable table2 *readtable*) → #<READTABLE 614000277>
      zvar → VAR
      (setq *readtable* (copy-readtable)) → #<READTABLE 46210223>
      zvar → VAR
      (setq *readtable* (copy-readtable nil)) → #<READTABLE 46302670>
      zvar → 123

See Also:
.........

*note readtable::, *note *readtable*::

Notes:
......

     (setq *readtable* (copy-readtable nil))

restores the input syntax to standard Common Lisp syntax, even if the
initial readtable has been clobbered (assuming it is not so badly
clobbered that you cannot type in the above expression).

On the other hand,

     (setq *readtable* (copy-readtable))

replaces the current readtable with a copy of itself.  This is useful if
you want to save a copy of a readtable for later use, protected from
alteration in the meantime.  It is also useful if you want to locally
bind the readtable to a copy of itself, as in:

     (let ((*readtable* (copy-readtable))) ...)


File: ansicl,  Node: make-dispatch-macro-character,  Next: read; read-preserving-whitespace,  Prev: copy-readtable,  Up: Reader

make-dispatch-macro-character (Function)
========================================

Syntax:
.......

 -- Function: make-dispatch-macro-character char &optional
          non-terminating-p readtable → ‘t’

Arguments and Values:
.....................

CHAR—a character.

NON-TERMINATING-P—a generalized boolean.  The default is false.

READTABLE—a readtable.  The default is the current readtable.

Description:
............

‘make-dispatch-macro-character’ makes CHAR be a dispatching macro
character in READTABLE.

Initially, every character in the dispatch table associated with the
CHAR has an associated function that signals an error of type
‘reader-error’.

If NON-TERMINATING-P is true, the dispatching macro character is made a
non-terminating macro character; if NON-TERMINATING-P is false, the
dispatching macro character is made a terminating macro character.

Examples:
.........

      (get-macro-character #\{) → NIL, false
      (make-dispatch-macro-character #\{) → T
      (not (get-macro-character #\{)) → false

The READTABLE is altered.

See Also:
.........

*note *readtable*::, *note set-dispatch-macro-character::


File: ansicl,  Node: read; read-preserving-whitespace,  Next: read-delimited-list,  Prev: make-dispatch-macro-character,  Up: Reader

read, read-preserving-whitespace (Function)
===========================================

Syntax:
.......

 -- Function: read &optional input-stream eof-error-p eof-value
          recursive-p → object

 -- Function: read-preserving-whitespace &optional
          input-stream eof-error-p eof-value recursive-p → object

Arguments and Values:
.....................

INPUT-STREAM—an input stream designator.

EOF-ERROR-P—a generalized boolean.  The default is true.

EOF-VALUE—an object.  The default is ‘nil’.

RECURSIVE-P—a generalized boolean.  The default is false.

OBJECT—an object (parsed by the Lisp reader) or the EOF-VALUE.

Description:
............

‘read’ parses the printed representation of an object from INPUT-STREAM
and builds such an object.

‘read-preserving-whitespace’ is like ‘read’ but preserves any
whitespacethat delimits the printed representation of the object.
‘read-preserving-whitespace’ is exactly like ‘read’ when the RECURSIVE-P
argument to ‘read-preserving-whitespace’ is true.

When ‘*read-suppress*’ is false, ‘read’ throws away the delimiting
character required by certain printed representations if it is a
whitespacebut ‘read’ preserves the character (using ‘unread-char’) if it
is syntactically meaningful, because it could be the start of the next
expression.

If a file ends in a symbol or a number immediately followed by an end of
file‘read’ reads the symbol or number successfully; when called again,
it sees the end of fileonly then acts according to EOF-ERROR-P.  If a
file contains ignorable text at the end, such as blank lines and
comments, ‘read’ does not consider it to end in the middle of an object.

If RECURSIVE-P is true, the call to ‘read’ is expected to be made from
within some function that itself has been called from ‘read’ or from a
similar input function, rather than from the top level.

Both functions return the object read from INPUT-STREAM.  EOF-VALUE is
returned if EOF-ERROR-P is false and end of file is reached before the
beginning of an object.

Examples:
.........

      (read)
     ▷ 'a
     → (QUOTE A)
      (with-input-from-string (is " ") (read is nil 'the-end)) → THE-END
      (defun skip-then-read-char (s c n)
         (if (char= c #\{) (read s t nil t) (read-preserving-whitespace s))
         (read-char-no-hang s)) → SKIP-THEN-READ-CHAR
      (let ((*readtable* (copy-readtable nil)))
         (set-dispatch-macro-character #\# #\{ #'skip-then-read-char)
         (set-dispatch-macro-character #\# #\} #'skip-then-read-char)
         (with-input-from-string (is "#{123 x #}123 y")
           (format t "~S ~S" (read is) (read is)))) → #\x, #\Space, NIL

As an example, consider this reader macro definition:

      (defun slash-reader (stream char)
        (declare (ignore char))
        `(path . ,(loop for dir = (read-preserving-whitespace stream t nil t)
                        then (progn (read-char stream t nil t)
                                    (read-preserving-whitespace stream t nil t))
                        collect dir
                        while (eql (peek-char nil stream nil nil t) #\/))))
      (set-macro-character #\/ #'slash-reader)

Consider now calling ‘read’ on this expression:

      (zyedh /usr/games/zork /usr/games/boggle)

The ‘/’ macro reads objects separated by more ‘/’ characters; thus
‘/usr/games/zork’ is intended to read as ‘(path usr games zork)’.  The
entire example expression should therefore be read as

      (zyedh (path usr games zork) (path usr games boggle))

However, if ‘read’ had been used instead of
‘read-preserving-whitespace’, then after the reading of the symbol
‘zork’, the following space would be discarded; the next call to
‘peek-char’ would see the following ‘/’, and the loop would continue,
producing this interpretation:

      (zyedh (path usr games zork usr games boggle))

There are times when whitespaceIf a command interpreter takes
single-character commands, but occasionally reads an object then if the
whitespaceafter a symbol is not discarded it might be interpreted as a
command some time later after the symbol had been read.

Affected By:
............

‘*standard-input*’, ‘*terminal-io*’, ‘*readtable*’,
‘*read-default-float-format*’, ‘*read-base*’, ‘*read-suppress*’,
‘*package*’, ‘*read-eval*’.

Exceptional Situations:
.......................

‘read’ signals an error of type ‘end-of-file’, regardless of
EOF-ERROR-P, if the file ends in the middle of an object representation.
For example, if a file does not contain enough right parentheses to
balance the left parentheses in it, ‘read’ signals an error.  This is
detected when ‘read’ or ‘read-preserving-whitespace’ is called with
RECURSIVE-P and EOF-ERROR-P non-nil, and end-of-file is reached before
the beginning of an object.

If EOF-ERROR-P is true, an error of type ‘end-of-file’ is signaled at
the end of file.

See Also:
.........

*note peek-char::, *note read-char::, *note unread-char::, *note
read-from-string::, *note read-delimited-list::, *note parse-integer::,
*note Chapter 2 (Syntax): Syntax, *note Section 23.1 (Reader Concepts):
Reader Concepts.


File: ansicl,  Node: read-delimited-list,  Next: read-from-string,  Prev: read; read-preserving-whitespace,  Up: Reader

read-delimited-list (Function)
==============================

Syntax:
.......

 -- Function: read-delimited-list char &optional input-stream
          recursive-p → list

Arguments and Values:
.....................

CHAR—a character.

INPUT-STREAM—an input stream designator.  The default is standard input.

RECURSIVE-P—a generalized boolean.  The default is false.

LIST—a list of the objects read.

Description:
............

‘read-delimited-list’ reads objects from INPUT-STREAM until the next
character after an object’s representation (ignoring whitespace

‘read-delimited-list’ looks ahead at each step for the next
non-whitespaceand peeks at it as if with ‘peek-char’.  If it is CHAR,
then the character is consumed and the list of objects is returned.  If
it is a constituent or escape character, then ‘read’ is used to read an
object, which is added to the end of the list.  If it is a macro
character, its reader macro function is called; if the function returns
a value, that value is added to the list.  The peek-ahead process is
then repeated.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ‘read’ or a similar function.

It is an error to reach end-of-file during the operation of
‘read-delimited-list’.

The consequences are undefined if CHAR has a syntax type of whitespacein
the current readtable.

Examples:
.........

      (read-delimited-list #\]) 1 2 3 4 5 6 ]
     → (1 2 3 4 5 6)

Suppose you wanted ‘#{a b c ... z}’ to read as a list of all pairs of
the elements a, b, c, ..., z, for example.

      #{p q z a}  reads as  ((p q) (p z) (p a) (q z) (q a) (z a))

This can be done by specifying a macro-character definition for ‘#{’
that does two things: reads in all the items up to the ‘}’, and
constructs the pairs.  ‘read-delimited-list’ performs the first task.

      (defun |#{-reader| (stream char arg)
        (declare (ignore char arg))
        (mapcon #'(lambda (x)
                   (mapcar #'(lambda (y) (list (car x) y)) (cdr x)))
               (read-delimited-list #\} stream t))) → |#{-reader|

      (set-dispatch-macro-character #\# #\{ #'|#{-reader|) → T
      (set-macro-character #\} (get-macro-character #\) nil))

Note that true is supplied for the RECURSIVE-P argument.

It is necessary here to give a definition to the character ‘}’ as well
to prevent it from being a constituent.  If the line

      (set-macro-character #\} (get-macro-character #\) nil))

shown above were not included, then the ‘}’ in

      #{ p q z a}

would be considered a constituent character, part of the symbol named
‘a}’.  This could be corrected by putting a space before the ‘}’, but it
is better to call ‘set-macro-character’.

Giving ‘}’ the same definition as the standard definition of the
character ‘)’ has the twin benefit of making it terminate tokens for use
with ‘read-delimited-list’ and also making it invalid for use in any
other context.  Attempting to read a stray ‘}’ will signal an error.

Affected By:
............

‘*standard-input*’, ‘*readtable*’, ‘*terminal-io*’.

See Also:
.........

*note read::, *note peek-char::, *note read-char::, *note unread-char::.

Notes:
......

‘read-delimited-list’ is intended for use in implementing reader macros.
Usually it is desirable for CHAR to be a terminating macro character so
that it can be used to delimit tokens; however, ‘read-delimited-list’
makes no attempt to alter the syntax specified for CHAR by the current
readtable.  The caller must make any necessary changes to the readtable
syntax explicitly.


File: ansicl,  Node: read-from-string,  Next: readtable-case,  Prev: read-delimited-list,  Up: Reader

read-from-string (Function)
===========================

Syntax:
.......

 -- Function: read-from-string string &optional eof-error-p eof-value
          &key start end preserve-whitespace → object, position

Arguments and Values:
.....................

STRING—a string.

EOF-ERROR-P—a generalized boolean.  The default is true.

EOF-VALUE—an object.  The default is ‘nil’.

START, END—bounding index designators of STRING.  The defaults for START
and END are ‘0’ and ‘nil’, respectively.

PRESERVE-WHITESPACE—a generalized boolean.  The default is false.

OBJECT—an object (parsed by the Lisp reader) or the EOF-VALUE.

POSITION—an integer greater than or equal to zero, and less than or
equal to one more than the length of the STRING.

Description:
............

Parses the printed representation of an object from the subsequence of
STRING bounded by START and END, as if ‘read’ had been called on an
input stream containing those same characters.

If PRESERVE-WHITESPACE is true, the operation will preserve whitespaceas
‘read-preserving-whitespace’ would do.

If an object is successfully parsed, the primary value, OBJECT, is the
object that was parsed.  If EOF-ERROR-P is false and if the end of the
SUBSTRING is reached, EOF-VALUE is returned.

The secondary value, POSITION, is the index of the first character in
the bounded STRING that was not read.  The POSITION may depend upon the
value of PRESERVE-WHITESPACE.  If the entire STRING was read, the
POSITION returned is either the LENGTH of the STRING or one greater than
the LENGTH of the STRING.

Examples:
.........

      (read-from-string " 1 3 5" t nil :start 2) → 3, 5
      (read-from-string "(a b c)") → (A B C), 7

Exceptional Situations:
.......................

If the end of the supplied substring occurs before an object can be
read, an error is signaled if EOF-ERROR-P is true.  An error is signaled
if the end of the SUBSTRING occurs in the middle of an incomplete
object.

See Also:
.........

*note read::, *note read-preserving-whitespace::

Notes:
......

The reason that POSITION is allowed to be beyond the length of the
STRING is to permit (but not require) the implementation to work by
simulating the effect of a trailing delimiter at the end of the bounded
STRING.  When PRESERVE-WHITESPACE is true, the POSITION might count the
simulated delimiter.


File: ansicl,  Node: readtable-case,  Next: readtablep,  Prev: read-from-string,  Up: Reader

readtable-case (Accessor)
=========================

Syntax:
.......

 -- Function: readtable-case readtable → mode

(setf (readtable-case readtable) mode)

Arguments and Values:
.....................

READTABLE—a readtable.

MODE—a case sensitivity mode.

Description:
............

Accesses the readtable case of READTABLE, which affects the way in which
the Lisp Reader reads symbols and the way in which the Lisp Printer
writes symbols.

Examples:
.........

See *note Section 23.1.2.1 (Examples of Effect of Readtable Case on the
Lisp Reader): ReadtableCaseReadExamples. and *note Section 22.1.3.3.2.1
(Examples of Effect of Readtable Case on the Lisp Printer):
ReadtableCasePrintExamples.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if READTABLE is not a
readtable.  Should signal an error of type ‘type-error’ if MODE is not a
case sensitivity mode.

See Also:
.........

*note *readtable*::, *note *print-escape*::, *note Section 2.2 (Reader
Algorithm): Reader Algorithm, *note Section 23.1.2 (Effect of Readtable
Case on the Lisp Reader): Effect of Readtable Case on the Lisp Reader,
*note Section 22.1.3.3.2 (Effect of Readtable Case on the Lisp Printer):
ReadtableCasePrintEffect.

Notes:
......

‘copy-readtable’ copies the readtable case of the READTABLE.


File: ansicl,  Node: readtablep,  Next: set-dispatch-macro-character; get-dispatch-macro-character,  Prev: readtable-case,  Up: Reader

readtablep (Function)
=====================

Syntax:
.......

 -- Function: readtablep object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘readtable’; otherwise, returns false.

Examples:
.........

      (readtablep *readtable*) → true
      (readtablep (copy-readtable)) → true
      (readtablep '*readtable*) → false

Notes:
......

      (readtablep OBJECT) ≡ (typep OBJECT 'readtable)


File: ansicl,  Node: set-dispatch-macro-character; get-dispatch-macro-character,  Next: set-macro-character; get-macro-character,  Prev: readtablep,  Up: Reader

set-dispatch-macro-character, get-dispatch-macro-character (Function)
=====================================================================

Syntax:
.......

 -- Function: get-dispatch-macro-character disp-char sub-char &optional
          readtable → function

 -- Function: set-dispatch-macro-character disp-char sub-char
          new-function &optional readtable → ‘t’

Arguments and Values:
.....................

DISP-CHAR—a character.

SUB-CHAR—a character.

READTABLE—a readtable designator.  The default is the current readtable.

FUNCTION—a function designator or ‘nil’.

NEW-FUNCTION—a function designator.

Description:
............

‘set-dispatch-macro-character’ causes NEW-FUNCTION to be called when
DISP-CHAR followed by SUB-CHAR is read.  If SUB-CHAR is a lowercase
letter, it is converted to its uppercase equivalent.  It is an error if
SUB-CHAR is one of the ten decimal digits.

‘set-dispatch-macro-character’ installs a NEW-FUNCTION to be called when
a particular dispatching macro character pair is read.  NEW-FUNCTION is
installed as the dispatch function to be called when READTABLE is in use
and when DISP-CHAR is followed by SUB-CHAR.

For more information about how the NEW-FUNCTION is invoked, see *note
Section 2.1.4.4 (Macro Characters): MacroChars.

‘get-dispatch-macro-character’ retrieves the dispatch function
associated with DISP-CHAR and SUB-CHAR in READTABLE.

‘get-dispatch-macro-character’ returns the macro-character function for
SUB-CHAR under DISP-CHAR, or ‘nil’ if there is no function associated
with SUB-CHAR.  If SUB-CHAR is a decimal digit,
‘get-dispatch-macro-character’ returns ‘nil’.

Examples:
.........

      (get-dispatch-macro-character #\# #\{) → NIL
      (set-dispatch-macro-character #\# #\{        ;dispatch on #{
         #'(lambda(s c n)
             (let ((list (read s nil (values) t)))  ;list is object after #n{
               (when (consp list)                   ;return nth element of list
                 (unless (and n (< 0 n (length list))) (setq n 0))
                 (setq list (nth n list)))
              list))) → T
      #{(1 2 3 4) → 1
      #3{(0 1 2 3) → 3
      #{123 → 123

If it is desired that ‘#$foo’ : as if it were ‘(dollars foo)’.

     (defun |#$-reader| (stream subchar arg)
        (declare (ignore subchar arg))
        (list 'dollars (read stream t nil t))) → |#$-reader|
      (set-dispatch-macro-character #\# #\$ #'|#$-reader|) → T

See Also:
.........

*note Section 2.1.4.4 (Macro Characters): MacroChars.

Side Effects:
.............

The READTABLE is modified.

Affected By:
............

‘*readtable*’.

Exceptional Situations:
.......................

For either function, an error is signaled if DISP-CHAR is not a
dispatching macro character in READTABLE.

See Also:
.........

*note *readtable*::

Notes:
......

It is necessary to use ‘make-dispatch-macro-character’ to set up the
dispatch character before specifying its sub-characters.


File: ansicl,  Node: set-macro-character; get-macro-character,  Next: set-syntax-from-char,  Prev: set-dispatch-macro-character; get-dispatch-macro-character,  Up: Reader

set-macro-character, get-macro-character (Function)
===================================================

Syntax:
.......

 -- Function: get-macro-character char &optional readtable → function,
          non-terminating-p

 -- Function: set-macro-character char new-function &optional
          non-terminating-p readtable → ‘t’

Arguments and Values:
.....................

CHAR—a character.

NON-TERMINATING-P—a generalized boolean.  The default is false.

READTABLE—a readtable designator.  The default is the current readtable.

FUNCTION—‘nil’, or a designator for a function of two arguments.

NEW-FUNCTION—a function designator.

Description:
............

‘get-macro-character’ returns as its primary value, FUNCTION, the reader
macro function associated with CHAR in READTABLE (if any), or else
‘nil’ if CHAR is not a macro character in READTABLE.  The secondary
value, NON-TERMINATING-P, is true if CHAR is a non-terminating macro
character; otherwise, it is false.

‘set-macro-character’ causes CHAR to be a macro character associated
with the reader macro function NEW-FUNCTION (or the designator for
NEW-FUNCTION) in READTABLE.  If NON-TERMINATING-P is true, CHAR becomes
a non-terminating macro character; otherwise it becomes a terminating
macro character.

Examples:
.........

      (get-macro-character #\{) → NIL, false
      (not (get-macro-character #\;)) → false

The following is a possible definition for the single-quote reader macro
in standard syntax:

      (defun single-quote-reader (stream char)
        (declare (ignore char))
        (list 'quote (read stream t nil t))) → SINGLE-QUOTE-READER
      (set-macro-character #\' #'single-quote-reader) → T

Here ‘single-quote-reader’ reads an object following the single-quote
and returns a list of ‘quote’ and that object.  The CHAR argument is
ignored.

The following is a possible definition for the semicolon reader macro in
standard syntax:

      (defun semicolon-reader (stream char)
        (declare (ignore char))
        ;; First swallow the rest of the current input line.
        ;; End-of-file is acceptable for terminating the comment.
        (do () ((char= (read-char stream nil #\Newline t) #\Newline)))
        ;; Return zero values.
        (values)) → SEMICOLON-READER
      (set-macro-character #\; #'semicolon-reader) → T

Side Effects:
.............

The READTABLE is modified.

See Also:
.........

*note *readtable*::


File: ansicl,  Node: set-syntax-from-char,  Next: with-standard-io-syntax,  Prev: set-macro-character; get-macro-character,  Up: Reader

set-syntax-from-char (Function)
===============================

Syntax:
.......

 -- Function: set-syntax-from-char to-char from-char &optional
          to-readtable from-readtable → ‘t’

Arguments and Values:
.....................

TO-CHAR—a character.

FROM-CHAR—a character.

TO-READTABLE—a readtable.  The default is the current readtable.

FROM-READTABLE—a readtable designator.  The default is the standard
readtable.

Description:
............

‘set-syntax-from-char’ makes the syntax of TO-CHAR in TO-READTABLE be
the same as the syntax of FROM-CHAR in FROM-READTABLE.

‘set-syntax-from-char’ copies the syntax types of FROM-CHAR.  If
FROM-CHAR is a macro character, its reader macro function is copied
also.  If the character is a dispatching macro character, its entire
dispatch table of reader macro functions is copied.  The constituent
traits of FROM-CHAR are not copied.

A macro definition from a character such as ‘"’ can be copied to another
character; the standard definition for ‘"’ looks for another character
that is the same as the character that invoked it.  The definition of
‘(’ can not be meaningfully copied to ‘{’, on the other hand.  The
result is that lists are of the form ‘{a b c)’, not ‘{a b c}’, because
the definition always looks for a closing parenthesis, not a closing
brace.

Examples:
.........

      (set-syntax-from-char #\7 #\;) → T
      123579 → 1235

Side Effects:
.............

The TO-READTABLE is modified.

Affected By:
............

The existing values in the FROM-READTABLE.

See Also:
.........

*note set-macro-character::, *note make-dispatch-macro-character::,
*note Section 2.1.4 (Character Syntax Types): Character Syntax Types.

Notes:
......

The constituent traits of a character are “hard wired” into the parser
for extended tokens.  For example, if the definition of ‘S’ is copied to
‘*’, then ‘*’ will become a constituent that is alphabeticshort float
exponent marker.  For further information, see *note Section 2.1.4.2
(Constituent Traits): ConstituentTraits.


File: ansicl,  Node: with-standard-io-syntax,  Next: *read-base*,  Prev: set-syntax-from-char,  Up: Reader

with-standard-io-syntax (Macro)
===============================

Syntax:
.......

 -- Macro: with-standard-io-syntax {form}* → {result}*

Arguments and Values:
.....................

FORMS—an implicit progn.

RESULTS—the values returned by the forms.

Description:
............

Within the dynamic extent of the body of FORMS, all reader/printer
control variables, including any implementation-defined ones not
specified by this standard, are bound to values that produce standard
read/print behavior.  The values for the variables specified by this
standard are listed in the next figure.

Variable                        Value
---------------------------------------------------------------------
‘*package*’                     The ‘CL-USER’ package
‘*print-array*’                 ‘t’
‘*print-base*’                  ‘10’
‘*print-case*’                  :upcase
‘*print-circle*’                ‘nil’
‘*print-escape*’                ‘t’
‘*print-gensym*’                ‘t’
‘*print-length*’                ‘nil’
‘*print-level*’                 ‘nil’
‘*print-lines*’                 ‘nil’
‘*print-miser-width*’           ‘nil’
‘*print-pprint-dispatch*’       The standard pprint dispatch table
‘*print-pretty*’                ‘nil’
‘*print-radix*’                 ‘nil’
‘*print-readably*’              ‘t’
‘*print-right-margin*’          ‘nil’
‘*read-base*’                   ‘10’
‘*read-default-float-format*’   ‘single-float’
‘*read-eval*’                   ‘t’
‘*read-suppress*’               ‘nil’
‘*readtable*’                   The standard readtable

Figure 23.1: Values of standard control variables

Examples:
.........

      (with-open-file (file pathname :direction :output)
        (with-standard-io-syntax
          (print data file)))

     ;;; ... Later, in another Lisp:

      (with-open-file (file pathname :direction :input)
        (with-standard-io-syntax
          (setq data (read file))))


File: ansicl,  Node: *read-base*,  Next: *read-default-float-format*,  Prev: with-standard-io-syntax,  Up: Reader

*read-base* (Variable)
======================

Value Type:
...........

a radix.

Initial Value:
..............

‘10’.

Description:
............

Controls the interpretation of tokens by ‘read’ as being integers or
ratios.

The value of ‘*read-base*’, called the “current input base”, is the
radix in which integers and ratios are to be read by the Lisp reader.
The parsing of other numeric types (e.g., floats) is not affected by
this option.

The effect of ‘*read-base*’ on the reading of any particular rational
number can be locally overridden by explicit use of the ‘#O’, ‘#X’,
‘#B’, or ‘#nR’ syntax or by a trailing decimal point.

Examples:
.........

      (dotimes (i 6)
        (let ((*read-base* (+ 10. i)))
          (let ((object (read-from-string "(\\DAD DAD |BEE| BEE 123. 123)")))
            (print (list *read-base* object)))))
     ▷ (10 (DAD DAD BEE BEE 123 123))
     ▷ (11 (DAD DAD BEE BEE 123 146))
     ▷ (12 (DAD DAD BEE BEE 123 171))
     ▷ (13 (DAD DAD BEE BEE 123 198))
     ▷ (14 (DAD 2701 BEE BEE 123 227))
     ▷ (15 (DAD 3088 BEE 2699 123 258))
     → NIL

Notes:
......

Altering the input radix can be useful when reading data files in
special formats.


File: ansicl,  Node: *read-default-float-format*,  Next: *read-eval*,  Prev: *read-base*,  Up: Reader

*read-default-float-format* (Variable)
======================================

Value Type:
...........

one of the atomic type specifiers ‘short-float’, ‘single-float’,
‘double-float’, or ‘long-float’, or else some other type specifier
defined by the implementation to be acceptable.

Initial Value:
..............

The symbol ‘single-float’.

Description:
............

Controls the floating-point format that is to be used when reading a
floating-point number that has no exponent marker or that has ‘e’ or ‘E’
for an exponent marker.  Other exponent markers explicitly prescribe the
floating-point format to be used.

The printer uses ‘*read-default-float-format*’ to guide the choice of
exponent markers when printing floating-point numbers.

Examples:
.........

      (let ((*read-default-float-format* 'double-float))
        (read-from-string "(1.0 1.0e0 1.0s0 1.0f0 1.0d0 1.0L0)"))
     → (1.0   1.0   1.0   1.0 1.0   1.0)   ;Implementation has float format F.
     → (1.0   1.0   1.0s0 1.0 1.0   1.0)   ;Implementation has float formats S and F.
     → (1.0d0 1.0d0 1.0   1.0 1.0d0 1.0d0) ;Implementation has float formats F and D.
     → (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0d0) ;Implementation has float formats S, F, D.
     → (1.0d0 1.0d0 1.0   1.0 1.0d0 1.0L0) ;Implementation has float formats F, D, L.
     → (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0L0) ;Implementation has formats S, F, D, L.


File: ansicl,  Node: *read-eval*,  Next: *read-suppress*,  Prev: *read-default-float-format*,  Up: Reader

*read-eval* (Variable)
======================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

true.

Description:
............

If it is true, the ‘#.’ reader macro has its normal effect.  Otherwise,
that reader macro signals an error of type ‘reader-error’.

See Also:
.........

*note *print-readably*::

Notes:
......

If ‘*read-eval*’ is false and ‘*print-readably*’ is true, any method for
‘print-object’ that would output a reference to the ‘#.’ reader macro
either outputs something different or signals an error of type
‘print-not-readable’.


File: ansicl,  Node: *read-suppress*,  Next: *readtable*,  Prev: *read-eval*,  Up: Reader

*read-suppress* (Variable)
==========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

false.

Description:
............

This variable is intended primarily to support the operation of the
read-time conditional notations ‘#+’ and ‘#-’.  It is important for the
reader macros which implement these notations to be able to skip over
the printed representation of an expression despite the possibility that
the syntax of the skipped expression may not be entirely valid for the
current implementation, since ‘#+’ and ‘#-’ exist in order to allow the
same program to be shared among several Lisp implementations (including
dialects other than Common Lisp) despite small incompatibilities of
syntax.

If it is false, the Lisp reader operates normally.

If the value of ‘*read-suppress*’ is true, ‘read’,
‘read-preserving-whitespace’, ‘read-delimited-list’, and
‘read-from-string’ all return a primary value of ‘nil’ when they
complete successfully; however, they continue to parse the
representation of an object in the normal way, in order to skip over the
object, and continue to indicate end of file in the normal way.  Except
as noted below, any standardized reader macrothat is defined to reada
following object or token will do so, but not signal an error if the
object read is not of an appropriate type or syntax.  The standard
syntax and its associated reader macros will not construct any new
objects (e.g., when reading the representation of a symbol, no symbol
will be constructed or interned).

Extended tokens

     All extended tokens are completely uninterpreted.  Errors such as
     those that might otherwise be signaled due to detection of invalid
     potential numbers, invalid patterns of package markers, and invalid
     uses of the dot character are suppressed.

Dispatching macro characters (including sharpsign)

     Dispatching macro characters continue to parse an infix numerical
     argument, and invoke the dispatch function.  The standardized
     sharpsign reader macros do not enforce any constraints on either
     the presence of or the value of the numerical argument.

‘#=’

     The ‘#=’ notation is totally ignored.  It does not read a following
     object.  It produces no object, but is treated as whitespace

‘##’

     The ‘##’ notation always produces ‘nil’.

No matter what the value of ‘*read-suppress*’, parentheses still
continue to delimit and construct lists; the ‘#(’ notation continues to
delimit vectors; and comments, strings, and the single-quote and
backquote notations continue to be interpreted properly.  Such
situations as ‘')’,‘#<’, ‘#)’, and ‘#<Space>’ continue to signal errors.

Examples:
.........

      (let ((*read-suppress* t))
        (mapcar #'read-from-string
                '("#(foo bar baz)" "#P(:type :lisp)" "#c1.2"
                  "#.(PRINT 'FOO)" "#3AHELLO" "#S(INTEGER)"
                  "#*ABC" "#\GARBAGE" "#RALPHA" "#3R444")))
     → (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)

See Also:
.........

*note read::, *note Chapter 2 (Syntax): Syntax.

Notes:
......

Programmers and implementations that define additional macro characters
are strongly encouraged to make them respect ‘*read-suppress*’ just as
standardized macro characters do.  That is, when the value of
‘*read-suppress*’ is true, they should ignore type errors when reading a
following object and the functions that implement dispatching macro
characters should tolerate ‘nil’ as their infix parameter value even if
a numeric value would ordinarily be required.


File: ansicl,  Node: *readtable*,  Next: reader-error,  Prev: *read-suppress*,  Up: Reader

*readtable* (Variable)
======================

Value Type:
...........

a readtable.

Initial Value:
..............

A readtable that conforms to the description of Common Lisp syntax in
*note Chapter 2 (Syntax): Syntax.

Description:
............

The value of ‘*readtable*’ is called the current readtable.  It controls
the parsing behavior of the Lisp reader, and can also influence the Lisp
printer (e.g., see the function *note readtable-case::).

Examples:
.........

      (readtablep *readtable*) → true
      (setq zvar 123) → 123
      (set-syntax-from-char #\z #\' (setq table2 (copy-readtable))) → T
      zvar → 123
      (setq *readtable* table2) → #<READTABLE>
      zvar → VAR
      (setq *readtable* (copy-readtable nil)) → #<READTABLE>
      zvar → 123

Affected By:
............

‘compile-file’, ‘load’

See Also:
.........

*note compile-file::, *note load::, *note readtable::, *note Section
2.1.1.1 (The Current Readtable): CurrentReadtable.


File: ansicl,  Node: reader-error,  Prev: *readtable*,  Up: Reader

reader-error (Condition Type)
=============================

Class Precedence List:
......................

‘reader-error’, ‘parse-error’, ‘stream-error’, ‘error’,
‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘reader-error’ consists of error conditions that are related to
tokenization and parsing done by the Lisp reader.

See Also:
.........

*note read::, *note stream-error-stream::, *note Section 23.1 (Reader
Concepts): Reader Concepts.


File: ansicl,  Node: System Construction,  Next: Environment,  Prev: Reader,  Up: Top

24 System Construction
**********************

* Menu:

* System Construction Concepts::

Dictionary

* compile-file::
* compile-file-pathname::
* load::
* with-compilation-unit::
* *features*::
* *compile-file-pathname*; *compile-file-truename*::
* *load-pathname*; *load-truename*::
* *compile-print*; *compile-verbose*::
* *load-print*; *load-verbose*::
* *modules*::
* provide; require::


File: ansicl,  Node: System Construction Concepts,  Next: compile-file,  Up: System Construction

24.1 System Construction Concepts
=================================

* Menu:

* Loading::
* Features::


File: ansicl,  Node: Loading,  Next: Features,  Up: System Construction Concepts

24.1.1 Loading
--------------

To ‘load’ a file is to treat its contents as code and execute that code.
The file may contain “source code” or “compiled code”.

A file containing source code is called a “source file”.  Loading a
source file is accomplished essentially by sequentially
readingevaluating each immediately after it is read.

A file containing compiled code is called a “compiled file”.  Loading a
compiled file is similar to loading a source file, except that the file
does not contain text but rather an implementation-dependent
representation of pre-digested expressions created by the compiler.
Often, a compiled file can be loaded more quickly than a source file.
See *note Section 3.2 (Compilation): Compilation.

The way in which a source file is distinguished from a compiled file is
implementation-dependent.


File: ansicl,  Node: Features,  Prev: Loading,  Up: System Construction Concepts

24.1.2 Features
---------------

A “feature” is an aspect or attribute of Common Lisp, of the
implementation, or of the environment.  A feature is identified by a
symbol.

A feature is said to be “present” in a Lisp image if and only if the
symbol naming it is an element of the list held by the variable
‘*features*’, which is called the “features list”.

24.1.2.1 Feature Expressions
............................

Boolean combinations of features, called “feature expressions”, are used
by the ‘#+’ and ‘#-’ reader macros in order to direct conditional
reading of expressions by the Lisp reader.

The rules for interpreting a feature expression are as follows:

feature

     If a symbol naming a feature is used as a feature expression, the
     feature expression succeeds if that feature is present; otherwise
     it fails.

‘(not FEATURE-CONDITIONAL)’

     A not feature expression succeeds if its argument
     FEATURE-CONDITIONAL fails; otherwise, it succeeds.

‘(and {feature-conditional}*)’

     An and feature expression succeeds if all of its argument
     FEATURE-CONDITIONALS succeed; otherwise, it fails.

‘(or {feature-conditional}*)’

     An or feature expression succeeds if any of its argument
     FEATURE-CONDITIONALS succeed; otherwise, it fails.

24.1.2.1.1 Examples of Feature Expressions
..........................................

For example, suppose that in implementation A, the features ‘spice’ and
‘perq’ are present, but the feature ‘lispm’ is not present; in
implementation B, the feature ‘lispm’ is present, but the features
‘spice’ and ‘perq’ are not present; and in implementation C, none of the
features ‘spice’, lispm, or ‘perq’ are present.  The next figure shows
some sample expressions, and how they would be read

‘(cons #+spice "Spice" #-spice
"Lispm" x)’
in implementation A ...               ‘(CONS "Spice" X)’
in implementation B ...               ‘(CONS "Lispm" X)’
in implementation C ...               ‘(CONS "Lispm" X)’
‘(cons #+spice "Spice" #+LispM
"Lispm" x)’
in implementation A ...               ‘(CONS "Spice" X)’
in implementation B ...               ‘(CONS "Lispm" X)’
in implementation C ...               ‘(CONS X)’
‘(setq a '(1 2 #+perq 43 #+(not
perq) 27))’
in implementation A ...               ‘(SETQ A '(1 2 43))’
in implementation B ...               ‘(SETQ A '(1 2 27))’
in implementation C ...               ‘(SETQ A '(1 2 27))’
‘(let ((a 3) #+(or spice lispm) (b
3)) (foo a))’
in implementation A ...               ‘(LET ((A 3) (B 3)) (FOO A))’
in implementation B ...               ‘(LET ((A 3) (B 3)) (FOO A))’
in implementation C ...               ‘(LET ((A 3)) (FOO A))’
‘(cons #+Lispm "#+Spice" #+Spice
"foo" #-(or Lispm Spice) 7 x)’
in implementation A ...               ‘(CONS "foo" X)’
in implementation B ...               ‘(CONS "#+Spice" X)’
in implementation C ...               ‘(CONS 7 X)’

Figure 24.1: Features examples


File: ansicl,  Node: compile-file,  Next: compile-file-pathname,  Prev: System Construction Concepts,  Up: System Construction

compile-file (Function)
=======================

Syntax:
.......

 -- Function: compile-file input-file &key output-file verbose
          print external-format → output-truename, warnings-p, failure-p

Arguments and Values:
.....................

INPUT-FILE—a pathname designator.  (Default fillers for unspecified
components are taken from ‘*default-pathname-defaults*’.)

OUTPUT-FILE—a pathname designator.  The default is
implementation-defined.

VERBOSE—a generalized boolean.  The default is the value of
‘*compile-verbose*’.

PRINT—a generalized boolean.  The default is the value of
‘*compile-print*’.

EXTERNAL-FORMAT—an external file format designator.  The default is
:default.

OUTPUT-TRUENAME—a pathname (the ‘truename’ of the output file), or
‘nil’.

WARNINGS-P—a generalized boolean.

FAILURE-P—a generalized boolean.

Description:
............

‘compile-file’ transforms the contents of the file specified by
INPUT-FILE into implementation-dependent binary data which are placed in
the file specified by OUTPUT-FILE.

The file to which INPUT-FILE refers should be a source file.
OUTPUT-FILE can be used to specify an output pathname; the actual
pathname of the compiled file to which compiled code will be output is
computed as if by calling ‘compile-file-pathname’.

If INPUT-FILE or OUTPUT-FILE is a logical pathname, it is translated
into a physical pathname as if by calling ‘translate-logical-pathname’.

If VERBOSE is true, ‘compile-file’ prints a message in the form of a
comment (i.e., with a leading semicolon) to standard output indicating
what file is being compiled and other useful information.  If VERBOSE is
false, ‘compile-file’ does not print this information.

If PRINT is true, information about top level forms in the file being
compiled is printed to standard output.  Exactly what is printed is
implementation-dependent, but nevertheless some information is printed.
If PRINT is ‘nil’, no information is printed.

The EXTERNAL-FORMAT specifies the external file format to be used when
opening the file; see the function *note open::.  ‘compile-file’ and
‘load’ must cooperate in such a way that the resulting compiled file can
be loaded without specifying an external file format anew; see the
function *note load::.

‘compile-file’ binds ‘*readtable*’ and ‘*package*’ to the values they
held before processing the file.

‘*compile-file-truename*’ is bound by ‘compile-file’ to hold the
truename of the pathname of the file being compiled.

‘*compile-file-pathname*’ is bound by ‘compile-file’ to hold a pathname
denoted by the first argument to ‘compile-file’, merged against the
defaults; that is, ‘(pathname (merge-pathnames INPUT-FILE))’.

The compiled functions contained in the compiled file become available
for use when the compiled file is loaded into Lisp.  Any function
definition that is processed by the compiler, including ‘#'(lambda ...)’
forms and local function definitions made by ‘flet’, ‘labels’ and
‘defun’ forms, result in an object of type ‘compiled-function’.

The primary value returned by ‘compile-file’, OUTPUT-TRUENAME, is the
‘truename’ of the output file, or ‘nil’ if the file could not be
created.

The secondary value, WARNINGS-P, is false if no conditions of type
‘error’ or ‘warning’ were detected by the compiler, and true otherwise.

The tertiary value, FAILURE-P, is false if no conditions of type ‘error’
or ‘warning’ (other than ‘style-warning’) were detected by the compiler,
and true otherwise.

For general information about how files are processed by the file
compiler, see *note Section 3.2.3 (File Compilation): File Compilation.

Programs to be compiled by the file compiler must only contain
externalizable objects; for details on such objects, see *note Section
3.2.4 (Literal Objects in Compiled Files): Literal Objects in Compiled
Files.  For information on how to extend the set of externalizable
objects, see the function *note make-load-form:: and *note Section
3.2.4.4 (Additional Constraints on Externalizable Objects):
CallingMakeLoadForm.

Affected By:
............

‘*error-output*’, ‘*standard-output*’, ‘*compile-verbose*’,
‘*compile-print*’

The computer’s file system.

Exceptional Situations:
.......................

For information about errors detected during the compilation process,
see *note Section 3.2.5 (Exceptional Situations in the Compiler):
Exceptional Situations in the Compiler.

An error of type ‘file-error’ might be signaled if ‘(wild-pathname-p
INPUT-FILE)’ returns true.

If either the attempt to open the source file for input or the attempt
to open the compiled file for output fails, an error of type
‘file-error’ is signaled.

See Also:
.........

*note compile::, *note declare::, *note eval-when::, *note pathname
(System Class)::, *note logical-pathname (System Class)::, *note Section
20.1 (File System Concepts): File System Concepts, *note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.


File: ansicl,  Node: compile-file-pathname,  Next: load,  Prev: compile-file,  Up: System Construction

compile-file-pathname (Function)
================================

Syntax:
.......

 -- Function: compile-file-pathname input-file &key output-file
          &allow-other-keys → pathname

Arguments and Values:
.....................

INPUT-FILE—a pathname designator.  (Default fillers for unspecified
components are taken from ‘*default-pathname-defaults*’.)

OUTPUT-FILE—a pathname designator.  The default is
implementation-defined.

PATHNAME—a pathname.

Description:
............

Returns the pathname that ‘compile-file’ would write into, if given the
same arguments.

The defaults for the OUTPUT-FILE are taken from the pathname that
results from merging the INPUT-FILE with the value of
‘*default-pathname-defaults*’, except that the type component should
default to the appropriate implementation-defined default type for
compiled files.

If INPUT-FILE is a logical pathname and OUTPUT-FILE is unsupplied, the
result is a logical pathname.  If INPUT-FILE is a logical pathname, it
is translated into a physical pathname as if by calling
‘translate-logical-pathname’.  If INPUT-FILE is a stream, the stream can
be either open or closed.  ‘compile-file-pathname’ returns the same
pathname after a file is closed as it did when the file was open.  It is
an error if INPUT-FILE is a stream that is created with
‘make-two-way-stream’, ‘make-echo-stream’, ‘make-broadcast-stream’,
‘make-concatenated-stream’, ‘make-string-input-stream’,
‘make-string-output-stream’.

If an implementation supports additional keyword arguments to
‘compile-file’, ‘compile-file-pathname’ must accept the same arguments.

Examples:
.........

See ‘logical-pathname-translations’.

Exceptional Situations:
.......................

An error of type ‘file-error’ might be signaled if either INPUT-FILE or
OUTPUT-FILE is wild.

See Also:
.........

*note compile-file::, *note pathname (System Class)::, *note
logical-pathname (System Class)::, *note Section 20.1 (File System
Concepts): File System Concepts, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: ansicl,  Node: load,  Next: with-compilation-unit,  Prev: compile-file-pathname,  Up: System Construction

load (Function)
===============

Syntax:
.......

 -- Function: load filespec &key verbose print
          if-does-not-exist external-format → generalized-boolean

Arguments and Values:
.....................

FILESPEC—a stream, or a pathname designator.  The default is taken from
‘*default-pathname-defaults*’.

VERBOSE—a generalized boolean.  The default is the value of
‘*load-verbose*’.

PRINT—a generalized boolean.  The default is the value of
‘*load-print*’.

IF-DOES-NOT-EXIST—a generalized boolean.  The default is true.

EXTERNAL-FORMAT—an external file format designator.  The default is
:default.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘load’ loads the file named by FILESPEC into the Lisp environment.

The manner in which a source file is distinguished from a compiled file
is implementation-dependent.  If the file specification is not complete
and both a source file and a compiled file exist which might match, then
which of those files ‘load’ selects is implementation-dependent.

If FILESPEC is a stream, ‘load’ determines what kind of stream it is and
loads directly from the stream.  If FILESPEC is a logical pathname, it
is translated into a physical pathname as if by calling
‘translate-logical-pathname’.

‘load’ sequentially executes each form it encounters in the file named
by FILESPEC.  If the file is a source file and the implementation
chooses to perform implicit compilation, ‘load’ must recognize top level
forms as described in *note Section 3.2.3.1 (Processing of Top Level
Forms): TopLevelForms. and arrange for each top level form to be
executed before beginning implicit compilation of the next.  (Note,
however, that processing of ‘eval-when’ forms by ‘load’ is controlled by
the :execute situation.)

If VERBOSE is true, ‘load’ prints a message in the form of a comment
(i.e., with a leading semicolon) to standard output indicating what file
is being loaded and other useful information.  If VERBOSE is false,
‘load’ does not print this information.

If PRINT is true, ‘load’ incrementally prints information to standard
output showing the progress of the loading process.  For a source file,
this information might mean printing the values yielded by each form in
the file as soon as those values are returned.  For a compiled file,
what is printed might not reflect precisely the contents of the source
file, but some information is generally printed.  If PRINT is false,
‘load’ does not print this information.

If the file named by FILESPEC is successfully loaded, ‘load’ returns
true.

If the file does not exist, the specific action taken depends on
IF-DOES-NOT-EXIST: if it is ‘nil’, ‘load’ returns ‘nil’; otherwise,
‘load’ signals an error.

The EXTERNAL-FORMAT specifies the external file format to be used when
opening the file (see the function *note open::), except that when the
file named by FILESPEC is a compiled file, the EXTERNAL-FORMAT is
ignored.  ‘compile-file’ and ‘load’ cooperate in an
implementation-dependent way to assure the preservation of the
similarity of characters referred to in the source file at the time the
source file was processed by the file compiler under a given external
file format, regardless of the value of EXTERNAL-FORMAT at the time the
compiled file is loaded.

‘load’ binds ‘*readtable*’ and ‘*package*’ to the values they held
before loading the file.

‘*load-truename*’ is bound by ‘load’ to hold the truename of the
pathname of the file being loaded.

‘*load-pathname*’ is bound by ‘load’ to hold a pathname that represents
FILESPEC merged against the defaults.  That is, ‘(pathname
(merge-pathnames FILESPEC))’.

Examples:
.........

     ;Establish a data file...
      (with-open-file (str "data.in" :direction :output :if-exists :error)
        (print 1 str) (print '(setq a 888) str) t)
     → T
      (load "data.in") → true
      a → 888
      (load (setq p (merge-pathnames "data.in")) :verbose t)
     ; Loading contents of file /fred/data.in
     ; Finished loading /fred/data.in
     → true
      (load p :print t)
     ; Loading contents of file /fred/data.in
     ;  1
     ;  888
     ; Finished loading /fred/data.in
     → true

 

 

      ;----[Begin file SETUP]----
      (in-package "MY-STUFF")
      (defmacro compile-truename () `',*compile-file-truename*)
      (defvar *my-compile-truename* (compile-truename) "Just for debugging.")
      (defvar *my-load-pathname* *load-pathname*)
      (defun load-my-system ()
        (dolist (module-name '("FOO" "BAR" "BAZ"))
          (load (merge-pathnames module-name *my-load-pathname*))))
      ;----[End of file SETUP]----


      (load "SETUP")
      (load-my-system)

Affected By:
............

The implementation, and the host computer’s file system.

Exceptional Situations:
.......................

If :if-does-not-exist is supplied and is true, or is not supplied,
‘load’ signals an error of type ‘file-error’ if the file named by
FILESPEC does not exist, or if the file system cannot perform the
requested operation.

An error of type ‘file-error’ might be signaled if ‘(wild-pathname-p
FILESPEC)’ returns true.

See Also:
.........

*note error (Function)::, *note merge-pathnames::, *note
*load-verbose*::, *note *default-pathname-defaults*::, *note pathname
(System Class)::, *note logical-pathname (System Class)::, *note Section
20.1 (File System Concepts): File System Concepts, *note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.


File: ansicl,  Node: with-compilation-unit,  Next: *features*,  Prev: load,  Up: System Construction

with-compilation-unit (Macro)
=============================

Syntax:
.......

 -- Macro: with-compilation-unit (〚↓option〛) {form}* → {result}*

OPTION::=
     :override override

Arguments and Values:
.....................

OVERRIDE—a generalized boolean; evaluated.  The default is ‘nil’.

FORMS—an implicit progn.

RESULTS—the values returned by the forms.

Description:
............

Executes FORMS from left to right.  Within the dynamic environment of
‘with-compilation-unit’, actions deferred by the compiler until the end
of compilation will be deferred until the end of the outermost call to
‘with-compilation-unit’.

The set of options permitted may be extended by the implementation, but
the only standardized keyword is :override.

If nested dynamically only the outer call to ‘with-compilation-unit’ has
any effect unless the value associated with :override is true, in which
case warnings are deferred only to the end of the innermost call for
which OVERRIDE is true.

The function ‘compile-file’ provides the effect of

      (with-compilation-unit (:override nil) ...)

around its code.

Any implementation-dependent extensions can only be provided as the
result of an explicit programmer request by use of an
implementation-dependent keyword.  Implementations are forbidden from
attaching additional meaning to a use of this macro which involves
either no keywords or just the keyword :override.

Examples:
.........

If an implementation would normally defer certain kinds of warnings,
such as warnings about undefined functions, to the end of a compilation
unit (such as a file), the following example shows how to cause those
warnings to be deferred to the end of the compilation of several files.

      (defun compile-files (&rest files)
        (with-compilation-unit ()
          (mapcar #'(lambda (file) (compile-file file)) files)))

      (compile-files "A" "B" "C")

Note however that if the implementation does not normally defer any
warnings, use of with-compilation-unit might not have any effect.

See Also:
.........

*note compile::, *note compile-file::


File: ansicl,  Node: *features*,  Next: *compile-file-pathname*; *compile-file-truename*,  Prev: with-compilation-unit,  Up: System Construction

*features* (Variable)
=====================

Value Type:
...........

a proper list.

Initial Value:
..............

implementation-dependent.

Description:
............

The value of ‘*features*’ is called the features list.  It is a list of
symbols, called features, that correspond to some aspect of the
implementation or environment.

Most features have implementation-dependent meanings; The following
meanings have been assigned to feature names:

:cltl1

     If present, indicates that the ‘LISP’ package purports to conform
     to the 1984 specification ‘Common Lisp: The Language’.  It is
     possible, but not required, for a conforming implementation to have
     this feature because this specification specifies that its symbols
     are to be in the ‘COMMON-LISP’ package, not the ‘LISP’ package.

:cltl2

     If present, indicates that the implementation purports to conform
     to ‘Common Lisp: The Language Second Edition’.  This feature must
     not be present in any conforming implementation, since conformance
     to that document is not compatible with conformance to this
     specification.  The name, however, is reserved by this
     specification in order to help programs distinguish implementations
     which conform to that document from implementations which conform
     to this specification.

:ieee-floating-point

     If present, indicates that the implementation purports to conform
     to the requirements of ‘IEEE Standard for Binary Floating-Point
     Arithmetic’.

:x3j13

     If present, indicates that the implementation conforms to some
     particular working draft of this specification, or to some subset
     of features that approximates a belief about what this
     specification might turn out to contain.  A conforming
     implementation might or might not contain such a feature.  (This
     feature is intended primarily as a stopgap in order to provide
     implementors something to use prior to the availability of a draft
     standard, in order to discourage them from introducing the
     :draft-ansi-cl and :ansi-cl features prematurely.)

:draft-ansi-cl

     If present, indicates that the implementation purports to conform
     to the first full draft of this specification, which went to public
     review in 1992.  A conforming implementation which has the
     :draft-ansi-cl-2 or :ansi-cl feature is not permitted to retain the
     :draft-ansi-cl feature since incompatible changes were made
     subsequent to the first draft.

:draft-ansi-cl-2

     If present, indicates that a second full draft of this
     specification has gone to public review, and that the
     implementation purports to conform to that specification.  (If
     additional public review drafts are produced, this keyword will
     continue to refer to the second draft, and additional keywords will
     be added to identify conformance with such later drafts.  As such,
     the meaning of this keyword can be relied upon not to change over
     time.)  A conforming implementation which has the :ansi-cl feature
     is only permitted to retain the :draft-ansi-cl feature if the
     finally approved standard is not incompatible with the draft
     standard.

:ansi-cl

     If present, indicates that this specification has been adopted by
     ANSI as an official standard, and that the implementation purports
     to conform.

:common-lisp

     This feature must appear in ‘*features*’ for any implementation
     that has one or more of the features :x3j13, :draft-ansi-cl, or
     :ansi-cl.  It is intended that it should also appear in
     implementations which have the features :cltl1 or :cltl2, but this
     specification cannot force such behavior.  The intent is that this
     feature should identify the language family named “Common Lisp,”
     rather than some specific dialect within that family.

See Also:
.........

*note Section 1.5.2.1.1 (Use of Read-Time Conditionals):
ReadTimeConditionals, *note Section 2.4 (Standard Macro Characters):
Standard Macro Characters.

Notes:
......

The value of ‘*features*’ is used by the ‘#+’ and ‘#-’ reader syntax.

Symbols in the features list may be in any package, but in practice they
are generally in the ‘KEYWORD’ package.  This is because ‘KEYWORD’ is
the package used by default when readingin the ‘#+’ and ‘#-’ reader
macros.  Code that needs to name a featurepackage P (other than
‘KEYWORD’) can do so by making explicit use of a package prefix for P,
but note that such code must also assure that the package P exists in
order for the feature expression to be read


File: ansicl,  Node: *compile-file-pathname*; *compile-file-truename*,  Next: *load-pathname*; *load-truename*,  Prev: *features*,  Up: System Construction

*compile-file-pathname*, *compile-file-truename* (Variable)
===========================================================

Value Type:
...........

The value of ‘*compile-file-pathname*’ must always be a pathname or
‘nil’.  The value of ‘*compile-file-truename*’ must always be a physical
pathname or ‘nil’.

Initial Value:
..............

‘nil’.

Description:
............

During a call to ‘compile-file’, ‘*compile-file-pathname*’ is bound to
the pathname denoted by the first argument to ‘compile-file’, merged
against the defaults; that is, it is bound to ‘(pathname
(merge-pathnames INPUT-FILE))’.  During the same time interval,
‘*compile-file-truename*’ is bound to the truename of the file being
compiled.

At other times, the value of these variables is ‘nil’.

If a break loop is entered while ‘compile-file’ is ongoing, it is
implementation-dependent whether these variables retain the values they
had just prior to entering the break loop or whether they are bound to
‘nil’.

The consequences are unspecified if an attempt is made to assign or bind
either of these variables.

Affected By:
............

The file system.

See Also:
.........

*note compile-file::


File: ansicl,  Node: *load-pathname*; *load-truename*,  Next: *compile-print*; *compile-verbose*,  Prev: *compile-file-pathname*; *compile-file-truename*,  Up: System Construction

*load-pathname*, *load-truename* (Variable)
===========================================

Value Type:
...........

The value of ‘*load-pathname*’ must always be a pathname or ‘nil’.  The
value of ‘*load-truename*’ must always be a physical pathname or ‘nil’.

Initial Value:
..............

‘nil’.

Description:
............

During a call to ‘load’, ‘*load-pathname*’ is bound to the pathname
denoted by the the first argument to ‘load’, merged against the
defaults; that is, it is bound to ‘(pathname (merge-pathnames
FILESPEC))’.  During the same time interval, ‘*load-truename*’ is bound
to the truename of the file being loaded.

At other times, the value of these variables is ‘nil’.

If a break loop is entered while ‘load’ is ongoing, it is
implementation-dependent whether these variables retain the values they
had just prior to entering the break loop or whether they are bound to
‘nil’.

The consequences are unspecified if an attempt is made to assign or bind
either of these variables.

Affected By:
............

The file system.

See Also:
.........

*note load::


File: ansicl,  Node: *compile-print*; *compile-verbose*,  Next: *load-print*; *load-verbose*,  Prev: *load-pathname*; *load-truename*,  Up: System Construction

*compile-print*, *compile-verbose* (Variable)
=============================================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

implementation-dependent.

Description:
............

The value of ‘*compile-print*’ is the default value of the :print
argument to ‘compile-file’.  The value of ‘*compile-verbose*’ is the
default value of the :verbose argument to ‘compile-file’.

See Also:
.........

*note compile-file::


File: ansicl,  Node: *load-print*; *load-verbose*,  Next: *modules*,  Prev: *compile-print*; *compile-verbose*,  Up: System Construction

*load-print*, *load-verbose* (Variable)
=======================================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

The initial value of ‘*load-print*’ is false.  The initial value of
‘*load-verbose*’ is implementation-dependent.

Description:
............

The value of ‘*load-print*’ is the default value of the :print argument
to ‘load’.  The value of ‘*load-verbose*’ is the default value of the
:verbose argument to ‘load’.

See Also:
.........

*note load::


File: ansicl,  Node: *modules*,  Next: provide; require,  Prev: *load-print*; *load-verbose*,  Up: System Construction

*modules* (Variable)
====================

Value Type:
...........

a list of strings.

Initial Value:
..............

implementation-dependent.

Description:
............

The value of ‘*modules*’ is a list of names of the modules that have
been loaded into the current Lisp image.

Affected By:
............

‘provide’

See Also:
.........

*note provide::, *note require::

Notes:
......

The variable ‘*modules*’ is deprecated.


File: ansicl,  Node: provide; require,  Prev: *modules*,  Up: System Construction

provide, require (Function)
===========================

Syntax:
.......

 -- Function: provide module-name → implementation-dependent
 -- Function: require module-name &optional pathname-list →
          implementation-dependent

Arguments and Values:
.....................

MODULE-NAME—a string designator.

PATHNAME-LIST—‘nil’, or a designator for a non-empty list of pathname
designators.  The default is ‘nil’.

Description:
............

‘provide’ adds the MODULE-NAME to the list held by ‘*modules*’, if such
a name is not already present.

‘require’ tests for the presence of the MODULE-NAME in the list held by
‘*modules*’.  If it is present, ‘require’ immediately returns.
Otherwise, an attempt is made to load an appropriate set of files as
follows: The PATHNAME-LIST argument, if non-nil, specifies a list of
pathnames to be loaded in order, from left to right.  If the
PATHNAME-LIST is ‘nil’, an implementation-dependent mechanism will be
invoked in an attempt to load the module named MODULE-NAME; if no such
module can be loaded, an error of type ‘error’ is signaled.

Both functions use ‘string=’ to test for the presence of a MODULE-NAME.

Examples:
.........

     ;;; This illustrates a nonportable use of REQUIRE, because it
     ;;; depends on the implementation-dependent file-loading mechanism.

     (require "CALCULUS")

     ;;; This use of REQUIRE is nonportable because of the literal
     ;;; physical pathname.

     (require "CALCULUS" "/usr/lib/lisp/calculus")

     ;;; One form of portable usage involves supplying a logical pathname,
     ;;; with appropriate translations defined elsewhere.

     (require "CALCULUS" "lib:calculus")

     ;;; Another form of portable usage involves using a variable or
     ;;; table lookup function to determine the pathname, which again
     ;;; must be initialized elsewhere.

     (require "CALCULUS" *calculus-module-pathname*)

Side Effects:
.............

‘provide’ modifies ‘*modules*’.

Affected By:
............

The specific action taken by ‘require’ is affected by calls to ‘provide’
(or, in general, any changes to the value of ‘*modules*’).

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if MODULE-NAME is not a
string designator.

If ‘require’ fails to perform the requested operation due to a problem
while interacting with the file system, an error of type ‘file-error’ is
signaled.

An error of type ‘file-error’ might be signaled if any pathname in
PATHNAME-LIST is a designator for a wild pathname.

See Also:
.........

*note *modules*::, *note Section 19.1.2 (Pathnames as Filenames):
Pathnames as Filenames.

Notes:
......

The functions ‘provide’ and ‘require’ are deprecated.

If a module consists of a single package, it is customary for the
package and module names to be the same.


File: ansicl,  Node: Environment,  Next: Glossary,  Prev: System Construction,  Up: Top

25 Environment
**************

* Menu:

* The External Environment::

Dictionary

* decode-universal-time::
* encode-universal-time::
* get-universal-time; get-decoded-time::
* sleep::
* apropos; apropos-list::
* describe::
* describe-object::
* trace; untrace::
* step::
* time (Macro)::
* internal-time-units-per-second::
* get-internal-real-time::
* get-internal-run-time::
* disassemble::
* documentation; setf documentation::
* room::
* ed::
* inspect::
* dribble::
* - (Variable)::
* +; ++; +++::
* *; **; ***::
* /; //; ///::
* lisp-implementation-type; lisp-implementation-version::
* short-site-name; long-site-name::
* machine-instance::
* machine-type::
* machine-version::
* software-type; software-version::
* user-homedir-pathname::


File: ansicl,  Node: The External Environment,  Next: decode-universal-time,  Up: Environment

25.1 The External Environment
=============================

* Menu:

* Top level loop::
* Debugging Utilities::
* Environment Inquiry::
* Time::


File: ansicl,  Node: Top level loop,  Next: Debugging Utilities,  Up: The External Environment

25.1.1 Top level loop
---------------------

The top level loop is the Common Lisp mechanism by which the user
normally interacts with the Common Lisp system.  This loop is sometimes
referred to as the Lisp read-eval-print loop because it typically
consists of an endless loop that reads an expression, evaluates it and
prints the results.

The top level loop is not completely specified; thus the user interface
is implementation-defined.  The top level loop prints all values
resulting from the evaluation of a form.  The next figure lists
variables that are maintained by the Lisp read-eval-print loop.

*     +     /     -
**    ++    //
***   +++   ///

Figure 25.1: Variables maintained by the Read-Eval-Print Loop


File: ansicl,  Node: Debugging Utilities,  Next: Environment Inquiry,  Prev: Top level loop,  Up: The External Environment

25.1.2 Debugging Utilities
--------------------------

The next figure shows defined names relating to debugging.

*debugger-hook*   documentation     step
apropos           dribble           time
apropos-list      ed                trace
break             inspect           untrace
describe          invoke-debugger

Figure 25.2: Defined names relating to debugging


File: ansicl,  Node: Environment Inquiry,  Next: Time,  Prev: Debugging Utilities,  Up: The External Environment

25.1.3 Environment Inquiry
--------------------------

Environment inquiry defined names provide information about the hardware
and software configuration on which a Common Lisp program is being
executed.

The next figure shows defined names relating to environment inquiry.

*features*                    machine-instance   short-site-name
lisp-implementation-type      machine-type       software-type
lisp-implementation-version   machine-version    software-version
long-site-name                room

Figure 25.3: Defined names relating to environment inquiry.


File: ansicl,  Node: Time,  Prev: Environment Inquiry,  Up: The External Environment

25.1.4 Time
-----------

Time is represented in four different ways in Common Lisp: decoded time,
universal time, internal time, and seconds.  Decoded time and universal
time are used primarily to represent calendar time, and are precise only
to one second.  Internal time is used primarily to represent
measurements of computer time (such as run time) and is precise to some
implementation-dependent fraction of a second called an internal time
unit, as specified by ‘internal-time-units-per-second’.  An internal
time can be used for either absolute and relative time measurements.
Both a universal time and a decoded time can be used only for absolute
time measurements.  In the case of one function, ‘sleep’, time intervals
are represented as a non-negative real number of seconds.

The next figure shows defined names relating to time.

decode-universal-time    get-internal-run-time
encode-universal-time    get-universal-time
get-decoded-time         internal-time-units-per-second
get-internal-real-time   sleep

Figure 25.4: Defined names involving Time.

25.1.4.1 Decoded Time
.....................

A “decoded time” is an ordered series of nine values that, taken
together, represent a point in calendar time (ignoring leap seconds):

Second

     An integer between 0 and 59, inclusive.

Minute

     An integer between 0 and 59, inclusive.

Hour

     An integer between 0 and 23, inclusive.

Date

     An integer between 1 and 31, inclusive (the upper limit actually
     depends on the month and year, of course).

Month

     An integer between 1 and 12, inclusive; 1 means January, 2 means
     February, and so on; 12 means December.

Year

     An integer indicating the year A.D. However, if this integer is
     between 0 and 99, the “obvious” year is used; more precisely, that
     year is assumed that is equal to the integer modulo 100 and within
     fifty years of the current year (inclusive backwards and exclusive
     forwards).  Thus, in the year 1978, year 28 is 1928 but year 27 is
     2027.  (Functions that return time in this format always return a
     full year number.)

Day of week

     An integer between 0 and 6, inclusive; 0 means Monday, 1 means
     Tuesday, and so on; 6 means Sunday.

Daylight saving time flag

     A generalized boolean that, if true, indicates that daylight saving
     time is in effect.

Time zone

     A time zone.

The next figure shows defined names relating to decoded time.

decode-universal-time   get-decoded-time

Figure 25.5: Defined names involving time in Decoded Time.

25.1.4.2 Universal Time
.......................

“Universal time” is an absolute time represented as a single
non-negative integer—the number of seconds since midnight, January 1,
1900 GMT (ignoring leap seconds).  Thus the time 1 is 00:00:01 (that is,
12:00:01 a.m.)  on January 1, 1900 GMT. Similarly, the time 2398291201
corresponds to time 00:00:01 on January 1, 1976 GMT. Recall that the
year 1900 was not a leap year; for the purposes of Common Lisp, a year
is a leap year if and only if its number is divisible by 4, except that
years divisible by 100 are not leap years, except that years divisible
by 400 are leap years.  Therefore the year 2000 will be a leap year.
Because universal time must be a non-negative integer, times before the
base time of midnight, January 1, 1900 GMT cannot be processed by Common
Lisp.

decode-universal-time   get-universal-time
encode-universal-time

Figure 25.6: Defined names involving time in Universal Time.

25.1.4.3 Internal Time
......................

“Internal time” represents time as a single integer, in terms of an
implementation-dependent unit called an internal time unit.  Relative
time is measured as a number of these units.  Absolute time is relative
to an arbitrary time base.

The next figure shows defined names related to internal time.

get-internal-real-time   internal-time-units-per-second
get-internal-run-time

Figure 25.7: Defined names involving time in Internal Time.

25.1.4.4 Seconds
................

One function, ‘sleep’, takes its argument as a non-negative real number
of seconds.  Informally, it may be useful to think of this as a relative
universal time, but it differs in one important way: universal times are
always non-negative integers, whereas the argument to ‘sleep’ can be any
kind of non-negative real, in order to allow for the possibility of
fractional seconds.

sleep

Figure 25.8: Defined names involving time in Seconds.


File: ansicl,  Node: decode-universal-time,  Next: encode-universal-time,  Prev: The External Environment,  Up: Environment

decode-universal-time (Function)
================================

Syntax:
.......

 -- Function: decode-universal-time universal-time &optional time-zone →
          second, minute, hour, date, month, year, day, daylight-p, zone

Arguments and Values:
.....................

UNIVERSAL-TIME—a universal time.

TIME-ZONE—a time zone.

SECOND, MINUTE, HOUR, DATE, MONTH, YEAR, DAY, DAYLIGHT-P, ZONE—a decoded
time.

Description:
............

Returns the decoded time represented by the given universal time.

If TIME-ZONE is not supplied, it defaults to the current time zone
adjusted for daylight saving time.  If TIME-ZONE is supplied, daylight
saving time information is ignored.  The daylight saving time flag is
‘nil’ if TIME-ZONE is supplied.

Examples:
.........

      (decode-universal-time 0 0) → 0, 0, 0, 1, 1, 1900, 0, false, 0

     ;; The next two examples assume Eastern Daylight Time.
      (decode-universal-time 2414296800 5) → 0, 0, 1, 4, 7, 1976, 6, false, 5
      (decode-universal-time 2414293200) → 0, 0, 1, 4, 7, 1976, 6, true, 5

     ;; This example assumes that the time zone is Eastern Daylight Time
     ;; (and that the time zone is constant throughout the example).
      (let* ((here (nth 8 (multiple-value-list (get-decoded-time)))) ;Time zone
             (recently (get-universal-time))
             (a (nthcdr 7 (multiple-value-list (decode-universal-time recently))))
             (b (nthcdr 7 (multiple-value-list (decode-universal-time recently here)))))
        (list a b (equal a b))) → ((T 5) (NIL 5) NIL)

Affected By:
............

Implementation-dependent mechanisms for calculating when or if daylight
savings time is in effect for any given session.

See Also:
.........

*note encode-universal-time::, *note get-universal-time::, *note Section
25.1.4 (Time): Time.


File: ansicl,  Node: encode-universal-time,  Next: get-universal-time; get-decoded-time,  Prev: decode-universal-time,  Up: Environment

encode-universal-time (function)
================================

Syntax:
.......

 -- Function: encode-universal-time second minute hour date month year
          &optional time-zone → universal-time

Arguments and Values:
.....................

SECOND, MINUTE, HOUR, DATE, MONTH, YEAR, TIME-ZONE—the corresponding
parts of a decoded time.  (Note that some of the nine values in a full
decoded time are redundant, and so are not used as inputs to this
function.)

UNIVERSAL-TIME—a universal time.

Description:
............

‘encode-universal-time’ converts a time from Decoded Time format to a
universal time.

If TIME-ZONE is supplied, no adjustment for daylight savings time is
performed.

Examples:
.........

      (encode-universal-time 0 0 0 1 1 1900 0) → 0
      (encode-universal-time 0 0 1 4 7 1976 5) → 2414296800
     ;; The next example assumes Eastern Daylight Time.
      (encode-universal-time 0 0 1 4 7 1976) → 2414293200

See Also:
.........

*note decode-universal-time::, *note get-decoded-time::


File: ansicl,  Node: get-universal-time; get-decoded-time,  Next: sleep,  Prev: encode-universal-time,  Up: Environment

get-universal-time, get-decoded-time (Function)
===============================================

Syntax:
.......

 -- Function: get-universal-time <no arguments> → universal-time

 -- Function: get-decoded-time <no arguments> → second, minute, hour,
          date, month, year, day, daylight-p, zone

Arguments and Values:
.....................

UNIVERSAL-TIME—a universal time.

SECOND, MINUTE, HOUR, DATE, MONTH, YEAR, DAY, DAYLIGHT-P, ZONE—a decoded
time.

Description:
............

‘get-universal-time’ returns the current time, represented as a
universal time.

‘get-decoded-time’ returns the current time, represented as a decoded
time.

Examples:
.........

     ;; At noon on July 4, 1976 in Eastern Daylight Time.
      (get-decoded-time) → 0, 0, 12, 4, 7, 1976, 6, true, 5
     ;; At exactly the same instant.
      (get-universal-time) → 2414332800
     ;; Exactly five minutes later.
      (get-universal-time) → 2414333100
     ;; The difference is 300 seconds (five minutes)
      (- * **) → 300

Affected By:
............

The time of day (i.e., the passage of time), the system clock’s ability
to keep accurate time, and the accuracy of the system clock’s initial
setting.

Exceptional Situations:
.......................

An error of type ‘error’ might be signaled if the current time cannot be
determined.

See Also:
.........

*note decode-universal-time::, *note encode-universal-time::, *note
Section 25.1.4 (Time): Time.

Notes:
......

      (get-decoded-time) ≡ (decode-universal-time (get-universal-time))

No implementation is required to have a way to verify that the time
returned is correct.  However, if an implementation provides a validity
check (e.g., the failure to have properly initialized the system clock
can be reliably detected) and that validity check fails, the
implementation is strongly encouraged (but not required) to signal an
error of type ‘error’ (rather than, for example, returning a
known-to-be-wrong value) that is correctable by allowing the user to
interactively set the correct time.


File: ansicl,  Node: sleep,  Next: apropos; apropos-list,  Prev: get-universal-time; get-decoded-time,  Up: Environment

sleep (Function)
================

Syntax:
.......

 -- Function: sleep seconds → ‘nil’

Arguments and Values:
.....................

SECONDS—a non-negative real.

Description:
............

Causes execution to cease and become dormant for approximately the
seconds of real time indicated by SECONDS, whereupon execution is
resumed.

Examples:
.........

      (sleep 1) → NIL

     ;; Actually, since SLEEP is permitted to use approximate timing,
     ;; this might not always yield true, but it will often enough that
     ;; we felt it to be a productive example of the intent.
      (let ((then (get-universal-time))
            (now  (progn (sleep 10) (get-universal-time))))
        (>= (- now then) 10))
     → true

Side Effects:
.............

Causes processing to pause.

Affected By:
............

The granularity of the scheduler.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SECONDS is not a
non-negative real.


File: ansicl,  Node: apropos; apropos-list,  Next: describe,  Prev: sleep,  Up: Environment

apropos, apropos-list (Function)
================================

Syntax:
.......

 -- Function: apropos string &optional package → <no values>

 -- Function: apropos-list string &optional package → symbols

Arguments and Values:
.....................

STRING—a string designator.

PACKAGE—a package designator or ‘nil’.  The default is ‘nil’.

SYMBOLS—a list of symbols.

Description:
............

These functions search for interned symbols whose names contain the
substring STRING.

For ‘apropos’, as each such symbol is found, its name is printed on
standard output.  In addition, if such a symbol is defined as a function
or dynamic variable, information about those definitions might also be
printed.

For ‘apropos-list’, no output occurs as the search proceeds; instead a
list of the matching symbols is returned when the search is complete.

If PACKAGE is non-nil, only the symbols accessible in that PACKAGE are
searched; otherwise all symbols accessible in any package are searched.

Because a symbol might be available by way of more than one inheritance
path, ‘apropos’ might print information about the same symbol more than
once, or ‘apropos-list’ might return a list containing duplicate
symbols.

Whether or not the search is case-sensitive is implementation-defined.

Affected By:
............

The set of symbols which are currently interned in any packages being
searched.

‘apropos’ is also affected by ‘*standard-output*’.


File: ansicl,  Node: describe,  Next: describe-object,  Prev: apropos; apropos-list,  Up: Environment

describe (Function)
===================

Syntax:
.......

 -- Function: describe object &optional stream → <no values>

Arguments and Values:
.....................

OBJECT—an object.

STREAM—an output stream designator.  The default is standard output.

Description:
............

‘describe’ displays information about OBJECT to STREAM.

For example, ‘describe’ of a symbol might show the symbol’s value, its
definition, and each of its properties.  ‘describe’ of a float might
show the number’s internal representation in a way that is useful for
tracking down round-off errors.  In all cases, however, the nature and
format of the output of ‘describe’ is implementation-dependent.

‘describe’ can describe something that it finds inside the OBJECT; in
such cases, a notational device such as increased indentation or
positioning in a table is typically used in order to visually
distinguish such recursive descriptions from descriptions of the
argument OBJECT.

The actual act of describing the object is implemented by
‘describe-object’.  ‘describe’ exists as an interface primarily to
manage argument defaulting (including conversion of arguments ‘t’ and
‘nil’ into stream objects) and to inhibit any return values from
‘describe-object’.

‘describe’ is not intended to be an interactive function.  In a
conforming implementation, ‘describe’ must not, by default, prompt for
user input.  User-defined methods for ‘describe-object’ are likewise
restricted.

Side Effects:
.............

Output to standard output or terminal I/O.

Affected By:
............

‘*standard-output*’ and ‘*terminal-io*’, methods on ‘describe-object’
and ‘print-object’ for objects having user-defined classes.

See Also:
.........

*note inspect::, *note describe-object::


File: ansicl,  Node: describe-object,  Next: trace; untrace,  Prev: describe,  Up: Environment

describe-object (Standard Generic Function)
===========================================

Syntax:
.......

 -- Generic Function: describe-object object stream →
          implementation-dependent

Method Signatures:
..................

describe-object (OBJECT standard-object) STREAM

Arguments and Values:
.....................

OBJECT—an object.

STREAM—a stream.

Description:
............

The generic function ‘describe-object’ prints a description of OBJECT to
a STREAM.  ‘describe-object’ is called by ‘describe’; it must not be
called by the user.

Each implementation is required to provide a method on the class
‘standard-object’ and methods on enough other classes so as to ensure
that there is always an applicable method.  Implementations are free to
add methods for other classes.  Users can write methods for
‘describe-object’ for their own classes if they do not wish to inherit
an implementation-supplied method.

Methods on ‘describe-object’ can recursively call ‘describe’.
Indentation, depth limits, and circularity detection are all taken care
of automatically, provided that each method handles exactly one level of
structure and calls ‘describe’ recursively if there are more structural
levels.  The consequences are undefined if this rule is not obeyed.

In some implementations the STREAM argument passed to a
‘describe-object’ method is not the original STREAM, but is an
intermediate stream that implements parts of ‘describe’.  Methods should
therefore not depend on the identity of this stream.

Examples:
.........

      (defclass spaceship ()
        ((captain :initarg :captain :accessor spaceship-captain)
         (serial# :initarg :serial-number :accessor spaceship-serial-number)))

      (defclass federation-starship (spaceship) ())

      (defmethod describe-object ((s spaceship) stream)
        (with-slots (captain serial#) s
          (format stream "~&~S is a spaceship of type ~S,~
                          ~%with ~A at the helm ~
                            and with serial number ~D.~%"
                  s (type-of s) captain serial#)))

      (make-instance 'federation-starship
                     :captain "Rachel Garrett"
                     :serial-number "NCC-1701-C")
     → #<FEDERATION-STARSHIP 26312465>

      (describe *)
     ▷ #<FEDERATION-STARSHIP 26312465> is a spaceship of type FEDERATION-STARSHIP,
     ▷ with Rachel Garrett at the helm and with serial number NCC-1701-C.
     → <no values>

See Also:
.........

*note describe::

Notes:
......

The same implementation techniques that are applicable to ‘print-object’
are applicable to ‘describe-object’.

The reason for making the return values for ‘describe-object’
unspecified is to avoid forcing users to include explicit ‘(values)’ in
all of their methods.  ‘describe’ takes care of that.


File: ansicl,  Node: trace; untrace,  Next: step,  Prev: describe-object,  Up: Environment

trace, untrace (Macro)
======================

Syntax:
.......

 -- Macro: trace {function-name}* → trace-result
 -- Macro: untrace {function-name}* → untrace-result

Arguments and Values:
.....................

FUNCTION-NAME—a function name.

TRACE-RESULT—implementation-dependent, unless no function-names are
supplied, in which case TRACE-RESULT is a list of function names.

UNTRACE-RESULT—implementation-dependent.

Description:
............

‘trace’ and ‘untrace’ control the invocation of the trace facility.

Invoking ‘trace’ with one or more FUNCTION-NAMES causes the denoted
functions to be “traced.” Whenever a traced function is invoked,
information about the call, about the arguments passed, and about any
eventually returned values is printed to trace output.  If ‘trace’ is
used with no FUNCTION-NAMES, no tracing action is performed; instead, a
list of the functions currently being traced is returned.

Invoking ‘untrace’ with one or more function names causes those
functions to be “untraced” (i.e., no longer traced).  If ‘untrace’ is
used with no FUNCTION-NAMES, all functions currently being traced are
untraced.

If a function to be traced has been open-coded (e.g., because it was
declared ‘inline’), a call to that function might not produce trace
output.

Examples:
.........

      (defun fact (n) (if (zerop n) 1 (* n (fact (- n 1)))))
     → FACT
      (trace fact)
     → (FACT)
     ;; Of course, the format of traced output is implementation-dependent.
      (fact 3)
     ▷ 1 Enter FACT 3
     ▷ | 2 Enter FACT 2
     ▷ |   3 Enter FACT 1
     ▷ |   | 4 Enter FACT 0
     ▷ |   | 4 Exit FACT 1
     ▷ |   3 Exit FACT 1
     ▷ | 2 Exit FACT 2
     ▷ 1 Exit FACT 6
     → 6

Side Effects:
.............

Might change the definitions of the functions named by FUNCTION-NAMES.

Affected By:
............

Whether the functions named are defined or already being traced.

Exceptional Situations:
.......................

Tracing an already traced function, or untracing a function not
currently being traced, should produce no harmful effects, but might
signal a warning.

See Also:
.........

*note *trace-output*::, *note step::

Notes:
......

‘trace’ and ‘untrace’ may also accept additional
implementation-dependent argument formats.  The format of the trace
output is implementation-dependent.

Although ‘trace’ can be extended to permit non-standard options,
implementations are nevertheless encouraged (but not required) to warn
about the use of syntax or options that are neither specified by this
standard nor added as an extension by the implementation, since they
could be symptomatic of typographical errors or of reliance on features
supported in implementations other than the current implementation.


File: ansicl,  Node: step,  Next: time (Macro),  Prev: trace; untrace,  Up: Environment

step (Macro)
============

Syntax:
.......

 -- Macro: step form → {result}*

Arguments and Values:
.....................

FORM—a form; evaluated as described below.

RESULTS—the values returned by the FORM.

Description:
............

‘step’ implements a debugging paradigm wherein the programmer is allowed
to step through the evaluation of a form.  The specific nature of the
interaction, including which I/O streams are used and whether the
stepping has lexical or dynamic scope, is implementation-defined.

‘step’ evaluates FORM in the current environment.  A call to ‘step’ can
be compiled, but it is acceptable for an implementation to interactively
step through only those parts of the computation that are interpreted.

It is technically permissible for a conforming implementation to take no
action at all other than normal execution of the FORM.  In such a
situation, ‘(step form)’ is equivalent to, for example, ‘(let () form)’.
In implementations where this is the case, the associated documentation
should mention that fact.

See Also:
.........

*note trace::

Notes:
......

Implementations are encouraged to respond to the typing of ‘?’ or the
pressing of a “help key” by providing help including a list of commands.


File: ansicl,  Node: time (Macro),  Next: internal-time-units-per-second,  Prev: step,  Up: Environment

time (Macro)
============

Syntax:
.......

 -- Macro: time form → {result}*

Arguments and Values:
.....................

FORM—a form; evaluated as described below.

RESULTS—the values returned by the FORM.

Description:
............

‘time’ evaluates FORM in the current environment (lexical and dynamic).
A call to ‘time’ can be compiled.

‘time’ prints various timing data and other information to trace output.
The nature and format of the printed information is
implementation-defined.  Implementations are encouraged to provide such
information as elapsed real time, machine run time, and storage
management statistics.

Affected By:
............

The accuracy of the results depends, among other things, on the accuracy
of the corresponding functions provided by the underlying operating
system.

The magnitude of the results may depend on the hardware, the operating
system, the lisp implementation, and the state of the global
environment.  Some specific issues which frequently affect the outcome
are hardware speed, nature of the scheduler (if any), number of
competing processes (if any), system paging, whether the call is
interpreted or compiled, whether functions called are compiled, the kind
of garbage collector involved and whether it runs, whether internal data
structures (e.g., hash tables) are implicitly reorganized, etc.

See Also:
.........

*note get-internal-real-time::, *note get-internal-run-time::

Notes:
......

In general, these timings are not guaranteed to be reliable enough for
marketing comparisons.  Their value is primarily heuristic, for tuning
purposes.

For useful background information on the complicated issues involved in
interpreting timing results, see ‘Performance and Evaluation of Lisp
Programs’.


File: ansicl,  Node: internal-time-units-per-second,  Next: get-internal-real-time,  Prev: time (Macro),  Up: Environment

internal-time-units-per-second (Constant Variable)
==================================================

Constant Value:
...............

A positive integer, the magnitude of which is implementation-dependent.

Description:
............

The number of internal time units in one second.

See Also:
.........

*note get-internal-run-time::, *note get-internal-real-time::

Notes:
......

These units form the basis of the Internal Time format representation.


File: ansicl,  Node: get-internal-real-time,  Next: get-internal-run-time,  Prev: internal-time-units-per-second,  Up: Environment

get-internal-real-time (Function)
=================================

Syntax:
.......

 -- Function: get-internal-real-time <no arguments> → internal-time

Arguments and Values:
.....................

INTERNAL-TIME—a non-negative integer.

Description:
............

‘get-internal-real-time’ returns as an integer the current time in
internal time units, relative to an arbitrary time base.  The difference
between the values of two calls to this function is the amount of
elapsed real time (i.e., clock time) between the two calls.

Affected By:
............

Time of day (i.e., the passage of time).  The time base affects the
result magnitude.

See Also:
.........

*note internal-time-units-per-second::


File: ansicl,  Node: get-internal-run-time,  Next: disassemble,  Prev: get-internal-real-time,  Up: Environment

get-internal-run-time (Function)
================================

Syntax:
.......

 -- Function: get-internal-run-time <no arguments> → internal-time

Arguments and Values:
.....................

INTERNAL-TIME—a non-negative integer.

Description:
............

Returns as an integer the current run time in internal time units.  The
precise meaning of this quantity is implementation-defined; it may
measure real time, run time, CPU cycles, or some other quantity.  The
intent is that the difference between the values of two calls to this
function be the amount of time between the two calls during which
computational effort was expended on behalf of the executing program.

Affected By:
............

The implementation, the time of day (i.e., the passage of time).

See Also:
.........

*note internal-time-units-per-second::

Notes:
......

Depending on the implementation, paging time and garbage collection time
might be included in this measurement.  Also, in a multitasking
environment, it might not be possible to show the time for just the
running process, so in some implementations, time taken by other
processes during the same time interval might be included in this
measurement as well.


File: ansicl,  Node: disassemble,  Next: documentation; setf documentation,  Prev: get-internal-run-time,  Up: Environment

disassemble (Function)
======================

Syntax:
.......

 -- Function: disassemble fn → ‘nil’

Arguments and Values:
.....................

FN—an extended function designator or a lambda expression.

Description:
............

The function ‘disassemble’ is a debugging aid that composes symbolic
instructions or expressions in some implementation-dependent language
which represent the code used to produce the function which is or is
named by the argument FN.  The result is displayed to standard output in
an implementation-dependent format.

If FN is a lambda expression or interpreted function, it is compiled
first and the result is disassembled.

If the FN designator is a function name, the function that it names is
disassembled.  (If that function is an interpreted function, it is first
compiled but the result of this implicit compilation is not installed.)

Examples:
.........

      (defun f (a) (1+ a)) → F
      (eq (symbol-function 'f)
          (progn (disassemble 'f)
                 (symbol-function 'f))) → true

Affected By:
............

‘*standard-output*’.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if FN is not an extended
function designator or a lambda expression.


File: ansicl,  Node: documentation; setf documentation,  Next: room,  Prev: disassemble,  Up: Environment

documentation, (setf documentation) (Standard Generic Function)
===============================================================

Syntax:
.......

 -- Generic Function: documentation x doc-type → documentation

 -- Generic Function: (setf documentation) new-value x doc-type →
          new-value

Argument Precedence Order:
..........................

DOC-TYPE, OBJECT

Method Signatures:
..................

Functions, Macros, and Special Forms

documentation (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’) symbol

documentation (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’) symbol

documentation (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’) symbol

documentation (X ‘list’) (DOC-TYPE ‘(eql 'list)’) list

documentation (X ‘list’) (DOC-TYPE ‘(eql 'list)’) list

documentation (X ‘function’) (DOC-TYPE ‘(eql 'function)’) function

documentation (X ‘function’) (DOC-TYPE ‘(eql 'function)’) function

(setf documentation) NEW-VALUE (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’)
symbol

(setf documentation) NEW-VALUE (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’)
symbol

(setf documentation) NEW-VALUE (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’)
symbol

(setf documentation) NEW-VALUE (X ‘list’) (DOC-TYPE ‘(eql 'list)’) list

(setf documentation) NEW-VALUE (X ‘list’) (DOC-TYPE ‘(eql 'list)’) list

(setf documentation) NEW-VALUE (X ‘function’) (DOC-TYPE ‘(eql
'function)’) function

(setf documentation) NEW-VALUE (X ‘function’) (DOC-TYPE ‘(eql
'function)’) function

Method Combinations

documentation (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’) symbol

documentation (X ‘method-combination’) (DOC-TYPE ‘(eql
'method-combination)’) method-combination

documentation (X ‘method-combination’) (DOC-TYPE ‘(eql
'method-combination)’) method-combination

(setf documentation) NEW-VALUE (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’)
symbol

(setf documentation) NEW-VALUE (X ‘method-combination’) (DOC-TYPE ‘(eql
'method-combination)’) method-combination

(setf documentation) NEW-VALUE (X ‘method-combination’) (DOC-TYPE ‘(eql
'method-combination)’) method-combination

Methods

documentation (X ‘standard-method’) (DOC-TYPE ‘(eql 'standard-method)’)
standard-method

(setf documentation) NEW-VALUE (X ‘standard-method’) (DOC-TYPE ‘(eql
'standard-method)’) standard-method

Packages

documentation (X ‘package’) (DOC-TYPE ‘(eql 'package)’) package

(setf documentation) NEW-VALUE (X ‘package’) (DOC-TYPE ‘(eql 'package)’)
package

Types, Classes, and Structure Names

documentation (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’) symbol

documentation (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’) symbol

documentation (X ‘structure-class’) (DOC-TYPE ‘(eql 'structure-class)’)
structure-class

documentation (X ‘structure-class’) (DOC-TYPE ‘(eql 'structure-class)’)
structure-class

documentation (X ‘standard-class’) (DOC-TYPE ‘(eql 'standard-class)’)
standard-class

documentation (X ‘standard-class’) (DOC-TYPE ‘(eql 'standard-class)’)
standard-class

(setf documentation) NEW-VALUE (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’)
symbol

(setf documentation) NEW-VALUE (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’)
symbol

(setf documentation) NEW-VALUE (X ‘structure-class’) (DOC-TYPE ‘(eql
'structure-class)’) structure-class

(setf documentation) NEW-VALUE (X ‘structure-class’) (DOC-TYPE ‘(eql
'structure-class)’) structure-class

(setf documentation) NEW-VALUE (X ‘standard-class’) (DOC-TYPE ‘(eql
'standard-class)’) standard-class

(setf documentation) NEW-VALUE (X ‘standard-class’) (DOC-TYPE ‘(eql
'standard-class)’) standard-class

Variables

documentation (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’) symbol

(setf documentation) NEW-VALUE (X ‘symbol’) (DOC-TYPE ‘(eql 'symbol)’)
symbol

Arguments and Values:
.....................

X—an object.

DOC-TYPE—a symbol.

DOCUMENTATION—a string, or ‘nil’.

NEW-VALUE—a string.

Description:
............

The generic function ‘documentation’ returns the documentation string
associated with the given object if it is available; otherwise it
returns ‘nil’.

The generic function ‘(setf documentation)’ updates the documentation
string associated with X to NEW-VALUE.  If X is a list, it must be of
the form ‘(setf SYMBOL)’.

Documentation strings are made available for debugging purposes.
Conforming programs are permitted to use documentation strings when they
are present, but should not depend for their correct behavior on the
presence of those documentation strings.  An implementation is permitted
to discard documentation strings at any time for implementation-defined
reasons.

The nature of the documentation string returned depends on the DOC-TYPE,
as follows:

compiler-macro

     Returns the documentation string of the compiler macro whose name
     is the function name X.

function

     If X is a function name, returns the documentation string of the
     function, macro, or special operator whose name is X.

     If X is a function, returns the documentation string associated
     with X.

method-combination

     If X is a symbol, returns the documentation string of the method
     combination whose name is X.

     If X is a method combination, returns the documentation string
     associated with X.

setf

     Returns the documentation string of the setf expander whose name is
     the symbol X.

structure

     Returns the documentation string associated with the structure name
     X.

t

     Returns a documentation string specialized on the class of the
     argument X itself.  For example, if X is a function, the
     documentation string associated with the function X is returned.

type

     If X is a symbol, returns the documentation string of the class
     whose name is the symbol X, if there is such a class.  Otherwise,
     it returns the documentation string of the type which is the type
     specifier symbol X.

     If X is a structure class or standard class, returns the
     documentation string associated with the class X.

variable

     Returns the documentation string of the dynamic variable or
     constant variable whose name is the symbol X.

A conforming implementation or a conforming program may extend the set
of symbols that are acceptable as the DOC-TYPE.

Notes:
......

This standard prescribes no means to retrieve the documentation strings
for individual slots specified in a ‘defclass’ form, but implementations
might still provide debugging tools and/or programming language
extensions which manipulate this information.  Implementors wishing to
provide such support are encouraged to consult the Metaobject Protocol
for suggestions about how this might be done.


File: ansicl,  Node: room,  Next: ed,  Prev: documentation; setf documentation,  Up: Environment

room (Function)
===============

Syntax:
.......

 -- Function: room &optional x → implementation-dependent

Arguments and Values:
.....................

X—one of ‘t’, ‘nil’, or :default.

Description:
............

‘room’ prints, to standard output, information about the state of
internal storage and its management.  This might include descriptions of
the amount of memory in use and the degree of memory compaction,
possibly broken down by internal data type if that is appropriate.  The
nature and format of the printed information is
implementation-dependent.  The intent is to provide information that a
programmer might use to tune a program for a particular implementation.

‘(room nil)’ prints out a minimal amount of information.  ‘(room t)’
prints out a maximal amount of information.  ‘(room)’ or ‘(room
:default)’ prints out an intermediate amount of information that is
likely to be useful.

Side Effects:
.............

Output to standard output.

Affected By:
............

‘*standard-output*’.


File: ansicl,  Node: ed,  Next: inspect,  Prev: room,  Up: Environment

ed (Function)
=============

Syntax:
.......

 -- Function: ed &optional x → implementation-dependent

Arguments and Values:
.....................

X—‘nil’, a pathname, a string, or a function name.  The default is
‘nil’.

Description:
............

‘ed’ invokes the editor if the implementation provides a resident
editor.

If X is ‘nil’, the editor is entered.  If the editor had been previously
entered, its prior state is resumed, if possible.

If X is a pathname or string, it is taken as the pathname designator for
a file to be edited.

If X is a function name, the text of its definition is edited.  The
means by which the function text is obtained is implementation-defined.

Exceptional Situations:
.......................

The consequences are undefined if the implementation does not provide a
resident editor.

Might signal ‘type-error’ if its argument is supplied but is not a
symbol, a pathname, or ‘nil’.

If a failure occurs when performing some operation on the file system
while attempting to edit a file, an error of type ‘file-error’ is
signaled.

An error of type ‘file-error’ might be signaled if X is a designator for
a wild pathname.

Implementation-dependent additional conditions might be signaled as
well.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note compile-file::, *note load::, *note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.


File: ansicl,  Node: inspect,  Next: dribble,  Prev: ed,  Up: Environment

inspect (Function)
==================

Syntax:
.......

 -- Function: inspect object → implementation-dependent

Arguments and Values:
.....................

OBJECT—an object.

Description:
............

‘inspect’ is an interactive version of ‘describe’.  The nature of the
interaction is implementation-dependent, but the purpose of ‘inspect’ is
to make it easy to wander through a data structure, examining and
modifying parts of it.

Side Effects:
.............

implementation-dependent.

Affected By:
............

implementation-dependent.

Exceptional Situations:
.......................

implementation-dependent.

See Also:
.........

*note describe::

Notes:
......

Implementations are encouraged to respond to the typing of ‘?’ or a
“help key” by providing help, including a list of commands.


File: ansicl,  Node: dribble,  Next: - (Variable),  Prev: inspect,  Up: Environment

dribble (Function)
==================

Syntax:
.......

 -- Function: dribble &optional pathname → implementation-dependent

Arguments and Values:
.....................

PATHNAME—a pathname designator.

Description:
............

Either binds ‘*standard-input*’ and ‘*standard-output*’ or takes other
appropriate action, so as to send a record of the input/output
interaction to a file named by PATHNAME.  ‘dribble’ is intended to
create a readable record of an interactive session.

If PATHNAME is a logical pathname, it is translated into a physical
pathname as if by calling ‘translate-logical-pathname’.

‘(dribble)’ terminates the recording of input and output and closes the
dribble file.

If ‘dribble’ is called while a stream to a “dribble file” is still open
from a previous call to ‘dribble’, the effect is implementation-defined.
For example, the already-open stream might be closed, or dribbling might
occur both to the old stream and to a new one, or the old stream might
stay open but not receive any further output, or the new request might
be ignored, or some other action might be taken.

Affected By:
............

The implementation.

Exceptional Situations:
.......................

If a failure occurs when performing some operation on the file system
while creating the dribble file, an error of type ‘file-error’ is
signaled.

An error of type ‘file-error’ might be signaled if PATHNAME is a
designator for a wild pathname.

See Also:
.........

*note Section 19.1.2 (Pathnames as Filenames): Pathnames as Filenames.

Notes:
......

‘dribble’ can return before subsequent forms are executed.  It also can
enter a recursive interaction loop, returning only when ‘(dribble)’ is
done.

‘dribble’ is intended primarily for interactive debugging; its effect
cannot be relied upon when used in a program.


File: ansicl,  Node: - (Variable),  Next: +; ++; +++,  Prev: dribble,  Up: Environment

- (Variable)
============

Value Type:
...........

a form.

Initial Value:
..............

implementation-dependent.

Description:
............

The value of ‘-’ is the form that is currently being evaluated by the
Lisp read-eval-print loop.

Examples:
.........

     (format t "~&Evaluating ~S~%" -)
     ▷ Evaluating (FORMAT T "~&Evaluating ~S~%" -)
     → NIL

Affected By:
............

Lisp read-eval-print loop.

See Also:
.........

*note + (Function):: (variable), *note * (Function):: (variable), *note
/ (Function):: (variable), *note Section 25.1.1 (Top level loop): Top
level loop.


File: ansicl,  Node: +; ++; +++,  Next: *; **; ***,  Prev: - (Variable),  Up: Environment

+, ++, +++ (Variable)
=====================

Value Type:
...........

an object.

Initial Value:
..............

implementation-dependent.

Description:
............

The variables ‘+’, ++, and +++ are maintained by the Lisp
read-eval-print loop to save forms that were recently evaluated.

The value of ‘+’ is the last form that was evaluated, the value of ‘++’
is the previous value of +, and the value of ‘+++’ is the previous value
of ++.

Examples:
.........

     (+ 0 1) → 1
     (- 4 2) → 2
     (/ 9 3) → 3
     (list + ++ +++) → ((/ 9 3) (- 4 2) (+ 0 1))
     (setq a 1 b 2 c 3 d (list a b c)) → (1 2 3)
     (setq a 4 b 5 c 6 d (list a b c)) → (4 5 6)
     (list a b c) → (4 5 6)
     (eval +++) → (1 2 3)
     #.`(,@++ d) → (1 2 3 (1 2 3))

Affected By:
............

Lisp read-eval-print loop.

See Also:
.........

*note - (Function):: (variable), *note * (Function):: (variable), *note
/ (Function):: (variable), *note Section 25.1.1 (Top level loop): Top
level loop.


File: ansicl,  Node: *; **; ***,  Next: /; //; ///,  Prev: +; ++; +++,  Up: Environment

*, **, *** (Variable)
=====================

Value Type:
...........

an object.

Initial Value:
..............

implementation-dependent.

Description:
............

The variables ‘*’, **, and *** are maintained by the Lisp
read-eval-print loop to save the values of results that are printed each
time through the loop.

The value of ‘*’ is the most recent primary value that was printed, the
value of ‘**’ is the previous value of *, and the value of ‘***’ is the
previous value of **.

If several values are produced, * contains the first value only; *
contains ‘nil’ if zero values are produced.

The values of *, **, and *** are updated immediately prior to printing
the return value of a top-level form by the Lisp read-eval-print loop.
If the evaluation of such a form is aborted prior to its normal return,
the values of *, **, and *** are not updated.

Examples:
.........

     (values 'a1 'a2) → A1, A2
     'b → B
     (values 'c1 'c2 'c3) → C1, C2, C3
     (list * ** ***) → (C1 B A1)

     (defun cube-root (x) (expt x 1/3)) → CUBE-ROOT
     (compile *) → CUBE-ROOT
     (setq a (cube-root 27.0)) → 3.0
     (* * 9.0) → 27.0

Affected By:
............

Lisp read-eval-print loop.

See Also:
.........

*note - (Function):: (variable), *note + (Function):: (variable), *note
/ (Function):: (variable), *note Section 25.1.1 (Top level loop): Top
level loop.

Notes:
......

      *   ≡ (car /)
      **  ≡ (car //)
      *** ≡ (car ///)


File: ansicl,  Node: /; //; ///,  Next: lisp-implementation-type; lisp-implementation-version,  Prev: *; **; ***,  Up: Environment

/, //, /// (Variable)
=====================

Value Type:
...........

a proper list.

Initial Value:
..............

implementation-dependent.

Description:
............

The variables ‘/’, //, and /// are maintained by the Lisp
read-eval-print loop to save the values of results that were printed at
the end of the loop.

The value of ‘/’ is a list of the most recent values that were printed,
the value of ‘//’ is the previous value of /, and the value of ‘///’ is
the previous value of //.

The values of /, //, and /// are updated immediately prior to printing
the return value of a top-level form by the Lisp read-eval-print loop.
If the evaluation of such a form is aborted prior to its normal return,
the values of /, //, and /// are not updated.

Examples:
.........

      (floor 22 7) → 3, 1
      (+ (* (car /) 7) (cadr /)) → 22

Affected By:
............

Lisp read-eval-print loop.

See Also:
.........

*note - (Function):: (variable), *note + (Function):: (variable), *note
* (Function):: (variable), *note Section 25.1.1 (Top level loop): Top
level loop.


File: ansicl,  Node: lisp-implementation-type; lisp-implementation-version,  Next: short-site-name; long-site-name,  Prev: /; //; ///,  Up: Environment

lisp-implementation-type, lisp-implementation-version (Function)
================================================================

Syntax:
.......

 -- Function: lisp-implementation-type <no arguments> → description

 -- Function: lisp-implementation-version <no arguments> → description

Arguments and Values:
.....................

DESCRIPTION—a string or ‘nil’.

Description:
............

‘lisp-implementation-type’ and ‘lisp-implementation-version’ identify
the current implementation of Common Lisp.

‘lisp-implementation-type’ returns a string that identifies the generic
name of the particular Common Lisp implementation.

‘lisp-implementation-version’ returns a string that identifies the
version of the particular Common Lisp implementation.

If no appropriate and relevant result can be produced, ‘nil’ is returned
instead of a string.

Examples:
.........

      (lisp-implementation-type)
     → "ACME Lisp"
     or→ "Joe's Common Lisp"
      (lisp-implementation-version)
     → "1.3a"
     → "V2"
     or→ "Release 17.3, ECO #6"


File: ansicl,  Node: short-site-name; long-site-name,  Next: machine-instance,  Prev: lisp-implementation-type; lisp-implementation-version,  Up: Environment

short-site-name, long-site-name (Function)
==========================================

Syntax:
.......

 -- Function: short-site-name <no arguments> → description

 -- Function: long-site-name <no arguments> → description

Arguments and Values:
.....................

DESCRIPTION—a string or ‘nil’.

Description:
............

‘short-site-name’ and ‘long-site-name’ return a string that identifies
the physical location of the computer hardware, or ‘nil’ if no
appropriate DESCRIPTION can be produced.

Examples:
.........

      (short-site-name)
     → "MIT AI Lab"
     or→ "CMU-CSD"
      (long-site-name)
     → "MIT Artificial Intelligence Laboratory"
     or→ "CMU Computer Science Department"

Affected By:
............

The implementation, the location of the computer hardware, and the
installation/configuration process.


File: ansicl,  Node: machine-instance,  Next: machine-type,  Prev: short-site-name; long-site-name,  Up: Environment

machine-instance (Function)
===========================

Syntax:
.......

 -- Function: machine-instance <no arguments> → description

Arguments and Values:
.....................

DESCRIPTION—a string or ‘nil’.

Description:
............

Returns a string that identifies the particular instance of the computer
hardware on which Common Lisp is running, or ‘nil’ if no such string can
be computed.

Examples:
.........

      (machine-instance)
     → "ACME.COM"
     or→ "S/N 123231"
     or→ "18.26.0.179"
     or→ "AA-00-04-00-A7-A4"

Affected By:
............

The machine instance, and the implementation.

See Also:
.........

*note machine-type::, *note machine-version::


File: ansicl,  Node: machine-type,  Next: machine-version,  Prev: machine-instance,  Up: Environment

machine-type (Function)
=======================

Syntax:
.......

 -- Function: machine-type <no arguments> → description

Arguments and Values:
.....................

DESCRIPTION—a string or ‘nil’.

Description:
............

Returns a string that identifies the generic name of the computer
hardware on which Common Lisp is running.

Examples:
.........

      (machine-type)
     → "DEC PDP-10"
     or→ "Symbolics LM-2"

Affected By:
............

The machine type.  The implementation.

See Also:
.........

*note machine-version::


File: ansicl,  Node: machine-version,  Next: software-type; software-version,  Prev: machine-type,  Up: Environment

machine-version (Function)
==========================

Syntax:
.......

 -- Function: machine-version <no arguments> → description

Arguments and Values:
.....................

DESCRIPTION—a string or ‘nil’.

Description:
............

Returns a string that identifies the version of the computer hardware on
which Common Lisp is running, or ‘nil’ if no such value can be computed.

Examples:
.........

      (machine-version) → "KL-10, microcode 9"

Affected By:
............

The machine version, and the implementation.

See Also:
.........

*note machine-type::, *note machine-instance::


File: ansicl,  Node: software-type; software-version,  Next: user-homedir-pathname,  Prev: machine-version,  Up: Environment

software-type, software-version (Function)
==========================================

Syntax:
.......

 -- Function: software-type <no arguments> → description
 -- Function: software-version <no arguments> → description

Arguments and Values:
.....................

DESCRIPTION—a string or ‘nil’.

Description:
............

‘software-type’ returns a string that identifies the generic name of any
relevant supporting software, or ‘nil’ if no appropriate or relevant
result can be produced.

‘software-version’ returns a string that identifies the version of any
relevant supporting software, or ‘nil’ if no appropriate or relevant
result can be produced.

Examples:
.........

      (software-type) → "Multics"
      (software-version) → "1.3x"

Affected By:
............

Operating system environment.

Notes:
......

This information should be of use to maintainers of the implementation.


File: ansicl,  Node: user-homedir-pathname,  Prev: software-type; software-version,  Up: Environment

user-homedir-pathname (Function)
================================

Syntax:
.......

 -- Function: user-homedir-pathname &optional host → pathname

Arguments and Values:
.....................

HOST—a string, a list of strings, or :unspecific.

PATHNAME—a pathname, or ‘nil’.

Description:
............

‘user-homedir-pathname’ determines the pathname that corresponds to the
user’s home directory on HOST.  If HOST is not supplied, its value is
implementation-dependent.  For a description of :unspecific, see *note
Section 19.2.1 (Pathname Components): Pathname Components.

The definition of home directory is implementation-dependent, but
defined in Common Lisp to mean the directory where the user keeps
personal files such as initialization files and mail.

‘user-homedir-pathname’ returns a pathname without any name, type, or
version component (those components are all ‘nil’) for the user’s home
directory on HOST.

If it is impossible to determine the user’s home directory on HOST, then
‘nil’ is returned.  ‘user-homedir-pathname’ never returns ‘nil’ if HOST
is not supplied.

Examples:
.........

      (pathnamep (user-homedir-pathname)) → true

Affected By:
............

The host computer’s file system, and the implementation.


File: ansicl,  Node: Glossary,  Next: Appendix,  Prev: Environment,  Up: Top

26 Glossary
***********

* Menu:

* Glossary Notation::
* Non-alphabetic::
* A::
* B::
* C::
* D::
* E::
* F::
* G::
* H::
* I::
* K::
* L::
* M::
* N::
* O::
* P::
* Q::
* R::
* S::
* T::
* U::
* V::
* W::
* Y::


File: ansicl,  Node: Glossary Notation,  Next: Non-alphabetic,  Up: Glossary

26.1 Glossary Notation
======================

Each entry in this glossary has the following parts:

   • the term being defined, set in boldface.

   • optional pronunciation, enclosed in square brackets and set in
     boldface, as in the following example: [ˈaˌlist].  The
     pronunciation key follows ‘Webster’s Third New International
     Dictionary the English Language, Unabridged’.

   • the part or parts of speech, set in italics.  If a term can be used
     as several parts of speech, there is a separate definition for each
     part of speech.

   • one or more definitions, organized as follows:

        – an optional number, present if there are several definitions.
          Lowercase letters might also be used in cases where
          subdefinitions of a numbered definition are necessary.

        – an optional part of speech, set in italics, present if the
          term is one of several parts of speech.

        – an optional discipline, set in italics, present if the term
          has a standard definition being repeated.  For example,
          “Math.”

        – an optional context, present if this definition is meaningful
          only in that context.  For example, “(of a symbol)”.

        – the definition.

        – an optional example sentence.  For example, “This is an
          example of an example.”

        – optional cross references.

In addition, some terms have idiomatic usage in the Common Lisp
community which is not shared by other communities, or which is not
technically correct.  Definitions labeled “Idiom.” represent such
idiomatic usage; these definitions are sometimes followed by an
explanatory note.

Words in this font are words with entries in the glossary.  Words in
example sentences do not follow this convention.

When an ambiguity arises, the longest matching substring has precedence.
For example, “complex float” refers to a single glossary entry for
“complex float” rather than the combined meaning of the glossary terms
“complex” and “float.”

Subscript notation, as in “something[n]” means that the nth definition
of “something” is intended.  This notation is used only in situations
where the context might be insufficient to disambiguate.

The following are abbreviations used in the glossary:

Abbreviation       Meaning
                   
----------------------------------------------------------------------
adj.               adjective
adv.               adverb
ANSI               compatible with one or more ANSI standards
Comp.              computers
Idiom.             idiomatic
IEEE               compatible with one or more IEEE standards
ISO                compatible with one or more ISO standards
Math.              mathematics
Trad.              traditional
n.                 noun
v.                 verb
v.t.               transitive verb


File: ansicl,  Node: Non-alphabetic,  Next: A,  Prev: Glossary Notation,  Up: Glossary

Non-alphabetic
==============

() 
     [ˈnil], n.  an alternative notation for writing the symbol ‘nil’,
     used to emphasize the use of nil as an empty list.


File: ansicl,  Node: A,  Next: B,  Prev: Non-alphabetic,  Up: Glossary

A
=

absolute 
     adj.  1.  (of a time) representing a specific point in time.  2.
     (of a pathname) representing a specific position in a directory
     hierarchy.  See *note relative: glos-relative.

access n., v.t.
     1.  v.t. (a place, or array) to readthe place or an element of the
     array.  2.  n. (of a place) an attempt to access

accessibility n.
     the state of being accessible.

accessible adj. 
     1.  (of an object) capable of being referenced.  2.  (of shared
     slots or local slots in an instance of a class) having been defined
     by the class of the instance or inherited from a superclass of that
     class.  3.  (of a symbol in a package) capable of being referenced
     without a package prefix when that package is current, regardless
     of whether the symbol is present in that package or is inherited.

accessor n.
     an operator that performs an access.  See *note reader:
     glos-reader. and writer.

active adj. 
     1.  (of a handler, a restart, or a catch tag) having been
     established but not yet disestablished.  2.  (of an element of an
     array) having an index that is greater than or equal to zero, but
     less than the fill pointer (if any).  For an array that has no fill
     pointer, all elements are considered active.

actual adjustability 
     n. (of an array) a generalized boolean that is associated with the
     array, representing whether the array is actually adjustable.  See
     also *note expressed adjustability: glos-expressed adjustability.
     and ‘adjustable-array-p’.

actual argument n. Trad. 
     an argument.

actual array element type n. (of an array)
     the type for which the array is actually specialized, which is the
     upgraded array element type of the expressed array element type of
     the array.  See the function *note array-element-type::.

actual complex part type n. (of a complex)
     the type in which the real and imaginary parts of the complex are
     actually represented, which is the upgraded complex part type of
     the expressed complex part type of the complex.

actual parameter n. Trad. 
     an argument.

actually adjustable adj. (of an array)
     such that ‘adjust-array’ can adjust its characteristics by direct
     modification.  A conforming program may depend on an array being
     actually adjustable only if either that array is known to have been
     expressly adjustable or if that array has been explicitly tested by
     ‘adjustable-array-p’.

adjustability n. (of an array)
     1.  expressed adjustability.  2.  actual adjustability.

adjustable adj. (of an array)
     1.  expressly adjustable.  2.  actually adjustable.

after method n.
     a method having the qualifier :after.

alist [ˈāˌlist], n. 
     an association list.

alphabetic n., adj.
     1.  adj. (of a character) being one of the standard characters ‘A’
     through ‘Z’ or ‘a’ through ‘z’, or being any implementation-defined
     character that has case, or being some other graphic character
     defined by the implementation to be alphabetic2.  a.  n.  one of
     several possible constituent traits of a character.  For details,
     see *note Section 2.1.4.1 (Constituent Characters):
     ConstituentChars. and *note Section 2.2 (Reader Algorithm): Reader
     Algorithm.  b.  adj. (of a character) being a character that has
     syntax type constituent in the current readtable and that has the
     constituent trait alphabetic[2a].  See *note Figure 2.8:
     ConstituentTraitsOfStdChars.

alphanumeric adj. (of a character)
     being either an alphabeticor a numeric character.

ampersand n.
     the standard character that is called “ampersand” (‘&’).  See *note
     Figure 2.5: StdCharsThree.

anonymous adj. 
     1.  (of a class or function) having no name 2.  (of a restart)
     having a name of ‘nil’.

apparently uninterned adj. 
     having a home package of ‘nil’.  (An apparently uninterned symbol
     might or might not be an uninterned symbol.  Uninterned symbols
     have a home package of ‘nil’, but symbols which have been
     uninterned from their home package also have a home package of
     ‘nil’, even though they might still be interned in some other
     package.)

applicable adj.
     1.  (of a handler) being an applicable handler.  2.  (of a method)
     being an applicable method.  3.  (of a restart) being an applicable
     restart.

applicable handler n. (for a condition being signaled)
     an active handler for which the associated type contains the
     condition.

applicable method n. (of a generic function
     called with arguments) a method of the generic function for which
     the arguments satisfy the parameter specializers of that method.
     See *note Section 7.6.6.1.1 (Selecting the Applicable Methods):
     SelApplMeth.

applicable restart n.
     1.  (for a condition) an active handler for which the associated
     test returns true when given the condition as an argument.  2.
     (for no particular condition) an active handler for which the
     associated test returns true when given ‘nil’ as an argument.

apply v.t. (a function to a list)
     to call the function with arguments that are the elements of the
     list.  “Applying the function ‘+’ to a list of integers returns the
     sum of the elements of that list.”

argument n.
     1.  (of a function) an object which is offered as data to the
     function when it is called.  2.  (of a format control) a format
     argument.

argument evaluation order n. 
     the order in which arguments are evaluated in a function call.
     “The argument evaluation order for Common Lisp is left to right.”
     See *note Section 3.1 (Evaluation): Evaluation.

argument precedence order n.
     the order in which the arguments to a generic function are
     considered when sorting the applicable methods into precedence
     order.

around method n.
     a method having the qualifier :around.

array n.
     an object of type ‘array’, which serves as a container for other
     objects arranged in a Cartesian coordinate system.

array element type n. (of an array)
     1.  a type associated with the array, and of which all elements of
     the array are constrained to be members.  2.  the actual array
     element type of the array.  3.  the expressed array element type of
     the array.

array total size n. 
     the total number of elements in an array, computed by taking the
     product of the dimensions of the array.  (The size of a
     zero-dimensional array is therefore one.)

assign v.t. (a variable)
     to change the value of the variable in a binding that has already
     been established.  See the special operator *note setq::.

association list 
     n.   a list of conses representing an association of keys with
     values, where the car of each cons is the key and the cdr is the
     value associated with that key.

asterisk n.
     the standard character that is variously called “asterisk” or
     “star” (‘*’).  See *note Figure 2.5: StdCharsThree.

at-sign n.
     the standard character that is variously called “commercial at” or
     “at sign” (‘@’).  See *note Figure 2.5: StdCharsThree.

atom n.
     any object that is not a cons.  “A vector is an atom.”

atomic adj. 
     being an atom.  “The number 3, the symbol ‘foo’, and ‘nil’ are
     atomic.”

atomic type specifier n.
     a type specifier that is atomic.  For every atomic type specifier,
     x, there is an equivalent compound type specifier with no arguments
     supplied, ‘(x)’.

attribute n. (of a character)
     a program-visible aspect of the character.  The only standardized
     attribute of a character is its codeadditional
     implementation-defined attributes.  See *note Section 13.1.3
     (Character Attributes): Character Attributes.  “An implementation
     that support fonts might make font information an attribute of a
     character, while others might represent font information separately
     from characters.”

aux variable n.
     a variable that occurs in the part of a lambda list that was
     introduced by ‘&aux’.  Unlike all other variables introduced by a
     lambda-list, aux variables are not parameters.

auxiliary method n.
     a member of one of two sets of methods (the set of primary methods
     is the other) that form an exhaustive partition of the set of
     methods on the method’s generic function.  How these sets are
     determined is dependent on the method combination type; see *note
     Section 7.6.2 (Introduction to Methods): Introduction to Methods.


File: ansicl,  Node: B,  Next: C,  Prev: A,  Up: Glossary

B
=

backquote n.
     the standard character that is variously called “grave accent” or
     “backquote” (‘`’).  See *note Figure 2.5: StdCharsThree.

backslash n.
     the standard character that is variously called “reverse solidus”
     or “backslash” (‘\’).  See *note Figure 2.5: StdCharsThree.

base character n.
     a character of type ‘base-char’.

base string n.
     a string of type ‘base-string’.

before method n.
     a method having the qualifier :before.

bidirectional adj. (of a stream)
     being both an input stream and an output stream.

binary 
     adj.   1.  (of a stream) being a stream that has an element type
     that is a subtype of type ‘integer’.  The most fundamental
     operation on a binary input stream is ‘read-byte’ and on a binary
     output stream is ‘write-byte’.  See *note character:
     glos-character.  2.  (of a file) having been created by opening a
     binary stream.  (It is implementation-dependent whether this is an
     detectable aspect of the file, or whether any given character file
     can be treated as a binary file.)

bind v.t. (a variable)
     to establish a binding for the variable.

binding n. 
     an association between a name and that which the name denotes.  “A
     lexical binding is a lexical association between a name and its
     value.” When the term binding is qualified by the name of a
     namespace, such as “variable” or “function,” it restricts the
     binding to the indicated namespace, as in: “‘let’ establishes
     variable bindings.” or “‘let’ establishes bindings of variables.”

bit n. 
     an object of type ‘bit’; that is, the integer ‘0’ or the integer
     ‘1’.

bit array n.
     a specialized array that is of type ‘(array bit)’, and whose
     elements are of type ‘bit’.

bit vector n. 
     a specialized vector that is of type ‘bit-vector’, and whose
     elements are of type ‘bit’.

bit-wise logical operation specifier n. 
     an object which names one of the sixteen possible bit-wise logical
     operations that can be performed by the ‘boole’ function, and which
     is the value of exactly one of the constant variables ‘boole-clr’,
     ‘boole-set’, ‘boole-1’, ‘boole-2’, ‘boole-c1’, ‘boole-c2’,
     ‘boole-and’, ‘boole-ior’, ‘boole-xor’, ‘boole-eqv’, ‘boole-nand’,
     ‘boole-nor’, ‘boole-andc1’, ‘boole-andc2’, ‘boole-orc1’, or
     ‘boole-orc2’.

block n.
     a named lexical exit point, established explicitly by ‘block’ or
     implicitly by operators such as ‘loop’, ‘do’ and ‘prog’, to which
     control and values may be transfered by using a ‘return-from’ form
     with the name of the block.

block tag n. 
     the symbol that, within the lexical scope of a ‘block’ form, names
     the block established by that ‘block’ form.  See ‘return’ or
     ‘return-from’.

boa lambda list n.
     a lambda list that is syntactically like an ordinary lambda list,
     but that is processed in “by order of argument” style.  See *note
     Section 3.4.6 (Boa Lambda Lists): Boa Lambda Lists.

body parameter n.
     a parameter available in certain lambda lists which from the point
     of view of conforming programs is like a rest parameter in every
     way except that it is introduced by ‘&body’ instead of ‘&rest’.
     (Implementations are permitted to provide extensions which
     distinguish body parameters and rest parameters—e.g., the forms for
     operators which were defined using a body parameter might be pretty
     printed slightly differently than forms for operators which were
     defined using rest parameters.)

boolean 
     n.   an object of type ‘boolean’; that is, one of the following
     objects: the symbol ‘t’  (representing true), or the
     symbol ‘nil’ (representing false).  See *note generalized boolean:
     glos-generalized boolean.

boolean equivalent n. (of an object O
     any object Owhen both O

bound 
     adj., v.t.   1.  adj. having an associated denotation in a binding.
     “The variables named by a ‘let’ are bound within its body.” See
     *note unbound: glos-unbound.  2.  adj. having a local binding which
     shadows“The variable ‘*print-escape*’ is bound while in the ‘princ’
     function.” 3.  v.t. the past tense of bind.

bound declaration n. 
     a declaration that refers to or is associated with a variable or
     function and that appears within the special form that establishes
     the variable or function, but before the body of that special form
     (specifically, at the head of that form’s body).  (If a bound
     declaration refers to a function binding or a lexical variable
     binding, the scope of the declaration is exactly the scope of that
     binding.  If the declaration refers to a dynamic variable binding,
     the scope of the declaration is what the scope of the binding would
     have been if it were lexical rather than dynamic.)

bounded adj. (of a sequence S,
     by an ordered pair of bounding indices irestricted to a subrange of
     the elements of S that includes each element beginning with (and
     including) the one indexed by icontinuing up to (but not including)
     the one indexed by i

bounding index n. (of a sequence with length n)
     either of a conceptual pair of integers, irespectively called the
     “lower bounding index” and “upper bounding index”, such that 0 ≤ ia
     subrange of the sequence bounded by i

bounding index designator (for a sequence)
     one of two objects that, taken together as an ordered pair, behave
     as a designator for bounding indices of the sequence; that is, they
     denote bounding indices of the sequence, and are either: an integer
     (denoting itself) and ‘nil’  (denoting the length of the sequence),
     or two integers (each denoting themselves).

break loop n.
     A variant of the normal Lisp read-eval-print loop that is
     recursively entered, usually because the ongoing evaluation of some
     other form has been suspended for the purpose of debugging.  Often,
     a break loop provides the ability to exit in such a way as to
     continue the suspended computation.  See the function *note
     break::.

broadcast stream n.
     an output stream of type ‘broadcast-stream’.

built-in class n.
     a class that is a generalized instance of class ‘built-in-class’.

built-in type n.
     one of the types in *note Figure 4.2: StandardizedAtomicTypeSpecs.

byte n.
     1.  adjacent bits within an integer.  (The specific number of bits
     can vary from point to point in the program; see the function *note
     byte::.)  2.  an integer in a specified range.  (The specific range
     can vary from point to point in the program; see the functions
     *note open:: and ‘write-byte’.)

byte specifier n.
     An object of implementation-dependent nature that is returned by
     the function ‘byte’ and that specifies the range of bits in an
     integer to be used as a byte by functions such as ‘ldb’.


File: ansicl,  Node: C,  Next: D,  Prev: B,  Up: Glossary

C
=

cadr [ˈkaˌdə r], n. (of an object)
     the car of the cdr of that object.

call v.t., n. 
     1.  v.t. (a function with arguments) to cause the code represented
     by that function to be executed in an environment where bindings
     for the values of its parameters have been established based on the
     arguments.  “Calling the function ‘+’ with the arguments ‘5’ and
     ‘1’ yields a value of ‘6’.” 2.  n. a situation in which a function
     is called.

captured initialization form n.
     an initialization form along with the lexical environment in which
     the form that defined the initialization form was evaluated.  “Each
     newly added shared slot is set to the result of evaluating the
     captured initialization form for the slot that was specified in the
     ‘defclass’ form for the new class.”

car n.
     1.  a.  (of a cons) the component of a cons corresponding to the
     first argument to ‘cons’; the other component is the cdr.  “The
     function ‘rplaca’ modifies the car of a cons.” b.  (of a list) the
     first element of the list, or ‘nil’ if the list is the empty list.
     2.  the object that is held in the car“The function ‘car’ returns
     the car of a cons.”

case n. (of a character)
     the property of being either uppercase or lowercase.  Not all
     characters have case.  “The characters ‘#\A’ and ‘#\a’ have case,
     but the character ‘#\$’ has no case.” See *note Section 13.1.4.3
     (Characters With Case): CharactersWithCase. and the function
     ‘both-case-p’.

case sensitivity mode n.
     one of the symbols :upcase, :downcase, :preserve, or :invert.

catch n.
     an exit point which is established by a ‘catch’ form within the
     dynamic scope of its body, which is named by a catch tag, and to
     which control and values may be thrown.

catch tag n.
     an object which names an active catch.  (If more than one catch is
     active with the same catch tag, it is only possible to throw to the
     innermost such catch because the outer one is shadowed

cddr [ˈk\.udə ˌdə r] or
     [ˈkəˌd\.udə r], n.   (of an object) the cdr of the cdr of that
     object.

cdr [ˈk\.uˌdə r], n. 
     1.  a.  (of a cons) the component of a cons corresponding to the
     second argument to ‘cons’; the other component is the car.  “The
     function ‘rplacd’ modifies the cdr of a cons.” b.  (of a list
     Leither the list Lthe elements of Lor else ‘nil’ if L2.  the object
     that is held in the cdr“The function ‘cdr’ returns the cdr of a
     cons.”

cell 
     n. Trad. (of an object) a conceptual slot of that object.  The
     dynamic variable and global function bindings of a symbol are
     sometimes referred to as its value cell and function cell,
     respectively.

character 
     n., adj.  1.  n. an object of type ‘character’; that is, an object
     that represents a unitary token in an aggregate quantity of text;
     see *note Section 13.1 (Character Concepts): Character Concepts.
     2.  adj.   a.  (of a stream) having an element type that is a
     subtype of type ‘character’.  The most fundamental operation on a
     character input stream is ‘read-char’ and on a character output
     stream is ‘write-char’.  See *note binary: glos-binary.  b.  (of a
     file) having been created by opening a character stream.  (It is
     implementation-dependent whether this is an inspectable aspect of
     the file, or whether any given binary file can be treated as a
     character file.)

character code n.
     1.  one of possibly several attributes of a character.  2.  a
     non-negative integer less than the value of ‘char-code-limit’ that
     is suitable for use as a character code

character designator n.
     a designator for a character; that is, an object that denotes a
     character and that is one of: a designator for a string of length
     one (denoting the character that is its only element), or a
     character (denoting itself).

circular adj.
     1.  (of a list) a circular list.  2.  (of an arbitrary object)
     having a component, element, constituentor subexpression (as
     appropriate to the context) that is the object itself.

circular list n. 
     a chain of conses that has no termination because some cons in the
     chain is the cdr of a later cons.

class n.
     1.  an object that uniquely determines the structure and behavior
     of a set of other objects called its direct instances, that
     contributes structure and behavior to a set of other objects called
     its indirect instances, and that acts as a type specifier for a set
     of objects called its generalized instances.  “The class ‘integer’
     is a subclass of the class ‘number’.” (Note that the phrase “the
     class ‘foo’” is often substituted for the more precise phrase “the
     class named ‘foo’”—in both cases, a class object (not a symbol) is
     denoted.)  2.  (of an object) the uniquely determined class of
     which the object is a direct instance.  See the function *note
     class-of::.  “The class of the object returned by ‘gensym’ is
     ‘symbol’.” (Note that with this usage a phrase such as “its class
     is ‘foo’” is often substituted for the more precise phrase “its
     class is the class named ‘foo’”—in both cases, a class object (not
     a symbol) is denoted.)

class designator n.
     a designator for a class; that is, an object that denotes a class
     and that is one of: a symbol (denoting the class named by that
     symbol; see the function *note find-class::) or a class (denoting
     itself).

class precedence list n.
     a unique total ordering on a class and its superclasses that is
     consistent with the local precedence orders for the class and its
     superclasses.  For detailed information, see *note Section 4.3.5
     (Determining the Class Precedence List): Determining the Class
     Precedence List.

close 
     v.t. (a stream) to terminate usage of the stream as a source or
     sink of data, permitting the implementation to reclaim its internal
     data structures, and to free any external resources which might
     have been locked by the stream when it was opened.

closed adj. (of a stream)
     having been closed (see *note close: glos-close.).  Some (but not
     all) operations that are valid on open streams are not valid on
     closed streams.  See *note Section 21.1.1.1.2 (Open and Closed
     Streams): File Operations on Open and Closed Streams.

closure n.
     a lexical closure.

coalesce v.t. (literal objects that are similar)
     to consolidate the identity of those objects, such that they become
     the same object.  See *note Section 3.2.1 (Compiler Terminology):
     Compiler Terminology.

code n.
     1.  Trad.   any representation of actions to be performed, whether
     conceptual or as an actual object, such as forms, lambda
     expressions, objects of type function, text in a source file, or
     instruction sequences in a compiled file.  This is a generic term;
     the specific nature of the representation depends on its context.
     2.  (of a character) a character code.

coerce v.t. (an object to a type)
     to produce an object from the given object, without modifying that
     object, by following some set of coercion rules that must be
     specifically stated for any context in which this term is used.
     The resulting object is necessarily of the indicated type, except
     when that type is a subtype of type ‘complex’; in that case, if a
     complex rational with an imaginary part of zero would result, the
     result is a rational rather than a complex—see *note Section
     12.1.5.3 (Rule of Canonical Representation for Complex Rationals):
     RuleOfCanonRepForComplexRationals.

colon n.
     the standard character that is called “colon” (‘:’).  See *note
     Figure 2.5: StdCharsThree.

comma n.
     the standard character that is called “comma” (‘,’).  See *note
     Figure 2.5: StdCharsThree.

compilation n.
     the process of compiling code by the compiler.

compilation environment n. 
     1.  An environment that represents information known by the
     compiler about a form that is being compiled.  See *note Section
     3.2.1 (Compiler Terminology): Compiler Terminology.  2.  An object
     that represents the compilation environmentand that is used as a
     second argument to a macro function (which supplies a value for any
     ‘&environment’ parameter in the macro function’s definition).

compilation unit n.
     an interval during which a single unit of compilation is occurring.
     See the macro *note with-compilation-unit::.

compile v.t. 
     1.  (code) to perform semantic preprocessing of the code, usually
     optimizing one or more qualities of the code, such as run-time
     speed of execution or run-time storage usage.  The minimum semantic
     requirements of compilation are that it must remove all macro calls
     and arrange for all load time values to be resolved prior to run
     time.  2.  (a function) to produce a new object of type
     ‘compiled-function’ which represents the result of compiling the
     code represented by the function.  See the function *note
     compile::.  3.  (a source file) to produce a compiled file from a
     source file.  See the function *note compile-file::.

compile time n. 
     the duration of time that the compiler is processing source code.

compile-time definition n.
     a definition in the compilation environment.

compiled code n.
     1.  compiled functions.  2.  code that represents compiled
     functions, such as the contents of a compiled file.

compiled file n.
     a file which represents the results of compiling the forms which
     appeared in a corresponding source file, and which can be loaded.
     See the function *note compile-file::.

compiled function n.
     an object of type ‘compiled-function’, which is a function that has
     been compiled, which contains no references to macros that must be
     expanded at run time, and which contains no unresolved references
     to load time values.

compiler n.
     a facility that is part of Lisp and that translates code into an
     implementation-dependent form that might be represented or executed
     efficiently.  The functions ‘compile’ and ‘compile-file’ permit
     programs to invoke the compiler.

compiler macro n.
     an auxiliary macro definition for a globally defined function or
     macro which might or might not be called by any given conforming
     implementation and which must preserve the semantics of the
     globally defined function or macro but which might perform some
     additional optimizations.  (Unlike a macro, a compiler macro does
     not extend the syntax of Common Lisp; rather, it provides an
     alternate implementation strategy for some existing syntax or
     functionality.)

compiler macro expansion n.
     1.  the process of translating a form into another form by a
     compiler macro.  2.  the form resulting from this process.

compiler macro form n.
     a function form or macro form whose operator has a definition as a
     compiler macro, or a ‘funcall’ form whose first argument is a
     ‘function’ form whose argument is the name of a function that has a
     definition as a compiler macro.

compiler macro function n. 
     a function of two arguments, a form and an environment, that
     implements compiler macro expansion by producing either a form to
     be used in place of the original argument form or else ‘nil’,
     indicating that the original form should not be replaced.  See
     *note Section 3.2.2.1 (Compiler Macros): CompilerMacros.

complex n.
     an object of type ‘complex’.

complex float n.
     an object of type ‘complex’ which has a complex part type that is a
     subtype of ‘float’.  A complex float is a complex, but it is not a
     float.

complex part type n. (of a complex)
     1.  the type which is used to represent both the real part and the
     imaginary part of the complex.  2.  the actual complex part type of
     the complex.  3.  the expressed complex part type of the complex.

complex rational n.
     an object of type ‘complex’ which has a complex part type that is a
     subtype of ‘rational’.  A complex rational is a complex, but it is
     not a rational.  No complex rational has an imaginary part of zero
     because such a number is always represented by Common Lisp as an
     object of type ‘rational’; see *note Section 12.1.5.3 (Rule of
     Canonical Representation for Complex Rationals):
     RuleOfCanonRepForComplexRationals.

complex single float n.
     an object of type ‘complex’ which has a complex part type that is a
     subtype of ‘single-float’.  A complex single float is a complex,
     but it is not a single float.

composite stream n.
     a stream that is composed of one or more other streams.
     “‘make-synonym-stream’ creates a composite stream.”

compound form n.
     a non-empty list which is a form: a special form, a lambda form, a
     macro form, or a function form.

compound type specifier n.
     a type specifier that is a cons; i.e., a type specifier that is not
     an atomic type specifier.  “‘(vector single-float)’ is a compound
     type specifier.”

concatenated stream n.
     an input stream of type ‘concatenated-stream’.

condition n.
     1.  an object which represents a situation—usually, but not
     necessarily, during signaling.  2.  an object of type ‘condition’.

condition designator n.
     one or more objects that, taken together, denote either an existing
     condition object or a condition object to be implicitly created.
     For details, see *note Section 9.1.2.1 (Condition Designators):
     ConditionDesignators.

condition handler n.
     a function that might be invoked by the act of signaling, that
     receives the condition being signaled as its only argument, and
     that is permitted to handle the condition or to decline.  See *note
     Section 9.1.4.1 (Signaling): Signaling.

condition reporter n.
     a function that describes how a condition is to be printed when the
     Lisp printer is invoked while ‘*print-escape*’ is false.  See *note
     Section 9.1.3 (Printing Conditions): Printing Conditions.

conditional newline n.
     a point in output where a newline might be inserted at the
     discretion of the pretty printer.  There are four kinds of
     conditional newlines, called “linear-style,” “fill-style,”
     “miser-style,” and “mandatory-style.” See the function *note
     pprint-newline:: and *note Section 22.2.1.1 (Dynamic Control of the
     Arrangement of Output): DynamicControlofOutput.

conformance n.
     a state achieved by proper and complete adherence to the
     requirements of this specification.  See *note Section 1.5
     (Conformance): Conformance.

conforming code n.
     code that is all of part of a conforming program.

conforming implementation n.
     an implementation, used to emphasize complete and correct adherance
     to all conformance criteria.  A conforming implementation is
     capable of accepting a conforming program as input, preparing that
     program for execution, and executing the prepared program in
     accordance with this specification.  An implementation which has
     been extended may still be a conforming implementation provided
     that no extension interferes with the correct function of any
     conforming program.

conforming processor n. ANSI 
     a conforming implementation.

conforming program n.
     a program, used to emphasize the fact that the program depends for
     its correctness only upon documented aspects of Common Lisp, and
     can therefore be expected to run correctly in any conforming
     implementation.

congruent n. 
     conforming to the rules of lambda list congruency, as detailed in
     *note Section 7.6.4 (Congruent Lambda-lists for all Methods of a
     Generic Function): Congruent Lambda-lists for all Methods of a
     Generic Function.

cons n.v. 
     1.  n. a compound data object having two components called the car
     and the cdr.  2.  v. to create such an object.  3.  v. Idiom. to
     create any object, or to allocate storage.

constant n.
     1.  a constant form.  2.  a constant variable.  3.  a constant
     object.  4.  a self-evaluating object.

constant form n.
     any form for which evaluation always yields the same value, that
     neither affects nor is affected by the environment in which it is
     evaluated (except that it is permitted to refer to the names of
     constant variables defined in the environment), and that neither
     affects nor is affected by the state of any object except those
     objects that are otherwise inaccessible parts of objects created by
     the form itself.  “A ‘car’ form in which the argument is a ‘quote’
     form is a constant form.”

constant object n.
     an object that is constrained (e.g., by its context in a program or
     by the source from which it was obtained) to be immutable.  “A
     literal object that has been processed by ‘compile-file’ is a
     constant object.”

constant variable n.
     a variable, the value of which can never change; that is, a
     keyword“The symbols ‘t’, ‘nil’, :direction, and
     ‘most-positive-fixnum’ are constant variables.”

constituent n., adj.
     1.  a.  n. the syntax type of a character that is part of a token.
     For details, see *note Section 2.1.4.1 (Constituent Characters):
     ConstituentChars.  b.  adj. (of a character) having the
     constituent[1a] syntax typec.  n. a constituent[1b] character.  2.
     n. (of a composite stream) one of possibly several objects that
     collectively comprise the source or sink of that stream.

constituent trait n. (of a character)
     one of several classifications of a constituent character in a
     readtable.  See *note Section 2.1.4.1 (Constituent Characters):
     ConstituentChars.

constructed stream n. 
     a stream whose source or sink is a Lisp object.  Note that since a
     stream is another Lisp object, composite streams are considered
     constructed streams.  “A string stream is a constructed stream.”

contagion n.
     a process whereby operations on objects of differing types (e.g.,
     arithmetic on mixed types of numbers) produce a result whose type
     is controlled by the dominance of one argument’s type over the
     types of the other arguments.  See *note Section 12.1.1.2
     (Contagion in Numeric Operations): NumericContagionRules.

continuable n. (of an error)
     an error that is correctable by the ‘continue’ restart.

control form n.
     1.  a form that establishes one or more places to which control can
     be transferred.  2.  a form that transfers control.

copy n.
     1.  (of a cons C) a fresh cons with the same car and cdr as C. 2.
     (of a list L) a fresh list with the same elements as L. (Only the
     list structure is fresh; the elements are the same.)  See the
     function *note copy-list::.  3.  (of an association list A with
     elements Aa fresh list B with elements B‘nil’ if ASee the function
     *note copy-alist::.  4.  (of a tree T) a fresh tree with the same
     leaves as T. See the function *note copy-tree::.  5.  (of a random
     state R) a fresh random state that, if used as an argument to to
     the function ‘random’ would produce the same series of “random”
     values as R would produce.  6.  (of a structure S) a fresh
     structure that has the same type as S, and that has slot values,
     each of which is the same as the corresponding slot value of S.
     (Note that since the difference between a cons, a list, and a tree
     is a matter of “view” or “intention,” there can be no
     general-purpose function which, based solely on the type of an
     object, can determine which of these distinct meanings is intended.
     The distinction rests solely on the basis of the text description
     within this document.  For example, phrases like “a copy of the
     given list” or “copy of the list X” imply the second definition.)

correctable adj. (of an error)
     1.  (by a restart other than abort that has been associated with
     the error) capable of being corrected by invoking that restart.
     “The function ‘cerror’ signals an error that is correctable by the
     continue restart.” (Note that correctability is not a property of
     an error object, but rather a property of the dynamic environment
     that is in effect when the error is signaled.  Specifically, the
     restart is “associated with” the error condition object.  See *note
     Section 9.1.4.2.4 (Associating a Restart with a Condition):
     AssocRestartWithCond.)  2.  (when no specific restart is mentioned)
     correctable“‘import’ signals a correctable error of type
     ‘package-error’ if any of the imported symbols has the same name as
     some distinct symbol already accessible in the package.”

current input base n. (in a dynamic environment)
     the radix that is the value of ‘*read-base*’ in that environment,
     and that is the default radix employed by the Lisp reader and its
     related functions.

current logical block n.
     the context of the innermost lexically enclosing use of
     ‘pprint-logical-block’.

current output base n. (in a dynamic environment)
     the radix that is the value of ‘*print-base*’ in that environment,
     and that is the default radix employed by the Lisp printer and its
     related functions.

current package n. (in a dynamic environment)
     the package that is the value of ‘*package*’ in that environment,
     and that is the default package employed by the Lisp reader and
     Lisp printer, and their related functions.

current pprint dispatch table n. (in a dynamic environment)
     the pprint dispatch table that is the value of
     ‘*print-pprint-dispatch*’ in that environment, and that is the
     default pprint dispatch table employed by the pretty printer.

current random state n. (in a dynamic environment)
     the random state that is the value of ‘*random-state*’ in that
     environment, and that is the default random state employed by
     ‘random’.

current readtable n. (in a dynamic environment)
     the readtable that is the value of ‘*readtable*’ in that
     environment, and that affects the way in which expressionsinto
     objects by the Lisp reader.


File: ansicl,  Node: D,  Next: E,  Prev: C,  Up: Glossary

D
=

data type n. Trad. 
     a type.

debug I/O n. 
     the bidirectional stream that is the value of the variable
     ‘*debug-io*’.

debugger n.
     a facility that allows the user to handle a condition
     interactively.  For example, the debugger might permit interactive
     selection of a restart from among the active restarts, and it might
     perform additional implementation-defined services for the purposes
     of debugging.

declaration n.
     a global declaration or local declaration.

declaration identifier n.
     one of the symbols ‘declaration’, ‘dynamic-extent’, ‘ftype’,
     ‘function’, ‘ignore’, ‘inline’, ‘notinline’, ‘optimize’, ‘special’,
     or ‘type’; or a symbol which is the name of a type; or a symbol
     which has been declared to be a declaration identifier by using a
     ‘declaration’ declaration.

declaration specifier n.
     an expression that can appear at top level of a declare expression
     or a ‘declaim’ form, or as the argument to ‘proclaim’, and which
     has a car which is a declaration identifier, and which has a cdr
     that is data interpreted according to rules specific to the
     declaration identifier.

declare v. 
     to establish a declaration.  See *note declare::, ‘declaim’, or
     ‘proclaim’.

decline v. (of a handler)
     to return normally without having handled the condition being
     signaled, permitting the signaling process to continue as if the
     handler had not been present.

decoded time 
     n.  absolute time, represented as an ordered series of nine objects
     which, taken together, form a description of a point in calendar
     time, accurate to the nearest second (except that leap seconds are
     ignored).  See *note Section 25.1.4.1 (Decoded Time): DecodedTime.

default method n.
     a method having no parameter specializers other than the class ‘t’.
     Such a method is always an applicable method but might be shadowed

defaulted initialization argument list n.
     a list of alternating initialization argument names and values in
     which unsupplied initialization arguments are defaulted, used in
     the protocol for initializing and reinitializing instances of
     classes.

define-method-combination arguments lambda list n.
     a lambda list used by the :arguments option to
     ‘define-method-combination’.  See *note Section 3.4.10
     (Define-method-combination Arguments Lambda Lists):
     Define-method-combination Arguments Lambda Lists.

define-modify-macro lambda list n.
     a lambda list used by ‘define-modify-macro’.  See *note Section
     3.4.9 (Define-modify-macro Lambda Lists): Define-modify-macro
     Lambda Lists.

defined name n.
     a symbol the meaning of which is defined by Common Lisp.

defining form n.
     a form that has the side-effect of establishing a definition.
     “‘defun’ and ‘defparameter’ are defining forms.”

defsetf lambda list n.
     a lambda list that is like an ordinary lambda list except that it
     does not permit ‘&aux’ and that it permits use of ‘&environment’.
     See *note Section 3.4.7 (Defsetf Lambda Lists): Defsetf Lambda
     Lists.

deftype lambda list n.
     a lambda list that is like a macro lambda list except that the
     default value for unsupplied optional parameters and keyword
     parameters is the symbol * (rather than ‘nil’).  See *note Section
     3.4.8 (Deftype Lambda Lists): Deftype Lambda Lists.

denormalized 
     adj., ANSI, IEEE (of a float) conforming to the description of
     “denormalized” as described by ‘IEEE Standard for Binary
     Floating-Point Arithmetic’.  For example, in an implementation
     where the minimum possible exponent was ‘-7’ but where ‘0.001’ was
     a valid mantissa, the number ‘1.0e-10’ might be representable as
     ‘0.001e-7’ internally even if the normalized representation would
     call for it to be represented instead as ‘1.0e-10’ or ‘0.1e-9’.  By
     their nature, denormalized floats generally have less precision
     than normalized floats.

derived type n.
     a type specifier which is defined in terms of an expansion into
     another type specifier.  ‘deftype’ defines derived types, and there
     may be other implementation-defined operators which do so as well.

derived type specifier n.
     a type specifier for a derived type.

designator n. 
     an object that denotes another object.  In the dictionary entry for
     an operator if a parameter is described as a designator for a type,
     the description of the operator is written in a way that assumes
     that appropriate coercion to that type has already occurred; that
     is, that the parameter is already of the denoted type.  For more
     detailed information, see *note Section 1.4.1.5 (Designators):
     Designators.

destructive adj. (of an operator)
     capable of modifying some program-visible aspect of one or more
     objects that are either explicit arguments to the operator or that
     can be obtained directly or indirectly from the global environment
     by the operator.

destructuring lambda list n.
     an extended lambda list used in ‘destructuring-bind’ and nested
     within macro lambda lists.  See *note Section 3.4.5 (Destructuring
     Lambda Lists): Destructuring Lambda Lists.

different adj. 
     not the same “The strings ‘"FOO"’ and ‘"foo"’ are different under
     ‘equal’ but not under ‘equalp’.”

digit n. (in a radix)
     a character that is among the possible digits (‘0’ to ‘9’, ‘A’ to
     ‘Z’, and ‘a’ to ‘z’) and that is defined to have an associated
     numeric weight as a digit in that radix.  See *note Section
     13.1.4.6 (Digits in a Radix): Digits.

dimension n.
     1.  a non-negative integer indicating the number of objects an
     array can hold along one axis.  If the array is a vector with a
     fill pointer, the fill pointer is ignored.  “The second dimension
     of that array is 7.” 2.  an axis of an array.  “This array has six
     dimensions.”

direct instance n. (of a class C)
     an object whose class is C itself, rather than some subclass of C.
     “The function ‘make-instance’ always returns a direct instance of
     the class which is (or is named by) its first argument.”

direct subclass n. (of a class C
     a class Csuch that C

direct superclass n. (of a class C
     a class Ca superclass of C

disestablish v.t. 
     to withdraw the establishment of an object, a binding, an exit
     point, a tag, a handler, a restart, or an environment.

disjoint n. (of types)
     having no elements in common.

dispatching macro character n. 
     a macro character that has an associated table that specifies the
     function to be called for each character that is seen following the
     dispatching macro character.  See the function *note
     make-dispatch-macro-character::.

displaced array n.
     an array which has no storage of its own, but which is instead
     indirected to the storage of another array, called its target, at a
     specified offset, in such a way that any attempt to access the
     displaced array implicitly references the target array.

distinct adj.
     not identical.

documentation string n. (in a defining form)
     A literal string which because of the context in which it appears
     (rather than because of some intrinsically observable aspect of the
     string) is taken as documentation.  In some cases, the
     documentation string is saved in such a way that it can later be
     obtained by supplying either an object, or by supplying a name and
     a “kind” to the function ‘documentation’.  “The body of code in a
     ‘defmacro’ form can be preceded by a documentation string of kind
     function.”

dot n.
     the standard character that is variously called “full stop,”
     “period,” or “dot” (‘.’).  See *note Figure 2.5: StdCharsThree.

dotted list n.
     a list which has a terminating atom that is not ‘nil’.  (An atom by
     itself is not a dotted list, however.)

dotted pair n.
     1.  a cons whose cdr is a non-list.  2.  any cons, used to
     emphasize the use of the cons as a symmetric data pair.

double float n.
     an object of type ‘double-float’.

double-quote n.
     the standard character that is variously called “quotation mark” or
     “double quote” (‘"’).  See *note Figure 2.5: StdCharsThree.

dynamic binding n. 
     a binding in a dynamic environment.

dynamic environment n.
     that part of an environment that contains bindings with dynamic
     extent.  A dynamic environment contains, among other things: exit
     points established by ‘unwind-protect’, and bindings of dynamic
     variables, exit points established by ‘catch’, condition handlers,
     and restarts.

dynamic extent n.
     an extent whose duration is bounded by points of establishment and
     disestablishment within the execution of a particular form.  See
     *note indefinite extent: glos-indefinite extent.  “Dynamic variable
     bindings have dynamic extent.”

dynamic scope n.
     indefinite scope along with dynamic extent.

dynamic variable n.
     a variable the binding for which is in the dynamic environment.
     See *note special::.


File: ansicl,  Node: E,  Next: F,  Prev: D,  Up: Glossary

E
=

echo stream n.
     a stream of type ‘echo-stream’.

effective method n.
     the combination of applicable methods that are executed when a
     generic function is invoked with a particular sequence of
     arguments.

element n.
     1.  (of a list) an object that is the car of one of the conses that
     comprise the list.  2.  (of an array) an object that is stored in
     the array.  3.  (of a sequence) an object that is an element of the
     list or array that is the sequence.  4.  (of a type) an object that
     is a member of the set of objects designated by the type.  5.  (of
     an input stream) a character or number (as appropriate to the
     element type of the stream) that is among the ordered series of
     objects that can be read from the stream (using ‘read-char’ or
     ‘read-byte’, as appropriate to the stream).  6.  (of an output
     stream) a character or number (as appropriate to the element type
     of the stream) that is among the ordered series of objects that has
     been or will be written to the stream (using ‘write-char’ or
     ‘write-byte’, as appropriate to the stream).  7.  (of a class) a
     generalized instance of the class.

element type n. 
     1.  (of an array) the array element type of the array.  2.  (of a
     stream) the stream element type of the stream.

em n. Trad. 
     a context-dependent unit of measure commonly used in typesetting,
     equal to the displayed width of of a letter “M” in the current
     font.  (The letter “M” is traditionally chosen because it is
     typically represented by the widest glyph in the font, and other
     characters’ widths are typically fractions of an em.  In
     implementations providing non-Roman characters with wider
     characters than “M,” it is permissible for another character to be
     the implementation-defined reference character for this measure,
     and for “M” to be only a fraction of an em wide.)  In a fixed width
     font, a line with n characters is n ems wide; in a variable width
     font, n ems is the expected upper bound on the width of such a
     line.

empty list 
     n.  the list containing no elements.  See *note (): glos-().

empty type n.
     the type that contains no elements, and that is a subtype of all
     types (including itself).  See *note nil: glos-nil.

end of file n.
     1.  the point in an input stream beyond which there is no further
     data.  Whether or not there is such a point on an interactive
     stream is implementation-defined.  2.  a situation that occurs upon
     an attempt to obtain data from an input stream that is at the end
     of file

environment n.
     1.  a set of bindings.  See *note Section 3.1.1 (Introduction to
     Environments): Introduction to Environments.  2.  an environment
     object.  “‘macroexpand’ takes an optional environment argument.”

environment object n.
     an object representing a set of lexical bindings, used in the
     processing of a form to provide meanings for names within that
     form.  “‘macroexpand’ takes an optional environment argument.” (The
     object ‘nil’ when used as an environment object denotes the null
     lexical environment; the values of environment parameters to macro
     functions are objects of implementation-dependent nature which
     represent the environmentis to be expanded.)  See *note Section
     3.1.1.4 (Environment Objects): EnvObjs.

environment parameter n.
     A parameter in a defining form f for which there is no
     corresponding argument; instead, this parameter receives as its
     value an environment object which corresponds to the lexical
     environment in which the defining form f appeared.

error n.
     1.  (only in the phrase “is an error”) a situation in which the
     semantics of a program are not specified, and in which the
     consequences are undefined.  2.  a condition which represents an
     error situation.  See *note Section 1.4.2 (Error Terminology):
     Error Terminology.  3.  an object of type ‘error’.

error output n. 
     the output stream which is the value of the dynamic variable
     ‘*error-output*’.

escape n., adj.
     1.  n. a single escape or a multiple escape.  2.  adj. single
     escape or multiple escape.

establish v.t. 
     to build or bring into being a binding, a declaration, an exit
     point, a tag, a handler, a restart, or an environment.  “‘let’
     establishes lexical bindings.”

evaluate v.t. (a form or an implicit progn)
     to execute the code represented by the form (or the series of forms
     making up the implicit progn) by applying the rules of evaluation,
     returning zero or more values.

evaluation n.
     a model whereby forms are executed, returning zero or more values.
     Such execution might be implemented directly in one step by an
     interpreter or in two steps by first compiling the form and then
     executing the compiled code; this choice is dependent both on
     context and the nature of the implementation, but in any case is
     not in general detectable by any program.  The evaluation model is
     designed in such a way that a conforming implementation might
     legitimately have only a compiler and no interpreter, or vice
     versa.  See *note Section 3.1.2 (The Evaluation Model): The
     Evaluation Model.

evaluation environment n.
     a run-time environment in which macro expanders and code specified
     by ‘eval-when’ to be evaluated are evaluated.  All evaluations
     initiated by the compiler take place in the evaluation environment.

execute v.t. Trad. (code)
     to perform the imperative actions represented by the code.

execution time n.
     the duration of time that compiled code is being executed.

exhaustive partition n. (of a type)
     a set of pairwise disjoint types that form an exhaustive union.

exhaustive union n. (of a type)
     a set of subtypes of the type, whose union contains all elements of
     that type.

exit point n.
     a point in a control form from which (e.g., ‘block’), through which
     (e.g., ‘unwind-protect’), or to which (e.g., ‘tagbody’) control and
     possibly values can be transferred both actively by using another
     control form and passively through the normal control and data flow
     of evaluation.  “‘catch’ and ‘block’ establish bindings for exit
     points to which ‘throw’ and ‘return-from’, respectively, can
     transfer control and values; ‘tagbody’ establishes a binding for an
     exit point with lexical extent to which ‘go’ can transfer control;
     and ‘unwind-protect’ establishes an exit point through which
     control might be transferred by operators such as ‘throw’,
     ‘return-from’, and ‘go’.”

explicit return n. 
     the act of transferring control (and possibly values) to a block by
     using ‘return-from’ (or ‘return’).

explicit use n. (of a variable V in a form F)
     a reference to V that is directly apparent in the normal semantics
     of F; i.e., that does not expose any undocumented details of the
     macro expansion of the form itself.  References to V exposed by
     expanding subforms of F are, however, considered to be explicit
     uses of V.

exponent marker n.
     a character that is used in the textual notation for a float to
     separate the mantissa from the exponent.  The characters defined as
     exponent markers in the standard readtable are shown in the next
     figure.  For more information, see *note Section 2.1 (Character
     Syntax): Character Syntax.  “The exponent marker ‘d’ in ‘3.0d7’
     indicates that this number is to be represented as a double float.”

     Marker       Meaning
     -----------------------------------------------------------
     ‘D’ or ‘d’   ‘double-float’
     ‘E’ or ‘e’   ‘float’ (see ‘*read-default-float-format*’)
     ‘F’ or ‘f’   ‘single-float’
     ‘L’ or ‘l’   ‘long-float’
     ‘S’ or ‘s’   ‘short-float’

     Figure 26.1: Exponent Markers

export v.t. (a symbol in a package)
     to add the symbol to the list of external symbols of the package.

exported adj. (of a symbol in a package)
     being an external symbol of the package.

expressed adjustability 
     n. (of an array) a generalized boolean that is conceptually (but
     not necessarily actually) associated with the array, representing
     whether the array is expressly adjustable.  See also *note actual
     adjustability: glos-actual adjustability.

expressed array element type n. (of an array)
     the type which is the array element type implied by a type
     declaration for the array, or which is the requested array element
     type at its time of creation, prior to any selection of an upgraded
     array element type.  (Common Lisp does not provide a way of
     detecting this type directly at run time, but an implementation is
     permitted to make assumptions about the array’s contents and the
     operations which may be performed on the array when this type is
     noted during code analysis, even if those assumptions would not be
     valid in general for the upgraded array element type of the
     expressed array element type.)

expressed complex part type n. (of a complex)
     the type which is implied as the complex part type by a type
     declaration for the complex, or which is the requested complex part
     type at its time of creation, prior to any selection of an upgraded
     complex part type.  (Common Lisp does not provide a way of
     detecting this type directly at run time, but an implementation is
     permitted to make assumptions about the operations which may be
     performed on the complex when this type is noted during code
     analysis, even if those assumptions would not be valid in general
     for the upgraded complex part type of the expressed complex part
     type.)

expression n.
     1.  an object, often used to emphasize the use of the object to
     encode or represent information in a specialized format, such as
     program text.  “The second expression in a ‘let’ form is a list of
     bindings.” 2.  the textual notation used to notate an object in a
     source file.  “The expression ‘'sample’ is equivalent to ‘(quote
     sample)’.”

expressly adjustable adj. (of an array)
     being actually adjustable by virtue of an explicit request for this
     characteristic having been made at the time of its creation.  All
     arrays that are expressly adjustable are actually adjustable, but
     not necessarily vice versa.

extended character n.
     a character of type ‘extended-char’: a character that is not a base
     character.

extended function designator 
     n.  a designator for a function; that is, an object that denotes a
     function and that is one of: a function name (denoting the function
     it names in the global environment), or a function (denoting
     itself).  The consequences are undefined if a function name is used
     as an extended function designator but it does not have a global
     definition as a function, or if it is a symbol that has a global
     definition as a macro or a special form.  See also *note function
     designator: glos-function designator.

extended lambda list n.
     a list resembling an ordinary lambda list in form and purpose, but
     offering additional syntax or functionality not available in an
     ordinary lambda list.  “‘defmacro’ uses extended lambda lists.”

extension n.
     a facility in an implementation of Common Lisp  that is not
     specified by this standard.

extent n.
     the interval of time during which a reference to an object, a
     binding, an exit point, a tag, a handler, a restart, or an
     environment is defined.

external file format n.
     an object of implementation-dependent nature which determines one
     of possibly several implementation-dependent ways in which
     characters are encoded externally in a character file.

external file format designator n.
     a designator for an external file format; that is, an object that
     denotes an external file format and that is one of: the symbol
     :default (denoting an implementation-dependent default external
     file format that can accomodate at least the base characters), some
     other object defined by the implementation to be an external file
     format designator (denoting an implementation-defined external file
     format), or some other object defined by the implementation to be
     an external file format (denoting itself).

external symbol n. (of a package)
     a symbol that is part of the ‘external interface’ to the package
     and that are inheritedthat uses the package.  When using the Lisp
     reader, if a package prefix is used, the name of an external symbol
     is separated from the package name by a single package marker while
     the name of an internal symbol is separated from the package name
     by a double package marker; see *note Section 2.3.4 (Symbols as
     Tokens): Symbols as Tokens.

externalizable object n.
     an object that can be used as a literal object in code to be
     processed by the file compiler.

