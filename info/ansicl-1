This is ansicl, produced by makeinfo version 6.7 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: Top,  Next: Credits,  Up: (dir)

ANSI Common Lisp
****************

This is a Texinfo version(1) of the draft ANSI Common Lisp standard.
Some font information has been lost in the conversion, and errors may
have been introduced.  Report discrepancies with the hardcopy version to
Jesper Harder <jesper.harder@gmail.com>.

* Menu:

* Credits::
* Introduction::
* Syntax::
* Evaluation and Compilation::
* Types and Classes::
* Data and Control Flow::
* Iteration::
* Objects::
* Structures::
* Conditions::
* Symbols::
* Packages::
* Numbers::
* Characters::
* Conses::
* Arrays::
* Strings::
* Sequences::
* Hash Tables::
* Filenames::
* Files::
* Streams::
* Printer::
* Reader::
* System Construction::
* Environment::
* Glossary::
* Appendix::
* Index::
* Symbol Index::
* List of Figures::

   ---------- Footnotes ----------

   (1) The converter is available from
<http://purl.org/harder/dpans.html>


File: ansicl,  Node: Credits,  Next: Introduction,  Prev: Top,  Up: Top

Credits
*******

Principal Technical Editors:
----------------------------

Kent M. Pitman         Harlequin, Inc.        1993-present
                       Symbolics, Inc.        1990-1992
Kathy Chapman          Digital Equipment      1987-1989
                       Corporation

Occasional Guest Editors:
-------------------------

Richard P. Gabriel     Lucid, Inc.
Sandra Loosemore       self

Financial Contributors to the Editing Process:
----------------------------------------------

Digital Equipment Corporation
Harlequin, Ltd.  and Harlequin, Inc.
Symbolics, Inc.
Apple, Inc.
Franz, Inc.
Lucid, Inc.

Special thanks to Guy L. Steele Jr.  and Digital Press for producing
‘Common Lisp: The Language’, and for relaxing copyright restrictions
enough to make it possible for that document’s text to provide an early
basis of this work.

Edit and Review History:
------------------------

01-Jan-89   Pitman      Draft of Chapters 5.1 (conditions).
01-May-89   Chapman     Draft of 1.2–1.6.
01-May-89   Gabriel     Rewrite of Chapters 1.1 and 5.1.
01-Jun-89   Loosemore   Review of Chapter 4.2.
01-Jun-89   Pitman      Review of Glossary
15-Jun-89   Gabriel     Rewrite of Glossary
16-Jun-89   Margolin    Comments on Chapters 2.1–2.4 (types, objects).
23-Jun-89   Gabriel     Rewrite of 4.2.
07-Jul-89   Moon        Review of Chapters 4.1, 4.3
12-Jul-89   Gabriel     Revision of 4.2.
15-Jul-89   Pitman      Review of Glossary
18-Jul-89   Gray        Comments on 5.1
25-Jul-89   Gabriel     Revision of Chapters 1.2–1.6, 2.2
26-Jul-89   Gabriel     Rewrite of 5.1
26-Jul-89   Gabriel     Rewrite of 4.1.
27-Jul-89   Pitman      Revision of 5.1
27-Jul-89   Gabriel     Revision of 5.1
28-Jul-89   Chapman     Draft of 2.2, 3.2, 3.3, 5.4
28-Jul-89   Gabriel     Revision of Glossary.
01-Oct-89   Margolin    Review of Dictionary from Jun-89 draft.
20-Jan-91   Pitman      Draft 8.81 (for X3J13 review).  Document
                        X3J13/91-101.
29-Jan-91   Waters      Review of 8.81/Chapter 23 (Printer).
01-Mar-91   Moon        Review of 8.81/Chapter 4 (Evaluation and
                        Compilation).
01-Mar-91   Barrett     Review of 8.81/Chapter 4 (Evaluation and
                        Compilation).
01-Mar-91   Moon        Review of 8.81/Glossary.
13-Mar-90   Wechsler    Review of 8.81/Glossary.
21-Mar-91   Kerns       Review of 8.81/Chapter 1.
26-Apr-91   Margolin    Review of 8.81/Chapters 1–12.
15-May-91   Barrett     Review of 8.81/Chapters 5 (Misc), 11
                        (Conditions).
04-Jun-91   Laddaga     Review of 9.60/Chapter 20 (Pathnames).
10-Jun-91   Pitman      Draft 9.126 (for X3J13 review).  Document
                        X3J13/91-102.
02-Sep-91   Barrett     Review of 9.28/Chapter 4 (Evaluation and
                        Compilation).
02-Sep-91   Barrett     Review of 9.52/Chapter 4 (Evaluation and
                        Compilation).
15-Sep-91   Barrett     Review of 9.126/Chapter 4 (Evaluation and
                        Compilation)
                        and Chapter 7 (Evaluation/Compilation).
                        (some comments not yet merged)
18-Sep-91   Wechsler    Review of 9.126.
21-Sep-91   Barrett     Review of 10.16/Chapter 7
                        (Evaluation/Compilation).
                        (some comments not yet merged)
28-Sep-91   Barrett     Review of 10.95/Chapter 25 (Printer).
                        (some comments not yet merged)
13-Oct-91   Barrett     Review (and help editing) of 10.104/Chapter 4
                        (Evaluation and Compilation)
15-Oct-91   Waters      Review of 10.95/Chapter 25 (Printer).
24-Oct-91   Pitman      Draft 10.156 (for X3J13 review).  Document
                        X3J13/91-103.
04-Nov-91   Moon        Review of 10.156/Chapter 5 (Data and Control
                        Flow)
                        and Chapter 26 (Glossary).
11-Nov-91   Loosemore   Review of 10.156/Chapter 2 (Syntax),
                        Chapter 3 (Evaluation and Compilation),
                        Chapter 5 (Data and Control Flow), and Chapter 8
                        (Structures).
02-Dec-91   Barrett     Review of 10.156/Chapter 4 (Types and Classes),
                        and Chapter 10 (Symbols).
02-Dec-91   Barrett     Review of 10.156/Chapter 3 (Evaluation and
                        Compilation),
                        Chapter 6 (Iteration), Chapter 9 (Conditions),
                        and Chapter 14 (Conses).
                        (some comments not yet merged)
09-Dec-91   Gabriel     Review of 10.156/Chapter 1 (Introduction),
                        Chapter 2 (Syntax), and Chapter 3 (Evaluation
                        and Compilation).
09-Dec-91   Ida         Light review of 10.156/Chapters 1-5.
09-Dec-91   Moon        Review of 10.156/Chapter 3 (Evaluation and
                        Compilation).
                        (some comments not yet merged)
10-Dec-91   Loosemore   Review of 10.156/Chapter 10 (Symbols),
                        Chapter 20 (Files), and Chapter 13 (Characters).
10-Dec-91   Loosemore   Review of 10.156/Chapter 14 (Conses).
                        (some comments not yet merged)
10-Dec-91   Laubsch     Review of 10.156/Chapters 1 (Introduction),
                        Chapter 2 (Syntax), Chapter 3 (Evaluation and
                        Compilation),
                        Chapter 4 (Types and Classes), Chapter 5 (Data
                        and Control Flow),
                        Chapter 7 (Objects), Chapter 11 (Packages),
                        Chapter 19 (Filenames), and Chapter 21
                        (Streams).
18-Dec-91   Margolin    Review of 10.156/Chapter 18 (Hash Tables).
04-Jan-92   White       Review of 10.156/Chapter 6 (Iteration),
                        Chapter 11 (Packages), Chapter 18 (Hash Tables),
                        and Chapter 23 (Reader).
04-Jan-92   White       Review of 10.156/Chapter 26 (Glossary).
                        (some comments not yet merged)
04-Jan-92   Barrett     Review of 10.156/Chapter 18 (Hash Tables) and
                        Chapter 16 (Strings).
04-Jan-92   Barrett     Review of 10.156/Chapter 15 (Arrays) and Chapter
                        21 (Streams).
                        (some comments not yet merged)
06-Jan-92   Loosemore   Review of 10.156/Chapter 16 (Strings),
                        Chapter 17 (Sequences), and Chapter 25
                        (Environment).
06-Jan-92   Loosemore   Review of 10.156/Chapter 21 (Streams) and
                        Chapter 23 (Reader).
                        (some comments not yet merged)
06-Jan-92   Margolin    Review of 10.156/Chapter 2 (Syntax).
07-Jan-92   Margolin    Review of 10.156/Chapter 4 (Types and Classes).
03-Feb-92   Aspinall    Review of 10.156/Chapter 12 (Numbers).
16-Feb-92   Pitman      Draft 11.82 (for X3J13 letter ballot).  Document
                        X3J13/92-101.
16-Mar-92   Loosemore   Review of 11.82/Chapter 1, 3, 4, 5, 7, 8, 9, 10,
                        11, 12, 18, 22, 23, 24, 25, and 26.
16-Feb-92   Pitman      Draft 12.24 (for X3 consideration).  Document
                        X3J13/92-102.
09-Sep-92   Samson      Public Review Comments (#1).  Documents
                        X3J13/92-1001 to 92-1003.
22-Oct-92   Rose, Yen   Public Review Comments (#2).  Documents
                        X3J13/92-1101 to 92-1103.
23-Oct-92   Staley      Public Review Comments (#3).  Documents
                        X3J13/92-1201 to 92-1204.
09-Nov-92   Barrett     Public Review Comments (#4).  Documents
                        X3J13/92-3101 to 92-3110.
11-Nov-92   Moon        Public Review Comments (#5).  Documents
                        X3J13/92-3201 to 92-3248.
17-Nov-92   Loosemore   Public Review Comments (#6).  Documents
                        X3J13/92-1301 to 92-1335.
23-Nov-92   Margolin    Public Review Comments (#7).  Documents
                        X3J13/92-1401 to 92-1419.
23-Nov-92   Withington  Public Review Comments (#8a).  Documents
                        X3J13/92-1501 to 92-1512.
23-Nov-92   Feinberg    Public Review Comments (#8b).  Documents
                        X3J13/92-1601 to 92-1603.
23-Nov-92   Wechsler    Public Review Comments (#8c).  Documents
                        X3J13/92-1701 to 92-1703.
23-Nov-92   Moore       Public Review Comments (#9).  Documents
                        X3J13/92-1801 to 92-1802.
23-Nov-92   Flanagan    Public Review Comments (#10).  Documents
                        X3J13/92-1901 to 92-1910.
23-Nov-92   Dalton      Public Review Comments (#11).  Documents
                        X3J13/92-2001 to 92-2012.
23-Nov-92   Gallagher   Public Review Comments (#12).  Documents
                        X3J13/92-2101 to 92-2103.
23-Nov-92   Norvig      Public Review Comments (#13).  Documents
                        X3J13/92-2201 to 92-2208.
24-Nov-92   Robertson   Public Review Comments (#14).  Document
                        X3J13/92-2301.
23-Nov-92   Kawabe      Public Review Comments (#15).  Documents
                        X3J13/92-2401 to 92-2403.
23-Nov-92   Barrett     Public Review Comments (#16).  Documents
                        X3J13/92-2511 to X3J13/92-2531.
23-Nov-92   Wertheimer  Public Review Comments (#17).  Document
                        X3J13/92-2601.
24-Nov-92   Pitman      Public Review Comments (#18).  Documents
                        X3J13/92-2701 to 92-2742.
24-Nov-92   Mato Mira   Public Review Comments (#19).  Documents
                        X3J13/92-2801 to 92-2805.
24-Nov-92   Philpot     Public Review Comments (#20).  Document
                        X3J13/92-2901.
23-Nov-92   Cerys       Public Review Comments (#21).  Document
                        X3J13/92-3001.
30-Aug-93   Pitman      Draft 13.65 (for X3J13 consideration).  Document
                        X3J13/93-101.
04-Oct-93   X3J13       Minor fixes to Draft 13.65 before sending to X3.
05-Oct-93   Pitman      Draft 14.10 (for X3 consideration).  Document
                        X3J13/93-102.
08-Nov-93   Dalton      “reply to reply to pr comments”.  Document
                        X3J13/94-311.
04-Apr-94   Boyer,
            Kaufmann,
            Moore       Public Review Comments (#1).  Document
                        X3J13/94-305.
05-Apr-94   Pitman      Public Review Comments (#2).  Document
                        X3J13/94-306.
14-Mar-94   Schulenburg Public Review Comments (#3).  Document
                        X3J13/94-307.
04-Apr-94   Shepard     Late commentary.  Document X3J13/94-309.
05-May-94   X3J13       Editorial-only changes to Draft 14.10 in
                        response to comments.
10-May-94   Pitman      Draft 15.17R (for X3 consideration).  Document
                        X3J13/94-101R.

The following lists of information are almost certainly incomplete, but
it was felt that it was better to risk publishing incomplete information
than to fail to acknowledge important contributions by the many people
and organizations who have contributed to this effort.

Mention here of any individual or organization does not imply
endorsement of this document by that individual or organization.

Ad Hoc Group Chairs:
--------------------

Charter                              Ennis, Susan P.
Cleanup                              Masinter, Larry
                                     Fahlman, Scott
Compiler                             Haflich, Steve
                                     Loosemore, Sandra
Conditions                           Pitman, Kent M.
Editorial                            Chapman, Kathy
Graphics & Windows                   Douglas Rand
Iteration                            White, JonL
Lisp
Macros                               Haflich, Steve
                                     Pitman, Kent M.
Objects                              Bobrow, Daniel G.
Presentation of Standard             Brown, Gary
Pretty Printer                       Waters, Richard C.
Public Review                        Ida, Masayuki
Types & Declarations                 Scherlis, William
Validation                           Berman, Richard
                                     Balzer, Bob
                                     

Major Administrative Contributions:
-----------------------------------

Steele, Guy L., Jr.                  Eiron, Hanoch
Zubkoff, Jan L.                      Haflich, Steve
Gabriel, Richard P.                  Ida, Masayuki
Masinter, Larry                      Loeffler, David D.
Loosemore, Sandra                    Tyson, Mabry
Pitman, Kent M.                      Whittemore, Susan
Barrett, Kim                         Woodyatt, Anne
                                     

Major Technical Contributions:
------------------------------

Loosemore, Sandra
Bobrow, Daniel G.        Margolin, Barry
Daniels, Andy            Moon, David A.
DeMichiel, Linda G.      Pitman, Kent M.
Dussud, Patrick H.       Perdue, Crispin
Gabriel, Richard P.      Steele, Guy L., Jr.
Ida, Masayuki            Waters, Richard C.
Kiczales, Gregor         White, JonL              

Participating Companies and Organizations:
------------------------------------------

LMI
AI Architects                        Loosemore, Sandra
Amoco Production Co.                 Lucid, Inc.
Aoyama Gakuin University             MCC
Apple Computer                       MIT
Barrett, Kim                         MITRE Corporation
Boeing Advanced Technology Center    MSC
Carnegie-Mellon University           NASA Ames Research Center
Chestnut Software                    Nihon Symbolics
Computer Sciences                    National Bureau of Standards
CONTEL                               Prime Computer
Digital Equipment Corporation        Siemens
Evans & Sutherland                   Southern Illinois University
Encore                               Sperry
Franz, Inc.                          SRI
Gigamos                              Sun Microsystems
GMD                                  Symbolics
Gold Hill                            Tektronix
Greenblatt, Richard                  Texas Instruments
Grumman Data Systems Corporation     Thinking Machines Corporation
Harlequin, Ltd.                      Unisys
Hewlett-Packard                      University of Bath
Honeywell                            University of Edinburgh
IBM                                  University of Utah
Integrated Inference Machines        US Army
International LISP Associates        USC/ISI
Johnson Controls                     Xerox
                                     

Individual Participants:
------------------------

Arbaugh, Bill            Hornig, Charles          Philipp, Christopher
Balzer, Bob              Ida, Masayuki            Pierson, Dan
Barrett, Kim             Keene, Sonya             Pitman, Kent M.
Bartley, David           Keller, Shaun            Raghavan, B.
Beckerle, Mike           Kempf, James             Rand, Douglas
Beiser, Paul             Kerns, Robert W.         Rininger, Jeff
Benson, Eric             Kiczales, Gregor         Rosenking, Jeff
Berman, Richard          Kolb, Dieter             Scherlis, William
Bobrow, Daniel G.        Koschmann, Timothy       Shiota, Eiji
Boelk, Mary              Kosinski, Paul           Sizer, Andy
Brittain, Skona          Larson, Aaron            Slater, David
Brown, Gary              Latto, Andy              Sodan, Angela
Chailloux, Jerome        Laubsch, Joachim         Soley, Richard
Chapman, Kathy           Layer, Kevin             St.  Clair, Bill
Clinger, Will            Linden, Thom             Stanhope, Philip
Coffee, Peter C.         Loeffler, David D.       Steele, Guy L., Jr.
Cugini, John             Loosemore, Sandra        Tucker, Paul
Curtis, Pavel            Magataca, Mituhiro       Turba, Thomas
Dabrowski, Christopher   Margolin, Barry          Unietis, Dave
Daessler, Klaus          Masinter, Larry          van Roggen, Walter
Dalton, Jeff             Mathis, Robert           van Roggen, Walter
Daniels, Andy            Matthews, Dave           Waldrum, Ellen
DeMichiel, Linda G.      McCarthy, John           Waters, Richard C.
Duggan, Jerry            Mikelsons, Martin        Wechsler, Allan
Dussud, Patrick H.       Moon, David A.           Wegman, Mark
Ennis, Susan P.          Moore, Timothy           Weinreb, Daniel
Fahlman, Scott           Nicoud, Stephen          White, JonL
Gabriel, Richard P.      Nilsson, Jarl            Wieland, Alexis
Giansiracusa, Bob        O’Dell, Jim              Withington, P. Tucker
Gray, David              Ohlander, Ron            Wright, Whitman
Greenblatt, Richard      Padget, Julian           York, Bill
Hadden, George D.        Palter, Gary             Zacharias, Gail
Haflich, Steve           Peck, Jeff               Zubkoff, Jan L.
Harris, Richard M.       Pellegrino, Bob          


File: ansicl,  Node: Introduction,  Next: Syntax,  Prev: Credits,  Up: Top

1 Introduction
**************

* Menu:

* Scope; Purpose; and History::
* Organization of the Document::
* Referenced Publications::
* Definitions::
* Conformance::
* Language Extensions::
* Language Subsets::
* Deprecated Language Features::
* Symbols in the COMMON-LISP Package::


File: ansicl,  Node: Scope; Purpose; and History,  Next: Organization of the Document,  Up: Introduction

1.1 Scope, Purpose, and History
===============================

* Menu:

* Scope and Purpose::
* History::


File: ansicl,  Node: Scope and Purpose,  Next: History,  Up: Scope; Purpose; and History

1.1.1 Scope and Purpose
-----------------------

The specification set forth in this document is designed to promote the
portability of Common Lisp programs among a variety of data processing
systems.  It is a language specification aimed at an audience of
implementors and knowledgeable programmers.  It is neither a tutorial
nor an implementation guide.


File: ansicl,  Node: History,  Prev: Scope and Purpose,  Up: Scope; Purpose; and History

1.1.2 History
-------------

Lisp is a family of languages with a long history.  Early key ideas in
Lisp were developed by John McCarthy during the 1956 Dartmouth Summer
Research Project on Artificial Intelligence.  McCarthy’s motivation was
to develop an algebraic list processing language for artificial
intelligence work.  Implementation efforts for early dialects of Lisp
were undertaken on the IBM 704, the IBM 7090, the Digital Equipment
Corporation (DEC) PDP-1, the DEC PDP-6, and the PDP-10.  The primary
dialect of Lisp between 1960 and 1965 was Lisp 1.5.  By the early 1970’s
there were two predominant dialects of Lisp, both arising from these
early efforts: MacLisp and Interlisp.  For further information about
very early Lisp dialects, see ‘The Anatomy of Lisp’ or ‘Lisp 1.5
Programmer’s Manual’.

MacLisp improved on the Lisp 1.5 notion of special variables and error
handling.  MacLisp also introduced the concept of functions that could
take a variable number of arguments, macros, arrays, non-local dynamic
exits, fast arithmetic, the first good Lisp compiler, and an emphasis on
execution speed.  By the end of the 1970’s, MacLisp was in use at over
50 sites.  For further information about Maclisp, see ‘Maclisp Reference
Manual, Revision 0’ or ‘The Revised Maclisp Manual’.

Interlisp introduced many ideas into Lisp programming environments and
methodology.  One of the Interlisp ideas that influenced Common Lisp was
an iteration construct implemented by Warren Teitelman that inspired the
‘loop’ macro used both on the Lisp Machines and in MacLisp, and now in
Common Lisp.  For further information about Interlisp, see ‘Interlisp
Reference Manual’.

Although the first implementations of Lisp were on the IBM 704 and the
IBM 7090, later work focussed on the DEC PDP-6 and, later, PDP-10
computers, the latter being the mainstay of Lisp and artificial
intelligence work at such places as Massachusetts Institute of
Technology (MIT), Stanford University, and Carnegie Mellon University
(CMU) from the mid-1960’s through much of the 1970’s.  The PDP-10
computer and its predecessor the PDP-6 computer were, by design,
especially well-suited to Lisp because they had 36-bit words and 18-bit
addresses.  This architecture allowed a cons cell to be stored in one
word; single instructions could extract the car and cdr parts.  The
PDP-6 and PDP-10 had fast, powerful stack instructions that enabled fast
function calling.  But the limitations of the PDP-10 were evident by
1973: it supported a small number of researchers using Lisp, and the
small, 18-bit address space (2^18 = 262,144 words) limited the size of a
single program.  One response to the address space problem was the Lisp
Machine, a special-purpose computer designed to run Lisp programs.  The
other response was to use general-purpose computers with address spaces
larger than 18 bits, such as the DEC VAX and the S-1 Mark IIA. For
further information about S-1 Common Lisp, see “S-1 Common Lisp
Implementation.”

The Lisp machine concept was developed in the late 1960’s.  In the early
1970’s, Peter Deutsch, working with Daniel Bobrow, implemented a Lisp on
the Alto, a single-user minicomputer, using microcode to interpret a
byte-code implementation language.  Shortly thereafter, Richard
Greenblatt began work on a different hardware and instruction set design
at MIT. Although the Alto was not a total success as a Lisp machine, a
dialect of Interlisp known as Interlisp-D became available on the
D-series machines manufactured by Xerox—the Dorado, Dandelion,
Dandetiger, and Dove (or Daybreak).  An upward-compatible extension of
MacLisp called Lisp Machine Lisp became available on the early MIT Lisp
Machines.  Commercial Lisp machines from Xerox, Lisp Machines (LMI), and
Symbolics were on the market by 1981.  For further information about
Lisp Machine Lisp, see ‘Lisp Machine Manual’.

During the late 1970’s, Lisp Machine Lisp began to expand towards a much
fuller language.  Sophisticated lambda lists, ‘setf’, multiple values,
and structures like those in Common Lisp are the results of early
experimentation with programming styles by the Lisp Machine group.  Jonl
White and others migrated these features to MacLisp.  Around 1980, Scott
Fahlman and others at CMU began work on a Lisp to run on the Scientific
Personal Integrated Computing Environment (SPICE) workstation.  One of
the goals of the project was to design a simpler dialect than Lisp
Machine Lisp.

The Macsyma group at MIT began a project during the late 1970’s called
the New Implementation of Lisp (NIL) for the VAX, which was headed by
White.  One of the stated goals of the NIL project was to fix many of
the historic, but annoying, problems with Lisp while retaining
significant compatibility with MacLisp.  At about the same time, a
research group at Stanford University and Lawrence Livermore National
Laboratory headed by Richard P. Gabriel began the design of a Lisp to
run on the S-1 Mark IIA supercomputer.  S-1 Lisp, never completely
functional, was the test bed for adapting advanced compiler techniques
to Lisp implementation.  Eventually the S-1 and NIL groups collaborated.
For further information about the NIL project, see “NIL—A Perspective.”

The first effort towards Lisp standardization was made in 1969, when
Anthony Hearn and Martin Griss at the University of Utah defined
Standard Lisp—a subset of Lisp 1.5 and other dialects—to transport
REDUCE, a symbolic algebra system.  During the 1970’s, the Utah group
implemented first a retargetable optimizing compiler for Standard Lisp,
and then an extended implementation known as Portable Standard Lisp
(PSL). By the mid 1980’s, PSL ran on about a dozen kinds of computers.
For further information about Standard Lisp, see “Standard LISP Report.”

PSL and Franz Lisp—a MacLisp-like dialect for Unix machines—were the
first examples of widely available Lisp dialects on multiple hardware
platforms.

One of the most important developments in Lisp occurred during the
second half of the 1970’s: Scheme.  Scheme, designed by Gerald J.
Sussman and Guy L. Steele Jr., is a simple dialect of Lisp whose design
brought to Lisp some of the ideas from programming language semantics
developed in the 1960’s.  Sussman was one of the prime innovators behind
many other advances in Lisp technology from the late 1960’s through the
1970’s.  The major contributions of Scheme were lexical scoping, lexical
closures, first-class continuations, and simplified syntax (no
separation of value cells and function cells).  Some of these
contributions made a large impact on the design of Common Lisp.  For
further information about Scheme, see ‘IEEE Standard for the Scheme
Programming Language’ or “Revised³ Report on the Algorithmic Language
Scheme.”

In the late 1970’s object-oriented programming concepts started to make
a strong impact on Lisp.  At MIT, certain ideas from Smalltalk made
their way into several widely used programming systems.  Flavors, an
object-oriented programming system with multiple inheritance, was
developed at MIT for the Lisp machine community by Howard Cannon and
others.  At Xerox, the experience with Smalltalk and Knowledge
Representation Language (KRL) led to the development of Lisp Object
Oriented Programming System (LOOPS) and later Common LOOPS. For further
information on Smalltalk, see ‘Smalltalk-80: The Language and its
Implementation’.  For further information on Flavors, see ‘Flavors: A
Non-Hierarchical Approach to Object-Oriented Programming’.

These systems influenced the design of the Common Lisp Object System
(CLOS). CLOS was developed specifically for this standardization effort,
and was separately written up in “Common Lisp Object System
Specification.” However, minor details of its design have changed
slightly since that publication, and that paper should not be taken as
an authoritative reference to the semantics of the object system as
described in this document.

In 1980 Symbolics and LMI were developing Lisp Machine Lisp;
stock-hardware implementation groups were developing NIL, Franz Lisp,
and PSL; Xerox was developing Interlisp; and the SPICE project at CMU
was developing a MacLisp-like dialect of Lisp called SpiceLisp.

In April 1981, after a DARPA-sponsored meeting concerning the splintered
Lisp community, Symbolics, the SPICE project, the NIL project, and the
S-1 Lisp project joined together to define Common Lisp.  Initially
spearheaded by White and Gabriel, the driving force behind this
grassroots effort was provided by Fahlman, Daniel Weinreb, David Moon,
Steele, and Gabriel.  Common Lisp was designed as a description of a
family of languages.  The primary influences on Common Lisp were Lisp
Machine Lisp, MacLisp, NIL, S-1 Lisp, Spice Lisp, and Scheme.  ‘Common
Lisp: The Language’ is a description of that design.  Its semantics were
intentionally underspecified in places where it was felt that a tight
specification would overly constrain Common Lisp research and use.

In 1986 X3J13 was formed as a technical working group to produce a draft
for an ANSI Common Lisp standard.  Because of the acceptance of Common
Lisp, the goals of this group differed from those of the original
designers.  These new goals included stricter standardization for
portability, an object-oriented programming system, a condition system,
iteration facilities, and a way to handle large character sets.  To
accommodate those goals, a new language specification, this document,
was developed.


File: ansicl,  Node: Organization of the Document,  Next: Referenced Publications,  Prev: Scope; Purpose; and History,  Up: Introduction

1.2 Organization of the Document
================================

This is a reference document, not a tutorial document.  Where possible
and convenient, the order of presentation has been chosen so that the
more primitive topics precede those that build upon them; however,
linear readability has not been a priority.

This document is divided into chapters by topic.  Any given chapter
might contain conceptual material, dictionary entries, or both.

Defined names within the dictionary portion of a chapter are grouped in
a way that brings related topics into physical proximity.  Many such
groupings were possible, and no deep significance should be inferred
from the particular grouping that was chosen.  To see defined names
grouped alphabetically, consult the index.  For a complete list of
defined names, see *note Section 1.9 (Symbols in the COMMON-LISP
Package): Symbols in the COMMON-LISP Package.

In order to compensate for the sometimes-unordered portions of this
document, a glossary has been provided; see *note Chapter 26 (Glossary):
Glossary.  The glossary provides connectivity by providing easy access
to definitions of terms, and in some cases by providing examples or
cross references to additional conceptual material.

For information about notational conventions used in this document, see
*note Section 1.4 (Definitions): Definitions.

For information about conformance, see *note Section 1.5 (Conformance):
Conformance.

For information about extensions and subsets, see *note Section 1.6
(Language Extensions): Language Extensions. and *note Section 1.7
(Language Subsets): Language Subsets.

For information about how programs in the language are parsed by the
Lisp reader, see *note Chapter 2 (Syntax): Syntax.

For information about how programs in the language are compiled and
executed, see *note Chapter 3 (Evaluation and Compilation): Evaluation
and Compilation.

For information about data types, see *note Chapter 4 (Types and
Classes): Types and Classes.  Not all types and classes are defined in
this chapter; many are defined in chapter corresponding to their
topic–for example, the numeric types are defined in *note Chapter 12
(Numbers): Numbers.  For a complete list of standardized types, see
*note Figure 4.2: StandardizedAtomicTypeSpecs.

For information about general purpose control and data flow, see *note
Chapter 5 (Data and Control Flow): Data and Control Flow. or *note
Chapter 6 (Iteration): Iteration.


File: ansicl,  Node: Referenced Publications,  Next: Definitions,  Prev: Organization of the Document,  Up: Introduction

1.3 Referenced Publications
===========================

   • ‘The Anatomy of Lisp’, John Allen, McGraw-Hill, Inc., 1978.

   • ‘The Art of Computer Programming, Volume 3’, Donald E. Knuth,
     Addison-Wesley Company (Reading, MA), 1973.

   • ‘The Art of the Metaobject Protocol’, Kiczales et al., MIT Press
     (Cambridge, MA), 1991.

   • “Common Lisp Object System Specification,” D. Bobrow, L. DiMichiel,
     R.P. Gabriel, S. Keene, G. Kiczales, D. Moon, SIGPLAN Notices V23,
     September, 1988.

   • ‘Common Lisp: The Language’, Guy L. Steele Jr., Digital Press
     (Burlington, MA), 1984.

   • ‘Common Lisp: The Language Second Edition’, Guy L. Steele Jr.,
     Digital Press (Bedford, MA), 1990.

   • ‘Exceptional Situations in Lisp’, Kent M. Pitman, Proceedings of
     the First European Conference on the Practical Application of LISP
     (EUROPAL ’90), Churchill College, Cambridge, England, March 27-29,
     1990.

   • ‘Flavors: A Non-Hierarchical Approach to Object-Oriented
     Programming’, Howard I. Cannon, 1982.

   • ‘IEEE Standard for Binary Floating-Point Arithmetic’, ANSI/IEEE Std
     754-1985, Institute of Electrical and Electronics Engineers, Inc.
     (New York), 1985.

   • ‘IEEE Standard for the Scheme Programming Language’, IEEE Std
     1178-1990, Institute of Electrical and Electronic Engineers, Inc.
     (New York), 1991.

   • ‘Interlisp Reference Manual’, Third Revision, Teitelman, Warren, et
     al, Xerox Palo Alto Research Center (Palo Alto, CA), 1978.

   • ‘ISO 6937/2’, Information processing—Coded character sets for text
     communication—Part 2: Latin alphabetic and non-alphabetic graphic
     characters, ISO, 1983.

   • ‘Lisp 1.5 Programmer’s Manual’, John McCarthy, MIT Press
     (Cambridge, MA), August, 1962.

   • ‘Lisp Machine Manual’, D.L. Weinreb and D.A. Moon, Artificial
     Intelligence Laboratory, MIT (Cambridge, MA), July, 1981.

   • ‘Maclisp Reference Manual, Revision 0’, David A. Moon, Project MAC
     (Laboratory for Computer Science), MIT (Cambridge, MA), March,
     1974.

   • “NIL—A Perspective,” JonL White, Macsyma User’s Conference, 1979.

   • ‘Performance and Evaluation of Lisp Programs’, Richard P. Gabriel,
     MIT Press (Cambridge, MA), 1985.

   • “Principal Values and Branch Cuts in Complex APL,” Paul Penfield
     Jr., APL 81 Conference Proceedings, ACM SIGAPL (San Francisco,
     September 1981), 248-256.  Proceedings published as APL Quote Quad
     12, 1 (September 1981).

   • ‘The Revised Maclisp Manual’, Kent M. Pitman, Technical Report 295,
     Laboratory for Computer Science, MIT (Cambridge, MA), May 1983.

   • “Revised³ Report on the Algorithmic Language Scheme,” Jonathan Rees
     and William Clinger (editors), SIGPLAN Notices V21, #12, December,
     1986.

   • “S-1 Common Lisp Implementation,” R.A. Brooks, R.P. Gabriel, and
     G.L. Steele, Conference Record of the 1982 ACM Symposium on Lisp
     and Functional Programming, 108-113, 1982.

   • ‘Smalltalk-80: The Language and its Implementation’, A. Goldberg
     and D. Robson, Addison-Wesley, 1983.

   • “Standard LISP Report,” J.B. Marti, A.C. Hearn, M.L. Griss, and C.
     Griss, SIGPLAN Notices V14, #10, October, 1979.

   • ‘Webster’s Third New International Dictionary the English Language,
     Unabridged’, Merriam Webster (Springfield, MA), 1986.

   • ‘XP: A Common Lisp Pretty Printing System’, R.C. Waters, Memo
     1102a, Artificial Intelligence Laboratory, MIT (Cambridge, MA),
     September 1989.


File: ansicl,  Node: Definitions,  Next: Conformance,  Prev: Referenced Publications,  Up: Introduction

1.4 Definitions
===============

This section contains notational conventions and definitions of terms
used in this manual.

* Menu:

* Notational Conventions::
* Error Terminology::
* Sections Not Formally Part Of This Standard::
* Interpreting Dictionary Entries::


File: ansicl,  Node: Notational Conventions,  Next: Error Terminology,  Up: Definitions

1.4.1 Notational Conventions
----------------------------

The following notational conventions are used throughout this document.

1.4.1.1 Font Key
................

Fonts are used in this document to convey information.

name

     Denotes a formal term whose meaning is defined in the Glossary.
     When this font is used, the Glossary definition takes precedence
     over normal English usage.

     Sometimes a glossary term appears subscripted, as in
     “whitespaceSuch a notation selects one particular Glossary
     definition out of several, in this case the second.  The subscript
     notation for Glossary terms is generally used where the context
     might be insufficient to disambiguate among the available
     definitions.

     “name”

     Denotes the introduction of a formal term locally to the current
     text.  There is still a corresponding glossary entry, and is
     formally equivalent to a use of “name,” but the hope is that making
     such uses conspicuous will save the reader a trip to the glossary
     in some cases.

name

     Denotes a symbol in the ‘COMMON-LISP’ package.  For information
     about case conventions, see *note Section 1.4.1.4.1 (Case in
     Symbols): CaseInSymbols.

‘name’

     Denotes a sample name or piece of code that a programmer might
     write in Common Lisp.

     This font is also used for certain standardized names that are not
     names of external symbols of the ‘COMMON-LISP’ package, such as
     keywordspackage names, and loop keywords.

NAME

     Denotes the name of a parameter or value.

     In some situations the notation “«NAME»” (i.e., the same font, but
     with surrounding “angle brackets”) is used instead in order to
     provide better visual separation from surrounding characters.
     These “angle brackets” are metasyntactic, and never actually appear
     in program input or output.

1.4.1.2 Modified BNF Syntax
...........................

This specification uses an extended Backus Normal Form (BNF) to describe
the syntax of Common Lisp macro forms and special forms.  This section
discusses the syntax of BNF expressions.

1.4.1.2.1 Splicing in Modified BNF Syntax
.........................................

The primary extension used is the following:

     〚O〛

An expression of this form appears whenever a list of elements is to be
spliced into a larger structure and the elements can appear in any
order.  The symbol O represents a description of the syntax of some
number of syntactic elements to be spliced; that description must be of
the form

     O

where each Othe form S* or of the form S¹.  The expression 〚O〛 means
that a list of the form

     (O

is spliced into the enclosing expression, such that if n ≠ m and 1≤ n,m≤
j, then either Oor Owhere for some 1≤ k ≤ n, OFurthermore, for each
Othat element is required to appear somewhere in the list to be spliced.

For example, the expression

‘(x 〚A | B* | C〛 y)’

means that at most one ‘A’, any number of ‘B’’s, and at most one ‘C’ can
occur in any order.  It is a description of any of these:

      (x y)
      (x B A C y)
      (x A B B B B B C y)
      (x C B A B B B y)

but not any of these:

      (x B B A A C C y)
      (x C B C y)

In the first case, both ‘A’ and ‘C’ appear too often, and in the second
case ‘C’ appears too often.

The notation 〚Oadds the additional restriction that at least one item
from among the possible choices must be used.  For example:

‘(x 〚A | B* | C〛+ y)’

means that at most one ‘A’, any number of ‘B’’s, and at most one ‘C’ can
occur in any order, but that in any case at least one of these options
must be selected.  It is a description of any of these:

      (x B y)
      (x B A C y)
      (x A B B B B B C y)
      (x C B A B B B y)

but not any of these:

      (x y)
      (x B B A A C C y)
      (x C B C y)

In the first case, no item was used; in the second case, both ‘A’ and
‘C’ appear too often; and in the third case ‘C’ appears too often.

Also, the expression:

‘(x 〚A¹ | B¹ | C〛 y)’

can generate exactly these and no others:

      (x A B C y)
      (x A C B y)
      (x A B y)
      (x B A C y)
      (x B C A y)
      (x B A y)
      (x C A B y)
      (x C B A y)

1.4.1.2.2 Indirection in Modified BNF Syntax
............................................

An indirection extension is introduced in order to make this new syntax
more readable:

     ↓O

If O is a non-terminal symbol, the right-hand side of its definition is
substituted for the entire expression ↓O. For example, the following BNF
is equivalent to the BNF in the previous example:

‘(x 〚↓O〛 y)’

O::=
     ‘A’ | ‘B’* | ‘C’

1.4.1.2.3 Additional Uses for Indirect Definitions in Modified BNF Syntax
.........................................................................

In some cases, an auxiliary definition in the BNF might appear to be
unused within the BNF, but might still be useful elsewhere.  For
example, consider the following definitions:

 -- Macro: case keyform {↓normal-clause}* [↓otherwise-clause] →
          {result}*
 -- Macro: ccase keyplace {↓normal-clause}* → {result}*
 -- Macro: ecase keyform {↓normal-clause}* → {result}*

NORMAL-CLAUSE::=
     (keys {form}*)
OTHERWISE-CLAUSE::=
     ({otherwise | t} {form}*)
CLAUSE::=
     normal-clause | otherwise-clause

Here the term “CLAUSE” might appear to be “dead” in that it is not used
in the BNF. However, the purpose of the BNF is not just to guide
parsing, but also to define useful terms for reference in the
descriptive text which follows.  As such, the term “CLAUSE” might appear
in text that follows, as shorthand for “NORMAL-CLAUSE or
OTHERWISE-CLAUSE.”

1.4.1.3 Special Symbols
.......................

The special symbols described here are used as a notational convenience
within this document, and are part of neither the Common Lisp language
nor its environment.

→

     This indicates evaluation.  For example:

           (+ 4 5) → 9

     This means that the result of evaluating the form ‘(+ 4 5)’ is ‘9’.

     If a form returns multiple values, those values might be shown
     separated by spaces, line breaks, or commas.  For example:

           (truncate 7 5)
          → 1 2
           (truncate 7 5)
          → 1
             2
           (truncate 7 5)
          → 1, 2

     Each of the above three examples is equivalent, and specifies that
     ‘(truncate 7 5)’ returns two values, which are ‘1’ and ‘2’.

     Some conforming implementations actually type an arrow (or some
     other indicator) before showing return values, while others do not.

or→

     The notation “or→” is used to denote one of several possible
     alternate results.  The example

           (char-name #\a)
          → NIL
          or→ "LOWERCASE-a"
          or→ "Small-A"
          or→ "LA01"

     indicates that ‘nil’, ‘"LOWERCASE-a"’, ‘"Small-A"’, ‘"LA01"’ are
     among the possible results of ‘(char-name #\a)’—each with equal
     preference.  Unless explicitly specified otherwise, it should not
     be assumed that the set of possible results shown is exhaustive.
     Formally, the above example is equivalent to

           (char-name #\a) → implementation-dependent

     but it is intended to provide additional information to illustrate
     some of the ways in which it is permitted for implementations to
     diverge.

not→

     The notation “not→” is used to denote a result which is not
     possible.  This might be used, for example, in order to emphasize a
     situation where some anticipated misconception might lead the
     reader to falsely believe that the result might be possible.  For
     example,

           (function-lambda-expression
              (funcall #'(lambda (x) #'(lambda () x)) nil))
          → NIL, true, NIL
          or→ (LAMBDA () X), true, NIL
          not→ NIL, false, NIL
          not→ (LAMBDA () X), false, NIL

≡

     This indicates code equivalence.  For example:

           (gcd x (gcd y z)) ≡ (gcd (gcd x y) z)

     This means that the results and observable side-effects of
     evaluating the form ‘(gcd x (gcd y z))’  are always the same as the
     results and observable side-effects of ‘(gcd (gcd x y) z)’  for any
     ‘x’, ‘y’, and ‘z’.

▷

     Common Lisp specifies input and output with respect to a
     non-interactive stream model.  The specific details of how
     interactive input and output are mapped onto that non-interactive
     model are implementation-defined.

     For example, conforming implementations are permitted to differ in
     issues of how interactive input is terminated.  For example, the
     function ‘read’ terminates when the final delimiter is typed on a
     non-interactive stream.  In some implementations, an interactive
     call to ‘read’ returns as soon as the final delimiter is typed,
     even if that delimiter is not a newline.  In other implementations,
     a final newline is always required.  In still other
     implementations, there might be a command which “activates” a
     buffer full of input without the command itself being visible on
     the program’s input stream.

     In the examples in this document, the notation “▷” precedes lines
     where interactive input and output occurs.  Within such a scenario,
     “‘this notation’” notates user input.

     For example, the notation

           (+ 1 (print (+ (sqrt (read)) (sqrt (read)))))
          ▷ 9 16
          ▷ 7
          → 8

     shows an interaction in which “‘(+ 1 (print (+ (sqrt (read)) (sqrt
     (read)))))’” is a form to be evaluated, “‘9 16 ’” is interactive
     input, “‘7’” is interactive output, and “‘8’” is the value yielded
     from the evaluation.

     The use of this notation is intended to disguise small differences
     in interactive input and output behavior between implementations.

     Sometimes, the non-interactive stream model calls for a newline.
     How that newline character is interactively entered is an
     implementation-defined detail of the user interface, but in that
     case, either the notation “<Newline>” or “↩” might be used.

           (progn (format t "~&Who? ") (read-line))
          ▷ Who? Fred, Mary, and Sally↩
          → "Fred, Mary, and Sally", false

1.4.1.4 Objects with Multiple Notations
.......................................

Some objects in Common Lisp can be notated in more than one way.  In
such situations, the choice of which notation to use is technically
arbitrary, but conventions may exist which convey a “point of view” or
“sense of intent.”

1.4.1.4.1 Case in Symbols
.........................

While case is significant in the process of interning a symbol, the Lisp
reader, by default, attempts to canonicalize the case of a symbol prior
to interning; see *note Section 23.1.2 (Effect of Readtable Case on the
Lisp Reader): Effect of Readtable Case on the Lisp Reader.  As such,
case in symbols is not, by default, significant.  Throughout this
document, except as explicitly noted otherwise, the case in which a
symbol appears is not significant; that is, ‘HELLO’, ‘Hello’, ‘hElLo’,
and ‘hello’ are all equivalent ways to denote a symbol whose name is
‘"HELLO"’.

The characters backslash and vertical-bar are used to explicitly quote
the case and other parsing-related aspects of characters.  As such, the
notations ‘|hello|’ and ‘\h\e\l\l\o’ are equivalent ways to refer to a
symbol whose name is ‘"hello"’, and which is distinct from any symbol
whose name is ‘"HELLO"’.

The symbols that correspond to Common Lisp defined names have uppercase
names even though their names generally appear in lowercase in this
document.

1.4.1.4.2 Numbers
.................

Although Common Lisp provides a variety of ways for programs to
manipulate the input and output radix for rational numbers, all numbers
in this document are in decimal notation unless explicitly noted
otherwise.

1.4.1.4.3 Use of the Dot Character
..................................

The dot appearing by itself in an expression such as

‘(ITEM1 ITEM2 . TAIL)’

means that TAIL represents a list of objects at the end of a list.  For
example,

‘(A B C . (D E F))’

is notationally equivalent to:

‘(A B C D E F)’

Although dot is a valid constituent character in a symbol, no
standardized symbols contain the character dot, so a period that follows
a reference to a symbol at the end of a sentence in this document should
always be interpreted as a period and never as part of the symbol’s
name.  For example, within this document, a sentence such as “This
sample sentence refers to the symbol ‘car’.” refers to a symbol whose
name is ‘"CAR"’ (with three letters), and never to a four-letter symbol
‘"CAR."’

1.4.1.4.4 NIL
.............

‘nil’ has a variety of meanings.  It is a symbol in the ‘COMMON-LISP’
package with the name ‘"NIL"’, it is boolean (and generalized boolean)
false, it is the empty list, and it is the name of the empty type (a
subtype of all types).

Within Common Lisp, ‘nil’ can be notated interchangeably as either ‘NIL’
or ‘()’.  By convention, the choice of notation offers a hint as to
which of its many roles it is playing.

For Evaluation?   Notation   Typically Implied Role
Yes               ‘nil’      use as a boolean.
Yes               ‘'nil’     use as a symbol.
Yes               ‘'()’      use as an empty list
No                ‘nil’      use as a symbol or boolean.
No                ‘()’       use as an empty list.

Figure 1.1: Notations for NIL

Within this document only, ‘nil’ is also sometimes notated as false to
emphasize its role as a boolean.

For example:

      (print ())                          ;avoided
      (defun three nil 3)                 ;avoided
      '(nil nil)                          ;list of two symbols
      '(() ())                            ;list of empty lists
      (defun three () 3)                  ;Emphasize empty parameter list.
      (append '() '()) → ()              ;Emphasize use of empty lists
      (not nil) → true                   ;Emphasize use as Boolean false
      (get 'nil 'color)                   ;Emphasize use as a symbol

A function is sometimes said to “be false” or “be true” in some
circumstance.  Since no function object can be the same as ‘nil’  and
all function objects represent true when viewed as booleans, it would be
meaningless to say that the function was literally false and
uninteresting to say that it was literally true.  Instead, these phrases
are just traditional alternative ways of saying that the function
“returns false” or “returns true,” respectively.

1.4.1.5 Designators
...................

A “designator” is an object that denotes another object.

Where a parameter of an operator is described as a designator, the
description of the operator is written in a way that assumes that the
value of the parameter is the denoted object; that is, that the
parameter is already of the denoted type.  (The specific nature of the
object denoted by a “«type» designator” or a “designator for a «type»”
can be found in the Glossary entry for “«type» designator.”)

For example, “‘nil’” and “the value of ‘*standard-output*’” are
operationally indistinguishable as stream designators.  Similarly, the
symbol ‘foo’ and the string ‘"FOO"’ are operationally indistinguishable
as string designators.

Except as otherwise noted, in a situation where the denoted object might
be used multiple times, it is implementation-dependent whether the
object is coerced only once or whether the coercion occurs each time the
object must be used.

For example, ‘mapcar’ receives a function designator as an argument, and
its description is written as if this were simply a function.  In fact,
it is implementation-dependent whether the function designator is
coerced right away or whether it is carried around internally in the
form that it was given as an argument and re-coerced each time it is
needed.  In most cases, conforming programs cannot detect the
distinction, but there are some pathological situations (particularly
those involving self-redefining or mutually-redefining functions) which
do conform and which can detect this difference.  The following program
is a conforming program, but might or might not have portably correct
results, depending on whether its correctness depends on one or the
other of the results:

      (defun add-some (x)
        (defun add-some (x) (+ x 2))
        (+ x 1)) → ADD-SOME
      (mapcar 'add-some '(1 2 3 4))
     → (2 3 4 5)
     or→ (2 4 5 6)

In a few rare situations, there may be a need in a dictionary entry to
refer to the object that was the original designator for a parameter.
Since naming the parameter would refer to the denoted object, the phrase
“the «parameter-name» designator” can be used to refer to the designator
which was the argument from which the value of «parameter-name» was
computed.

1.4.1.6 Nonsense Words
......................

When a word having no pre-attached semantics is required (e.g., in an
example), it is common in the Lisp community to use one of the words
“foo,” “bar,” “baz,” and “quux.” For example, in

      (defun foo (x) (+ x 1))

the use of the name ‘foo’ is just a shorthand way of saying “please
substitute your favorite name here.”

These nonsense words have gained such prevalance of usage, that it is
commonplace for newcomers to the community to begin to wonder if there
is an attached semantics which they are overlooking—there is not.


File: ansicl,  Node: Error Terminology,  Next: Sections Not Formally Part Of This Standard,  Prev: Notational Conventions,  Up: Definitions

1.4.2 Error Terminology
-----------------------

Situations in which errors might, should, or must be signaled are
described in the standard.  The wording used to describe such situations
is intended to have precise meaning.  The following list is a glossary
of those meanings.

Safe code

     This is code processed with the ‘safety’ optimization at its
     highest setting (‘3’).  ‘safety’ is a lexical property of code.
     The phrase “the function ‘F’ should signal an error” means that if
     ‘F’ is invoked from code processed with the highest ‘safety’
     optimization, an error is signaled.  It is implementation-dependent
     whether ‘F’ or the calling code signals the error.

Unsafe code

     This is code processed with lower safety levels.

     Unsafe code might do error checking.  Implementations are permitted
     to treat all code as safe code all the time.

An error is signaled

     This means that an error is signaled in both safe and unsafe code.
     Conforming code may rely on the fact that the error is signaled in
     both safe and unsafe code.  Every implementation is required to
     detect the error in both safe and unsafe code.  For example, “an
     error is signaled if ‘unexport’ is given a symbol not accessible in
     the current package.”

     If an explicit error type is not specified, the default is ‘error’.

An error should be signaled

     This means that an error is signaled in safe code, and an error
     might be signaled in unsafe code.  Conforming code may rely on the
     fact that the error is signaled in safe code.  Every implementation
     is required to detect the error at least in safe code.  When the
     error is not signaled, the “consequences are undefined” (see
     below).  For example, “‘+’ should signal an error of type
     ‘type-error’ if any argument is not of type ‘number’.”

Should be prepared to signal an error

     This is similar to “should be signaled” except that it does not
     imply that ‘extra effort’ has to be taken on the part of an
     operator to discover an erroneous situation if the normal action of
     that operator can be performed successfully with only ‘lazy’
     checking.  An implementation is always permitted to signal an
     error, but even in safe code, it is only required to signal the
     error when failing to signal it might lead to incorrect results.
     In unsafe code, the consequences are undefined.

     For example, defining that “‘find’ should be prepared to signal an
     error of type ‘type-error’ if its second argument is not a proper
     list” does not imply that an error is always signaled.  The form

           (find 'a '(a b . c))

     must either signal an error of type ‘type-error’ in safe code, else
     return ‘A’.  In unsafe code, the consequences are undefined.  By
     contrast,

           (find 'd '(a b . c))

     must signal an error of type ‘type-error’ in safe code.  In unsafe
     code, the consequences are undefined.  Also,

           (find 'd '#1=(a b . #1#))

     in safe code might return ‘nil’ (as an implementation-defined
     extension), might never return, or might signal an error of type
     ‘type-error’.  In unsafe code, the consequences are undefined.

     Typically, the “should be prepared to signal” terminology is used
     in type checking situations where there are efficiency
     considerations that make it impractical to detect errors that are
     not relevant to the correct operation of the operator.

The consequences are unspecified

     This means that the consequences are unpredictable but harmless.
     Implementations are permitted to specify the consequences of this
     situation.  No conforming code may depend on the results or effects
     of this situation, and all conforming code is required to treat the
     results and effects of this situation as unpredictable but
     harmless.  For example, “if the second argument to
     ‘shared-initialize’ specifies a name that does not correspond to
     any slots accessible in the object, the results are unspecified.”

The consequences are undefined

     This means that the consequences are unpredictable.  The
     consequences may range from harmless to fatal.  No conforming code
     may depend on the results or effects.  Conforming code must treat
     the consequences as unpredictable.  In places where the words
     “must,” “must not,” or “may not” are used, then “the consequences
     are undefined” if the stated requirement is not met and no specific
     consequence is explicitly stated.  An implementation is permitted
     to signal an error in this case.

     For example: “Once a name has been declared by ‘defconstant’ to be
     constant, any further assignment or binding of that variable has
     undefined consequences.”

An error might be signaled

     This means that the situation has undefined consequences; however,
     if an error is signaled, it is of the specified type.  For example,
     “‘open’ might signal an error of type ‘file-error’.”

The return values are unspecified

     This means that only the number and nature of the return values of
     a form are not specified.  However, the issue of whether or not any
     side-effects or transfer of control occurs is still well-specified.

     A program can be well-specified even if it uses a function whose
     returns values are unspecified.  For example, even if the return
     values of some function ‘F’ are unspecified, an expression such as
     ‘(length (list (F)))’ is still well-specified because it does not
     rely on any particular aspect of the value or values returned by
     ‘F’.

Implementations may be extended to cover this situation

     This means that the situation has undefined consequences; however,
     a conforming implementation is free to treat the situation in a
     more specific way.  For example, an implementation might define
     that an error is signaled, or that an error should be signaled, or
     even that a certain well-defined non-error behavior occurs.

     No conforming code may depend on the consequences of such a
     situation; all conforming code must treat the consequences of the
     situation as undefined.  Implementations are required to document
     how the situation is treated.

     For example, “implementations may be extended to define other type
     specifiers to have a corresponding class.”

Implementations are free to extend the syntax

     This means that in this situation implementations are permitted to
     define unambiguous extensions to the syntax of the form being
     described.  No conforming code may depend on this extension.
     Implementations are required to document each such extension.  All
     conforming code is required to treat the syntax as meaningless.
     The standard might disallow certain extensions while allowing
     others.  For example, “no implementation is free to extend the
     syntax of ‘defclass’.”

A warning might be issued

     This means that implementations are encouraged to issue a warning
     if the context is appropriate (e.g., when compiling).  However, a
     conforming implementation is not required to issue a warning.


File: ansicl,  Node: Sections Not Formally Part Of This Standard,  Next: Interpreting Dictionary Entries,  Prev: Error Terminology,  Up: Definitions

1.4.3 Sections Not Formally Part Of This Standard
-------------------------------------------------

Front matter and back matter, such as the “Table of Contents,” “Index,”
“Figures,” “Credits,” and “Appendix” are not considered formally part of
this standard, so that we retain the flexibility needed to update these
sections even at the last minute without fear of needing a formal vote
to change those parts of the document.  These items are quite short and
very useful, however, and it is not recommended that they be removed
even in an abridged version of this document.

Within the concept sections, subsections whose names begin with the
words “Note” or “Notes” or “Example” or “Examples” are provided for
illustration purposes only, and are not considered part of the standard.

An attempt has been made to place these sections last in their parent
section, so that they could be removed without disturbing the contiguous
numbering of the surrounding sections in order to produce a document of
smaller size.

Likewise, the “Examples” and “Notes” sections in a dictionary entry are
not considered part of the standard and could be removed if necessary.

Nevertheless, the examples provide important clarifications and
consistency checks for the rest of the material, and such abridging is
not recommended unless absolutely unavoidable.


File: ansicl,  Node: Interpreting Dictionary Entries,  Prev: Sections Not Formally Part Of This Standard,  Up: Definitions

1.4.4 Interpreting Dictionary Entries
-------------------------------------

The dictionary entry for each defined name is partitioned into sections.
Except as explicitly indicated otherwise below, each section is
introduced by a label identifying that section.  The omission of a
section implies that the section is either not applicable, or would
provide no interesting information.

This section defines the significance of each potential section in a
dictionary entry.

1.4.4.1 The “Affected By” Section of a Dictionary Entry
.......................................................

For an operator, anything that can affect the side effects of or values
returned by the operator.

For a variable, anything that can affect the value of the variable
including functions that bind or assign it.

1.4.4.2 The “Arguments” Section of a Dictionary Entry
.....................................................

This information describes the syntax information of entries such as
those for declarations and special expressions which are never evaluated
as forms, and so do not return values.

1.4.4.3 The “Arguments and Values” Section of a Dictionary Entry
................................................................

An English language description of what arguments the operator accepts
and what values it returns, including information about defaults for
parameters corresponding to omittable arguments (such as optional
parameters and keyword parameters).  For special operators and macros,
their arguments are not evaluated unless it is explicitly stated in
their descriptions that they are evaluated.

Except as explicitly specified otherwise, the consequences are undefined
if these type restrictions are violated.

1.4.4.4 The “Binding Types Affected” Section of a Dictionary Entry
..................................................................

This information alerts the reader to the kinds of bindings that might
potentially be affected by a declaration.  Whether in fact any
particular such binding is actually affected is dependent on additional
factors as well.  See the “Description” section of the declaration in
question for details.

1.4.4.5 The “Class Precedence List” Section of a Dictionary Entry
.................................................................

This appears in the dictionary entry for a class, and contains an
ordered list of the classes defined by Common Lisp that must be in the
class precedence list of this class.

It is permissible for other (implementation-defined) classes to appear
in the implementation’s class precedence list for the class.

It is permissible for either ‘standard-object’ or ‘structure-object’ to
appear in the implementation’s class precedence list; for details, see
*note Section 4.2.2 (Type Relationships): Type Relationships.

Except as explicitly indicated otherwise somewhere in this
specification, no additional standardized classes may appear in the
implementation’s class precedence list.

By definition of the relationship between classes and types, the classes
listed in this section are also supertypes of the type denoted by the
class.

1.4.4.6 Dictionary Entries for Type Specifiers
..............................................

The atomic type specifiers are those defined names listed in *note
Figure 4.2: StandardizedAtomicTypeSpecs.  Such dictionary entries are of
kind “Class,” “Condition Type,” “System Class,” or “Type.” A description
of how to interpret a symbol naming one of these types or classes as an
atomic type specifier is found in the “Description” section of such
dictionary entries.

The compound type specifiers are those defined names listed in *note
Figure 4.3: StandardizedCompoundTypeSpecNames.  Such dictionary entries
are of kind “Class,” “System Class,” “Type,” or “Type Specifier.” A
description of how to interpret as a compound type specifier a list
whose car is such a symbol is found in the “Compound Type Specifier
Kind,” “Compound Type Specifier Syntax,” “Compound Type Specifier
Arguments,” and “Compound Type Specifier Description” sections of such
dictionary entries.

1.4.4.6.1 The “Compound Type Specifier Kind” Section of a Dictionary Entry
..........................................................................

An “abbreviating” type specifier is one that describes a subtype for
which it is in principle possible to enumerate the elements, but for
which in practice it is impractical to do so.

A “specializing” type specifier is one that describes a subtype by
restricting the type of one or more components of the type, such as
element type or complex part type.

A “predicating” type specifier is one that describes a subtype
containing only those objects that satisfy a given predicate.

A “combining” type specifier is one that describes a subtype in a
compositional way, using combining operations (such as “and,” “or,” and
“not”) on other types.

1.4.4.6.2 The “Compound Type Specifier Syntax” Section of a Dictionary Entry
............................................................................

This information about a type describes the syntax of a compound type
specifier for that type.

Whether or not the type is acceptable as an atomic type specifier is not
represented here; see *note Section 1.4.4.6 (Dictionary Entries for Type
Specifiers): TypeSpecEntries.

1.4.4.6.3 The “Compound Type Specifier Arguments” Section of a Dictionary Entry
...............................................................................

This information describes type information for the structures defined
in the “Compound Type Specifier Syntax” section.

1.4.4.6.4 The “Compound Type Specifier Description” Section of a Dictionary Entry
.................................................................................

This information describes the meaning of the structures defined in the
“Compound Type Specifier Syntax” section.

1.4.4.7 The “Constant Value” Section of a Dictionary Entry
..........................................................

This information describes the unchanging type and value of a constant
variable.

1.4.4.8 The “Description” Section of a Dictionary Entry
.......................................................

A summary of the operator and all intended aspects of the operator, but
does not necessarily include all the fields referenced below it (“Side
Effects,” “Exceptional Situations,” etc.)

1.4.4.9 The “Examples” Section of a Dictionary Entry
....................................................

Examples of use of the operator.  These examples are not considered part
of the standard; see *note Section 1.4.3 (Sections Not Formally Part Of
This Standard): Sections Not Formally Part Of This Standard.

1.4.4.10 The “Exceptional Situations” Section of a Dictionary Entry
...................................................................

Three kinds of information may appear here:

   • Situations that are detected by the function and formally signaled.
   • Situations that are handled by the function.
   • Situations that may be detected by the function.

This field does not include conditions that could be signaled by
functions passed to and called by this operator as arguments or through
dynamic variables, nor by executing subforms of this operator if it is a
macro or special operator.

1.4.4.11 The “Initial Value” Section of a Dictionary Entry
..........................................................

This information describes the initial value of a dynamic variable.
Since this variable might change, see type restrictions in the “Value
Type” section.

1.4.4.12 The “Argument Precedence Order” Section of a Dictionary Entry
......................................................................

This information describes the argument precedence order.  If it is
omitted, the argument precedence order is the default (left to right).

1.4.4.13 The “Method Signature” Section of a Dictionary Entry
.............................................................

The description of a generic function includes descriptions of the
methods that are defined on that generic function by the standard.  A
method signature is used to describe the parameters and parameter
specializers for each method.  Methods defined for the generic function
must be of the form described by the method signature.

F (X CLASS) (Y t) &optional Z &key K

This signature indicates that this method on the generic function F has
two required parameters: X, which must be a generalized instance of the
class CLASS; and Y, which can be any object (i.e., a generalized
instance of the class ‘t’).  In addition, there is an optional parameter
Z and a keyword parameter K.  This signature also indicates that this
method on ‘F’ is a primary method and has no qualifiers.

For each parameter, the argument supplied must be in the intersection of
the type specified in the description of the corresponding generic
function and the type given in the signature of some method (including
not only those methods defined in this specification, but also
implementation-defined or user-defined methods in situations where the
definition of such methods is permitted).

1.4.4.14 The “Name” Section of a Dictionary Entry
.................................................

This section introduces the dictionary entry.  It is not explicitly
labeled.  It appears preceded and followed by a horizontal bar.

In large print at left, the defined name appears; if more than one
defined name is to be described by the entry, all such names are shown
separated by commas.

In somewhat smaller italic print at right is an indication of what kind
of dictionary entry this is.  Possible values are:

Accessor

     This is an accessor function.

Class

     This is a class.

Condition Type

     This is a subtype of type ‘condition’.

Constant Variable

     This is a constant variable.

Declaration

     This is a declaration identifier.

Function

     This is a function.

Local Function

     This is a function that is defined only lexically within the scope
     of some other macro form.

Local Macro

     This is a macro that is defined only lexically within the scope of
     some other macro form.

Macro

     This is a macro.

Restart

     This is a restart.

Special Operator

     This is a special operator.

Standard Generic Function

     This is a standard generic function.

Symbol

     This is a symbol that is specially recognized in some particular
     situation, such as the syntax of a macro.

System Class

     This is like class, but it identifies a class that is potentially a
     built-in class.  (No class is actually required to be a built-in
     class.)

Type

     This is an atomic type specifier, and depending on information for
     each particular entry, may subject to form other type specifiers.

Type Specifier

     This is a defined name that is not an atomic type specifier, but
     that can be used in constructing valid type specifiers.

Variable

     This is a dynamic variable.

1.4.4.15 The “Notes” Section of a Dictionary Entry
..................................................

Information not found elsewhere in this description which pertains to
this operator.  Among other things, this might include cross reference
information, code equivalences, stylistic hints, implementation hints,
typical uses.  This information is not considered part of the standard;
any conforming implementation or conforming program is permitted to
ignore the presence of this information.

1.4.4.16 The “Pronunciation” Section of a Dictionary Entry
..........................................................

This offers a suggested pronunciation for defined names so that people
not in verbal communication with the original designers can figure out
how to pronounce words that are not in normal English usage.  This
information is advisory only, and is not considered part of the
standard.  For brevity, it is only provided for entries with names that
are specific to Common Lisp and would not be found in ‘Webster’s Third
New International Dictionary the English Language, Unabridged’.

1.4.4.17 The “See Also” Section of a Dictionary Entry
.....................................................

List of references to other parts of this standard that offer
information relevant to this operator.  This list is not part of the
standard.

1.4.4.18 The “Side Effects” Section of a Dictionary Entry
.........................................................

Anything that is changed as a result of the evaluation of the form
containing this operator.

1.4.4.19 The “Supertypes” Section of a Dictionary Entry
.......................................................

This appears in the dictionary entry for a type, and contains a list of
the standardized types that must be supertypes of this type.

In implementations where there is a corresponding class, the order of
the classes in the class precedence list is consistent with the order
presented in this section.

1.4.4.20 The “Syntax” Section of a Dictionary Entry
...................................................

This section describes how to use the defined name in code.  The
“Syntax” description for a generic function describes the lambda list of
the generic function itself, while the “Method Signatures” describe the
lambda lists of the defined methods.  The “Syntax” description for an
ordinary function, a macro, or a special operator describes its
parameters.

For example, an operator description might say:

 -- Function: F x y &optional z &key k

This description indicates that the function F has two required
parameters, X and Y.  In addition, there is an optional parameter Z and
a keyword parameter K.

For macros and special operators, syntax is given in modified BNF
notation; see *note Section 1.4.1.2 (Modified BNF Syntax): ModifiedBNF.
For functions a lambda list is given.  In both cases, however, the
outermost parentheses are omitted, and default value information is
omitted.

1.4.4.20.1 Special “Syntax” Notations for Overloaded Operators
..............................................................

If two descriptions exist for the same operation but with different
numbers of arguments, then the extra arguments are to be treated as
optional.  For example, this pair of lines:

 -- Function: file-position stream → position
 -- Function: file-position stream position-spec → success-p

is operationally equivalent to this line:

 -- Function: file-position stream &optional position-spec → result

and differs only in that it provides on opportunity to introduce
different names for parameter and values for each case.  The separated
(multi-line) notation is used when an operator is overloaded in such a
way that the parameters are used in different ways depending on how many
arguments are supplied (e.g., for the function ‘/’) or the return values
are different in the two cases (e.g., for the function ‘file-position’).

1.4.4.20.2 Naming Conventions for Rest Parameters
.................................................

Within this specification, if the name of a rest parameter is chosen to
be a plural noun, use of that name in PARAMETER font refers to the list
to which the rest parameter is bound.  Use of the singular form of that
name in PARAMETER font refers to an element of that list.

For example, given a syntax description such as:

 -- Function: F &rest ARGUMENTS

it is appropriate to refer either to the rest parameter named ARGUMENTS
by name, or to one of its elements by speaking of “an ARGUMENT,” “some
ARGUMENT,” “each ARGUMENT” etc.

1.4.4.20.3 Requiring Non-Null Rest Parameters in the “Syntax” Section
.....................................................................

In some cases it is useful to refer to all arguments equally as a single
aggregation using a rest parameter while at the same time requiring at
least one argument.  A variety of imperative and declarative means are
available in code for expressing such a restriction, however they
generally do not manifest themselves in a lambda list.  For descriptive
purposes within this specification,

 -- Function: F &rest arguments+

means the same as

 -- Function: F &rest arguments

but introduces the additional requirement that there be at least one
ARGUMENT.

1.4.4.20.4 Return values in the “Syntax” Section
................................................

An evaluation arrow “→” precedes a list of values to be returned.  For
example:

 -- Function: F a b c → x

indicates that ‘F’ is an operator that has three required parameters
(i.e., A, B, and C) and that returns one value (i.e., X).  If more than
one value is returned by an operator, the names of the values are
separated by commas, as in:

 -- Function: F a b c → x, y, z

1.4.4.20.4.1 No Arguments or Values in the “Syntax” Section
...........................................................

If no arguments are permitted, or no values are returned, a special
notation is used to make this more visually apparent.  For example,

 -- Function: F <no arguments> → <no values>

indicates that ‘F’ is an operator that accepts no arguments and returns
no values.

1.4.4.20.4.2 Unconditional Transfer of Control in the “Syntax” Section
......................................................................

Some operators perform an unconditional transfer of control, and so
never have any return values.  Such operators are notated using a
notation such as the following:

 -- Function: F a b c →|

1.4.4.21 The “Valid Context” Section of a Dictionary Entry
..........................................................

This information is used by dictionary entries such as “Declarations” in
order to restrict the context in which the declaration may appear.

A given “Declaration” might appear in a declaration (i.e., a declare
expression), a proclamation (i.e., a ‘declaim’ or ‘proclaim’ form), or
both.

1.4.4.22 The “Value Type” Section of a Dictionary Entry
.......................................................

This information describes any type restrictions on a dynamic variable.

Except as explicitly specified otherwise, the consequences are undefined
if this type restriction is violated.


File: ansicl,  Node: Conformance,  Next: Language Extensions,  Prev: Definitions,  Up: Introduction

1.5 Conformance
===============

This standard presents the syntax and semantics to be implemented by a
conforming implementation (and its accompanying documentation).  In
addition, it imposes requirements on conforming programs.

* Menu:

* Conforming Implementations::
* Conforming Programs::


File: ansicl,  Node: Conforming Implementations,  Next: Conforming Programs,  Up: Conformance

1.5.1 Conforming Implementations
--------------------------------

A “conforming implementation” shall adhere to the requirements outlined
in this section.

1.5.1.1 Required Language Features
..................................

A conforming implementation shall accept all features (including
deprecated features) of the language specified in this standard, with
the meanings defined in this standard.

A conforming implementation shall not require the inclusion of
substitute or additional language elements in code in order to
accomplish a feature of the language that is specified in this standard.

1.5.1.2 Documentation of Implementation-Dependent Features
..........................................................

A conforming implementation shall be accompanied by a document that
provides a definition of all implementation-defined aspects of the
language defined by this specification.

In addition, a conforming implementation is encouraged (but not
required) to document items in this standard that are identified as
implementation-dependent, although in some cases such documentation
might simply identify the item as “undefined.”

1.5.1.3 Documentation of Extensions
...................................

A conforming implementation shall be accompanied by a document that
separately describes any features accepted by the implementation that
are not specified in this standard, but that do not cause any ambiguity
or contradiction when added to the language standard.  Such extensions
shall be described as being “extensions to Common Lisp as specified by
ANSI «standard number».”

1.5.1.4 Treatment of Exceptional Situations
...........................................

A conforming implementation shall treat exceptional situations in a
manner consistent with this specification.

1.5.1.4.1 Resolution of Apparent Conflicts in Exceptional Situations
....................................................................

If more than one passage in this specification appears to apply to the
same situation but in conflicting ways, the passage that appears to
describe the situation in the most specific way (not necessarily the
passage that provides the most constrained kind of error detection)
takes precedence.

1.5.1.4.1.1 Examples of Resolution of Apparent Conflicts
........................................................

in Exceptional Situations

Suppose that function ‘foo’ is a member of a set S of functions that
operate on numbers.  Suppose that one passage states that an error must
be signaled if any function in S is ever given an argument of ‘17’.
Suppose that an apparently conflicting passage states that the
consequences are undefined if ‘foo’ receives an argument of ‘17’.  Then
the second passage (the one specifically about ‘foo’) would dominate
because the description of the situational context is the most specific,
and it would not be required that ‘foo’ signal an error on an argument
of ‘17’ even though other functions in the set S would be required to do
so.

1.5.1.5 Conformance Statement
.............................

A conforming implementation shall produce a conformance statement as a
consequence of using the implementation, or that statement shall be
included in the accompanying documentation.  If the implementation
conforms in all respects with this standard, the conformance statement
shall be

     “«Implementation» conforms with the requirements of ANSI «standard
     number»”

If the implementation conforms with some but not all of the requirements
of this standard, then the conformance statement shall be

     “«Implementation» conforms with the requirements of ANSI «standard
     number» with the following exceptions: «reference to or complete
     list of the requirements of the standard with which the
     implementation does not conform».”


File: ansicl,  Node: Conforming Programs,  Prev: Conforming Implementations,  Up: Conformance

1.5.2 Conforming Programs
-------------------------

Code conforming with the requirements of this standard shall adhere to
the following:

  1. Conforming code shall use only those features of the language
     syntax and semantics that are either specified in this standard or
     defined using the extension mechanisms specified in the standard.

  2. Conforming code may use implementation-dependent features and
     values, but shall not rely upon any particular interpretation of
     these features and values other than those that are discovered by
     the execution of code.

  3. Conforming code shall not depend on the consequences of undefined
     or unspecified situations.

  4. Conforming code does not use any constructions that are prohibited
     by the standard.

  5. Conforming code does not depend on extensions included in an
     implementation.

1.5.2.1 Use of Implementation-Defined Language Features
.......................................................

Note that conforming code may rely on particular implementation-defined
values or features.  Also note that the requirements for conforming code
and conforming implementations do not require that the results produced
by conforming code always be the same when processed by a conforming
implementation.  The results may be the same, or they may differ.

Conforming code may run in all conforming implementations, but might
have allowable implementation-defined behavior that makes it
non-portable code.  For example, the following are examples of forms
that are conforming, but that might return different values in different
implementations:

      (evenp most-positive-fixnum) → implementation-dependent
      (random) → implementation-dependent
      (> lambda-parameters-limit 93) → implementation-dependent
      (char-name #\A) → implementation-dependent

1.5.2.1.1 Use of Read-Time Conditionals
.......................................

Use of ‘#+’ and ‘#-’ does not automatically disqualify a program from
being conforming.  A program which uses ‘#+’ and ‘#-’ is considered
conforming if there is no set of features in which the program would not
be conforming.  Of course, conforming programs are not necessarily
working programs.  The following program is conforming:

     (defun foo ()
       #+ACME (acme:initialize-something)
       (print 'hello-there))

However, this program might or might not work, depending on whether the
presence of the feature ‘ACME’ really implies that a function named
‘acme:initialize-something’ is present in the environment.  In effect,
using ‘#+’ or ‘#-’ in a conforming program means that the variable
‘*features*’ becomes just one more piece of input data to that program.
Like any other data coming into a program, the programmer is responsible
for assuring that the program does not make unwarranted assumptions on
the basis of input data.

1.5.2.2 Character Set for Portable Code
.......................................

Portable code is written using only standard characters.


File: ansicl,  Node: Language Extensions,  Next: Language Subsets,  Prev: Conformance,  Up: Introduction

1.6 Language Extensions
=======================

A language extension is any documented implementation-defined behavior
of a defined name in this standard that varies from the behavior
described in this standard, or a documented consequence of a situation
that the standard specifies as undefined, unspecified, or extendable by
the implementation.  For example, if this standard says that “the
results are unspecified,” an extension would be to specify the results.

If the correct behavior of a program depends on the results provided by
an extension, only implementations with the same extension will execute
the program correctly.  Note that such a program might be
non-conforming.  Also, if this standard says that “an implementation may
be extended,” a conforming, but possibly non-portable, program can be
written using an extension.

An implementation can have extensions, provided they do not alter the
behavior of conforming code and provided they are not explicitly
prohibited by this standard.

The term “extension” refers only to extensions available upon startup.
An implementation is free to allow or prohibit redefinition of an
extension.

The following list contains specific guidance to implementations
concerning certain types of extensions.

Extra return values

     An implementation must return exactly the number of return values
     specified by this standard unless the standard specifically
     indicates otherwise.

Unsolicited messages

     No output can be produced by a function other than that specified
     in the standard or due to the signaling of conditions detected by
     the function.

     Unsolicited output, such as garbage collection notifications and
     autoload heralds, should not go directly to the stream that is the
     value of a stream variable defined in this standard, but can go
     indirectly to terminal I/O by using a synonym stream to
     ‘*terminal-io*’.

     Progress reports from such functions as ‘load’ and ‘compile’ are
     considered solicited, and are not covered by this prohibition.

Implementation of macros and special forms

     Macros and special operators defined in this standard must not be
     functions.


File: ansicl,  Node: Language Subsets,  Next: Deprecated Language Features,  Prev: Language Extensions,  Up: Introduction

1.7 Language Subsets
====================

The language described in this standard contains no subsets, though
subsets are not forbidden.

For a language to be considered a subset, it must have the property that
any valid program in that language has equivalent semantics and will run
directly (with no extralingual pre-processing, and no special
compatibility packages) in any conforming implementation of the full
language.

A language that conforms to this requirement shall be described as being
a “subset of Common Lisp as specified by ANSI «standard number».”


File: ansicl,  Node: Deprecated Language Features,  Next: Symbols in the COMMON-LISP Package,  Prev: Language Subsets,  Up: Introduction

1.8 Deprecated Language Features
================================

Deprecated language features are not expected to appear in future Common
Lisp standards, but are required to be implemented for conformance with
this standard; see *note Section 1.5.1.1 (Required Language Features):
ReqLangFeatures.

Conforming programs can use deprecated features; however, it is
considered good programming style to avoid them.  It is permissible for
the compiler to produce style warnings about the use of such features at
compile time, but there should be no such warnings at program execution
time.

* Menu:

* Deprecated Functions::
* Deprecated Argument Conventions::
* Deprecated Variables::
* Deprecated Reader Syntax::


File: ansicl,  Node: Deprecated Functions,  Next: Deprecated Argument Conventions,  Up: Deprecated Language Features

1.8.1 Deprecated Functions
--------------------------

The functions in the next figure are deprecated.

assoc-if-not    nsubst-if-not        require
count-if-not    nsubstitute-if-not   set
delete-if-not   position-if-not      subst-if-not
find-if-not     provide              substitute-if-not
gentemp         rassoc-if-not
member-if-not   remove-if-not

Figure 1.2: Deprecated Functions


File: ansicl,  Node: Deprecated Argument Conventions,  Next: Deprecated Variables,  Prev: Deprecated Functions,  Up: Deprecated Language Features

1.8.2 Deprecated Argument Conventions
-------------------------------------

The ability to pass a numeric argument to ‘gensym’ has been deprecated.

The :test-not argument to the functions in the next figure are
deprecated.

adjoin              nset-difference     search
assoc               nset-exclusive-or   set-difference
count               nsublis             set-exclusive-or
delete              nsubst              sublis
delete-duplicates   nsubstitute         subsetp
find                nunion              subst
intersection        position            substitute
member              rassoc              tree-equal
mismatch            remove              union
nintersection       remove-duplicates

Figure 1.3: Functions with Deprecated :TEST-NOT Arguments

The use of the situation names compile, load, and eval in ‘eval-when’ is
deprecated.


File: ansicl,  Node: Deprecated Variables,  Next: Deprecated Reader Syntax,  Prev: Deprecated Argument Conventions,  Up: Deprecated Language Features

1.8.3 Deprecated Variables
--------------------------

The variable ‘*modules*’ is deprecated.


File: ansicl,  Node: Deprecated Reader Syntax,  Prev: Deprecated Variables,  Up: Deprecated Language Features

1.8.4 Deprecated Reader Syntax
------------------------------

The ‘#S’ reader macro forces keyword names into the ‘KEYWORD’ package;
see *note Section 2.4.8.13 (Sharpsign S): SharpsignS. This feature is
deprecated; in the future, keyword names will be taken in the package
they are read in, so symbols that are actually in the ‘KEYWORD’ package
should be used if that is what is desired.


File: ansicl,  Node: Symbols in the COMMON-LISP Package,  Prev: Deprecated Language Features,  Up: Introduction

1.9 Symbols in the COMMON-LISP Package
======================================

The figures on the next twelve pages contain a complete enumeration of
the 978 external symbols in the ‘COMMON-LISP’ package.

&allow-other-keys             *print-miser-width*
&aux                          *print-pprint-dispatch*
&body                         *print-pretty*
&environment                  *print-radix*
&key                          *print-readably*
&optional                     *print-right-margin*
&rest                         *query-io*
&whole                        *random-state*
*                             *read-base*
**                            *read-default-float-format*
***                           *read-eval*
*break-on-signals*            *read-suppress*
*compile-file-pathname*       *readtable*
*compile-file-truename*       *standard-input*
*compile-print*               *standard-output*
*compile-verbose*             *terminal-io*
*debug-io*                    *trace-output*
*debugger-hook*               +
*default-pathname-defaults*   ++
*error-output*                +++
*features*                    -
*gensym-counter*              /
*load-pathname*               //
*load-print*                  ///
*load-truename*               /=
*load-verbose*                1+
*macroexpand-hook*            1-
*modules*                     <
*package*                     <=
*print-array*                 =
*print-base*                  >
*print-case*                  >=
*print-circle*                abort
*print-escape*                abs
*print-gensym*                acons
*print-length*                acos
*print-level*                 acosh
*print-lines*                 add-method

Figure 1.4: Symbols in the COMMON-LISP package (part one of twelve).

adjoin                       atom           boundp
adjust-array                 base-char      break
adjustable-array-p           base-string    broadcast-stream
allocate-instance            bignum         broadcast-stream-streams
alpha-char-p                 bit            built-in-class
alphanumericp                bit-and        butlast
and                          bit-andc1      byte
append                       bit-andc2      byte-position
apply                        bit-eqv        byte-size
apropos                      bit-ior        caaaar
apropos-list                 bit-nand       caaadr
aref                         bit-nor        caaar
arithmetic-error             bit-not        caadar
arithmetic-error-operands    bit-orc1       caaddr
arithmetic-error-operation   bit-orc2       caadr
array                        bit-vector     caar
array-dimension              bit-vector-p   cadaar
array-dimension-limit        bit-xor        cadadr
array-dimensions             block          cadar
array-displacement           boole          caddar
array-element-type           boole-1        cadddr
array-has-fill-pointer-p     boole-2        caddr
array-in-bounds-p            boole-and      cadr
array-rank                   boole-andc1    call-arguments-limit
array-rank-limit             boole-andc2    call-method
array-row-major-index        boole-c1       call-next-method
array-total-size             boole-c2       car
array-total-size-limit       boole-clr      case
arrayp                       boole-eqv      catch
ash                          boole-ior      ccase
asin                         boole-nand     cdaaar
asinh                        boole-nor      cdaadr
assert                       boole-orc1     cdaar
assoc                        boole-orc2     cdadar
assoc-if                     boole-set      cdaddr
assoc-if-not                 boole-xor      cdadr
atan                         boolean        cdar
atanh                        both-case-p    cddaar

Figure 1.5: Symbols in the COMMON-LISP package (part two of twelve).

cddadr              clear-input                   copy-tree
cddar               clear-output                  cos
cdddar              close                         cosh
cddddr              clrhash                       count
cdddr               code-char                     count-if
cddr                coerce                        count-if-not
cdr                 compilation-speed             ctypecase
ceiling             compile                       debug
cell-error          compile-file                  decf
cell-error-name     compile-file-pathname         declaim
cerror              compiled-function             declaration
change-class        compiled-function-p           declare
char                compiler-macro                decode-float
char-code           compiler-macro-function       decode-universal-time
char-code-limit     complement                    defclass
char-downcase       complex                       defconstant
char-equal          complexp                      defgeneric
char-greaterp       compute-applicable-methods    define-compiler-macro
char-int            compute-restarts              define-condition
char-lessp          concatenate                   define-method-combination
char-name           concatenated-stream           define-modify-macro
char-not-equal      concatenated-stream-streams   define-setf-expander
char-not-greaterp   cond                          define-symbol-macro
char-not-lessp      condition                     defmacro
char-upcase         conjugate                     defmethod
char/=              cons                          defpackage
char<               consp                         defparameter
char<=              constantly                    defsetf
char=               constantp                     defstruct
char>               continue                      deftype
char>=              control-error                 defun
character           copy-alist                    defvar
characterp          copy-list                     delete
check-type          copy-pprint-dispatch          delete-duplicates
cis                 copy-readtable                delete-file
class               copy-seq                      delete-if
class-name          copy-structure                delete-if-not
class-of            copy-symbol                   delete-package

Figure 1.6: Symbols in the COMMON-LISP package (part three of twelve).

denominator                     eq
deposit-field                   eql
describe                        equal
describe-object                 equalp
destructuring-bind              error
digit-char                      etypecase
digit-char-p                    eval
directory                       eval-when
directory-namestring            evenp
disassemble                     every
division-by-zero                exp
do                              export
do*                             expt
do-all-symbols                  extended-char
do-external-symbols             fboundp
do-symbols                      fceiling
documentation                   fdefinition
dolist                          ffloor
dotimes                         fifth
double-float                    file-author
double-float-epsilon            file-error
double-float-negative-epsilon   file-error-pathname
dpb                             file-length
dribble                         file-namestring
dynamic-extent                  file-position
ecase                           file-stream
echo-stream                     file-string-length
echo-stream-input-stream        file-write-date
echo-stream-output-stream       fill
ed                              fill-pointer
eighth                          find
elt                             find-all-symbols
encode-universal-time           find-class
end-of-file                     find-if
endp                            find-if-not
enough-namestring               find-method
ensure-directories-exist        find-package
ensure-generic-function         find-restart

Figure 1.7: Symbols in the COMMON-LISP package (part four of twelve).

find-symbol                        get-internal-run-time
finish-output                      get-macro-character
first                              get-output-stream-string
fixnum                             get-properties
flet                               get-setf-expansion
float                              get-universal-time
float-digits                       getf
float-precision                    gethash
float-radix                        go
float-sign                         graphic-char-p
floating-point-inexact             handler-bind
floating-point-invalid-operation   handler-case
floating-point-overflow            hash-table
floating-point-underflow           hash-table-count
floatp                             hash-table-p
floor                              hash-table-rehash-size
fmakunbound                        hash-table-rehash-threshold
force-output                       hash-table-size
format                             hash-table-test
formatter                          host-namestring
fourth                             identity
fresh-line                         if
fround                             ignorable
ftruncate                          ignore
ftype                              ignore-errors
funcall                            imagpart
function                           import
function-keywords                  in-package
function-lambda-expression         incf
functionp                          initialize-instance
gcd                                inline
generic-function                   input-stream-p
gensym                             inspect
gentemp                            integer
get                                integer-decode-float
get-decoded-time                   integer-length
get-dispatch-macro-character       integerp
get-internal-real-time             interactive-stream-p

Figure 1.8: Symbols in the COMMON-LISP package (part five of twelve).

intern                                   lisp-implementation-type
internal-time-units-per-second           lisp-implementation-version
intersection                             list
invalid-method-error                     list*
invoke-debugger                          list-all-packages
invoke-restart                           list-length
invoke-restart-interactively             listen
isqrt                                    listp
keyword                                  load
keywordp                                 load-logical-pathname-translations
labels                                   load-time-value
lambda                                   locally
lambda-list-keywords                     log
lambda-parameters-limit                  logand
last                                     logandc1
lcm                                      logandc2
ldb                                      logbitp
ldb-test                                 logcount
ldiff                                    logeqv
least-negative-double-float              logical-pathname
least-negative-long-float                logical-pathname-translations
least-negative-normalized-double-float   logior
least-negative-normalized-long-float     lognand
least-negative-normalized-short-float    lognor
least-negative-normalized-single-float   lognot
least-negative-short-float               logorc1
least-negative-single-float              logorc2
least-positive-double-float              logtest
least-positive-long-float                logxor
least-positive-normalized-double-float   long-float
least-positive-normalized-long-float     long-float-epsilon
least-positive-normalized-short-float    long-float-negative-epsilon
least-positive-normalized-single-float   long-site-name
least-positive-short-float               loop
least-positive-single-float              loop-finish
length                                   lower-case-p
let                                      machine-instance
let*                                     machine-type

Figure 1.9: Symbols in the COMMON-LISP package (part six of twelve).

machine-version                 mask-field
macro-function                  max
macroexpand                     member
macroexpand-1                   member-if
macrolet                        member-if-not
make-array                      merge
make-broadcast-stream           merge-pathnames
make-concatenated-stream        method
make-condition                  method-combination
make-dispatch-macro-character   method-combination-error
make-echo-stream                method-qualifiers
make-hash-table                 min
make-instance                   minusp
make-instances-obsolete         mismatch
make-list                       mod
make-load-form                  most-negative-double-float
make-load-form-saving-slots     most-negative-fixnum
make-method                     most-negative-long-float
make-package                    most-negative-short-float
make-pathname                   most-negative-single-float
make-random-state               most-positive-double-float
make-sequence                   most-positive-fixnum
make-string                     most-positive-long-float
make-string-input-stream        most-positive-short-float
make-string-output-stream       most-positive-single-float
make-symbol                     muffle-warning
make-synonym-stream             multiple-value-bind
make-two-way-stream             multiple-value-call
makunbound                      multiple-value-list
map                             multiple-value-prog1
map-into                        multiple-value-setq
mapc                            multiple-values-limit
mapcan                          name-char
mapcar                          namestring
mapcon                          nbutlast
maphash                         nconc
mapl                            next-method-p
maplist                         nil

Figure 1.10: Symbols in the COMMON-LISP package (part seven of twelve).

nintersection          package-error
ninth                  package-error-package
no-applicable-method   package-name
no-next-method         package-nicknames
not                    package-shadowing-symbols
notany                 package-use-list
notevery               package-used-by-list
notinline              packagep
nreconc                pairlis
nreverse               parse-error
nset-difference        parse-integer
nset-exclusive-or      parse-namestring
nstring-capitalize     pathname
nstring-downcase       pathname-device
nstring-upcase         pathname-directory
nsublis                pathname-host
nsubst                 pathname-match-p
nsubst-if              pathname-name
nsubst-if-not          pathname-type
nsubstitute            pathname-version
nsubstitute-if         pathnamep
nsubstitute-if-not     peek-char
nth                    phase
nth-value              pi
nthcdr                 plusp
null                   pop
number                 position
numberp                position-if
numerator              position-if-not
nunion                 pprint
oddp                   pprint-dispatch
open                   pprint-exit-if-list-exhausted
open-stream-p          pprint-fill
optimize               pprint-indent
or                     pprint-linear
otherwise              pprint-logical-block
output-stream-p        pprint-newline
package                pprint-pop

Figure 1.11: Symbols in the COMMON-LISP package (part eight of twelve).

pprint-tab                  read-char
pprint-tabular              read-char-no-hang
prin1                       read-delimited-list
prin1-to-string             read-from-string
princ                       read-line
princ-to-string             read-preserving-whitespace
print                       read-sequence
print-not-readable          reader-error
print-not-readable-object   readtable
print-object                readtable-case
print-unreadable-object     readtablep
probe-file                  real
proclaim                    realp
prog                        realpart
prog*                       reduce
prog1                       reinitialize-instance
prog2                       rem
progn                       remf
program-error               remhash
progv                       remove
provide                     remove-duplicates
psetf                       remove-if
psetq                       remove-if-not
push                        remove-method
pushnew                     remprop
quote                       rename-file
random                      rename-package
random-state                replace
random-state-p              require
rassoc                      rest
rassoc-if                   restart
rassoc-if-not               restart-bind
ratio                       restart-case
rational                    restart-name
rationalize                 return
rationalp                   return-from
read                        revappend
read-byte                   reverse

Figure 1.12: Symbols in the COMMON-LISP package (part nine of twelve).

room                           simple-bit-vector
rotatef                        simple-bit-vector-p
round                          simple-condition
row-major-aref                 simple-condition-format-arguments
rplaca                         simple-condition-format-control
rplacd                         simple-error
safety                         simple-string
satisfies                      simple-string-p
sbit                           simple-type-error
scale-float                    simple-vector
schar                          simple-vector-p
search                         simple-warning
second                         sin
sequence                       single-float
serious-condition              single-float-epsilon
set                            single-float-negative-epsilon
set-difference                 sinh
set-dispatch-macro-character   sixth
set-exclusive-or               sleep
set-macro-character            slot-boundp
set-pprint-dispatch            slot-exists-p
set-syntax-from-char           slot-makunbound
setf                           slot-missing
setq                           slot-unbound
seventh                        slot-value
shadow                         software-type
shadowing-import               software-version
shared-initialize              some
shiftf                         sort
short-float                    space
short-float-epsilon            special
short-float-negative-epsilon   special-operator-p
short-site-name                speed
signal                         sqrt
signed-byte                    stable-sort
signum                         standard
simple-array                   standard-char
simple-base-string             standard-char-p

Figure 1.13: Symbols in the COMMON-LISP package (part ten of twelve).

standard-class              sublis
standard-generic-function   subseq
standard-method             subsetp
standard-object             subst
step                        subst-if
storage-condition           subst-if-not
store-value                 substitute
stream                      substitute-if
stream-element-type         substitute-if-not
stream-error                subtypep
stream-error-stream         svref
stream-external-format      sxhash
streamp                     symbol
string                      symbol-function
string-capitalize           symbol-macrolet
string-downcase             symbol-name
string-equal                symbol-package
string-greaterp             symbol-plist
string-left-trim            symbol-value
string-lessp                symbolp
string-not-equal            synonym-stream
string-not-greaterp         synonym-stream-symbol
string-not-lessp            t
string-right-trim           tagbody
string-stream               tailp
string-trim                 tan
string-upcase               tanh
string/=                    tenth
string<                     terpri
string<=                    the
string=                     third
string>                     throw
string>=                    time
stringp                     trace
structure                   translate-logical-pathname
structure-class             translate-pathname
structure-object            tree-equal
style-warning               truename

Figure 1.14: Symbols in the COMMON-LISP package (part eleven of twelve).

truncate                              values-list
two-way-stream                        variable
two-way-stream-input-stream           vector
two-way-stream-output-stream          vector-pop
type                                  vector-push
type-error                            vector-push-extend
type-error-datum                      vectorp
type-error-expected-type              warn
type-of                               warning
typecase                              when
typep                                 wild-pathname-p
unbound-slot                          with-accessors
unbound-slot-instance                 with-compilation-unit
unbound-variable                      with-condition-restarts
undefined-function                    with-hash-table-iterator
unexport                              with-input-from-string
unintern                              with-open-file
union                                 with-open-stream
unless                                with-output-to-string
unread-char                           with-package-iterator
unsigned-byte                         with-simple-restart
untrace                               with-slots
unuse-package                         with-standard-io-syntax
unwind-protect                        write
update-instance-for-different-class   write-byte
update-instance-for-redefined-class   write-char
upgraded-array-element-type           write-line
upgraded-complex-part-type            write-sequence
upper-case-p                          write-string
use-package                           write-to-string
use-value                             y-or-n-p
user-homedir-pathname                 yes-or-no-p
values                                zerop

Figure 1.15: Symbols in the COMMON-LISP package (part twelve of twelve).


File: ansicl,  Node: Syntax,  Next: Evaluation and Compilation,  Prev: Introduction,  Up: Top

2 Syntax
********

* Menu:

* Character Syntax::
* Reader Algorithm::
* Interpretation of Tokens::
* Standard Macro Characters::


File: ansicl,  Node: Character Syntax,  Next: Reader Algorithm,  Up: Syntax

2.1 Character Syntax
====================

The Lisp reader takes characters from a stream, interprets them as a
printed representation of an object, constructs that object, and returns
it.

The syntax described by this chapter is called the “standard syntax”.
Operations are provided by Common Lisp so that various aspects of the
syntax information represented by a readtable can be modified under
program control; see *note Chapter 23 (Reader): Reader.  Except as
explicitly stated otherwise, the syntax used throughout this document is
standard syntax.

* Menu:

* Readtables::
* Variables that affect the Lisp Reader::
* Standard Characters::
* Character Syntax Types::


File: ansicl,  Node: Readtables,  Next: Variables that affect the Lisp Reader,  Up: Character Syntax

2.1.1 Readtables
----------------

Syntax information for use by the Lisp reader is embodied in an object
called a “readtable”.  Among other things, the readtable contains the
association between characters and syntax types.

The next figure lists some defined names that are applicable to
readtables.

*readtable*                     readtable-case
copy-readtable                  readtablep
get-dispatch-macro-character    set-dispatch-macro-character
get-macro-character             set-macro-character
make-dispatch-macro-character   set-syntax-from-char

Figure 2.1: Readtable defined names

2.1.1.1 The Current Readtable
.............................

Several readtables describing different syntaxes can exist, but at any
given time only one, called the “current readtable”, affects the way in
which expressionsinto objects by the Lisp reader.  The current readtable
in a given dynamic environment is the value of ‘*readtable*’ in that
environment.  To make a different readtable become the current
readtable, ‘*readtable*’ can be assigned or bound.

2.1.1.2 The Standard Readtable
..............................

The “standard readtable” conforms to standard syntax.  The consequences
are undefined if an attempt is made to modify the standard readtable.
To achieve the effect of altering or extending standard syntax, a copy
of the standard readtable can be created; see the function *note
copy-readtable::.

The readtable case of the standard readtable is :upcase.

2.1.1.3 The Initial Readtable
.............................

The “initial readtable” is the readtable that is the current readtable
at the time when the Lisp image starts.  At that time, it conforms to
standard syntax.  The initial readtable is distinct from the standard
readtable.  It is permissible for a conforming program to modify the
initial readtable.


File: ansicl,  Node: Variables that affect the Lisp Reader,  Next: Standard Characters,  Prev: Readtables,  Up: Character Syntax

2.1.2 Variables that affect the Lisp Reader
-------------------------------------------

The Lisp reader is influenced not only by the current readtable, but
also by various dynamic variables.  The next figure lists the variables
that influence the behavior of the Lisp reader.

*package*     *read-default-float-format*   *readtable*
*read-base*   *read-suppress*

Figure 2.2: Variables that influence the Lisp reader.


File: ansicl,  Node: Standard Characters,  Next: Character Syntax Types,  Prev: Variables that affect the Lisp Reader,  Up: Character Syntax

2.1.3 Standard Characters
-------------------------

All implementations must support a character repertoire called
‘standard-char’; characters that are members of that repertoire are
called “standard characters”.

The ‘standard-char’ repertoire consists of the non-graphic character
newline, the graphic character space, and the following additional
ninety-four graphic characters or their equivalents:

Graphic ID   Glyph   Description   Graphic ID   Glyph   Description
----------------------------------------------------------------------
LA01         ‘a’     small a       LN01         ‘n’     small n
LA02         ‘A’     capital A     LN02         ‘N’     capital N
LB01         ‘b’     small b       LO01         ‘o’     small o
LB02         ‘B’     capital B     LO02         ‘O’     capital O
LC01         ‘c’     small c       LP01         ‘p’     small p
LC02         ‘C’     capital C     LP02         ‘P’     capital P
LD01         ‘d’     small d       LQ01         ‘q’     small q
LD02         ‘D’     capital D     LQ02         ‘Q’     capital Q
LE01         ‘e’     small e       LR01         ‘r’     small r
LE02         ‘E’     capital E     LR02         ‘R’     capital R
LF01         ‘f’     small f       LS01         ‘s’     small s
LF02         ‘F’     capital F     LS02         ‘S’     capital S
LG01         ‘g’     small g       LT01         ‘t’     small t
LG02         ‘G’     capital G     LT02         ‘T’     capital T
LH01         ‘h’     small h       LU01         ‘u’     small u
LH02         ‘H’     capital H     LU02         ‘U’     capital U
LI01         ‘i’     small i       LV01         ‘v’     small v
LI02         ‘I’     capital I     LV02         ‘V’     capital V
LJ01         ‘j’     small j       LW01         ‘w’     small w
LJ02         ‘J’     capital J     LW02         ‘W’     capital W
LK01         ‘k’     small k       LX01         ‘x’     small x
LK02         ‘K’     capital K     LX02         ‘X’     capital X
LL01         ‘l’     small l       LY01         ‘y’     small y
LL02         ‘L’     capital L     LY02         ‘Y’     capital Y
LM01         ‘m’     small m       LZ01         ‘z’     small z
LM02         ‘M’     capital M     LZ02         ‘Z’     capital Z

Figure 2.3: Standard Character Subrepertoire (Part 1 of 3: Latin
Characters)

Graphic ID   Glyph   Description   Graphic ID   Glyph   Description
----------------------------------------------------------------------
ND01         ‘1’     digit 1       ND06         ‘6’     digit 6
ND02         ‘2’     digit 2       ND07         ‘7’     digit 7
ND03         ‘3’     digit 3       ND08         ‘8’     digit 8
ND04         ‘4’     digit 4       ND09         ‘9’     digit 9
ND05         ‘5’     digit 5       ND10         ‘0’     digit 0

Figure 2.4: Standard Character Subrepertoire (Part 2 of 3: Numeric
Characters)

Graphic ID   Glyph Description
-------------------------------------------------------------
SP02         ‘!’   exclamation mark
SC03         ‘$’   dollar sign
SP04         ‘"’   quotation mark, or double quote
SP05         ‘'’   apostrophe, or [single] quote
SP06         ‘(’   left parenthesis, or open parenthesis
SP07         ‘)’   right parenthesis, or close parenthesis
SP08         ‘,’   comma
SP09         ‘_’   low line, or underscore
SP10         ‘-’   hyphen, or minus [sign]
SP11         ‘.’   full stop, period, or dot
SP12         ‘/’   solidus, or slash
SP13         ‘:’   colon
SP14         ‘;’   semicolon
SP15         ‘?’   question mark
SA01         ‘+’   plus [sign]
SA03         ‘<’   less-than [sign]
SA04         ‘=’   equals [sign]
SA05         ‘>’   greater-than [sign]
SM01         ‘#’   number sign, or sharp[sign]
SM02         ‘%’   percent [sign]
SM03         ‘&’   ampersand
SM04         ‘*’   asterisk, or star
SM05         ‘@’   commercial at, or at-sign
SM06         ‘[’   left [square] bracket
SM07         ‘\’   reverse solidus, or backslash
SM08         ‘]’   right [square] bracket
SM11         ‘{’   left curly bracket, or left brace
SM13         ‘|’   vertical bar
SM14         ‘}’   right curly bracket, or right brace
SD13         ‘`’   grave accent, or backquote
SD15         ‘^’   circumflex accent
SD19         ‘~’   tilde

Figure 2.5: Standard Character Subrepertoire (Part 3 of 3: Special
Characters)

The graphic IDs are not used within Common Lisp, but are provided for
cross reference purposes with ‘ISO 6937/2’.  Note that the first letter
of the graphic ID categorizes the character as follows: L—Latin,
N—Numeric, S—Special.


File: ansicl,  Node: Character Syntax Types,  Prev: Standard Characters,  Up: Character Syntax

2.1.4 Character Syntax Types
----------------------------

The Lisp reader constructs an object from the input text by interpreting
each character according to its syntax type.  The Lisp reader cannot
accept as input everything that the Lisp printer produces, and the Lisp
reader has features that are not used by the Lisp printer.  The Lisp
reader can be used as a lexical analyzer for a more general user-written
parser.

When the Lisp reader is invoked, it reads a single character from the
input stream and dispatches according to the “syntax type” of that
character.  Every character that can appear in the input stream is of
one of the syntax types shown in *note Figure 2.6: PossibleSyntaxTypes.

constituent   macro character   single
                                escape
invalid       multiple escape   whitespace

Figure 2.6: Possible Character Syntax Types

The syntax type of a character in a readtable determines how that
character is interpreted by the Lisp reader while that readtable is the
current readtable.  At any given time, every character has exactly one
syntax type.

*note Figure 2.7: CharSyntaxTypesInStdSyntax.  lists the syntax type of
each character in standard syntax.

character   syntax type                  charactersyntax type
---------------------------------------------------------------------------
Backspace   constituent                  0–9      constituent
Tab         whitespace
Newline     whitespace
Linefeed    whitespace
Page        whitespace
Return      whitespace
Space       whitespace
!           constituent                  ‘@’      constituent
‘"’         terminating macro char       A–Z      constituent
#           non-terminating macro char   ‘[’      constituent
$           constituent                  ‘\’      single escape
%           constituent                  ‘]’      constituent
&           constituent                  ^        constituent
’           terminating macro char       ‘_’      constituent
(           terminating macro char       ‘        terminating macro char
)           terminating macro char       a–z      constituent
‘*’         constituent                  ‘{’      constituent
+           constituent                  ‘|’      multiple escape
,           terminating macro char       ‘}’      constituent
-           constituent                  ‘~’      constituent
.           constituent                  Rubout   constituent
/           constituent

Figure 2.7: Character Syntax Types in Standard Syntax

The characters marked with an asterisk (*) are initially constituents,
but they are not used in any standard Common Lisp notations.  These
characters are explicitly reserved to the programmer.  ‘~’ is not used
in Common Lisp, and reserved to implementors.  ‘$’ and ‘%’ are
alphabeticbut are not used in the names of any standard Common
Lisp defined names.

Whitespaceignored.  Constituent and escape characters are accumulated to
make a token, which is then interpreted as a number or symbol.  Macro
characters trigger the invocation of functions (possibly user-supplied)
that can perform arbitrary parsing actions.  Macro characters are
divided into two kinds, terminating and non-terminating, depending on
whether or not they terminate a token.  The following are descriptions
of each kind of syntax type.

2.1.4.1 Constituent Characters
..............................

Constituent characters are used in tokens.  A “token” is a
representation of a number or a symbol.  Examples of constituent
characters are letters and digits.

Letters in symbol names are sometimes converted to letters in the
opposite case when the name is read; see *note Section 23.1.2 (Effect of
Readtable Case on the Lisp Reader): Effect of Readtable Case on the Lisp
Reader.  Case conversion can be suppressed by the use of single escape
or multiple escape characters.

2.1.4.2 Constituent Traits
..........................

Every character has one or more constituent traits that define how the
character is to be interpreted by the Lisp reader when the character is
a constituent character.  These constituent traits are alphabeticdigit,
package marker, plus sign, minus sign, dot, decimal point, ratio marker,
exponent marker, and invalid.  *note Figure 2.8:
ConstituentTraitsOfStdChars. shows the constituent traits of the
standard characters and of certain semi-standard characters; no
mechanism is provided for changing the constituent trait of a character.
Any character with the alphadigit constituent trait in that figure is a
digit if the current input base is greater than that character’s digit
value, otherwise the character is alphabeticAny character quoted by a
single escape is treated as an alphabetic

constituent   traits
              constituent
              traits
characters    characters
Backspace     invalid
              ‘{’
              alphabetic
Tab           invalid*
              ‘}’
              alphabetic
Newline       invalid*
              +
              alphabetic
Linefeed      invalid*
              -
              alphabetic
Page          invalid*
              .
              alphabetic
Return        invalid*
              /
              alphabetic
Space         invalid*
              A, a
              alphadigit
!             alphabetic
‘"’           alphabetic
#             alphabetic
$             alphabetic
%             alphabetic
&             alphabetic
’             alphabetic
(             alphabetic
)             alphabetic
‘*’           alphabetic
,             alphabetic
0-9           alphadigit
              M, m
              alphadigit
:             package
              marker
              N, n
              alphadigit
;             alphabetic
‘<’           alphabetic
=             alphabetic
‘>’           alphabetic
?             alphabetic
‘@’           alphabetic
‘[’           alphabetic
‘\’           alphabetic
‘]’           alphabetic
^             alphabetic
‘_’           alphabetic
‘             alphabetic
‘|’           alphabetic
‘~’           alphabetic

Figure 2.8: Constituent Traits of Standard Characters and Semi-Standard
Characters

The interpretations in this table apply only to characters whose syntax
type is constituent.  Entries marked with an asterisk (*) are normally
shadowedbecause the indicated characters are of syntax type
whitespacemacro character, single escape, or multiple escape; these
constituent traits apply to them only if their syntax types are changed
to constituent.

2.1.4.3 Invalid Characters
..........................

Characters with the constituent trait invalid cannot ever appear in a
token except under the control of a single escape character.  If an
invalid character is encountered while an object is being read, an error
of type ‘reader-error’ is signaled.  If an invalid character is preceded
by a single escape character, it is treated as an alphabetic

2.1.4.4 Macro Characters
........................

When the Lisp reader encounters a macro character on an input stream,
special parsing of subsequent characters on the input stream is
performed.

A macro character has an associated function called a “reader macro
function” that implements its specialized parsing behavior.  An
association of this kind can be established or modified under control of
a conforming program by using the functions ‘set-macro-character’ and
‘set-dispatch-macro-character’.

Upon encountering a macro character, the Lisp reader calls its reader
macro function, which parses one specially formatted object from the
input stream.  The function either returns the parsed object, or else it
returns no values to indicate that the characters scanned by the
function are being ignored (e.g., in the case of a comment).  Examples
of macro characters are backquote, single-quote, left-parenthesis, and
right-parenthesis.

A macro character is either terminating or non-terminating.  The
difference between terminating and non-terminating macro characters lies
in what happens when such characters occur in the middle of a token.  If
a “non-terminating” macro character occurs in the middle of a token, the
function associated with the non-terminating macro character is not
called, and the non-terminating macro character does not terminate the
token’s name; it becomes part of the name as if the macro character were
really a constituent character.  A “terminating” macro character
terminates any token, and its associated reader macro function is called
no matter where the character appears.  The only non-terminating macro
character in standard syntax is sharpsign.

If a character is a dispatching macro character Cits reader macro
function is a function supplied by the implementation.  This function
reads decimal digit characters until a non-digit CIf any digits were
read, they are converted into a corresponding integer infix parameter P;
otherwise, the infix parameter P is ‘nil’.  The terminating non-digit
C(sometimes called a “sub-character” to emphasize its subordinate role
in the dispatching) that is looked up in the dispatch table associated
with the dispatching macro character CThe reader macro function
associated with the sub-character Cis invoked with three arguments: the
stream, the sub-character Cand the infix parameter P. For more
information about dispatch characters, see the function *note
set-dispatch-macro-character::.

For information about the macro characters that are available in
standard syntax, see *note Section 2.4 (Standard Macro Characters):
Standard Macro Characters.

2.1.4.5 Multiple Escape Characters
..................................

A pair of “multiple escape” characters is used to indicate that an
enclosed sequence of characters, including possible macro characters and
whitespaceare to be treated as alphabeticwith case preserved.  Any
single escape and multiple escape characters that are to appear in the
sequence must be preceded by a single escape character.

Vertical-bar is a multiple escape character in standard syntax.

2.1.4.5.1 Examples of Multiple Escape Characters
................................................

      ;; The following examples assume the readtable case of *readtable*
      ;; and *print-case* are both :upcase.
      (eq 'abc 'ABC) → true
      (eq 'abc '|ABC|) → true
      (eq 'abc 'a|B|c) → true
      (eq 'abc '|abc|) → false

2.1.4.6 Single Escape Character
...............................

A “single escape” is used to indicate that the next character is to be
treated as an alphabeticwith its case preserved, no matter what the
character is or which constituent traits it has.

Backslash is a single escape character in standard syntax.

2.1.4.6.1 Examples of Single Escape Characters
..............................................

      ;; The following examples assume the readtable case of *readtable*
      ;; and *print-case* are both :upcase.
      (eq 'abc '\A\B\C) → true
      (eq 'abc 'a\Bc) → true
      (eq 'abc '\ABC) → true
      (eq 'abc '\abc) → false

2.1.4.7 Whitespace Characters
.............................

Whitespace

Space and newline are whitespacein standard syntax.

2.1.4.7.1 Examples of Whitespace Characters
...........................................

      (length '(this-that)) → 1
      (length '(this - that)) → 3
      (length '(a
                b)) → 2
      (+ 34) → 34
      (+ 3 4) → 7


File: ansicl,  Node: Reader Algorithm,  Next: Interpretation of Tokens,  Prev: Character Syntax,  Up: Syntax

2.2 Reader Algorithm
====================

This section describes the algorithm used by the Lisp reader to parse
objects from an input character stream, including how the Lisp reader
processes macro characters.

When dealing with tokens, the reader’s basic function is to distinguish
representations of symbols from those of numbers.  When a token is
accumulated, it is assumed to represent a number if it satisfies the
syntax for numbers listed in *note Figure 2.9: SyntaxForNumericTokens.
If it does not represent a number, it is then assumed to be a potential
number if it satisfies the rules governing the syntax for a potential
number.  If a valid token is neither a representation of a number nor a
potential number, it represents a symbol.

The algorithm performed by the Lisp reader is as follows:

  1. If at end of file, end-of-file processing is performed as specified
     in ‘read’.  Otherwise, one character, X, is read from the input
     stream, and dispatched according to the syntax type of X to one of
     steps 2 to 7.

  2. If X is an invalid character, an error of type ‘reader-error’ is
     signaled.

  3. If X is a whitespacethen it is discarded and step 1 is re-entered.

  4. If X is a terminating or non-terminating macro character then its
     associated reader macro function is called with two arguments, the
     input stream and X.

     The reader macro function may read characters from the input
     stream; if it does, it will see those characters following the
     macro character.  The Lisp reader may be invoked recursively from
     the reader macro function.

     The reader macro function must not have any side effects other than
     on the input stream; because of backtracking and restarting of the
     ‘read’ operation, front ends to the Lisp reader (e.g., “editors”
     and “rubout handlers”) may cause the reader macro function to be
     called repeatedly during the reading of a single expression in
     which X only appears once.

     The reader macro function may return zero values or one value.  If
     one value is returned, then that value is returned as the result of
     the read operation; the algorithm is done.  If zero values are
     returned, then step 1 is re-entered.

  5. If X is a single escape character then the next character, Y, is
     read, or an error of type ‘end-of-file’ is signaled if at the end
     of file.  Y is treated as if it is a constituent whose only
     constituent trait is alphabeticY is used to begin a token, and step
     8 is entered.

  6. If X is a multiple escape character then a token (initially
     containing no characters) is begun and step 9 is entered.

  7. If X is a constituent character, then it begins a token.  After the
     token is read in, it will be interpreted either as a Lisp object or
     as being of invalid syntax.  If the token represents an object,
     that object is returned as the result of the read operation.  If
     the token is of invalid syntax, an error is signaled.  If X is a
     character with case, it might be replaced with the corresponding
     character of the opposite case, depending on the readtable case of
     the current readtable, as outlined in *note Section 23.1.2 (Effect
     of Readtable Case on the Lisp Reader): Effect of Readtable Case on
     the Lisp Reader.  X is used to begin a token, and step 8 is
     entered.

  8. At this point a token is being accumulated, and an even number of
     multiple escape characters have been encountered.  If at end of
     file, step 10 is entered.  Otherwise, a character, Y, is read, and
     one of the following actions is performed according to its syntax
     type:

        • If Y is a constituent or non-terminating macro character:

             – If Y is a character with case, it might be replaced with
               the corresponding character of the opposite case,
               depending on the readtable case of the current readtable,
               as outlined in *note Section 23.1.2 (Effect of Readtable
               Case on the Lisp Reader): Effect of Readtable Case on the
               Lisp Reader.
             – Y is appended to the token being built.
             – Step 8 is repeated.

        • If Y is a single escape character, then the next character, Z,
          is read, or an error of type ‘end-of-file’ is signaled if at
          end of file.  Z is treated as if it is a constituent whose
          only constituent trait is alphabeticZ is appended to the token
          being built, and step 8 is repeated.

        • If Y is a multiple escape character, then step 9 is entered.

        • If Y is an invalid character, an error of type ‘reader-error’
          is signaled.

        • If Y is a terminating macro character, then it terminates the
          token.  First the character Y is unread (see ‘unread-char’),
          and then step 10 is entered.

        • If Y is a whitespacethe token.  First the character Y is
          unread if appropriate (see ‘read-preserving-whitespace’), and
          then step 10 is entered.

  9. At this point a token is being accumulated, and an odd number of
     multiple escape characters have been encountered.  If at end of
     file, an error of type ‘end-of-file’ is signaled.  Otherwise, a
     character, Y, is read, and one of the following actions is
     performed according to its syntax type:

        • If Y is a constituent, macro, or whitespaceY is treated as a
          constituent whose only constituent trait is alphabeticY is
          appended to the token being built, and step 9 is repeated.

        • If Y is a single escape character, then the next character, Z,
          is read, or an error of type ‘end-of-file’ is signaled if at
          end of file.  Z is treated as a constituent whose only
          constituent trait is alphabeticZ is appended to the token
          being built, and step 9 is repeated.

        • If Y is a multiple escape character, then step 8 is entered.

        • If Y is an invalid character, an error of type ‘reader-error’
          is signaled.

  10. An entire token has been accumulated.  The object represented by
     the token is returned as the result of the read operation, or an
     error of type ‘reader-error’ is signaled if the token is not of
     valid syntax.


File: ansicl,  Node: Interpretation of Tokens,  Next: Standard Macro Characters,  Prev: Reader Algorithm,  Up: Syntax

2.3 Interpretation of Tokens
============================

* Menu:

* Numbers as Tokens::
* Constructing Numbers from Tokens::
* The Consing Dot::
* Symbols as Tokens::
* Valid Patterns for Tokens::
* Package System Consistency Rules::


File: ansicl,  Node: Numbers as Tokens,  Next: Constructing Numbers from Tokens,  Up: Interpretation of Tokens

2.3.1 Numbers as Tokens
-----------------------

When a token is read, it is interpreted as a number or symbol.  The
token is interpreted as a number if it satisfies the syntax for numbers
specified in the next figure.

NUMERIC-TOKEN   ::=   ↓integer | ↓ratio | ↓float
INTEGER         ::=   [SIGN] {DECIMAL-DIGIT}+ DECIMAL-POINT | [SIGN] {DIGIT}+
RATIO           ::=   [SIGN] {DIGIT}+ SLASH {DIGIT}+
FLOAT           ::=   [SIGN] {DECIMAL-DIGIT}* DECIMAL-POINT {DECIMAL-DIGIT}+ [↓exponent]
                      | [SIGN] {DECIMAL-DIGIT}+ [DECIMAL-POINT {DECIMAL-DIGIT}*] ↓exponent
EXPONENT        ::=   EXPONENT-MARKER [SIGN] {DIGIT}+

Figure 2.9: Syntax for Numeric Tokens

SIGN—a sign.
SLASH—a slash
DECIMAL-POINT—a dot.
EXPONENT-MARKER—an exponent marker.
DECIMAL-DIGIT—a digit in radix ‘10’.
DIGIT—a digit in the current input radix.

2.3.1.1 Potential Numbers as Tokens
...................................

To allow implementors and future Common Lisp standards to extend the
syntax of numbers, a syntax for potential numbers is defined that is
more general than the syntax for numbers.  A token is a potential number
if it satisfies all of the following requirements:

  1. The token consists entirely of digits, signs, ratio markers,
     decimal points (‘.’), extension characters (^ or ‘_’), and number
     markers.  A number marker is a letter.  Whether a letter may be
     treated as a number marker depends on context, but no letter that
     is adjacent to another letter may ever be treated as a number
     marker.  Exponent markers are number markers.

  2. The token contains at least one digit.  Letters may be considered
     to be digits, depending on the current input base, but only in
     tokens containing no decimal points.

  3. The token begins with a digit, sign, decimal point, or extension
     character,

     but not a package marker.  The syntax involving a leading package
     marker followed by a potential number is not well-defined.  The
     consequences of the use of notation such as ‘:1’, ‘:1/2’, and
     ‘:2^3’ in a position where an expression appropriate for ‘read’ is
     expected are unspecified.

  4. The token does not end with a sign.

If a potential number has number syntax, a number of the appropriate
type is constructed and returned, if the number is representable in an
implementation.  A number will not be representable in an implementation
if it is outside the boundaries set by the implementation-dependent
constants for numbers.  For example, specifying too large or too small
an exponent for a float may make the number impossible to represent in
the implementation.  A ratio with denominator zero (such as ‘-35/000’)
is not represented in any implementation.  When a token with the syntax
of a number cannot be converted to an internal number, an error of type
‘reader-error’ is signaled.  An error must not be signaled for
specifying too many significant digits for a float; a truncated or
rounded value should be produced.

If there is an ambiguity as to whether a letter should be treated as a
digit or as a number marker, the letter is treated as a digit.

2.3.1.1.1 Escape Characters and Potential Numbers
.................................................

A potential number cannot contain any escape characters.  An escape
character robs the following character of all syntactic qualities,
forcing it to be strictly alphabeticpotential number.  For example, all
of the following representations are interpreted as symbols, not
numbers:

      \256   25\64   1.0\E6   |100|   3\.14159   |3/4|   3\/4   5||

In each case, removing the escape character (or characters) would cause
the token to be a potential number.

2.3.1.1.2 Examples of Potential Numbers
.......................................

As examples, the tokens in the next figure are potential numbers, but
they are not actually numbers, and so are reserved tokens; a conforming
implementation is permitted, but not required, to define their meaning.

‘1b5000’                        ‘777777q’   ‘1.7J’   ‘-3/4+6.7J’   ‘12/25/83’
‘27^19’                         ‘3^4/5’     ‘6//7’   ‘3.1.2.6’     ‘^-43^’
‘3.141_592_653_589_793_238_4’   ‘-3.7+2.6i-6.17j+19.6k’

Figure 2.10: Examples of reserved tokens

The tokens in the next figure are not potential numbers; they are always
treated as symbols:

‘/’      ‘/5’      ‘+’   ‘1+’  ‘1-’
‘foo+’   ‘ab.cd’   ‘_’   ‘^’   ‘^/-’

Figure 2.11: Examples of symbols

The tokens in the next figure are potential numbers if the current input
base is ‘16’, but they are always treated as symbols if the current
input base is ‘10’.

‘bad-face’   ‘25-dec-83’   ‘a/b’   ‘fad_cafe’   ‘f^’

Figure 2.12: Examples of symbols or potential numbers


File: ansicl,  Node: Constructing Numbers from Tokens,  Next: The Consing Dot,  Prev: Numbers as Tokens,  Up: Interpretation of Tokens

2.3.2 Constructing Numbers from Tokens
--------------------------------------

A real is constructed directly from a corresponding numeric token; see
*note Figure 2.9: SyntaxForNumericTokens.

A complex is notated as a ‘#C’ (or ‘#c’) followed by a list of two
reals; see *note Section 2.4.8.11 (Sharpsign C): SharpsignC.

The reader macros ‘#B’, ‘#O’, ‘#X’, and ‘#R’ may also be useful in
controlling the input radix in which rationals are parsed; see *note
Section 2.4.8.7 (Sharpsign B): SharpsignB, *note Section 2.4.8.8
(Sharpsign O): SharpsignO, *note Section 2.4.8.9 (Sharpsign X):
SharpsignX, and *note Section 2.4.8.10 (Sharpsign R): SharpsignR.

This section summarizes the full syntax for numbers.

2.3.2.1 Syntax of a Rational
............................

2.3.2.1.1 Syntax of an Integer
..............................

Integers can be written as a sequence of digits, optionally preceded by
a sign and optionally followed by a decimal point; see *note Figure 2.9:
SyntaxForNumericTokens.  When a decimal point is used, the digits are
taken to be in radix ‘10’; when no decimal point is used, the digits are
taken to be in radix given by the current input base.

For information on how integers are printed, see *note Section
22.1.3.1.1 (Printing Integers): PrintingIntegers.

2.3.2.1.2 Syntax of a Ratio
...........................

Ratios can be written as an optional sign followed by two non-empty
sequences of digits separated by a slash; see *note Figure 2.9:
SyntaxForNumericTokens.  The second sequence may not consist entirely of
zeros.  Examples of ratios are in the next figure.

‘2/3’                  ;This is in canonical form
‘4/6’                  ;A non-canonical form for 2/3
‘-17/23’               ;A ratio preceded by a sign
‘-30517578125/32768’   ;This is (-5/2)^15
‘10/5’                 ;The canonical form for this is ‘2’
‘#o-101/75’            ;Octal notation for -65/61
‘#3r120/21’            ;Ternary notation for 15/7
‘#Xbc/ad’              ;Hexadecimal notation for 188/173
‘#xFADED/FACADE’       ;Hexadecimal notation for 1027565/16435934

Figure 2.13: Examples of Ratios

For information on how ratios are printed, see *note Section 22.1.3.1.2
(Printing Ratios): PrintingRatios.

2.3.2.2 Syntax of a Float
.........................

Floats can be written in either decimal fraction or computerized
scientific notation: an optional sign, then a non-empty sequence of
digits with an embedded decimal point, then an optional decimal exponent
specification.  If there is no exponent specifier, then the decimal
point is required, and there must be digits after it.  The exponent
specifier consists of an exponent marker, an optional sign, and a
non-empty sequence of digits.  If no exponent specifier is present, or
if the exponent marker ‘e’ (or ‘E’) is used, then the format specified
by ‘*read-default-float-format*’ is used.  See *note Figure 2.9:
SyntaxForNumericTokens.

An implementation may provide one or more kinds of float that
collectively make up the type ‘float’.  The letters ‘s’, ‘f’, ‘d’, and
‘l’ (or their respective uppercase equivalents) explicitly specify the
use of the types ‘short-float’, ‘single-float’, ‘double-float’, and
‘long-float’, respectively.

The internal format used for an external representation depends only on
the exponent marker, and not on the number of decimal digits in the
external representation.

The next figure contains examples of notations for floats:

‘0.0’        ;Floating-point zero in default format
‘0E0’        ;As input, this is also floating-point zero in default
             format.
             ;As output, this would appear as ‘0.0’.
‘0e0’        ;As input, this is also floating-point zero in default
             format.
             ;As output, this would appear as ‘0.0’.
‘-.0’        ;As input, this might be a zero or a minus zero,
             ; depending on whether the implementation supports
             ; a distinct minus zero.
             ;As output, ‘0.0’ is zero and ‘-0.0’ is minus zero.
‘0.’         ;On input, the integer zero—not a floating-point
             number!
             ;Whether this appears as ‘0’ or ‘0.’ on output depends
             ;on the value of ‘*print-radix*’.
‘0.0s0’      ;A floating-point zero in short format
‘0s0’        ;As input, this is a floating-point zero in short
             format.
             ;As output, such a zero would appear as ‘0.0s0’
             ; (or as ‘0.0’ if short-float was the default format).
‘6.02E+23’   ;Avogadro’s number, in default format
‘602E+21’    ;Also Avogadro’s number, in default format

Figure 2.14: Examples of Floating-point numbers

For information on how floats are printed, see *note Section 22.1.3.1.3
(Printing Floats): PrintingFloats.

2.3.2.3 Syntax of a Complex
...........................

A complex has a Cartesian structure, with a real part and an imaginary
part each of which is a real.  The parts of a complex are not
necessarily floats but both parts must be of the same type:

either both are rationals, or both are of the same float subtype.  When
constructing a complex, if the specified parts are not the same type,
the parts are converted to be the same type internally (i.e., the
rational part is converted to a float).  An object of type ‘(complex
rational)’ is converted internally and represented thereafter as a
rational if its imaginary part is an integer whose value is 0.

For further information, see *note Section 2.4.8.11 (Sharpsign C):
SharpsignC. and *note Section 22.1.3.1.4 (Printing Complexes):
PrintingComplexes.


File: ansicl,  Node: The Consing Dot,  Next: Symbols as Tokens,  Prev: Constructing Numbers from Tokens,  Up: Interpretation of Tokens

2.3.3 The Consing Dot
---------------------

If a token consists solely of dots (with no escape characters), then an
error of type ‘reader-error’ is signaled, except in one circumstance: if
the token is a single dot and appears in a situation where dotted pair
notation permits a dot, then it is accepted as part of such syntax and
no error is signaled.  See *note Section 2.4.1 (Left-Parenthesis):
Left-Parenthesis.


File: ansicl,  Node: Symbols as Tokens,  Next: Valid Patterns for Tokens,  Prev: The Consing Dot,  Up: Interpretation of Tokens

2.3.4 Symbols as Tokens
-----------------------

Any token that is not a potential number, does not contain a package
marker, and does not consist entirely of dots will always be interpreted
as a symbol.  Any token that is a potential number but does not fit the
number syntax is a reserved token and has an implementation-dependent
interpretation.  In all other cases, the token is construed to be the
name of a symbol.

Examples of the printed representation of symbols are in the next
figure.  For presentational simplicity, these examples assume that the
readtable case of the current readtable is :upcase.

‘FROBBOZ’         The symbol whose name is ‘FROBBOZ’.
‘frobboz’         Another way to notate the same symbol.
‘fRObBoz’         Yet another way to notate it.
‘unwind-protect’  A symbol with a hyphen in its name.
‘+$’              The symbol named ‘+$’.
‘1+’              The symbol named ‘1+’.
‘+1’              This is the integer ‘1’, not a symbol.
‘pascal_style’    This symbol has an underscore in its name.
‘file.rel.43’     This symbol has periods in its name.
‘\(’              The symbol whose name is ‘(’.
‘\+1’             The symbol whose name is ‘+1’.
‘+\1’             Also the symbol whose name is ‘+1’.
‘\frobboz’        The symbol whose name is ‘fROBBOZ’.
‘3.14159265\s0’   The symbol whose name is ‘3.14159265s0’.
‘3.14159265\S0’   A different symbol, whose name is ‘3.14159265S0’.
‘3.14159265s0’    A possible short float approximation to π.

Figure 2.15: Examples of the printed representation of symbols (Part 1
of 2)

‘APL\\360’              The symbol whose name is ‘APL\360’.
‘apl\\360’              Also the symbol whose name is ‘APL\360’.
‘\(b^2\)\ -\ 4*a*c’     The name is ‘(B^2) - 4*A*C’.
                        Parentheses and two spaces in it.
‘\(\b^2\)\ -\4*\a*\c’   The name is ‘(b^2) - 4*a*c’.
                        Letters explicitly lowercase.
‘|"|’                   The same as writing ‘\"’.
‘|(b^2) - 4*a*c|’       The name is ‘(b^2) - 4*a*c’.
‘|frobboz|’             The name is ‘frobboz’, not ‘FROBBOZ’.
‘|APL\360|’             The name is ‘APL360’.
‘|APL\\360|’            The name is ‘APL\360’.
‘|apl\\360|’            The name is ‘apl\360’.
‘|\|\||’                Same as ‘\|\|’ —the name is ‘||’.
‘|(B^2) - 4*A*C|’       The name is ‘(B^2) - 4*A*C’.
                        Parentheses and two spaces in it.
‘|(b^2) - 4*a*c|’       The name is ‘(b^2) - 4*a*c’.

Figure 2.16: Examples of the printed representation of symbols (Part 2
of 2)

In the process of parsing a symbol, it is implementation-dependent which
implementation-defined attributes are removed from the characters
forming a token that represents a symbol.

When parsing the syntax for a symbol, the Lisp reader looks up the name
of that symbol in the current package.  This lookup may involve looking
in other packages whose external symbols are inherited by the current
package.  If the name is found, the corresponding symbol is returned.
If the name is not found (that is, there is no symbol of that name
accessible in the current package), a new symbol is created and is
placed in the current package as an internal symbol.  The current
package becomes the owner (home package) of the symbol, and the symbol
becomes interned in the current package.  If the name is later read
again while this same package is current, the same symbol will be found
and returned.


File: ansicl,  Node: Valid Patterns for Tokens,  Next: Package System Consistency Rules,  Prev: Symbols as Tokens,  Up: Interpretation of Tokens

2.3.5 Valid Patterns for Tokens
-------------------------------

The valid patterns for tokens are summarized in the next figure.

‘nnnnn’               a number
‘xxxxx’               a symbol in the current package
‘:xxxxx’              a symbol in the the ‘KEYWORD’ package
‘ppppp:xxxxx’         an external symbol in the ppppp package
‘ppppp::xxxxx’        a (possibly internal) symbol in the ppppp package
‘:nnnnn’              undefined
‘ppppp:nnnnn’         undefined
‘ppppp::nnnnn’        undefined
‘::aaaaa’             undefined
‘aaaaa:’              undefined
‘aaaaa:aaaaa:aaaaa’   undefined

Figure 2.17: Valid patterns for tokens

Note that nnnnn has number syntax, neither xxxxx nor ppppp has number
syntax, and aaaaa has any syntax.

A summary of rules concerning package markers follows.  In each case,
examples are offered to illustrate the case; for presentational
simplicity, the examples assume that the readtable case of the current
readtable is :upcase.

  1. If there is a single package marker, and it occurs at the beginning
     of the token, then the token is interpreted as a symbol in the
     ‘KEYWORD’ package.  It also sets the ‘symbol-value’ of the
     newly-created symbol to that same symbol so that the symbol will
     self-evaluate.

     For example, ‘:bar’, when read, interns ‘BAR’ as an external symbol
     in the ‘KEYWORD’ package.

  2. If there is a single package marker not at the beginning or end of
     the token, then it divides the token into two parts.  The first
     part specifies a package; the second part is the name of an
     external symbol available in that package.

     For example, ‘foo:bar’, when read, looks up ‘BAR’ among the
     external symbols of the package named ‘FOO’.

  3. If there are two adjacent package markers not at the beginning or
     end of the token, then they divide the token into two parts.  The
     first part specifies a package; the second part is the name of a
     symbol within that package (possibly an internal symbol).

     For example, ‘foo::bar’, when read, interns ‘BAR’ in the package
     named ‘FOO’.

  4. If the token contains no package markers, and does not have
     potential number syntax, then the entire token is the name of the
     symbol.  The symbol is looked up in the current package.

     For example, ‘bar’, when read, interns ‘BAR’ in the current
     package.

  5. The consequences are unspecified if any other pattern of package
     markers in a token is used.  All other uses of package markers
     within names of symbols are not defined by this standard but are
     reserved for implementation-dependent use.

For example, assuming the readtable case of the current readtable is
:upcase, ‘editor:buffer’ refers to the external symbol named ‘BUFFER’
present in the package named ‘editor’, regardless of whether there is a
symbol named ‘BUFFER’ in the current package.  If there is no package
named ‘editor’, or if no symbol named ‘BUFFER’ is present in ‘editor’,
or if ‘BUFFER’ is not exported by ‘editor’, the reader signals a
correctable error.  If ‘editor::buffer’ is seen, the effect is exactly
the same as reading ‘buffer’ with the ‘EDITOR’ package being the current
package.


File: ansicl,  Node: Package System Consistency Rules,  Prev: Valid Patterns for Tokens,  Up: Interpretation of Tokens

2.3.6 Package System Consistency Rules
--------------------------------------

The following rules apply to the package system as long as the value of
‘*package*’ is not changed:

Read-read consistency

     Reading the same symbol name always results in the same symbol.

Print-read consistency

     An interned symbol always prints as a sequence of characters that,
     when read back in, yields the same symbol.

     For information about how the Lisp printer treats symbols, see
     *note Section 22.1.3.3 (Printing Symbols): PrintingSymbols.

Print-print consistency

     If two interned symbols are not the same, then their printed
     representations will be different sequences of characters.

These rules are true regardless of any implicit interning.  As long as
the current package is not changed, results are reproducible regardless
of the order of loading files or the exact history of what symbols were
typed in when.  If the value of ‘*package*’ is changed and then changed
back to the previous value, consistency is maintained.  The rules can be
violated by changing the value of ‘*package*’, forcing a change to
symbols or to packages or to both by continuing from an error, or
calling one of the following functions: ‘unintern’, ‘unexport’,
‘shadow’, ‘shadowing-import’, or ‘unuse-package’.

An inconsistency only applies if one of the restrictions is violated
between two of the named symbols.  ‘shadow’, ‘unexport’, ‘unintern’, and
‘shadowing-import’ can only affect the consistency of symbols with the
same names (under ‘string=’) as the ones supplied as arguments.


File: ansicl,  Node: Standard Macro Characters,  Prev: Interpretation of Tokens,  Up: Syntax

2.4 Standard Macro Characters
=============================

If the reader encounters a macro character, then its associated reader
macro function is invoked and may produce an object to be returned.
This function may read the characters following the macro character in
the stream in any syntax and return the object represented by that
syntax.

Any character can be made to be a macro character.  The macro characters
defined initially in a conforming implementation include the following:

* Menu:

* Left-Parenthesis::
* Right-Parenthesis::
* Single-Quote::
* Semicolon::
* Double-Quote::
* Backquote::
* Comma::
* Sharpsign::
* Re-Reading Abbreviated Expressions::


File: ansicl,  Node: Left-Parenthesis,  Next: Right-Parenthesis,  Up: Standard Macro Characters

2.4.1 Left-Parenthesis
----------------------

The left-parenthesis initiates reading of a list.  ‘read’ is called
recursively to read successive objects until a right parenthesis is
found in the input stream.  A list of the objects read is returned.
Thus

      (a b c)

is read as a list of three objects (the symbols ‘a’, ‘b’, and ‘c’).  The
right parenthesis need not immediately follow the printed representation
of the last object; whitespacecharacters and comments may precede it.

If no objects precede the right parenthesis, it reads as a list of zero
objects (the empty list).

If a token that is just a dot not immediately preceded by an escape
character is read after some object then exactly one more object must
follow the dot, possibly preceded or followed by whitespacefollowed by
the right parenthesis:

      (a b c . d)

This means that the cdr of the last cons in the list is not ‘nil’, but
rather the object whose representation followed the dot.  The above
example might have been the result of evaluating

      (cons 'a (cons 'b (cons 'c 'd)))

Similarly,

      (cons 'this-one 'that-one) → (this-one . that-one)

It is permissible for the object following the dot to be a list:

      (a b c d . (e f . (g))) ≡ (a b c d e f g)

For information on how the Lisp printer prints lists and conses, see
*note Section 22.1.3.5 (Printing Lists and Conses):
PrintingListsAndConses.


File: ansicl,  Node: Right-Parenthesis,  Next: Single-Quote,  Prev: Left-Parenthesis,  Up: Standard Macro Characters

2.4.2 Right-Parenthesis
-----------------------

The right-parenthesis is invalid except when used in conjunction with
the left parenthesis character.  For more information, see *note Section
2.2 (Reader Algorithm): Reader Algorithm.


File: ansicl,  Node: Single-Quote,  Next: Semicolon,  Prev: Right-Parenthesis,  Up: Standard Macro Characters

2.4.3 Single-Quote
------------------

Syntax: ‘'«EXP»’

A single-quote introduces an expression to be “quoted.” Single-quote
followed by an expression EXP is treated by the Lisp reader as an
abbreviation for and is parsed identically to the expression ‘(quote
EXP)’.  See the special operator *note quote::.

2.4.3.1 Examples of Single-Quote
................................

      'foo → FOO
      ''foo → (QUOTE FOO)
      (car ''foo) → QUOTE


File: ansicl,  Node: Semicolon,  Next: Double-Quote,  Prev: Single-Quote,  Up: Standard Macro Characters

2.4.4 Semicolon
---------------

Syntax: ‘;«TEXT»’

A semicolon introduces characters that are to be ignored, such as
comments.  The semicolon and all characters up to and including the next
newline or end of file are ignored.

2.4.4.1 Examples of Semicolon
.............................

      (+ 3 ; three
         4)
     → 7

2.4.4.2 Notes about Style for Semicolon
.......................................

Some text editors make assumptions about desired indentation based on
the number of semicolons that begin a comment.  The following style
conventions are common, although not by any means universal.

2.4.4.2.1 Use of Single Semicolon
.................................

Comments that begin with a single semicolon are all aligned to the same
column at the right (sometimes called the “comment column”).  The text
of such a comment generally applies only to the line on which it
appears.  Occasionally two or three contain a single sentence together;
this is sometimes indicated by indenting all but the first with an
additional space (after the semicolon).

2.4.4.2.2 Use of Double Semicolon
.................................

Comments that begin with a double semicolon are all aligned to the same
level of indentation as a form would be at that same position in the
code.  The text of such a comment usually describes the state of the
program at the point where the comment occurs, the code which follows
the comment, or both.

2.4.4.2.3 Use of Triple Semicolon
.................................

Comments that begin with a triple semicolon are all aligned to the left
margin.  Usually they are used prior to a definition or set of
definitions, rather than within a definition.

2.4.4.2.4 Use of Quadruple Semicolon
....................................

Comments that begin with a quadruple semicolon are all aligned to the
left margin, and generally contain only a short piece of text that serve
as a title for the code which follows, and might be used in the header
or footer of a program that prepares code for presentation as a hardcopy
document.

2.4.4.2.5 Examples of Style for Semicolon
.........................................

     ;;;; Math Utilities

     ;;; FIB computes the the Fibonacci function in the traditional
     ;;; recursive way.

     (defun fib (n)
       (check-type n integer)
       ;; At this point we're sure we have an integer argument.
       ;; Now we can get down to some serious computation.
       (cond ((< n 0)
              ;; Hey, this is just supposed to be a simple example.
              ;; Did you really expect me to handle the general case?
              (error "FIB got ~D as an argument." n))
             ((< n 2) n)             ;fib[0]=0 and fib[1]=1
             ;; The cheap cases didn't work.
             ;; Nothing more to do but recurse.
             (t (+ (fib (- n 1))     ;The traditional formula
                   (fib (- n 2)))))) ; is fib[n-1]+fib[n-2].


File: ansicl,  Node: Double-Quote,  Next: Backquote,  Prev: Semicolon,  Up: Standard Macro Characters

2.4.5 Double-Quote
------------------

Syntax: ‘"«TEXT»"’

The double-quote is used to begin and end a string.  When a double-quote
is encountered, characters are read from the input stream and
accumulated until another double-quote is encountered.  If a single
escape character is seen, the single escape character is discarded, the
next character is accumulated, and accumulation continues.  The
accumulated characters up to but not including the matching double-quote
are made into a simple string and returned.  It is
implementation-dependent which attributes of the accumulated characters
are removed in this process.

Examples of the use of the double-quote character are in the next
figure.

‘"Foo"’                       ;A string with three characters in it
‘""’                          ;An empty string
‘"\"APL\\360?\" he cried."’   ;A string with twenty characters
‘"|x| = |-x|"’                ;A ten-character string

Figure 2.18: Examples of the use of double-quote

Note that to place a single escape character or a double-quote into a
string, such a character must be preceded by a single escape character.
Note, too, that a multiple escape character need not be quoted by a
single escape character within a string.

For information on how the Lisp printer prints strings, see *note
Section 22.1.3.4 (Printing Strings): PrintingStrings.


File: ansicl,  Node: Backquote,  Next: Comma,  Prev: Double-Quote,  Up: Standard Macro Characters

2.4.6 Backquote
---------------

The backquote introduces a template of a data structure to be built.
For example, writing

      `(cond ((numberp ,x) ,@y) (t (print ,x) ,@y))

is roughly equivalent to writing

      (list 'cond
            (cons (list 'numberp x) y)
            (list* 't (list 'print x) y))

Where a comma occurs in the template, the expression following the comma
is to be evaluated to produce an object to be inserted at that point.
Assume ‘b’ has the value 3, for example, then evaluating the form
denoted by ‘`(a b ,b ,(+ b 1) b)’ produces the result ‘(a b 3 4 b)’.

If a comma is immediately followed by an at-sign, then the form
following the at-sign is evaluated to produce a list of objects.  These
objects are then “spliced” into place in the template.  For example, if
‘x’ has the value ‘(a b c)’, then

      `(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))
     → (x (a b c) a b c foo b bar (b c) baz b c)

The backquote syntax can be summarized formally as follows.

   • ‘`BASIC’ is the same as ‘'BASIC’, that is, ‘(quote BASIC)’, for any
     expression BASIC that is not a list or a general vector.

   • ‘`,FORM’ is the same as FORM, for any FORM, provided that the
     representation of FORM does not begin with at-sign or dot.  (A
     similar caveat holds for all occurrences of a form after a comma.)

   • ‘`,@FORM’ has undefined consequences.

   • ‘`(x1 x2 x3 ... xn . atom)’ may be interpreted to mean

           (append [ x1] [ x2] [ x3] ... [ xn] (quote atom))

     where the brackets are used to indicate a transformation of an XJ
     as follows:

        – ‘[FORM]’ is interpreted as ‘(list `FORM)’, which contains a
          backquoted form that must then be further interpreted.

        – ‘[,FORM]’ is interpreted as ‘(list FORM)’.

        – ‘[,@FORM]’ is interpreted as FORM.

   • ‘`(x1 x2 x3 ... xn)’ may be interpreted to mean the same as the
     backquoted form ‘`(x1 x2 x3 ... xn . nil)’, thereby reducing it to
     the previous case.

   • ‘`(x1 x2 x3 ... xn . ,form)’ may be interpreted to mean

           (append [ x1] [ x2] [ x3] ... [ xn] form)

     where the brackets indicate a transformation of an ‘xj’ as
     described above.

   • ‘`(x1 x2 x3 ... xn . ,@form)’ has undefined consequences.

   • ‘`#(x1 x2 x3 ... xn)’ may be interpreted to mean ‘(apply #'vector
     `(x1 x2 x3 ... xn))’.

Anywhere “‘,@’” may be used, the syntax “‘,.’” may be used instead to
indicate that it is permissible to operate destructively on the list
structure produced by the form following the “‘,.’” (in effect, to use
‘nconc’ instead of ‘append’).

If the backquote syntax is nested, the innermost backquoted form should
be expanded first.  This means that if several commas occur in a row,
the leftmost one belongs to the innermost backquote.

An implementation is free to interpret a backquoted form Fas any form
Fthe same under ‘equal’ as the result implied by the above definition,
provided that the side-effect behavior of the substitute form Fis also
consistent with the description given above.  The constructed copy of
the template might or might not share list structure with the template
itself.  As an example, the above definition implies that

      `((,a b) ,c ,@d)

will be interpreted as if it were

      (append (list (append (list a) (list 'b) 'nil)) (list c) d 'nil)

but it could also be legitimately interpreted to mean any of the
following:

      (append (list (append (list a) (list 'b))) (list c) d)
      (append (list (append (list a) '(b))) (list c) d)
      (list* (cons a '(b)) c d)
      (list* (cons a (list 'b)) c d)
      (append (list (cons a '(b))) (list c) d)
      (list* (cons a '(b)) c (copy-list d))

2.4.6.1 Notes about Backquote
.............................

Since the exact manner in which the Lisp reader will parse an expression
involving the backquote reader macro is not specified, an implementation
is free to choose any representation that preserves the semantics
described.

Often an implementation will choose a representation that facilitates
pretty printing of the expression, so that ‘(pprint `(a ,b))’ will
display ‘`(a ,b)’ and not, for example, ‘(list 'a b)’.  However, this is
not a requirement.

Implementors who have no particular reason to make one choice or another
might wish to refer to ‘IEEE Standard for the Scheme Programming
Language’, which identifies a popular choice of representation for such
expressions that might provide useful to be useful compatibility for
some user communities.  There is no requirement, however, that any
conforming implementation use this particular representation.  This
information is provided merely for cross-reference purposes.


File: ansicl,  Node: Comma,  Next: Sharpsign,  Prev: Backquote,  Up: Standard Macro Characters

2.4.7 Comma
-----------

The comma is part of the backquote syntax; see *note Section 2.4.6
(Backquote): Backquote.  Comma is invalid if used other than inside the
body of a backquote expression as described above.


File: ansicl,  Node: Sharpsign,  Next: Re-Reading Abbreviated Expressions,  Prev: Comma,  Up: Standard Macro Characters

2.4.8 Sharpsign
---------------

Sharpsign is a non-terminating dispatching macro character.  It reads an
optional sequence of digits and then one more character, and uses that
character to select a function to run as a reader macro function.

The standard syntax includes constructs introduced by the ‘#’ character.
The syntax of these constructs is as follows: a character that
identifies the type of construct is followed by arguments in some form.
If the character is a letter, its case is not important; ‘#O’ and ‘#o’
are considered to be equivalent, for example.

Certain ‘#’ constructs allow an unsigned decimal number to appear
between the ‘#’ and the character.

The reader macros associated with the dispatching macro character ‘#’
are described later in this section and summarized in the next figure.

dispatch char   purpose                   dispatch char   purpose
-----------------------------------------------------------------------------
Backspace       signals error             ‘{’             undefined*
Tab             signals error             ‘}’             undefined*
Newline         signals error             +               read-time
                                                          conditional
Linefeed        signals error             -               read-time
                                                          conditional
Page            signals error             .               read-time
                                                          evaluation
Return          signals error             /               undefined
Space           signals error             A, a            array
!               undefined*                B, b            binary rational
‘"’             undefined                 C, c            complex number
#               reference to = label      D, d            undefined
$               undefined                 E, e            undefined
%               undefined                 F, f            undefined
&               undefined                 G, g            undefined
’               function abbreviation     H, h            undefined
(               simple vector             I, i            undefined
)               signals error             J, j            undefined
‘*’             bit vector                K, k            undefined
,               undefined                 L, l            undefined
:               uninterned symbol         M, m            undefined
;               undefined                 N, n            undefined
‘<’             signals error             O, o            octal rational
‘=’             labels following object   P, p            pathname
‘>’             undefined                 Q, q            undefined
?               undefined*                R, r            radix-n rational
@               undefined                 S, s            structure
[               undefined*                T, t            undefined
‘\’             character object          U, u            undefined
]               undefined*                V, v            undefined
^               undefined                 W, w            undefined
‘_’             undefined                 X, x            hexadecimal
                                                          rational
‘               undefined                 Y, y            undefined
‘|’             balanced comment          Z, z            undefined
‘~’             undefined                 Rubout          undefined

Figure 2.19: Standard # Dispatching Macro Character Syntax

The combinations marked by an asterisk (*) are explicitly reserved to
the user.  No conforming implementation defines them.

Note also that digits do not appear in the preceding table.  This is
because the notations ‘#0’, ‘#1’, ..., ‘#9’ are reserved for another
purpose which occupies the same syntactic space.  When a digit follows a
sharpsign, it is not treated as a dispatch character.  Instead, an
unsigned integer argument is accumulated and passed as an argument to
the reader macro for the character that follows the digits.  For
example, ‘#2A((1 2) (3 4))’ is a use of ‘#A’ with an argument of ‘2’.

2.4.8.1 Sharpsign Backslash
...........................

Syntax: ‘#\«X»’

When the token X is a single character long, this parses as the literal
character CHAR.  Uppercase and lowercase letters are distinguished after
‘#\’; ‘#\A’ and ‘#\a’ denote different character objects.  Any single
character works after ‘#\’, even those that are normally special to
‘read’, such as left-parenthesis and right-parenthesis.

In the single character case, the X must be followed by a
non-constituent character.  After ‘#\’ is read, the reader backs up over
the slash and then reads a token, treating the initial slash as a single
escape character (whether it really is or not in the current readtable).

When the token X is more than one character long, the X must have the
syntax of a symbol with no embedded package markers.  In this case, the
sharpsign backslash notation parses as the character whose name is
‘(string-upcase X)’; see *note Section 13.1.7 (Character Names):
Character Names.

For information about how the Lisp printer prints character objects, see
*note Section 22.1.3.2 (Printing Characters): PrintingCharacters.

2.4.8.2 Sharpsign Single-Quote
..............................

Any EXPRESSION preceded by ‘#'’ (sharpsign followed by single-quote), as
in ‘#'EXPRESSION’, is treated by the Lisp reader as an abbreviation for
and parsed identically to the expression ‘(function EXPRESSION)’.  See
‘function’.  For example,

     (apply #'+ l) ≡ (apply (function +) l)

2.4.8.3 Sharpsign Left-Parenthesis
..................................

‘#(’ and ‘)’ are used to notate a simple vector.

If an unsigned decimal integer appears between the ‘#’ and ‘(’, it
specifies explicitly the length of the vector.  The consequences are
undefined if the number of objects specified before the closing ‘)’
exceeds the unsigned decimal integer.  If the number of objects supplied
before the closing ‘)’ is less than the unsigned decimal integer but
greater than zero, the last object is used to fill all remaining
elements of the vector.

The consequences are undefined if the unsigned decimal integer is
non-zero and number of objects supplied before the closing ‘)’ is zero.
For example,

      #(a b c c c c)
      #6(a b c c c c)
      #6(a b c)
      #6(a b c c)

all mean the same thing: a vector of length ‘6’ with elements ‘a’, ‘b’,
and four occurrences of ‘c’.  Other examples follow:

      #(a b c)               ;A vector of length 3
      #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)
                             ;A vector containing the primes below 50
      #()                    ;An empty vector

The notation ‘#()’ denotes an empty vector, as does ‘#0()’.

For information on how the Lisp printer prints vectors, see *note
Section 22.1.3.4 (Printing Strings): PrintingStrings, *note Section
22.1.3.6 (Printing Bit Vectors): PrintingBitVectors, or *note Section
22.1.3.7 (Printing Other Vectors): PrintingOtherVectors.

2.4.8.4 Sharpsign Asterisk
..........................

Syntax: ‘#*«BITS»’

A simple bit vector is constructed containing the indicated bits (‘0’’s
and ‘1’’s), where the leftmost BIT has index zero and the subsequent
BITS have increasing indices.

Syntax: ‘#«N»*«BITS»’

With an argument N, the vector to be created is of length N.  If the
number of BITS is less than N but greater than zero, the last bit is
used to fill all remaining bits of the bit vector.

The notations ‘#*’ and ‘#0*’ each denote an empty bit vector.

Regardless of whether the optional numeric argument N is provided, the
token that follows the asterisk is delimited by a normal token
delimiter.  However, (unless the value of ‘*read-suppress*’ is true) an
error of type ‘reader-error’ is signaled if that token is not composed
entirely of ‘0’’s and ‘1’’s, or if N was supplied and the token is
composed of more than N BITS, or if N is greater than one, but no BITS
were specified.  Neither a single escape nor a multiple escape is
permitted in this token.

For information on how the Lisp printer prints bit vectors, see *note
Section 22.1.3.6 (Printing Bit Vectors): PrintingBitVectors.

2.4.8.4.1 Examples of Sharpsign Asterisk
........................................

For example,
       #*101111
      #6*101111
      #6*101
      #6*1011

all mean the same thing: a vector of length ‘6’ with elements ‘1’, ‘0’,
‘1’, ‘1’, ‘1’, and ‘1’.

For example:

      #*         ;An empty bit-vector

2.4.8.5 Sharpsign Colon
.......................

Syntax: ‘#:«SYMBOL-NAME»’

‘#:’ introduces an uninterned symbol whose name is SYMBOL-NAME.  Every
time this syntax is encountered, a distinct uninterned symbol is
created.  The SYMBOL-NAME must have the syntax of a symbol with no
package prefix.

For information on how the Lisp reader prints uninterned symbols, see
*note Section 22.1.3.3 (Printing Symbols): PrintingSymbols.

2.4.8.6 Sharpsign Dot
.....................

‘#.FOO’ is read as the object resulting from the evaluation of the
object represented by FOO.  The evaluation is done during the ‘read’
process, when the ‘#.’ notation is encountered.  The ‘#.’ syntax
therefore performs a read-time evaluation of FOO.

The normal effect of ‘#.’ is inhibited when the value of ‘*read-eval*’
is false.  In that situation, an error of type ‘reader-error’ is
signaled.

For an object that does not have a convenient printed representation, a
form that computes the object can be given using the ‘#.’ notation.

2.4.8.7 Sharpsign B
...................

‘#B’RATIONAL reads RATIONAL in binary (radix 2).  For example,

      #B1101 ≡ 13 ;1101 #b101/11 ≡ 5/3

The consequences are undefined if the token immediately following the
‘#B’ does not have the syntax of a binary (i.e., radix 2) rational.

2.4.8.8 Sharpsign O
...................

‘#O’RATIONAL reads RATIONAL in octal (radix 8).  For example,

      #o37/15 ≡ 31/13
      #o777 ≡ 511
      #o105 ≡ 69 ;105

The consequences are undefined if the token immediately following the
‘#O’ does not have the syntax of an octal (i.e., radix 8) rational.

2.4.8.9 Sharpsign X
...................

‘#X’RATIONAL reads RATIONAL in hexadecimal (radix 16).  The digits above
‘9’ are the letters ‘A’ through ‘F’ (the lowercase letters ‘a’ through
‘f’ are also acceptable).  For example,

      #xF00 ≡ 3840
      #x105 ≡ 261 ;105

The consequences are undefined if the token immediately following the
‘#X’ does not have the syntax of a hexadecimal (i.e., radix 16)
rational.

2.4.8.10 Sharpsign R
....................

‘#NR’

‘#RADIXRRATIONAL’ reads RATIONAL in radix RADIX.  RADIX must consist of
only digits that are interpreted as an integer in decimal radix; its
value must be between 2 and 36 (inclusive).  Only valid digits for the
specified radix may be used.

For example, ‘#3r102’ is another way of writing ‘11’ (decimal), and
‘#11R32’ is another way of writing ‘35’ (decimal).  For radices larger
than 10, letters of the alphabet are used in order for the digits after
‘9’.  No alternate ‘#’ notation exists for the decimal radix since a
decimal point suffices.

The next figure contains examples of the use of ‘#B’, ‘#O’, ‘#X’, and
‘#R’.

‘#2r11010101’   ;Another way of writing ‘213’ decimal
‘#b11010101’    ;Ditto
‘#b+11010101’   ;Ditto
‘#o325’         ;Ditto, in octal radix
‘#xD5’          ;Ditto, in hexadecimal radix
‘#16r+D5’       ;Ditto
‘#o-300’        ;Decimal ‘-192’, written in base 8
‘#3r-21010’     ;Same thing in base 3
‘#25R-7H’       ;Same thing in base 25
‘#xACCEDED’     ;‘181202413’, in hexadecimal radix

Figure 2.20: Radix Indicator Example

The consequences are undefined if the token immediately following the
‘#NR’ does not have the syntax of a rational in radix N.

2.4.8.11 Sharpsign C
....................

‘#C’ reads a following object, which must be a list of length two whose
elements are both reals.  These reals denote, respectively, the real and
imaginary parts of a complex number.  If the two parts as notated are
not of the same data type, then they are converted according to the
rules of floating-point contagion described in *note Section 12.1.1.2
(Contagion in Numeric Operations): NumericContagionRules.

‘#C(REAL IMAG)’ is equivalent to ‘#.(complex (quote REAL) (quote
IMAG))’, except that ‘#C’ is not affected by ‘*read-eval*’.  See the
function *note complex (Function)::.

The next figure contains examples of the use of ‘#C’.

‘#C(3.0s1 2.0s-1)’   ;A complex with small float parts.
‘#C(5 -3) ’          ;A “Gaussian integer”
‘#C(5/3 7.0) ’       ;Will be converted internally to ‘#C(1.66666 7.0)’
‘#C(0 1)’            ;The imaginary unit; that is, i.

Figure 2.21: Complex Number Example

For further information, see *note Section 22.1.3.1.4 (Printing
Complexes): PrintingComplexes. and *note Section 2.3.2.3 (Syntax of a
Complex): SyntaxOfComplexes.

2.4.8.12 Sharpsign A
....................

‘#NA’

‘#NAOBJECT’ constructs an N-dimensional array, using OBJECT as the value
of the :initial-contents argument to ‘make-array’.

For example, ‘#2A((0 1 5) (foo 2 (hot dog)))’ represents a 2-by-3
matrix:

      0       1       5
      foo     2       (hot dog)

In contrast, ‘#1A((0 1 5) (foo 2 (hot dog)))’ represents a vector of
length ‘2’ whose elements are lists:

      (0 1 5) (foo 2 (hot dog))

‘#0A((0 1 5) (foo 2 (hot dog)))’ represents a zero-dimensional array
whose sole element is a list:

      ((0 1 5) (foo 2 (hot dog)))

‘#0A foo’ represents a zero-dimensional array whose sole element is the
symbol ‘foo’.  The notation ‘#1A foo’ is not valid because ‘foo’ is not
a sequence.

If some dimension of the array whose representation is being parsed is
found to be ‘0’, all dimensions to the right (i.e., the higher numbered
dimensions) are also considered to be ‘0’.

For information on how the Lisp printer prints arrays, see *note Section
22.1.3.4 (Printing Strings): PrintingStrings, *note Section 22.1.3.6
(Printing Bit Vectors): PrintingBitVectors, *note Section 22.1.3.7
(Printing Other Vectors): PrintingOtherVectors, or *note Section
22.1.3.8 (Printing Other Arrays): PrintingOtherArrays.

2.4.8.13 Sharpsign S
....................

‘#s(name slot1 value1 slot2 value2 ...)’ denotes a structure.  This is
valid only if NAME is the name of a structure type already defined by
‘defstruct’ and if the structure type has a standard constructor
function.  Let CM stand for the name of this constructor function; then
this syntax is equivalent to

      #.(cm keyword1 'value1 keyword2 'value2 ...)

where each KEYWORDJ is the result of computing

      (intern (string slotj) (find-package 'keyword))

The net effect is that the constructor function is called with the
specified slots having the specified values.  (This coercion feature is
deprecated; in the future, keyword names will be taken in the package
they are read in, so symbols that are actually in the ‘KEYWORD’ package
should be used if that is what is desired.)

Whatever object the constructor function returns is returned by the ‘#S’
syntax.

For information on how the Lisp printer prints structures, see *note
Section 22.1.3.12 (Printing Structures): PrintingStructures.

2.4.8.14 Sharpsign P
....................

‘#P’ reads a following object, which must be a string.

‘#P«EXPRESSION»’ is equivalent to ‘#.(parse-namestring '«EXPRESSION»)’,
except that ‘#P’ is not affected by ‘*read-eval*’.

For information on how the Lisp printer prints pathnames, see *note
Section 22.1.3.11 (Printing Pathnames): PrintingPathnames.

2.4.8.15 Sharpsign Equal-Sign
.............................

‘#N=’

‘#N=OBJECT’ reads as whatever object has OBJECT as its printed
representation.  However, that object is labeled by N, a required
unsigned decimal integer, for possible reference by the syntax ‘#N#’.
The scope of the label is the expression being read by the outermost
call to ‘read’; within this expression, the same label may not appear
twice.

2.4.8.16 Sharpsign Sharpsign
............................

‘#N#’

‘#N#’, where N is a required unsigned decimal integer, provides a
reference to some object labeled by ‘#N=’; that is, ‘#N#’ represents a
pointer to the same (‘eq’) object labeled by ‘#N=’.  For example, a
structure created in the variable ‘y’ by this code:

      (setq x (list 'p 'q))
      (setq y (list (list 'a 'b) x 'foo x))
      (rplacd (last y) (cdr y))

could be represented in this way:

      ((a b) . #1=(#2=(p q) foo #2# . #1#))

Without this notation, but with ‘*print-length*’ set to ‘10’ and
‘*print-circle*’ set to ‘nil’, the structure would print in this way:

      ((a b) (p q) foo (p q) (p q) foo (p q) (p q) foo (p q) ...)

A reference ‘#N#’ may only occur after a label ‘#N=’; forward references
are not permitted.  The reference may not appear as the labeled object
itself (that is, ‘#N=#N#’) may not be written because the object labeled
by ‘#N=’ is not well defined in this case.

2.4.8.17 Sharpsign Plus
.......................

‘#+’ provides a read-time conditionalization facility; the syntax is
‘#+TEST EXPRESSION’.  If the feature expression TEST succeeds, then this
textual notation represents an object whose printed representation is
EXPRESSION.  If the feature expression TEST fails, then this textual
notation is treated as whitespacethat is, it is as if the “‘#+’ TEST
EXPRESSION” did not appear and only a space appeared in its place.

For a detailed description of success and failure in feature
expressions, see *note Section 24.1.2.1 (Feature Expressions):
FeatureExpressions.

‘#+’ operates by first reading the feature expression and then skipping
over the FORM if the feature expression fails.  While reading the TEST,
the current package is the ‘KEYWORD’ package.  Skipping over the FORM is
accomplished by binding ‘*read-suppress*’ to true and then calling
‘read’.

For examples, see *note Section 24.1.2.1.1 (Examples of Feature
Expressions): FeatureExpExamples.

2.4.8.18 Sharpsign Minus
........................

‘#-’ is like ‘#+’ except that it skips the EXPRESSION if the TEST
succeeds; that is,

     #-TEST EXPRESSION ≡ #+(not TEST) EXPRESSION

For examples, see *note Section 24.1.2.1.1 (Examples of Feature
Expressions): FeatureExpExamples.

2.4.8.19 Sharpsign Vertical-Bar
...............................

‘#|...|#’ is treated as a comment by the reader.  It must be balanced
with respect to other occurrences of ‘#|’ and ‘|#’, but otherwise may
contain any characters whatsoever.

2.4.8.19.1 Examples of Sharpsign Vertical-Bar
.............................................

The following are some examples that exploit the ‘#|...|#’ notation:

     ;;; In this example, some debugging code is commented out with #|...|#
     ;;; Note that this kind of comment can occur in the middle of a line
     ;;; (because a delimiter marks where the end of the comment occurs)
     ;;; where a semicolon comment can only occur at the end of a line
     ;;; (because it comments out the rest of the line).
      (defun add3 (n) #|(format t "~&Adding 3 to ~D." n)|# (+ n 3))

     ;;; The examples that follow show issues related to #| ... |# nesting.

     ;;; In this first example, #| and |# always occur properly paired,
     ;;; so nesting works naturally.
      (defun mention-fun-fact-1a ()
        (format t "CL uses ; and #|...|# in comments."))
     → MENTION-FUN-FACT-1A
      (mention-fun-fact-1a)
     ▷ CL uses ; and #|...|# in comments.
     → NIL
      #| (defun mention-fun-fact-1b ()
           (format t "CL uses ; and #|...|# in comments.")) |#
      (fboundp 'mention-fun-fact-1b) → NIL

     ;;; In this example, vertical-bar followed by sharpsign needed to appear
     ;;; in a string without any matching sharpsign followed by vertical-bar
     ;;; having preceded this.  To compensate, the programmer has included a
     ;;; slash separating the two characters.  In case 2a, the slash is
     ;;; unnecessary but harmless, but in case 2b, the slash is critical to
     ;;; allowing the outer #| ... |# pair match.  If the slash were not present,
     ;;; the outer comment would terminate prematurely.
      (defun mention-fun-fact-2a ()
        (format t "Don't use |\# unmatched or you'll get in trouble!"))
     → MENTION-FUN-FACT-2A
      (mention-fun-fact-2a)
     ▷ Don't use |# unmatched or you'll get in trouble!
     → NIL
      #| (defun mention-fun-fact-2b ()
           (format t "Don't use |\# unmatched or you'll get in trouble!") |#
      (fboundp 'mention-fun-fact-2b) → NIL

     ;;; In this example, the programmer attacks the mismatch problem in a
     ;;; different way.  The sharpsign vertical bar in the comment is not needed
     ;;; for the correct parsing of the program normally (as in case 3a), but
     ;;; becomes important to avoid premature termination of a comment when such
     ;;; a program is commented out (as in case 3b).
      (defun mention-fun-fact-3a () ; #|
        (format t "Don't use |# unmatched or you'll get in trouble!"))
     → MENTION-FUN-FACT-3A
      (mention-fun-fact-3a)
     ▷ Don't use |# unmatched or you'll get in trouble!
     → NIL
      #|
      (defun mention-fun-fact-3b () ; #|
        (format t "Don't use |# unmatched or you'll get in trouble!"))
      |#
      (fboundp 'mention-fun-fact-3b) → NIL

2.4.8.19.2 Notes about Style for Sharpsign Vertical-Bar
.......................................................

Some text editors that purport to understand Lisp syntax treat any
‘|...|’ as balanced pairs that cannot nest (as if they were just
balanced pairs of the multiple escapes used in notating certain
symbols).  To compensate for this deficiency, some programmers use the
notation ‘#||...#||...||#...||#’ instead of ‘#|...#|...|#...|#’.  Note
that this alternate usage is not a different reader macro; it merely
exploits the fact that the additional vertical-bars occur within the
comment in a way that tricks certain text editor into better supporting
nested comments.  As such, one might sometimes see code like:

      #|| (+ #|| 3 ||# 4 5) ||#

Such code is equivalent to:

      #| (+ #| 3 |# 4 5) |#

2.4.8.20 Sharpsign Less-Than-Sign
.................................

‘#<’ is not valid reader syntax.  The Lisp reader will signal an error
of type ‘reader-error’ on encountering ‘#<’.  This syntax is typically
used in the printed representation of objects that cannot be read back
in.

2.4.8.21 Sharpsign Whitespace
.............................

‘#’ followed immediately by whitespaceThe Lisp reader will signal an
error of type ‘reader-error’ if it encounters the reader macro notation
‘#<Newline>’ or ‘#<Space>’.

2.4.8.22 Sharpsign Right-Parenthesis
....................................

This is not valid reader syntax.

The Lisp reader will signal an error of type ‘reader-error’ upon
encountering ‘#)’.


File: ansicl,  Node: Re-Reading Abbreviated Expressions,  Prev: Sharpsign,  Up: Standard Macro Characters

2.4.9 Re-Reading Abbreviated Expressions
----------------------------------------

Note that the Lisp reader will generally signal an error of type
‘reader-error’ when reading an expressionabbreviated because of length
or level limits (see ‘*print-level*’, ‘*print-length*’, and
‘*print-lines*’) due to restrictions on “‘..’”, “‘...’”, “‘#’” followed
by whitespaceand “‘#)’”.


File: ansicl,  Node: Evaluation and Compilation,  Next: Types and Classes,  Prev: Syntax,  Up: Top

3 Evaluation and Compilation
****************************

* Menu:

* Evaluation::
* Compilation::
* Declarations::
* Lambda Lists::
* Error Checking in Function Calls::
* Traversal Rules and Side Effects::
* Destructive Operations::

Dictionary

* lambda (Symbol)::
* lambda (Macro)::
* compile::
* eval::
* eval-when::
* load-time-value::
* quote::
* compiler-macro-function::
* define-compiler-macro::
* defmacro::
* macro-function::
* macroexpand; macroexpand-1::
* define-symbol-macro::
* symbol-macrolet::
* *macroexpand-hook*::
* proclaim::
* declaim::
* declare::
* ignore; ignorable::
* dynamic-extent::
* type::
* inline; notinline::
* ftype::
* declaration::
* optimize::
* special::
* locally::
* the::
* special-operator-p::
* constantp::


File: ansicl,  Node: Evaluation,  Next: Compilation,  Up: Evaluation and Compilation

3.1 Evaluation
==============

Execution of code can be accomplished by a variety of means ranging from
direct interpretation of a form representing a program to invocation of
compiled code produced by a compiler.

“Evaluation” is the process by which a program is executed in Common
Lisp.  The mechanism of evaluation is manifested both implicitly through
the effect of the Lisp read-eval-print loop, and explicitly through the
presence of the functions ‘eval’, ‘compile’, ‘compile-file’, and ‘load’.
Any of these facilities might share the same execution strategy, or each
might use a different one.

The behavior of a conforming program processed by ‘eval’ and by
‘compile-file’ might differ; see *note Section 3.2.2.3 (Semantic
Constraints): SemanticConstraints.

Evaluation can be understood in terms of a model in which an interpreter
recursively traverses a form performing each step of the computation as
it goes.  This model, which describes the semantics of Common
Lisp programs, is described in *note Section 3.1.2 (The Evaluation
Model): The Evaluation Model.

* Menu:

* Introduction to Environments::
* The Evaluation Model::
* Lambda Expressions::
* Closures and Lexical Binding::
* Shadowing::
* Extent::
* Return Values::


File: ansicl,  Node: Introduction to Environments,  Next: The Evaluation Model,  Up: Evaluation

3.1.1 Introduction to Environments
----------------------------------

A “binding” is an association between a name and that which the name
denotes.  Bindings are established in a lexical environment or a dynamic
environment by particular special operators.

An “environment” is a set of bindings and other information used during
evaluation (e.g., to associate meanings with names).

Bindings in an environment are partitioned into “namespaces”.  A single
name can simultaneously have more than one associated binding per
environment, but can have only one associated binding per namespace.

3.1.1.1 The Global Environment
..............................

The “global environment” is that part of an environment that contains
bindings with both indefinite scope and indefinite extent.  The global
environment contains, among other things, the following:

   • bindings of dynamic variables and constant variables.
   • bindings of functions, macros, and special operators.
   • bindings of compiler macros.
   • bindings of type and class names
   • information about proclamations.

3.1.1.2 Dynamic Environments
............................

A “dynamic environment” for evaluation is that part of an environment
that contains bindings whose duration is bounded by points of
establishment and disestablishment within the execution of the form that
established the binding.  A dynamic environment contains, among other
things, the following:

   • bindings for dynamic variables.
   • information about active catch tags.
   • information about exit points established by ‘unwind-protect’.
   • information about active handlers and restarts.

The dynamic environment that is active at any given point in the
execution of a program is referred to by definite reference as “the
current dynamic environment,” or sometimes as just “the dynamic
environment.”

Within a given namespace, a name is said to be bound in a dynamic
environment if there is a binding associated with its name in the
dynamic environment or, if not, there is a binding associated with its
name in the global environment.

3.1.1.3 Lexical Environments
............................

A “lexical environment” for evaluation at some position in a program is
that part of the environment that contains information having lexical
scope within the forms containing that position.  A lexical environment
contains, among other things, the following:

   • bindings of lexical variables and symbol macros.
   • bindings of functions and macros.  (Implicit in this is information
     about those compiler macros that are locally disabled.)
   • bindings of block tags.
   • bindings of go tags.
   • information about declarations.

The lexical environment that is active at any given position in a
program being semantically processed is referred to by definite
reference as “the current lexical environment,” or sometimes as just
“the lexical environment.”

Within a given namespace, a name is said to be bound in a lexical
environment if there is a binding associated with its name in the
lexical environment or, if not, there is a binding associated with its
name in the global environment.

3.1.1.3.1 The Null Lexical Environment
......................................

The “null lexical environment” is equivalent to the global environment.

Although in general the representation of an environment object is
implementation-dependent, ‘nil’ can be used in any situation where an
environment object is called for in order to denote the null lexical
environment.

3.1.1.4 Environment Objects
...........................

Some operators make use of an object, called an “environment object”,
that represents the set of lexical bindings needed to perform semantic
analysis on a form in a given lexical environment.  The set of bindings
in an environment object may be a subset of the bindings that would be
needed to actually perform an evaluation; for example, values associated
with variable names and function names in the corresponding lexical
environment might not be available in an environment object.

The type and nature of an environment object is
implementation-dependent.  The values of environment parameters to macro
functions are examples of environment objects.

The object ‘nil’ when used as an environment object denotes the null
lexical environment; see *note Section 3.1.1.3.1 (The Null Lexical
Environment): NullLexicalEnv.


File: ansicl,  Node: The Evaluation Model,  Next: Lambda Expressions,  Prev: Introduction to Environments,  Up: Evaluation

3.1.2 The Evaluation Model
--------------------------

A Common Lisp system evaluates forms with respect to lexical, dynamic,
and global environments.  The following sections describe the components
of the Common Lisp evaluation model.

3.1.2.1 Form Evaluation
.......................

Forms fall into three categories: symbols, conses, and self-evaluating
objects.  The following sections explain these categories.

3.1.2.1.1 Symbols as Forms
..........................

If a form is a symbol, then it is either a symbol macro or a variable.

The symbol names a symbol macro if there is a binding of the symbol as a
symbol macro in the current lexical environment (see
‘define-symbol-macro’ and ‘symbol-macrolet’).  If the symbol is a symbol
macro, its expansion function is obtained.  The expansion function is a
function of two arguments, and is invoked by calling the macroexpand
hook with the expansion function as its first argument, the symbol as
its second argument, and an environment object (corresponding to the
current lexical environment) as its third argument.  The macroexpand
hook, in turn, calls the expansion function with the form as its first
argument and the environment as its second argument.  The value of the
expansion function, which is passed through by the macroexpand hook, is
a form.  This resulting form is processed in place of the original
symbol.

If a form is a symbol that is not a symbol macro, then it is the name of
a variable, and the value of that variable is returned.  There are three
kinds of variables: lexical variables, dynamic variables, and constant
variables.  A variable can store one object.  The main operations on a
variable are to readto writeits value.

An error of type ‘unbound-variable’ should be signaled if an unbound
variable is referenced.

Non-constant variables can be assigned by using ‘setq’ or boundThe next
figure lists some defined names that are applicable to assigning,
binding, and defining variables.

boundp         let                   progv
defconstant    let*                  psetq
defparameter   makunbound            set
defvar         multiple-value-bind   setq
lambda         multiple-value-setq   symbol-value

Figure 3.1: Some Defined Names Applicable to Variables

The following is a description of each kind of variable.

3.1.2.1.1.1 Lexical Variables
.............................

A lexical variable is a variable that can be referenced only within the
lexical scope of the form that establishes that variable; lexical
variables have lexical scope.  Each time a form creates a lexical
binding of a variable, a fresh binding is established.

Within the scope of a binding for a lexical variable name, uses of that
name as a variable are considered to be references to that binding
except where the variable is shadowedby a form that establishes a fresh
binding for that variable name, or by a form that locally declares the
name ‘special’.

A lexical variable always has a value.  There is no operator that
introduces a binding for a lexical variable without giving it an initial
value, nor is there any operator that can make a lexical variable be
unbound.

Bindings of lexical variables are found in the lexical environment.

3.1.2.1.1.2 Dynamic Variables
.............................

A variable is a dynamic variable if one of the following conditions
hold:

   • It is locally declared or globally proclaimed ‘special’.

   • It occurs textually within a form that creates a dynamic binding
     for a variable of the same name, and the binding is not
     shadowedthat creates a lexical binding of the same variable name.

A dynamic variable can be referenced at any time in any program; there
is no textual limitation on references to dynamic variables.  At any
given time, all dynamic variables with a given name refer to exactly one
binding, either in the dynamic environment or in the global environment.

The value part of the binding for a dynamic variable might be empty; in
this case, the dynamic variable is said to have no value, or to be
unbound.  A dynamic variable can be made unbound by using ‘makunbound’.

The effect of binding a dynamic variable is to create a new binding to
which all references to that dynamic variable in any program refer for
the duration of the evaluation of the form that creates the dynamic
binding.

A dynamic variable can be referenced outside the dynamic extent of a
form that binds it.  Such a variable is sometimes called a “global
variable” but is still in all respects just a dynamic variable whose
binding happens to exist in the global environment rather than in some
dynamic environment.

A dynamic variable is unbound unless and until explicitly assigned a
value, except for those variables whose initial value is defined in this
specification or by an implementation.

3.1.2.1.1.3 Constant Variables
..............................

Certain variables, called constant variables, are reserved as “named
constants.” The consequences are undefined if an attempt is made to
assign a value to, or create a binding for a constant variable, except
that a ‘compatible’ redefinition of a constant variable using
‘defconstant’ is permitted; see the macro *note defconstant::.

Keywords, symbols defined by Common Lisp or the implementation as
constant (such as ‘nil’, ‘t’, and ‘pi’), and symbols declared as
constant using ‘defconstant’ are constant variables.

3.1.2.1.1.4 Symbols Naming Both Lexical and Dynamic Variables
.............................................................

The same symbol can name both a lexical variable and a dynamic variable,
but never in the same lexical environment.

In the following example, the symbol ‘x’ is used, at different times, as
the name of a lexical variable and as the name of a dynamic variable.

      (let ((x 1))            ;Binds a special variable X
        (declare (special x))
        (let ((x 2))          ;Binds a lexical variable X
          (+ x                ;Reads a lexical variable X
             (locally (declare (special x))
                      x))))   ;Reads a special variable X
     → 3

3.1.2.1.2 Conses as Forms
.........................

A cons that is used as a form is called a compound form.

If the car of that compound form is a symbol, that symbol is the name of
an operator, and the form is either a special form, a macro form, or a
function form, depending on the function binding of the operator in the
current lexical environment.  If the operator is neither a special
operator nor a macro name, it is assumed to be a function name (even if
there is no definition for such a function).

If the car of the compound form is not a symbol, then that car must be a
lambda expression, in which case the compound form is a lambda form.

How a compound form is processed depends on whether it is classified as
a special form, a macro form, a function form, or a lambda form.

3.1.2.1.2.1 Special Forms
.........................

A special form is a form with special syntax, special evaluation rules,
or both, possibly manipulating the evaluation environment, control flow,
or both.  A special operator has access to the current lexical
environment and the current dynamic environment.  Each special operator
defines the manner in which its subexpressions are treated—which are
forms, which are special syntax, etc.

Some special operators create new lexical or dynamic environments for
use during the evaluation of subforms of the special form.  For example,
‘block’ creates a new lexical environment that is the same as the one in
force at the point of evaluation of the ‘block’ form with the addition
of a binding of the ‘block’ name to an exit point from the ‘block’.

The set of special operator names is fixed in Common Lisp; no way is
provided for the user to define a special operator.  The next
figure lists all of the Common Lisp symbols that have definitions as
special operators.

block       let*                   return-from
catch       load-time-value        setq
eval-when   locally                symbol-macrolet
flet        macrolet               tagbody
function    multiple-value-call    the
go          multiple-value-prog1   throw
if          progn                  unwind-protect
labels      progv
let         quote

Figure 3.2: Common Lisp Special Operators

3.1.2.1.2.2 Macro Forms
.......................

If the operator names a macro, its associated macro function is applied
to the entire form and the result of that application is used in place
of the original form.

Specifically, a symbol names a macro in a given lexical environment if
‘macro-function’ is true of the symbol and that environment.  The
function returned by ‘macro-function’ is a function of two arguments,
called the expansion function.  The expansion function is invoked by
calling the macroexpand hook with the expansion function as its first
argument, the entire macro form as its second argument, and an
environment object (corresponding to the current lexical environment) as
its third argument.  The macroexpand hook, in turn, calls the expansion
function with the form as its first argument and the environment as its
second argument.  The value of the expansion function, which is passed
through by the macroexpand hook, is a form.  The returned form is
evaluated in place of the original form.

The consequences are undefined if a macro function destructively
modifies any part of its form argument.

A macro name is not a function designator, and cannot be used as the
FUNCTION argument to functions such as ‘apply’, ‘funcall’, or ‘map’.

An implementation is free to implement a Common Lisp special operator as
a macro.  An implementation is free to implement any macro operator as a
special operator, but only if an equivalent definition of the macro is
also provided.

The next figure lists some defined names that are applicable to macros.

*macroexpand-hook*   macro-function   macroexpand-1
defmacro             macroexpand      macrolet

Figure 3.3: Defined names applicable to macros

3.1.2.1.2.3 Function Forms
..........................

If the operator is a symbol naming a function, the form represents a
function form, and the cdr of the list contains the forms which when
evaluated will supply the arguments passed to the function.

When a function name is not defined, an error of type
‘undefined-function’ should be signaled at run time; see *note Section
3.2.2.3 (Semantic Constraints): SemanticConstraints.

A function form is evaluated as follows:

The subforms in the cdr of the original form are evaluated in
left-to-right order in the current lexical and dynamic environments.
The primary value of each such evaluation becomes an argument to the
named function; any additional values returned by the subforms are
discarded.

The functional value of the operator is retrieved from the lexical
environment, and that function is invoked with the indicated arguments.

Although the order of evaluation of the argument subforms themselves is
strictly left-to-right, it is not specified whether the definition of
the operator in a function form is looked up before the evaluation of
the argument subforms, after the evaluation of the argument subforms, or
between the evaluation of any two argument subforms if there is more
than one such argument subform.  For example, the following might return
23 or 24.

      (defun foo (x) (+ x 3))
      (defun bar () (setf (symbol-function 'foo) #'(lambda (x) (+ x 4))))
      (foo (progn (bar) 20))

A binding for a function name can be established in one of several ways.
A binding for a function name in the global environment can be
established by ‘defun’, ‘setf’ of ‘fdefinition’, ‘setf’ of
‘symbol-function’, ‘ensure-generic-function’, ‘defmethod’ (implicitly,
due to ‘ensure-generic-function’), or ‘defgeneric’.  A binding for a
function name in the lexical environment can be established by ‘flet’ or
‘labels’.

The next figure lists some defined names that are applicable to
functions.

apply                  fdefinition   mapcan
call-arguments-limit   flet          mapcar
complement             fmakunbound   mapcon
constantly             funcall       mapl
defgeneric             function      maplist
defmethod              functionp     multiple-value-call
defun                  labels        reduce
fboundp                map           symbol-function

Figure 3.4: Some function-related defined names

3.1.2.1.2.4 Lambda Forms
........................

A lambda form is similar to a function form, except that the function
name is replaced by a lambda expression.

A lambda form is equivalent to using funcall of a lexical closure of the
lambda expression on the given arguments.  (In practice, some compilers
are more likely to produce inline code for a lambda form than for an
arbitrary named function that has been declared ‘inline’; however, such
a difference is not semantic.)

For further information, see *note Section 3.1.3 (Lambda Expressions):
Lambda Expressions.

3.1.2.1.3 Self-Evaluating Objects
.................................

A form that is neither a symbol nor a cons is defined to be a
self-evaluating object.  Evaluating such an object yields the same
object as a result.

Certain specific symbols and conses might also happen to be
“self-evaluating” but only as a special case of a more general set of
rules for the evaluation of symbols and conses; such objects are not
considered to be self-evaluating objects.

The consequences are undefined if literal objects (including
self-evaluating objects) are destructively modified.

3.1.2.1.3.1 Examples of Self-Evaluating Objects
...............................................

Numbers, pathnames, and arrays are examples of self-evaluating objects.

      3 → 3
      #c(2/3 5/8) → #C(2/3 5/8)
      #p"S:[BILL]OTHELLO.TXT" → #P"S:[BILL]OTHELLO.TXT"
      #(a b c) → #(A B C)
      "fred smith" → "fred smith"


File: ansicl,  Node: Lambda Expressions,  Next: Closures and Lexical Binding,  Prev: The Evaluation Model,  Up: Evaluation

3.1.3 Lambda Expressions
------------------------

In a lambda expression, the body is evaluated in a lexical environment
that is formed by adding the binding of each parameter in the lambda
list with the corresponding value from the arguments to the current
lexical environment.

For further discussion of how bindings are established based on the
lambda list, see *note Section 3.4 (Lambda Lists): Lambda Lists.

The body of a lambda expression is an implicit progn; the values it
returns are returned by the lambda expression.


File: ansicl,  Node: Closures and Lexical Binding,  Next: Shadowing,  Prev: Lambda Expressions,  Up: Evaluation

3.1.4 Closures and Lexical Binding
----------------------------------

A lexical closure is a function that can refer to and alter the values
of lexical bindings established by binding forms that textually include
the function definition.

Consider this code, where ‘x’ is not declared ‘special’:

      (defun two-funs (x)
        (list (function (lambda () x))
              (function (lambda (y) (setq x y)))))
      (setq funs (two-funs 6))
      (funcall (car funs)) → 6
      (funcall (cadr funs) 43) → 43
      (funcall (car funs)) → 43

The ‘function’ special form coerces a lambda expression into a closure
in which the lexical environment in effect when the special form is
evaluated is captured along with the lambda expression.

The function ‘two-funs’ returns a list of two functions, each of which
refers to the binding of the variable ‘x’ created on entry to the
function ‘two-funs’ when it was called.  This variable has the value ‘6’
initially, but ‘setq’ can alter this binding.  The lexical closure
created for the first lambda expression does not “snapshot” the value
‘6’ for ‘x’ when the closure is created; rather it captures the binding
of ‘x’.  The second function can be used to alter the value in the same
(captured) binding (to ‘43’, in the example), and this altered variable
binding then affects the value returned by the first function.

In situations where a closure of a lambda expression over the same set
of bindings may be produced more than once, the various resulting
closures may or may not be identical, at the discretion of the
implementation.  That is, two functions that are behaviorally
indistinguishable might or might not be identical.  Two functions that
are behaviorally distinguishable are distinct.  For example:

      (let ((x 5) (funs '()))
        (dotimes (j 10)
          (push #'(lambda (z)
                    (if (null z) (setq x 0) (+ x z)))
                funs))
        funs)

The result of the above form is a list of ten closures.  Each requires
only the binding of ‘x’.  It is the same binding in each case, but the
ten closure objects might or might not be identical.  On the other hand,
the result of the form

      (let ((funs '()))
        (dotimes (j 10)
          (let ((x 5))
            (push (function (lambda (z)
                             (if (null z) (setq x 0) (+ x z))))
                  funs)))
       funs)

is also a list of ten closures.  However, in this case no two of the
closure objects can be identical because each closure is closed over a
distinct binding of ‘x’, and these bindings can be behaviorally
distinguished because of the use of ‘setq’.

The result of the form

      (let ((funs '()))
        (dotimes (j 10)
          (let ((x 5))
            (push (function (lambda (z) (+ x z)))
                 funs)))
        funs)

is a list of ten closure objects that might or might not be identical.
A different binding of ‘x’ is involved for each closure, but the
bindings cannot be distinguished because their values are the same and
immutable (there being no occurrence of ‘setq’ on ‘x’).  A compiler
could internally transform the form to

      (let ((funs '()))
        (dotimes (j 10)
          (push (function (lambda (z) (+ 5 z)))
                funs))
       funs)

where the closures may be identical.

It is possible that a closure does not close over any variable bindings.
In the code fragment

      (mapcar (function (lambda (x) (+ x 2))) y)

the function ‘(lambda (x) (+ x 2))’ contains no references to any
outside object.  In this case, the same closure might be returned for
all evaluations of the ‘function’ form.


File: ansicl,  Node: Shadowing,  Next: Extent,  Prev: Closures and Lexical Binding,  Up: Evaluation

3.1.5 Shadowing
---------------

If two forms that establish lexical bindings with the same name N are
textually nested, then references to N within the inner form refer to
the binding established by the inner form; the inner binding for N
“shadows” the outer binding for N. Outside the inner form but inside the
outer one, references to N refer to the binding established by the outer
form.  For example:

      (defun test (x z)
        (let ((z (* x 2)))
          (print z))
        z)

The binding of the variable ‘z’ by ‘let’ shadows the parameter binding
for the function ‘test’.  The reference to the variable ‘z’ in the
‘print’ form refers to the ‘let’ binding.  The reference to ‘z’ at the
end of the function ‘test’ refers to the parameter named ‘z’.

Constructs that are lexically scoped act as if new names were generated
for each object on each execution.  Therefore, dynamic shadowing cannot
occur.  For example:

      (defun contorted-example (f g x)
        (if (= x 0)
            (funcall f)
            (block here
               (+ 5 (contorted-example g
                                       #'(lambda () (return-from here 4))
                                       (- x 1))))))

Consider the call ‘(contorted-example nil nil 2)’.  This produces ‘4’.
During the course of execution, there are three calls to
‘contorted-example’, interleaved with two blocks:

      (contorted-example nil nil 2)
        (block here     (contorted-example nil #'(lambda () (return-from here       (block here         (contorted-example #'(lambda () (return-from here                            #'(lambda () (return-from here                            0)
                  (funcall f)
                         where f → #'(lambda () (return-from here                 (return-from here

At the time the ‘funcall’ is executed there are two ‘block’ exit points
outstanding, each apparently named ‘here’.  The ‘return-from’ form
executed as a result of the ‘funcall’ operation refers to the outer
outstanding exit point (hereinner one (hereIt refers to that exit point
textually visible at the point of execution of ‘function’ (here
abbreviated by the ‘#'’ syntax) that resulted in creation of the
function object actually invoked by ‘funcall’.

If, in this example, one were to change the ‘(funcall f)’ to ‘(funcall
g)’, then the value of the call ‘(contorted-example nil nil 2)’ would be
‘9’.  The value would change because ‘funcall’ would cause the execution
of ‘(return-from here’


File: ansicl,  Node: Extent,  Next: Return Values,  Prev: Shadowing,  Up: Evaluation

3.1.6 Extent
------------

‘Contorted-example’ works only because the function named by ‘f’ is
invoked during the extent of the exit point.  Once the flow of execution
has left the block, the exit point is disestablished.  For example:

      (defun invalid-example ()
        (let ((y (block here #'(lambda (z) (return-from here z)))))
          (if (numberp y) y (funcall y 5))))

One might expect the call ‘(invalid-example)’ to produce ‘5’ by the
following incorrect reasoning: ‘let’ binds ‘y’ to the value of ‘block’;
this value is a function resulting from the lambda expression.  Because
‘y’ is not a number, it is invoked on the value ‘5’.  The ‘return-from’
should then return this value from the exit point named ‘here’, thereby
exiting from the block again and giving ‘y’ the value ‘5’ which, being a
number, is then returned as the value of the call to ‘invalid-example’.

The argument fails only because exit points have dynamic extent.  The
argument is correct up to the execution of ‘return-from’.  The execution
of ‘return-from’ should signal an error of type ‘control-error’,
however, not because it cannot refer to the exit point, but because it
does correctly refer to an exit point and that exit point has been
disestablished.

A reference by name to a dynamic exit point binding such as a catch tag
refers to the most recently established binding of that name that has
not been disestablished.  For example:

      (defun fun1 (x)
        (catch 'trap (+ 3 (fun2 x))))
      (defun fun2 (y)
        (catch 'trap (* 5 (fun3 y))))
      (defun fun3 (z)
        (throw 'trap z))

Consider the call ‘(fun1 7)’.  The result is ‘10’.  At the time the
‘throw’ is executed, there are two outstanding catchers with the name
‘trap’: one established within procedure ‘fun1’, and the other within
procedure ‘fun2’.  The latter is the more recent, and so the value ‘7’
is returned from ‘catch’ in ‘fun2’.  Viewed from within ‘fun3’, the
‘catch’ in ‘fun2’ shadows the one in ‘fun1’.  Had ‘fun2’ been defined as

      (defun fun2 (y)
        (catch 'snare (* 5 (fun3 y))))

then the two exit points would have different names, and therefore the
one in ‘fun1’ would not be shadowed.  The result would then have been
‘7’.


File: ansicl,  Node: Return Values,  Prev: Extent,  Up: Evaluation

3.1.7 Return Values
-------------------

Ordinarily the result of calling a function is a single object.
Sometimes, however, it is convenient for a function to compute several
objects and return them.

In order to receive other than exactly one value from a form, one of
several special forms or macros must be used to request those values.
If a form produces multiple values which were not requested in this way,
then the first value is given to the caller and all others are
discarded; if the form produces zero values, then the caller receives
‘nil’ as a value.

The next figure lists some operators for receiving multiple valuesThese
operators can be used to specify one or more forms to evaluate and where
to put the values returned by those forms.

multiple-value-bind   multiple-value-prog1   return-from
multiple-value-call   multiple-value-setq    throw
multiple-value-list   return

Figure 3.5: Some operators applicable to receiving multiple values

The function ‘values’ can produce multiple values‘(values)’ returns zero
values; ‘(values FORM)’ returns the primary value returned by FORM;
‘(values FORM1 FORM2)’ returns two values, the primary value of FORM1
and the primary value of FORM2; and so on.

See ‘multiple-values-limit’ and ‘values-list’.


File: ansicl,  Node: Compilation,  Next: Declarations,  Prev: Evaluation,  Up: Evaluation and Compilation

3.2 Compilation
===============

* Menu:

* Compiler Terminology::
* Compilation Semantics::
* File Compilation::
* Literal Objects in Compiled Files::
* Exceptional Situations in the Compiler::


File: ansicl,  Node: Compiler Terminology,  Next: Compilation Semantics,  Up: Compilation

3.2.1 Compiler Terminology
--------------------------

The following terminology is used in this section.

The “compiler” is a utility that translates code into an
implementation-dependent form that might be represented or executed
efficiently.  The term “compiler” refers to both of the functions
‘compile’ and ‘compile-file’.

The term “compiled code” refers to objects representing compiled
programs, such as objects constructed by ‘compile’ or by ‘load’ when
loading a compiled file.

The term “implicit compilation” refers to compilation performed during
evaluation.

The term “literal object” refers to a quoted object or a self-evaluating
object or an object that is a substructure of such an object.  A
constant variable is not itself a literal object.

The term “coalesce” is defined as follows.  Suppose ‘A’ and ‘B’ are two
literal constants in the source code, and that ‘A'’ and ‘B'’ are the
corresponding objects in the compiled code.  If ‘A'’ and ‘B'’ are ‘eql’
but ‘A’ and ‘B’ are not ‘eql’, then it is said that ‘A’ and ‘B’ have
been coalesced by the compiler.

The term “minimal compilation” refers to actions the compiler must take
at compile time.  These actions are specified in *note Section 3.2.2
(Compilation Semantics): Compilation Semantics.

The verb “process” refers to performing minimal compilation, determining
the time of evaluation for a form, and possibly evaluating that form (if
required).

The term “further compilation” refers to implementation-dependent
compilation beyond minimal compilation.  That is, processing does not
imply complete compilation.  Block compilation and generation of
machine-specific instructions are examples of further compilation.
Further compilation is permitted to take place at run time.

Four different environments relevant to compilation are distinguished:
the startup environment, the compilation environment, the evaluation
environment, and the run-time environment.

The “startup environment” is the environment of the Lisp image from
which the compiler was invoked.

The “compilation environment” is maintained by the compiler and is used
to hold definitions and declarations to be used internally by the
compiler.  Only those parts of a definition needed for correct
compilation are saved.  The compilation environment is used as the
environment argument to macro expanders called by the compiler.  It is
unspecified whether a definition available in the compilation
environment can be used in an evaluation initiated in the startup
environment or evaluation environment.

The “evaluation environment” is a run-time environment in which macro
expanders and code specified by ‘eval-when’ to be evaluated are
evaluated.  All evaluations initiated by the compiler take place in the
evaluation environment.

The “run-time environment” is the environment in which the program being
compiled will be executed.

The compilation environment inherits from the evaluation environment,
and the compilation environment and evaluation environment might be
identical.  The evaluation environment inherits from the startup
environment, and the startup environment and evaluation environment
might be identical.

The term “compile time” refers to the duration of time that the compiler
is processing source code.  At compile time, only the compilation
environment and the evaluation environment are available.

The term “compile-time definition” refers to a definition in the
compilation environment.  For example, when compiling a file, the
definition of a function might be retained in the compilation
environment if it is declared ‘inline’.  This definition might not be
available in the evaluation environment.

The term “run time” refers to the duration of time that the loader is
loading compiled code or compiled code is being executed.  At run time,
only the run-time environment is available.

The term “run-time definition” refers to a definition in the run-time
environment.

The term “run-time compiler” refers to the function ‘compile’ or
implicit compilation, for which the compilation and run-time
environments are maintained in the same Lisp image.  Note that when the
run-time compiler is used, the run-time environment and startup
environment are the same.


File: ansicl,  Node: Compilation Semantics,  Next: File Compilation,  Prev: Compiler Terminology,  Up: Compilation

3.2.2 Compilation Semantics
---------------------------

Conceptually, compilation is a process that traverses code, performs
certain kinds of syntactic and semantic analyses using information (such
as proclamations and macro definitions) present in the compilation
environment, and produces equivalent, possibly more efficient code.

3.2.2.1 Compiler Macros
.......................

A compiler macro can be defined for a name that also names a function or
macro.  That is, it is possible for a function name to name both a
function and a compiler macro.

A function name names a compiler macro if ‘compiler-macro-function’ is
true of the function name in the lexical environment in which it
appears.  Creating a lexical binding for the function name not only
creates a new local function or macro definition, but also shadows

The function returned by ‘compiler-macro-function’ is a function of two
arguments, called the expansion function.  To expand a compiler macro,
the expansion function is invoked by calling the macroexpand hook with
the expansion function as its first argument, the entire compiler macro
form as its second argument, and the current compilation environment (or
with the current lexical environment, if the form is being processed by
something other than ‘compile-file’) as its third argument.  The
macroexpand hook, in turn, calls the expansion function with the form as
its first argument and the environment as its second argument.  The
return value from the expansion function, which is passed through by the
macroexpand hook, might either be the same form, or else a form that
can, at the discretion of the code doing the expansion, be used in place
of the original form.

*macroexpand-hook*   compiler-macro-function   define-compiler-macro

Figure 3.6: Defined names applicable to compiler macros

3.2.2.1.1 Purpose of Compiler Macros
....................................

The purpose of the compiler macro facility is to permit selective source
code transformations as optimization advice to the compiler.  When a
compound form is being processed (as by the compiler), if the operator
names a compiler macro then the compiler macro function may be invoked
on the form, and the resulting expansion recursively processed in
preference to performing the usual processing on the original form
according to its normal interpretation as a function form or macro form.

A compiler macro function, like a macro function, is a function of two
arguments: the entire call form and the environment.  Unlike an ordinary
macro function, a compiler macro function can decline to provide an
expansion merely by returning a value that is the same as the original
form.  The consequences are undefined if a compiler macro function
destructively modifies any part of its form argument.

The form passed to the compiler macro function can either be a list
whose car is the function name, or a list whose car is ‘funcall’ and
whose cadr is a list ‘(function NAME)’; note that this affects
destructuring of the form argument by the compiler macro function.
‘define-compiler-macro’ arranges for destructuring of arguments to be
performed correctly for both possible formats.

When ‘compile-file’ chooses to expand a top level form that is a
compiler macro form, the expansion is also treated as a top level form
for the purposes of ‘eval-when’ processing; see *note Section 3.2.3.1
(Processing of Top Level Forms): TopLevelForms.

3.2.2.1.2 Naming of Compiler Macros
...................................

Compiler macros may be defined for function names that name macros as
well as functions.

Compiler macro definitions are strictly global.  There is no provision
for defining local compiler macros in the way that ‘macrolet’ defines
local macros.  Lexical bindings of a function name shadow any compiler
macro definition associated with the name as well as its global function
or macro definition.

Note that the presence of a compiler macro definition does not affect
the values returned by functions that access function definitions (e.g.,
‘fboundp’) or macro definitions (e.g., ‘macroexpand’).  Compiler macros
are global, and the function ‘compiler-macro-function’ is sufficient to
resolve their interaction with other lexical and global definitions.

3.2.2.1.3 When Compiler Macros Are Used
.......................................

The presence of a compiler macro definition for a function or macro
indicates that it is desirable for the compiler to use the expansion of
the compiler macro instead of the original function form or macro form.
However, no language processor (compiler, evaluator, or other code
walker) is ever required to actually invoke compiler macro functions, or
to make use of the resulting expansion if it does invoke a compiler
macro function.

When the compiler encounters a form during processing that represents a
call to a compiler macro name (that is not declared ‘notinline’), the
compiler might expand the compiler macro, and might use the expansion in
place of the original form.

When ‘eval’ encounters a form during processing that represents a call
to a compiler macro name (that is not declared ‘notinline’), ‘eval’
might expand the compiler macro, and might use the expansion in place of
the original form.

There are two situations in which a compiler macro definition must not
be applied by any language processor:

   • The global function name binding associated with the compiler macro
     is shadowed by a lexical binding of the function name.

   • The function name has been declared or proclaimed ‘notinline’ and
     the call form appears within the scope of the declaration.

It is unspecified whether compiler macros are expanded or used in any
other situations.

3.2.2.1.3.1 Notes about the Implementation of Compiler Macros
.............................................................

Although it is technically permissible, as described above, for ‘eval’
to treat compiler macros in the same situations as compiler might, this
is not necessarily a good idea in interpreted implementations.

Compiler macros exist for the purpose of trading compile-time speed for
run-time speed.  Programmers who write compiler macros tend to assume
that the compiler macros can take more time than normal functions and
macros in order to produce code which is especially optimal for use at
run time.  Since ‘eval’ in an interpreted implementation might perform
semantic analysis of the same form multiple times, it might be
inefficient in general for the implementation to choose to call compiler
macros on every such evaluation.

Nevertheless, the decision about what to do in these situations is left
to each implementation.

3.2.2.2 Minimal Compilation
...........................

Minimal compilation is defined as follows:

   • All compiler macro calls appearing in the source code being
     compiled are expanded, if at all, at compile time; they will not be
     expanded at run time.

   • All macro and symbol macro calls appearing in the source code being
     compiled are expanded at compile time in such a way that they will
     not be expanded again at run time.  ‘macrolet’ and
     ‘symbol-macrolet’ are effectively replaced by forms corresponding
     to their bodies in which calls to macros are replaced by their
     expansions.

   • The first argument in a ‘load-time-value’ form in source code
     processed by ‘compile’ is evaluated at compile time; in source code
     processed by ‘compile-file’ , the compiler arranges for it to be
     evaluated at load time.  In either case, the result of the
     evaluation is remembered and used later as the value of the
     ‘load-time-value’ form at execution time.

3.2.2.3 Semantic Constraints
............................

All conforming programs must obey the following constraints, which are
designed to minimize the observable differences between compiled and
interpreted programs:

   • Definitions of any referenced macros must be present in the
     compilation environment.  Any form that is a list beginning with a
     symbol that does not name a special operator or a macro defined in
     the compilation environment is treated by the compiler as a
     function call.

   • ‘Special’ proclamations for dynamic variables must be made in the
     compilation environment.  Any binding for which there is no
     ‘special’ declaration or proclamation in the compilation
     environment is treated by the compiler as a lexical binding.

   • The definition of a function that is defined and declared ‘inline’
     in the compilation environment must be the same at run time.

   • Within a function named F, the compiler may (but is not required
     to) assume that an apparent recursive call to a function named F
     refers to the same definition of F, unless that function has been
     declared ‘notinline’.  The consequences of redefining such a
     recursively defined function F while it is executing are undefined.

   • A call within a file to a named function that is defined in the
     same file refers to that function, unless that function has been
     declared ‘notinline’.  The consequences are unspecified if
     functions are redefined individually at run time or multiply
     defined in the same file.

   • The argument syntax and number of return values for all functions
     whose ‘ftype’ is declared at compile time must remain the same at
     run time.

   • Constant variables defined in the compilation environment must have
     a similar value at run time.  A reference to a constant variable in
     source code is equivalent to a reference to a literal object that
     is the value of the constant variable.

   • Type definitions made with ‘deftype’ or ‘defstruct’ in the
     compilation environment must retain the same definition at run
     time.  Classes defined by ‘defclass’ in the compilation environment
     must be defined at run time to have the same superclasses and same
     metaclass.

     This implies that subtype/supertype relationships of type
     specifiers must not change between compile time and run time.

   • Type declarations present in the compilation environment must
     accurately describe the corresponding values at run time;
     otherwise, the consequences are undefined.  It is permissible for
     an unknown type to appear in a declaration at compile time, though
     a warning might be signaled in such a case.

   • Except in the situations explicitly listed above, a function
     defined in the evaluation environment is permitted to have a
     different definition or a different signature at run time, and the
     run-time definition prevails.

Conforming programs should not be written using any additional
assumptions about consistency between the run-time environment and the
startup, evaluation, and compilation environments.

Except where noted, when a compile-time and a run-time definition are
different, one of the following occurs at run time:

   • an error of type ‘error’ is signaled
   • the compile-time definition prevails
   • the run-time definition prevails

If the compiler processes a function form whose operator is not defined
at compile time, no error is signaled at compile time.


File: ansicl,  Node: File Compilation,  Next: Literal Objects in Compiled Files,  Prev: Compilation Semantics,  Up: Compilation

3.2.3 File Compilation
----------------------

The function ‘compile-file’ performs compilation of forms in a file
following the rules specified in *note Section 3.2.2 (Compilation
Semantics): Compilation Semantics, and produces an output file that can
be loaded by using ‘load’.

Normally, the top level forms appearing in a file compiled with
‘compile-file’ are evaluated only when the resulting compiled file is
loaded, and not when the file is compiled.  However, it is typically the
case that some forms in the file need to be evaluated at compile time so
the remainder of the file can be read and compiled correctly.

The ‘eval-when’ special form can be used to control whether a top level
form is evaluated at compile time, load time, or both.  It is possible
to specify any of three situations with ‘eval-when’, denoted by the
symbols :compile-toplevel, :load-toplevel, and :execute.  For top level
‘eval-when’ forms, :compile-toplevel specifies that the compiler must
evaluate the body at compile time, and ‘:load-toplevel’ specifies that
the compiler must arrange to evaluate the body at load time.  For
non-top level ‘eval-when’ forms, :execute specifies that the body must
be executed in the run-time environment.

The behavior of this form can be more precisely understood in terms of a
model of how ‘compile-file’ processes forms in a file to be compiled.
There are two processing modes, called “not-compile-time” and
“compile-time-too”.

Successive forms are read from the file by ‘compile-file’ and processed
in not-compile-time mode; in this mode, ‘compile-file’ arranges for
forms to be evaluated only at load time and not at compile time.  When
‘compile-file’ is in compile-time-too mode, forms are evaluated both at
compile time and load time.

3.2.3.1 Processing of Top Level Forms
.....................................

Processing of top level forms in the file compiler is defined as
follows:

  1. If the form is a compiler macro form (not disabled by a ‘notinline’
     declaration), the implementation might or might not choose to
     compute the compiler macro expansion of the form and, having
     performed the expansion, might or might not choose to process the
     result as a top level form in the same processing mode
     (compile-time-too or not-compile-time).  If it declines to obtain
     or use the expansion, it must process the original form.

  2. If the form is a macro form, its macro expansion is computed and
     processed as a top level form in the same processing mode
     (compile-time-too or not-compile-time).

  3. If the form is a ‘progn’ form, each of its body forms is
     sequentially processed as a top level form in the same processing
     mode.

  4. If the form is a ‘locally’, ‘macrolet’, or ‘symbol-macrolet’,
     ‘compile-file’ establishes the appropriate bindings and processes
     the body forms as top level forms with those bindings in effect in
     the same processing mode.  (Note that this implies that the lexical
     environment in which top level forms are processed is not
     necessarily the null lexical environment.)

  5. If the form is an ‘eval-when’ form, it is handled according to the
     next figure.

     CT   LT   E   Mode  Action   New Mode
     ------------------------------------------------
     Yes  Yes  —   —     Process  compile-time-too
     No   Yes  Yes CTT   Process  compile-time-too
     No   Yes  Yes NCT   Process  not-compile-time
     No   Yes  No  —     Process  not-compile-time
     Yes  No   —   —     Evaluate —
     No   No   Yes CTT   Evaluate —
     No   No   Yes NCT   Discard  —
     No   No   No  —     Discard  —

     Figure 3.7: EVAL-WHEN processing

     Column CT indicates whether :compile-toplevel is specified.  Column
     LT indicates whether :load-toplevel is specified.  Column E
     indicates whether :execute is specified.  Column Mode indicates the
     processing mode; a dash (—) indicates that the processing mode is
     not relevant.

     The Action column specifies one of three actions:

          Process: process the body as top level forms in the specified
          mode.

          Evaluate: evaluate the body in the dynamic execution context
          of the compiler, using the evaluation environment as the
          global environment and the lexical environment in which the
          ‘eval-when’ appears.

          Discard: ignore the form.

     The New Mode column indicates the new processing mode.  A dash (—)
     indicates the compiler remains in its current mode.

  6. Otherwise, the form is a top level form that is not one of the
     special cases.  In compile-time-too mode, the compiler first
     evaluates the form in the evaluation environment and then minimally
     compiles it.  In not-compile-time mode, the form is simply
     minimally compiled.  All subforms are treated as non-top-level
     forms.

     Note that top level forms are processed in the order in which they
     textually appear in the file and that each top level form read by
     the compiler is processed before the next is read.  However, the
     order of processing (including macro expansion) of subforms that
     are not top level forms and the order of further compilation is
     unspecified as long as Common Lisp semantics are preserved.

‘eval-when’ forms cause compile-time evaluation only at top level.  Both
:compile-toplevel and :load-toplevel situation specifications are
ignored for non-top-level forms.  For non-top-level forms, an
‘eval-when’ specifying the :execute situation is treated as an implicit
progn including the forms in the body of the ‘eval-when’ form;
otherwise, the forms in the body are ignored.

3.2.3.1.1 Processing of Defining Macros
.......................................

Defining macros (such as ‘defmacro’ or ‘defvar’) appearing within a file
being processed by ‘compile-file’ normally have compile-time side
effects which affect how subsequent forms in the same file are compiled.
A convenient model for explaining how these side effects happen is that
the defining macro expands into one or more ‘eval-when’ forms, and that
the calls which cause the compile-time side effects to happen appear in
the body of an ‘(eval-when (:compile-toplevel) ...)’ form.

The compile-time side effects may cause information about the definition
to be stored differently than if the defining macro had been processed
in the ‘normal’ way (either interpretively or by loading the compiled
file).

In particular, the information stored by the defining macros at compile
time might or might not be available to the interpreter (either during
or after compilation), or during subsequent calls to the compiler.  For
example, the following code is nonportable because it assumes that the
compiler stores the macro definition of ‘foo’ where it is available to
the interpreter:

      (defmacro foo (x) `(car ,x))
      (eval-when (:execute :compile-toplevel :load-toplevel)
        (print (foo '(a b c))))

A portable way to do the same thing would be to include the macro
definition inside the ‘eval-when’ form, as in:

      (eval-when (:execute :compile-toplevel :load-toplevel)
        (defmacro foo (x) `(car ,x))
        (print (foo '(a b c))))

The next figure lists macros that make definitions available both in the
compilation and run-time environments.  It is not specified whether
definitions made available in the compilation environment are available
in the evaluation environment, nor is it specified whether they are
available in subsequent compilation units or subsequent invocations of
the compiler.  As with ‘eval-when’, these compile-time side effects
happen only when the defining macros appear at top level.

declaim                 define-modify-macro    defsetf
defclass                define-setf-expander   defstruct
defconstant             defmacro               deftype
define-compiler-macro   defpackage             defvar
define-condition        defparameter

Figure 3.8: Defining Macros That Affect the Compile-Time Environment

3.2.3.1.2 Constraints on Macros and Compiler Macros
...................................................

Except where explicitly stated otherwise, no macro defined in the Common
Lisp standard produces an expansion that could cause any of the subforms
of the macro form to be treated as top level forms.  If an
implementation also provides a special operator definition of a Common
Lisp macro, the special operator definition must be semantically
equivalent in this respect.

Compiler macro expansions must also have the same top level evaluation
semantics as the form which they replace.  This is of concern both to
conforming implementations and to conforming programs.


File: ansicl,  Node: Literal Objects in Compiled Files,  Next: Exceptional Situations in the Compiler,  Prev: File Compilation,  Up: Compilation

3.2.4 Literal Objects in Compiled Files
---------------------------------------

The functions ‘eval’ and ‘compile’ are required to ensure that literal
objects referenced within the resulting interpreted or compiled code
objects are the same as the corresponding objects in the source code.
‘compile-file’, on the other hand, must produce a compiled file that,
when loaded with ‘load’, constructs the objects defined by the source
code and produces references to them.

In the case of ‘compile-file’, objects constructed by ‘load’ of the
compiled file cannot be spoken of as being the same as the objects
constructed at compile time, because the compiled file may be loaded
into a different Lisp image than the one in which it was compiled.  This
section defines the concept of similarity which relates objects in the
evaluation environment to the corresponding objects in the run-time
environment.

The constraints on literal objects described in this section apply only
to ‘compile-file’; ‘eval’ and ‘compile’ do not copy or coalesce
constants.

3.2.4.1 Externalizable Objects
..............................

The fact that the file compiler represents literal objects externally in
a compiled file and must later reconstruct suitable equivalents of those
objects when that file is loaded imposes a need for constraints on the
nature of the objects that can be used as literal objects in code to be
processed by the file compiler.

An object that can be used as a literal object in code to be processed
by the file compiler is called an “externalizable object”.

We define that two objects are “similar” if they satisfy a two-place
conceptual equivalence predicate (defined below), which is independent
of the Lisp image so that the two objects in different Lisp images can
be understood to be equivalent under this predicate.  Further, by
inspecting the definition of this conceptual predicate, the programmer
can anticipate what aspects of an object are reliably preserved by file
compilation.

The file compiler must cooperate with the loader in order to assure that
in each case where an externalizable object is processed as a literal
object, the loader will construct a similar object.

The set of objects that are “externalizable objects” are those for which
the new conceptual term “similar” is defined, such that when a compiled
file is loaded, an object can be constructed which can be shown to be
similar to the original object which existed at the time the file
compiler was operating.

3.2.4.2 Similarity of Literal Objects
.....................................

3.2.4.2.1 Similarity of Aggregate Objects
.........................................

Of the types over which similarity is defined, some are treated as
aggregate objects.  For these types, similarity is defined recursively.
We say that an object of these types has certain “basic qualities” and
to satisfy the similarity relationship, the values of the corresponding
qualities of the two objects must also be similar.

3.2.4.2.2 Definition of Similarity
..................................

Two objects S (in source code) and C (in compiled code) are defined to
be similar if and only if they are both of one of the types listed here
(or defined by the implementation) and they both satisfy all additional
requirements of similarity indicated for that type.

‘number’

     Two numbers S and C are similar if they are of the same type and
     represent the same mathematical value.

‘character’

     Two simple characters S and C are similar if they have similar code
     attributes.

     Implementations providing additional, implementation-defined
     attributes must define whether and how non-simple characters can be
     regarded as similar.

‘symbol’

     Two apparently uninterned symbols S and C are similar if their
     names are similar.

     Two interned symbols S and C are similar if their names are
     similar, and if either S is accessible in the current package at
     compile time and C is accessible in the current package at load
     time, or C is accessible in the package that is similar to the home
     package of S.

     (Note that similarity of symbols is dependent on neither the
     current readtable nor how the function ‘read’ would parse the
     characters in the name of the symbol.)

‘package’

     Two packages S and C are similar if their names are similar.

     Note that although a package object is an externalizable object,
     the programmer is responsible for ensuring that the corresponding
     package is already in existence when code referencing it as a
     literal object is loaded.  The loader finds the corresponding
     package object as if by calling ‘find-package’ with that name as an
     argument.  An error is signaled by the loader if no package exists
     at load time.

‘random-state’

     Two random states S and C are similar if S would always produce the
     same sequence of pseudo-random numbers as a copywhen given as the
     RANDOM-STATE argument to the function ‘random’, assuming equivalent
     LIMIT arguments in each case.

     (Note that since C has been processed by the file compiler, it
     cannot be used directly as an argument to ‘random’ because ‘random’
     would perform a side effect.)

‘cons’

     Two conses, S and C, are similar if the carand the cdr

‘array’

     Two one-dimensional arrays, S and C, are similar if the length of S
     is similar to the length of C, the actual array element type of S
     is similar to the actual array element type of C, and each active
     element of S is similar to the corresponding element of C.

     Two arrays of rank other than one, S and C, are similar if the rank
     of S is similar to the rank of C, each dimensionthe corresponding
     dimensionthe actual array element type of S is similar to the
     actual array element type of C, and each element of S is similar to
     the corresponding element of C.

     In addition, if S is a simple array, then C must also be a simple
     array.  If S is a displaced array, has a fill pointer, or is
     actually adjustable, C is permitted to lack any or all of these
     qualities.

‘hash-table’

     Two hash tables S and C are similar if they meet the following
     three requirements:

       1. They both have the same test (e.g., they are both ‘eql’ hash
          tables).

       2. There is a unique one-to-one correspondence between the keys
          of the two hash tables, such that the corresponding keys are
          similar.

       3. For all keys, the values associated with two corresponding
          keys are similar.

     If there is more than one possible one-to-one correspondence
     between the keys of S and C, the consequences are unspecified.  A
     conforming program cannot use a table such as S as an
     externalizable constant.

‘pathname’

     Two pathnames S and C are similar if all corresponding pathname
     components are similar.

‘function’

     Functions are not externalizable objects.

‘structure-object’ and ‘standard-object’

     A general-purpose concept of similarity does not exist for
     structures and standard objects.  However, a conforming program is
     permitted to define a ‘make-load-form’ method for any class K
     defined by that program that is a subclass of either
     ‘structure-object’ or ‘standard-object’.  The effect of such a
     method is to define that an object S of type K in source code is
     similar to an object C of type K in compiled code if C was
     constructed from code produced by calling ‘make-load-form’ on S.

3.2.4.3 Extensions to Similarity Rules
......................................

Some objects, such as streams, ‘readtables’, and ‘methods’ are not
externalizable objects under the definition of similarity given above.
That is, such objects may not portably appear as literal objects in code
to be processed by the file compiler.

An implementation is permitted to extend the rules of similarity, so
that other kinds of objects are externalizable objects for that
implementation.

If for some kind of object, similarity is neither defined by this
specification nor by the implementation, then the file compiler must
signal an error upon encountering such an object as a literal constant.

3.2.4.4 Additional Constraints on Externalizable Objects
........................................................

If two literal objects appearing in the source code for a single file
processed with the file compiler are the identical, the corresponding
objects in the compiled code must also be the identical.  With the
exception of symbols and packages, any two literal objects in code being
processed by the file compiler may be coalesced if and only if they are
similar; if they are either both symbols or both packages, they may only
be coalesced if and only if they are identical.

Objects containing circular references can be externalizable objects.
The file compiler is required to preserve ‘eql’ness of substructures
within a file.  Preserving ‘eql’ness means that subobjects that are the
same in the source code must be the same in the corresponding compiled
code.

In addition, the following are constraints on the handling of literal
objects by the file compiler:

     array: If an array in the source code is a simple array, then the
     corresponding array in the compiled code will also be a simple
     array.  If an array in the source code is displaced, has a fill
     pointer, or is actually adjustable, the corresponding array in the
     compiled code might lack any or all of these qualities.  If an
     array in the source code has a fill pointer, then the corresponding
     array in the compiled code might be only the size implied by the
     fill pointer.

     packages: The loader is required to find the corresponding package
     object as if by calling ‘find-package’ with the package name as an
     argument.  An error of type ‘package-error’ is signaled if no
     package of that name exists at load time.

     random-state: A constant random state object cannot be used as the
     state argument to the function ‘random’ because ‘random’ modifies
     this data structure.

     structure, standard-object: Objects of type ‘structure-object’ and
     ‘standard-object’ may appear in compiled constants if there is an
     appropriate ‘make-load-form’ method defined for that type.

     The file compiler calls ‘make-load-form’ on any object that is
     referenced as a literal object if the object is a generalized
     instance of ‘standard-object’, ‘structure-object’, ‘condition’, or
     any of a (possibly empty) implementation-dependent set of other
     classes.  The file compiler only calls ‘make-load-form’ once for
     any given object within a single file.

     symbol: In order to guarantee that compiled files can be loaded
     correctly, users must ensure that the packages referenced in those
     files are defined consistently at compile time and load time.
     Conforming programs must satisfy the following requirements:

       1. The current package when a top level form in the file is
          processed by ‘compile-file’ must be the same as the current
          package when the code corresponding to that top level form in
          the compiled file is executed by ‘load’.  In particular:

            a. Any top level form in a file that alters the current
               package must change it to a package of the same name both
               at compile time and at load time.

            b. If the first non-atomic top level form in the file is not
               an ‘in-package’ form, then the current package at the
               time ‘load’ is called must be a package with the same
               name as the package that was the current package at the
               time ‘compile-file’ was called.

       2. For all symbols appearing lexically within a top level form
          that were accessible in the package that was the current
          package during processing of that top level form at compile
          time, but whose home package was another package, at load time
          there must be a symbol with the same name that is accessible
          in both the load-time current package and in the package with
          the same name as the compile-time home package.

       3. For all symbols represented in the compiled file that were
          external symbols in their home package at compile time, there
          must be a symbol with the same name that is an external symbol
          in the package with the same name at load time.

     If any of these conditions do not hold, the package in which the
     loader looks for the affected symbols is unspecified.
     Implementations are permitted to signal an error or to define this
     behavior.


File: ansicl,  Node: Exceptional Situations in the Compiler,  Prev: Literal Objects in Compiled Files,  Up: Compilation

3.2.5 Exceptional Situations in the Compiler
--------------------------------------------

‘compile’ and ‘compile-file’ are permitted to signal errors and
warnings, including errors due to compile-time processing of ‘(eval-when
(:compile-toplevel) ...)’ forms, macro expansion, and conditions
signaled by the compiler itself.

Conditions of type ‘error’ might be signaled by the compiler in
situations where the compilation cannot proceed without intervention.

In addition to situations for which the standard specifies that
conditions of type ‘warning’ must or might be signaled, warnings might
be signaled in situations where the compiler can determine that the
consequences are undefined or that a run-time error will be signaled.
Examples of this situation are as follows: violating type declarations,
altering or assigning the value of a constant defined with
‘defconstant’, calling built-in Lisp functions with a wrong number of
arguments or malformed keyword argument lists, and using unrecognized
declaration specifiers.

The compiler is permitted to issue warnings about matters of programming
style as conditions of type ‘style-warning’.  Examples of this situation
are as follows: redefining a function using a different argument list,
calling a function with a wrong number of arguments, not declaring
‘ignore’ of a local variable that is not referenced, and referencing a
variable declared ‘ignore’.

Both ‘compile’ and ‘compile-file’ are permitted (but not required) to
establish a handler for conditions of type ‘error’.  For example, they
might signal a warning, and restart compilation from some
implementation-dependent point in order to let the compilation proceed
without manual intervention.

Both ‘compile’ and ‘compile-file’ return three values, the second two
indicating whether the source code being compiled contained errors and
whether style warnings were issued.

Some warnings might be deferred until the end of compilation.  See
‘with-compilation-unit’.


File: ansicl,  Node: Declarations,  Next: Lambda Lists,  Prev: Compilation,  Up: Evaluation and Compilation

3.3 Declarations
================

“Declarations” provide a way of specifying information for use by
program processors, such as the evaluator or the compiler.

“Local declarations” can be embedded in executable code using declare.
“Global declarations”, or “proclamations”, are established by ‘proclaim’
or ‘declaim’.

The ‘the’ special form provides a shorthand notation for making a local
declaration about the type of the value of a given form.

The consequences are undefined if a program violates a declaration or a
proclamation.

* Menu:

* Minimal Declaration Processing Requirements::
* Declaration Specifiers::
* Declaration Identifiers::
* Declaration Scope::


File: ansicl,  Node: Minimal Declaration Processing Requirements,  Next: Declaration Specifiers,  Up: Declarations

3.3.1 Minimal Declaration Processing Requirements
-------------------------------------------------

In general, an implementation is free to ignore declaration specifiers
except for the ‘declaration’ , ‘notinline’ , ‘safety’ , and ‘special’
declaration specifiers.

A ‘declaration’ declaration must suppress warnings about unrecognized
declarations of the kind that it declares.  If an implementation does
not produce warnings about unrecognized declarations, it may safely
ignore this declaration.

A ‘notinline’ declaration must be recognized by any implementation that
supports inline functions or compiler macros in order to disable those
facilities.  An implementation that does not use inline functions or
compiler macros may safely ignore this declaration.

A ‘safety’ declaration that increases the current safety level must
always be recognized.  An implementation that always processes code as
if safety were high may safely ignore this declaration.

A ‘special’ declaration must be processed by all implementations.


File: ansicl,  Node: Declaration Specifiers,  Next: Declaration Identifiers,  Prev: Minimal Declaration Processing Requirements,  Up: Declarations

3.3.2 Declaration Specifiers
----------------------------

A “declaration specifier” is an expression that can appear at top level
of a declare expression or a ‘declaim’ form, or as the argument to
‘proclaim’.  It is a list whose car is a declaration identifier, and
whose cdr is data interpreted according to rules specific to the
declaration identifier.


File: ansicl,  Node: Declaration Identifiers,  Next: Declaration Scope,  Prev: Declaration Specifiers,  Up: Declarations

3.3.3 Declaration Identifiers
-----------------------------

The next figure shows a list of all declaration identifiers

defined by this standard.

declaration      ignore      special
dynamic-extent   inline      type
ftype            notinline
ignorable        optimize

Figure 3.9: Common Lisp Declaration Identifiers

An implementation is free to support other (implementation-defined)
declaration identifiers as well.  A warning might be issued if a
declaration identifier is not among those defined above, is not defined
by the implementation, is not a type name, and has not been declared in
a ‘declaration’ proclamation.

3.3.3.1 Shorthand notation for Type Declarations
................................................

A type specifier can be used as a declaration identifier.
‘(TYPE-SPECIFIER {var}*)’ is taken as shorthand for ‘(type
TYPE-SPECIFIER {var}*)’.


File: ansicl,  Node: Declaration Scope,  Prev: Declaration Identifiers,  Up: Declarations

3.3.4 Declaration Scope
-----------------------

Declarations can be divided into two kinds: those that apply to the
bindings of variables or functions; and those that do not apply to
bindings.

A declaration that appears at the head of a binding form and applies to
a variable or function binding made by that form is called a “bound
declaration”; such a declaration affects both the binding and any
references within the scope of the declaration.

Declarations that are not bound declarations are called “free
declarations”.

A free declaration in a form F1 that applies to a binding for a name N
established by some form F2 of which F1 is a subform affects only
references to N within F1; it does not to apply to other references to N
outside of F1, nor does it affect the manner in which the binding of N
by F2 is established.

Declarations that do not apply to bindings can only appear as free
declarations.

The scope of a bound declaration is the same as the lexical scope of the
binding to which it applies; for special variables, this means the scope
that the binding would have had had it been a lexical binding.

Unless explicitly stated otherwise, the scope of a free declaration
includes only the body subforms of the form at whose head it appears,
and no other subforms.  The scope of free declarations specifically does
not include initialization forms for bindings established by the form
containing the declarations.

Some iteration forms include step, end-test, or result subforms that are
also included in the scope of declarations that appear in the iteration
form.  Specifically, the iteration forms and subforms involved are:

   • ‘do’, ‘do*’: STEP-FORMS, END-TEST-FORM, and RESULT-FORMS.
   • ‘dolist’, ‘dotimes’: RESULT-FORM
   • ‘do-all-symbols’, ‘do-external-symbols’, ‘do-symbols’: RESULT-FORM

3.3.4.1 Examples of Declaration Scope
.....................................

Here is an example illustrating the scope of bound declarations.

      (let ((x 1))                ;[1] 1st occurrence of x
        (declare (special x))     ;[2] 2nd occurrence of x
        (let ((x 2))              ;[3] 3rd occurrence of x
          (let ((old-x x)         ;[4] 4th occurrence of x
                (x 3))            ;[5] 5th occurrence of x
            (declare (special x)) ;[6] 6th occurrence of x
            (list old-x x))))     ;[7] 7th occurrence of x
     → (2 3)

The first occurrence of ‘x’ establishes a dynamic binding of ‘x’ because
of the ‘special’ declaration for ‘x’ in the second line.  The third
occurrence of ‘x’ establishes a lexical binding of ‘x’ (because there is
no ‘special’ declaration in the corresponding ‘let’ form).  The fourth
occurrence of ‘x’ x is a reference to the lexical binding of ‘x’
established in the third line.  The fifth occurrence of ‘x’ establishes
a dynamic binding of x for the body of the ‘let’ form that begins on
that line because of the ‘special’ declaration for ‘x’ in the sixth
line.  The reference to ‘x’ in the fourth line is not affected by the
‘special’ declaration in the sixth line because that reference is not
within the “would-be lexical scope” of the variable ‘x’ in the fifth
line.  The reference to ‘x’ in the seventh line is a reference to the
dynamic binding of x established in the fifth line.

Here is another example, to illustrate the scope of a free declaration.
In the following:

      (lambda (&optional (x (foo 1))) ;[1]
        (declare (notinline foo))     ;[2]
        (foo x))                      ;[3]

the call to ‘foo’ in the first line might be compiled inline even though
the call to ‘foo’ in the third line must not be.  This is because the
‘notinline’ declaration for ‘foo’ in the second line applies only to the
body on the third line.  In order to suppress inlining for both calls,
one might write:

      (locally (declare (notinline foo)) ;[1]
        (lambda (&optional (x (foo 1)))  ;[2]
          (foo x)))                      ;[3]

or, alternatively:

      (lambda (&optional                               ;[1]
                 (x (locally (declare (notinline foo)) ;[2]
                      (foo 1))))                       ;[3]
        (declare (notinline foo))                      ;[4]
        (foo x))                                       ;[5]

Finally, here is an example that shows the scope of declarations in an
iteration form.

      (let ((x  1))                     ;[1]
        (declare (special x))           ;[2]
          (let ((x 2))                  ;[3]
            (dotimes (i x x)            ;[4]
              (declare (special x)))))  ;[5]
     → 1

In this example, the first reference to ‘x’ on the fourth line is to the
lexical binding of ‘x’ established on the third line.  However, the
second occurrence of ‘x’ on the fourth line lies within the scope of the
free declaration on the fifth line (because this is the RESULT-FORM of
the ‘dotimes’) and therefore refers to the dynamic binding of ‘x’.


File: ansicl,  Node: Lambda Lists,  Next: Error Checking in Function Calls,  Prev: Declarations,  Up: Evaluation and Compilation

3.4 Lambda Lists
================

A “lambda list” is a list that specifies a set of parameters (sometimes
called lambda variables) and a protocol for receiving values for those
parameters.

There are several kinds of lambda lists.

Context                                         Kind of Lambda List
--------------------------------------------------------------------------------------------------
‘defun’ form                                    ordinary lambda list
‘defmacro’ form                                 macro lambda list
lambda expression                               ordinary lambda list
‘flet’ local function definition                ordinary lambda list
‘labels’ local function definition              ordinary lambda list
‘handler-case’ CLAUSE specification             ordinary lambda list
‘restart-case’ CLAUSE specification             ordinary lambda list
‘macrolet’ local macro definition               macro lambda list
‘define-method-combination’                     ordinary lambda list
‘define-method-combination’ :arguments option   define-method-combination arguments lambda list
‘defstruct’ :constructor option                 boa lambda list
‘defgeneric’ form                               generic function lambda list
‘defgeneric’ method clause                      specialized lambda list
‘defmethod’ form                                specialized lambda list
‘defsetf’ form                                  defsetf lambda list
‘define-setf-expander’ form                     macro lambda list
‘deftype’ form                                  deftype lambda list
‘destructuring-bind’ form                       destructuring lambda list
‘define-compiler-macro’ form                    macro lambda list
‘define-modify-macro’ form                      define-modify-macro lambda list

Figure 3.10: What Kind of Lambda Lists to Use

The next figure lists some defined names that are applicable to lambda
lists.

lambda-list-keywords   lambda-parameters-limit

Figure 3.11: Defined names applicable to lambda lists

* Menu:

* Ordinary Lambda Lists::
* Generic Function Lambda Lists::
* Specialized Lambda Lists::
* Macro Lambda Lists::
* Destructuring Lambda Lists::
* Boa Lambda Lists::
* Defsetf Lambda Lists::
* Deftype Lambda Lists::
* Define-modify-macro Lambda Lists::
* Define-method-combination Arguments Lambda Lists::
* Syntactic Interaction of Documentation Strings and Declarations::


File: ansicl,  Node: Ordinary Lambda Lists,  Next: Generic Function Lambda Lists,  Up: Lambda Lists

3.4.1 Ordinary Lambda Lists
---------------------------

An “ordinary lambda list” is used to describe how a set of arguments is
received by an ordinary function.  The defined names in the next
figure are those which use ordinary lambda lists:

define-method-combination   handler-case   restart-case
defun                       labels
flet                        lambda

Figure 3.12: Standardized Operators that use Ordinary Lambda Lists

An ordinary lambda list can contain the lambda list keywords shown in
the next figure.

‘&allow-other-keys’   ‘&key’        ‘&rest’
‘&aux’                ‘&optional’

Figure 3.13: Lambda List Keywords used by Ordinary Lambda Lists

Each element of a lambda list is either a parameter specifier or a
lambda list keyword.  Implementations are free to provide additional
lambda list keywords.  For a list of all lambda list keywords used by
the implementation, see ‘lambda-list-keywords’.

The syntax for ordinary lambda lists is as follows:

LAMBDA-LIST::=
     ({var}*
      [&optional {var | (var [init-form [supplied-p-parameter]])}*]
      [&rest VAR]
      ‘[’&key {var ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}*
     [&allow-other-keys]‘]’
      [&aux {var | (var [init-form])}*])

A VAR or SUPPLIED-P-PARAMETER must be a symbol that is not the name of a
constant variable.

An INIT-FORM can be any form.  Whenever any INIT-FORM is evaluated for
any parameter specifier, that form may refer to any parameter variable
to the left of the specifier in which the INIT-FORM appears, including
any SUPPLIED-P-PARAMETER variables, and may rely on the fact that no
other parameter variable has yet been bound (including its own parameter
variable).

A KEYWORD-NAME can be any symbol, but by convention is normally a
keywordall standardized functions follow that convention.

An ordinary lambda list has five parts, any or all of which may be
empty.  For information about the treatment of argument mismatches, see
*note Section 3.5 (Error Checking in Function Calls): Error Checking in
Function Calls.

3.4.1.1 Specifiers for the required parameters
..............................................

These are all the parameter specifiers up to the first lambda list
keyword; if there are no lambda list keywords, then all the specifiers
are for required parameters.  Each required parameter is specified by a
parameter variable VAR.  VAR is bound as a lexical variable unless it is
declared ‘special’.

If there are ‘n’ required parameters (‘n’ may be zero), there must be at
least ‘n’ passed arguments, and the required parameters are bound to the
first ‘n’ passed arguments; see *note Section 3.5 (Error Checking in
Function Calls): Error Checking in Function Calls.  The other parameters
are then processed using any remaining arguments.

3.4.1.2 Specifiers for optional parameters
..........................................

If ‘&optional’ is present, the optional parameter specifiers are those
following ‘&optional’ up to the next lambda list keyword or the end of
the list.  If optional parameters are specified, then each one is
processed as follows.  If any unprocessed arguments remain, then the
parameter variable VAR is bound to the next remaining argument, just as
for a required parameter.  If no arguments remain, however, then
INIT-FORM is evaluated, and the parameter variable is bound to the
resulting value (or to ‘nil’ if no INIT-FORM appears in the parameter
specifier).  If another variable name SUPPLIED-P-PARAMETER appears in
the specifier, it is bound to true if an argument had been available,
and to false if no argument remained (and therefore INIT-FORM had to be
evaluated).  SUPPLIED-P-PARAMETER is bound not to an argument but to a
value indicating whether or not an argument had been supplied for the
corresponding VAR.

3.4.1.3 A specifier for a rest parameter
........................................

‘&rest’, if present, must be followed by a single rest parameter
specifier, which in turn must be followed by another lambda list keyword
or the end of the lambda list.  After all optional parameter specifiers
have been processed, then there may or may not be a rest parameter.  If
there is a rest parameter, it is bound to a list of all
as-yet-unprocessed arguments.  If no unprocessed arguments remain, the
rest parameter is bound to the empty list.  If there is no rest
parameter and there are no keyword parameters, then an error should be
signaled if any unprocessed arguments remain; see *note Section 3.5
(Error Checking in Function Calls): Error Checking in Function Calls.
The value of a rest parameter is permitted, but not required, to share
structure with the last argument to ‘apply’.

3.4.1.4 Specifiers for keyword parameters
.........................................

If ‘&key’ is present, all specifiers up to the next lambda list keyword
or the end of the list are keyword parameter specifiers.  When keyword
parameters are processed, the same arguments are processed that would be
made into a list for a rest parameter.  It is permitted to specify both
‘&rest’ and ‘&key’.  In this case the remaining arguments are used for
both purposes; that is, all remaining arguments are made into a list for
the rest parameter, and are also processed for the ‘&key’ parameters.
If ‘&key’ is specified, there must remain an even number of arguments;
see *note Section 3.5.1.6 (Odd Number of Keyword Arguments):
OddNumberOfKeyArgs.  These arguments are considered as pairs, the first
argument in each pair being interpreted as a name and the second as the
corresponding value.  The first object of each pair must be a symbol;
see *note Section 3.5.1.5 (Invalid Keyword Arguments): InvalidKeyArgs.
The keyword parameter specifiers may optionally be followed by the
lambda list keyword ‘&allow-other-keys’.

In each keyword parameter specifier must be a name VAR for the parameter
variable.  If the VAR appears alone or in a ‘(VAR INIT-FORM)’
combination, the keyword name used when matching arguments to parameters
is a symbol in the ‘KEYWORD’ package whose name is the same (under
‘string=’) as VAR’s.  If the notation ‘((KEYWORD-NAME VAR) INIT-FORM)’
is used, then the keyword name used to match arguments to parameters is
KEYWORD-NAME, which may be a symbol in any package.  (Of course, if it
is not a symbol in the ‘KEYWORD’ package, it does not necessarily
self-evaluate, so care must be taken when calling the function to make
sure that normal evaluation still yields the keyword name.)  Thus

      (defun foo (&key radix (type 'integer)) ...)

means exactly the same as

      (defun foo (&key ((:radix radix)) ((:type type) 'integer)) ...)

The keyword parameter specifiers are, like all parameter specifiers,
effectively processed from left to right.  For each keyword parameter
specifier, if there is an argument pair whose name matches that
specifier’s name (that is, the names are ‘eq’), then the parameter
variable for that specifier is bound to the second item (the value) of
that argument pair.  If more than one such argument pair matches, the
leftmost argument pair is used.  If no such argument pair exists, then
the INIT-FORM for that specifier is evaluated and the parameter variable
is bound to that value (or to ‘nil’ if no INIT-FORM was specified).
SUPPLIED-P-PARAMETER is treated as for ‘&optional’ parameters: it is
bound to true if there was a matching argument pair, and to false
otherwise.

Unless keyword argument checking is suppressed, an argument pair must a
name matched by a parameter specifier; see *note Section 3.5.1.4
(Unrecognized Keyword Arguments): UnrecognizedKeyArgs.

If keyword argument checking is suppressed, then it is permitted for an
argument pair to match no parameter specifier, and the argument pair is
ignored, but such an argument pair is accessible through the rest
parameter if one was supplied.  The purpose of these mechanisms is to
allow sharing of argument lists among several lambda expressions and to
allow either the caller or the called lambda expression to specify that
such sharing may be taking place.

Note that if ‘&key’ is present, a keyword argument of :allow-other-keys
is always permitted—regardless of whether the associated value is true
or false.  However, if the value is false, other non-matching keywords
are not tolerated (unless ‘&allow-other-keys’ was used).

Furthermore, if the receiving argument list specifies a regular argument
which would be flagged by :allow-other-keys, then :allow-other-keys has
both its special-cased meaning (identifying whether additional keywords
are permitted) and its normal meaning (data flow into the function in
question).

3.4.1.4.1 Suppressing Keyword Argument Checking
...............................................

If ‘&allow-other-keys’ was specified in the lambda list of a function,
keywordto that function.

If the :allow-other-keys argument is true in a call to a function,
keywordin that call.

The :allow-other-keys argument is permissible in all situations
involving keywordis false.

3.4.1.4.1.1 Examples of Suppressing Keyword Argument Checking
.............................................................

     ;;; The caller can supply :ALLOW-OTHER-KEYS T to suppress checking.
      ((lambda (&key x) x) :x 1 :y 2 :allow-other-keys t) → 1
     ;;; The callee can use &ALLOW-OTHER-KEYS to suppress checking.
      ((lambda (&key x &allow-other-keys) x) :x 1 :y 2) → 1
     ;;; :ALLOW-OTHER-KEYS NIL is always permitted.
      ((lambda (&key) t) :allow-other-keys nil) → T
     ;;; As with other keyword arguments, only the left-most pair
     ;;; named :ALLOW-OTHER-KEYS has any effect.
      ((lambda (&key x) x)
       :x 1 :y 2 :allow-other-keys t :allow-other-keys nil)
     → 1
     ;;; Only the left-most pair named :ALLOW-OTHER-KEYS has any effect,
     ;;; so in safe code this signals a PROGRAM-ERROR (and might enter the
     ;;; debugger).  In unsafe code, the consequences are undefined.
      ((lambda (&key x) x)                   ;This call is not valid
       :x 1 :y 2 :allow-other-keys nil :allow-other-keys t)

3.4.1.5 Specifiers for ‘&aux’ variables
.......................................

These are not really parameters.  If the lambda list keyword ‘&aux’ is
present, all specifiers after it are auxiliary variable specifiers.
After all parameter specifiers have been processed, the auxiliary
variable specifiers (those following &aux) are processed from left to
right.  For each one, INIT-FORM is evaluated and VAR is bound to that
value (or to ‘nil’ if no INIT-FORM was specified).  ‘&aux’ variable
processing is analogous to ‘let*’ processing.

      (lambda (x y &aux (a (car x)) (b 2) c) (list x y a b c))
         ≡ (lambda (x y) (let* ((a (car x)) (b 2) c) (list x y a b c)))

3.4.1.6 Examples of Ordinary Lambda Lists
.........................................

Here are some examples involving optional parameters and rest
parameters:

      ((lambda (a b) (+ a (* b 3))) 4 5) → 19
      ((lambda (a &optional (b 2)) (+ a (* b 3))) 4 5) → 19
      ((lambda (a &optional (b 2)) (+ a (* b 3))) 4) → 10
      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)))
     → (2 NIL 3 NIL NIL)
      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6)
     → (6 T 3 NIL NIL)
      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3)
     → (6 T 3 T NIL)
      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3 8)
     → (6 T 3 T (8))
      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x))
       6 3 8 9 10 11)
     → (6 t 3 t (8 9 10 11))

Here are some examples involving keyword parameters:

      ((lambda (a b &key c d) (list a b c d)) 1 2) → (1 2 NIL NIL)
      ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6) → (1 2 6 NIL)
      ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8) → (1 2 NIL 8)
      ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6 :d 8) → (1 2 6 8)
      ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8 :c 6) → (1 2 6 8)
      ((lambda (a b &key c d) (list a b c d)) :a 1 :d 8 :c 6) → (:a 1 6 8)
      ((lambda (a b &key c d) (list a b c d)) :a :b :c :d) → (:a :b :d NIL)
      ((lambda (a b &key ((:sea c)) d) (list a b c d)) 1 2 :sea 6) → (1 2 6 NIL)
      ((lambda (a b &key ((c c)) d) (list a b c d)) 1 2 'c 6) → (1 2 6 NIL)

Here are some examples involving optional parameters, rest parameters,
and keyword parameters together:

      ((lambda (a &optional (b 3) &rest x &key c (d a))
         (list a b c d x)) 1)
     → (1 3 NIL 1 ())
      ((lambda (a &optional (b 3) &rest x &key c (d a))
         (list a b c d x)) 1 2)
     → (1 2 NIL 1 ())
      ((lambda (a &optional (b 3) &rest x &key c (d a))
         (list a b c d x)) :c 7)
     → (:c 7 NIL :c ())
      ((lambda (a &optional (b 3) &rest x &key c (d a))
         (list a b c d x)) 1 6 :c 7)
     → (1 6 7 1 (:c 7))
      ((lambda (a &optional (b 3) &rest x &key c (d a))
         (list a b c d x)) 1 6 :d 8)
     → (1 6 NIL 8 (:d 8))
      ((lambda (a &optional (b 3) &rest x &key c (d a))
         (list a b c d x)) 1 6 :d 8 :c 9 :d 10)
     → (1 6 9 8 (:d 8 :c 9 :d 10))

As an example of the use of ‘&allow-other-keys’ and :allow-other-keys,
consider a function that takes two named arguments of its own and also
accepts additional named arguments to be passed to ‘make-array’:

      (defun array-of-strings (str dims &rest named-pairs
                               &key (start 0) end &allow-other-keys)
        (apply #'make-array dims
               :initial-element (subseq str start end)
               :allow-other-keys t
               named-pairs))

This function takes a string and dimensioning information and returns an
array of the specified dimensions, each of whose elements is the
specified string.  However, :start and :end named arguments may be used
to specify that a substring of the given string should be used.  In
addition, the presence of ‘&allow-other-keys’ in the lambda list
indicates that the caller may supply additional named arguments; the
rest parameter provides access to them.  These additional named
arguments are passed to ‘make-array’.  The function ‘make-array’
normally does not allow the named arguments :start and :end to be used,
and an error should be signaled if such named arguments are supplied to
‘make-array’.  However, the presence in the call to ‘make-array’ of the
named argument :allow-other-keys with a true value causes any extraneous
named arguments, including :start and :end, to be acceptable and
ignored.

