This is ansicl, produced by makeinfo version 6.7 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: remhash,  Next: maphash,  Prev: gethash,  Up: Hash Tables

remhash (Function)
==================

Syntax:
.......

 -- Function: remhash key hash-table → generalized-boolean

Arguments and Values:
.....................

KEY—an object.

HASH-TABLE—a hash table.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Removes the entry for KEY in HASH-TABLE, if any.  Returns true if there
was such an entry, or false otherwise.

Examples:
.........

      (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32115666>
      (setf (gethash 100 table) "C") → "C"
      (gethash 100 table) → "C", true
      (remhash 100 table) → true
      (gethash 100 table) → NIL, false
      (remhash 100 table) → false

Side Effects:
.............

The HASH-TABLE is modified.


File: ansicl,  Node: maphash,  Next: with-hash-table-iterator,  Prev: remhash,  Up: Hash Tables

maphash (Function)
==================

Syntax:
.......

 -- Function: maphash function hash-table → ‘nil’

Arguments and Values:
.....................

FUNCTION—a designator for a function of two arguments, the key and the
value.

HASH-TABLE—a hash table.

Description:
............

Iterates over all entries in the HASH-TABLE.  For each entry, the
FUNCTION is called with two arguments—the key and the value of that
entry.

The consequences are unspecified if any attempt is made to add or remove
an entry from the HASH-TABLE while a ‘maphash’ is in progress, with two
exceptions: the FUNCTION can use can use ‘setf’ of ‘gethash’ to change
the value part of the entry currently being processed, or it can use
‘remhash’ to remove that entry.

Examples:
.........

      (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32304110>
      (dotimes (i 10) (setf (gethash i table) i)) → NIL
      (let ((sum-of-squares 0))
         (maphash #'(lambda (key val)
                      (let ((square (* val val)))
                        (incf sum-of-squares square)
                        (setf (gethash key table) square)))
                  table)
         sum-of-squares) → 285
      (hash-table-count table) → 10
      (maphash #'(lambda (key val)
                    (when (oddp val) (remhash key table)))
                table) → NIL
      (hash-table-count table) → 5
      (maphash #'(lambda (k v) (print (list k v))) table)
     (0 0)
     (8 64)
     (2 4)
     (6 36)
     (4 16)
     → NIL

Side Effects:
.............

None, other than any which might be done by the FUNCTION.

See Also:
.........

*note loop::, *note with-hash-table-iterator::, *note Section 3.6
(Traversal Rules and Side Effects): Traversal Rules and Side Effects.


File: ansicl,  Node: with-hash-table-iterator,  Next: clrhash,  Prev: maphash,  Up: Hash Tables

with-hash-table-iterator (Macro)
================================

Syntax:
.......

 -- Macro: with-hash-table-iterator (name hash-table) {declaration}*
          {form}* → {result}*

Arguments and Values:
.....................

NAME—a name suitable for the first argument to ‘macrolet’.

HASH-TABLE—a form, evaluated once, that should produce a hash table.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—the values returned by FORMS.

Description:
............

Within the lexical scope of the body, NAME is defined via ‘macrolet’
such that successive invocations of ‘(NAME)’ return the items, one by
one, from the hash table that is obtained by evaluating HASH-TABLE only
once.

An invocation ‘(NAME)’ returns three values as follows:

  1. A generalized boolean that is true if an entry is returned.
  2. The key from the HASH-TABLE entry.
  3. The value from the HASH-TABLE entry.

After all entries have been returned by successive invocations of
‘(NAME)’, then only one value is returned, namely ‘nil’.

It is unspecified what happens if any of the implicit interior state of
an iteration is returned outside the dynamic extent of the
‘with-hash-table-iterator’ form such as by returning some closure over
the invocation form.

Any number of invocations of ‘with-hash-table-iterator’ can be nested,
and the body of the innermost one can invoke all of the locally
established macros, provided all of those macros have distinct names.

Examples:
.........

The following function should return ‘t’ on any hash table, and signal
an error if the usage of ‘with-hash-table-iterator’ does not agree with
the corresponding usage of ‘maphash’.

      (defun test-hash-table-iterator (hash-table)
        (let ((all-entries '())
              (generated-entries '())
              (unique (list nil)))
          (maphash #'(lambda (key value) (push (list key value) all-entries))
                   hash-table)
          (with-hash-table-iterator (generator-fn hash-table)
            (loop
              (multiple-value-bind (more? key value) (generator-fn)
                (unless more? (return))
                (unless (eql value (gethash key hash-table unique))
                  (error "Key ~S not found for value ~S" key value))
                (push (list key value) generated-entries))))
          (unless (= (length all-entries)
                     (length generated-entries)
                     (length (union all-entries generated-entries
                                    :key #'car :test (hash-table-test hash-table))))
            (error "Generated entries and Maphash entries don't correspond"))
          t))

The following could be an acceptable definition of ‘maphash’,
implemented by ‘with-hash-table-iterator’.

      (defun maphash (function hash-table)
        (with-hash-table-iterator (next-entry hash-table)
          (loop (multiple-value-bind (more key value) (next-entry)
                  (unless more (return nil))
                  (funcall function key value)))))

Exceptional Situations:
.......................

The consequences are undefined if the local function named NAME
established by ‘with-hash-table-iterator’ is called after it has
returned false as its primary value.

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: ansicl,  Node: clrhash,  Next: sxhash,  Prev: with-hash-table-iterator,  Up: Hash Tables

clrhash (Function)
==================

Syntax:
.......

 -- Function: clrhash hash-table → hash-table

Arguments and Values:
.....................

HASH-TABLE—a hash table.

Description:
............

Removes all entries from HASH-TABLE, and then returns that empty hash
table.

Examples:
.........

      (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32004073>
      (dotimes (i 100) (setf (gethash i table) (format nil "~R" i))) → NIL
      (hash-table-count table) → 100
      (gethash 57 table) → "fifty-seven", true
      (clrhash table) → #<HASH-TABLE EQL 0/120 32004073>
      (hash-table-count table) → 0
      (gethash 57 table) → NIL, false

Side Effects:
.............

The HASH-TABLE is modified.


File: ansicl,  Node: sxhash,  Prev: clrhash,  Up: Hash Tables

sxhash (Function)
=================

Syntax:
.......

 -- Function: sxhash object → hash-code

Arguments and Values:
.....................

OBJECT—an object.

HASH-CODE—a non-negative fixnum.

Description:
............

‘sxhash’ returns a hash code for OBJECT.

The manner in which the hash code is computed is
implementation-dependent, but subject to certain constraints:

  1. ‘(equal X Y)’ implies ‘(= (sxhash X) (sxhash Y))’.

  2. For any two objects, X and Y, both of which are bit vectors,
     characters, conses, numbers, pathnames, strings, or symbols, and
     which are similar, ‘(sxhash X)’ and ‘(sxhash Y)’ yield the same
     mathematical value even if X and Y exist in different Lisp images
     of the same implementation.  See *note Section 3.2.4 (Literal
     Objects in Compiled Files): Literal Objects in Compiled Files.

  3. The HASH-CODE for an object is always the same within a single
     session provided that the object is not visibly modified with
     regard to the equivalence test ‘equal’.  See *note Section 18.1.2
     (Modifying Hash Table Keys): Modifying Hash Table Keys.

  4. The HASH-CODE is intended for hashing.  This places no verifiable
     constraint on a conforming implementation, but the intent is that
     an implementation should make a good-faith effort to produce
     HASH-CODES that are well distributed within the range of
     non-negative fixnums.

  5. Computation of the HASH-CODE must terminate, even if the OBJECT
     contains circularities.

Examples:
.........

      (= (sxhash (list 'list "ab")) (sxhash (list 'list "ab"))) → true
      (= (sxhash "a") (sxhash (make-string 1 :initial-element #\a))) → true
      (let ((r (make-random-state)))
        (= (sxhash r) (sxhash (make-random-state r))))
     → implementation-dependent

Affected By:
............

The implementation.

Notes:
......

Many common hashing needs are satisfied by ‘make-hash-table’ and the
related functions on hash tables.  ‘sxhash’ is intended for use where
the pre-defined abstractions are insufficient.  Its main intent is to
allow the user a convenient means of implementing more complicated
hashing paradigms than are provided through hash tables.

The hash codes returned by ‘sxhash’ are not necessarily related to any
hashing strategy used by any other function in Common Lisp.

For objects of types that ‘equal’ compares with ‘eq’, item 3 requires
that the HASH-CODE be based on some immutable quality of the identity of
the object.  Another legitimate implementation technique would be to
have ‘sxhash’ assign (and cache) a random hash code for these objects,
since there is no requirement that similar but non-‘eq’ objects have the
same hash code.

Although similarity is defined for symbols in terms of both the symbol’s
name and the packages in which the symbol is accessible, item 3
disallows using package information to compute the hash code, since
changes to the package status of a symbol are not visible to EQUAL.


File: ansicl,  Node: Filenames,  Next: Files,  Prev: Hash Tables,  Up: Top

19 Filenames
************

* Menu:

* Overview of Filenames::
* Pathnames::
* Logical Pathnames::

Dictionary

* pathname (System Class)::
* logical-pathname (System Class)::
* pathname (Function)::
* make-pathname::
* pathnamep::
* pathname-host; pathname-device; pathname-directory; pathname-name; path+::
* load-logical-pathname-translations::
* logical-pathname-translations::
* logical-pathname (Function)::
* *default-pathname-defaults*::
* namestring; file-namestring; directory-namestring; host-namestring; eno+::
* parse-namestring::
* wild-pathname-p::
* pathname-match-p::
* translate-logical-pathname::
* translate-pathname::
* merge-pathnames::


File: ansicl,  Node: Overview of Filenames,  Next: Pathnames,  Up: Filenames

19.1 Overview of Filenames
==========================

There are many kinds of file systems, varying widely both in their
superficial syntactic details, and in their underlying power and
structure.  The facilities provided by Common Lisp for referring to and
manipulating files has been chosen to be compatible with many kinds of
file systems, while at the same time minimizing the program-visible
differences between kinds of file systems.

Since file systems vary in their conventions for naming files, there are
two distinct ways to represent filenames: as namestrings and as
pathnames.

* Menu:

* Namestrings as Filenames::
* Pathnames as Filenames::
* Parsing Namestrings Into Pathnames::


File: ansicl,  Node: Namestrings as Filenames,  Next: Pathnames as Filenames,  Up: Overview of Filenames

19.1.1 Namestrings as Filenames
-------------------------------

A “namestring” is a string that represents a filename.

In general, the syntax of namestrings involves the use of
implementation-defined conventions, usually those customary for the file
system in which the named file resides.  The only exception is the
syntax of a logical pathname namestring, which is defined in this
specification; see *note Section 19.3.1 (Syntax of Logical Pathname
Namestrings): Syntax of Logical Pathname Namestrings.

A conforming program must never unconditionally use a literal namestring
other than a logical pathname namestring because Common Lisp does not
define any namestring syntax other than that for logical pathnames that
would be guaranteed to be portable.  However, a conforming program can,
if it is careful, successfully manipulate user-supplied data which
contains or refers to non-portable namestrings.

A namestring can be coerced to a pathname by the functions ‘pathname’ or
‘parse-namestring’.


File: ansicl,  Node: Pathnames as Filenames,  Next: Parsing Namestrings Into Pathnames,  Prev: Namestrings as Filenames,  Up: Overview of Filenames

19.1.2 Pathnames as Filenames
-----------------------------

“Pathnames” are structured objects that can represent, in an
implementation-independent way, the filenames that are used natively by
an underlying file system.

In addition, pathnames can also represent certain partially composed
filenames for which an underlying file system might not have a specific
namestring representation.

A pathname need not correspond to any file that actually exists, and
more than one pathname can refer to the same file.  For example, the
pathname with a version of :newest might refer to the same file as a
pathname with the same components except a certain number as the
version.  Indeed, a pathname with version :newest might refer to
different files as time passes, because the meaning of such a pathname
depends on the state of the file system.

Some file systems naturally use a structural model for their filenames,
while others do not.  Within the Common Lisp pathname model, all
filenames are seen as having a particular structure, even if that
structure is not reflected in the underlying file system.  The nature of
the mapping between structure imposed by pathnames and the structure, if
any, that is used by the underlying file system is
implementation-defined.

Every pathname has six components: a host, a device, a directory, a
name, a type, and a version.  By naming files with pathnames, Common
Lisp programs can work in essentially the same way even in file systems
that seem superficially quite different.  For a detailed description of
these components, see *note Section 19.2.1 (Pathname Components):
Pathname Components.

The mapping of the pathname components into the concepts peculiar to
each file system is implementation-defined.  There exist conceivable
pathnames for which there is no mapping to a syntactically valid
filename in a particular implementation.  An implementation may use
various strategies in an attempt to find a mapping; for example, an
implementation may quietly truncate filenames that exceed length
limitations imposed by the underlying file system, or ignore certain
pathname components for which the file system provides no support.  If
such a mapping cannot be found, an error of type ‘file-error’ is
signaled.

The time at which this mapping and associated error signaling occurs is
implementation-dependent.  Specifically, it may occur at the time the
pathname is constructed, when coercing a pathname to a namestring, or
when an attempt is made to open or otherwise access the file designated
by the pathname.

The next figure lists some defined names that are applicable to
pathnames.

*default-pathname-defaults*   namestring           pathname-name
directory-namestring          open                 pathname-type
enough-namestring             parse-namestring     pathname-version
file-namestring               pathname             pathnamep
file-string-length            pathname-device      translate-pathname
host-namestring               pathname-directory   truename
make-pathname                 pathname-host        user-homedir-pathname
merge-pathnames               pathname-match-p     wild-pathname-p

Figure 19.1: Pathname Operations


File: ansicl,  Node: Parsing Namestrings Into Pathnames,  Prev: Pathnames as Filenames,  Up: Overview of Filenames

19.1.3 Parsing Namestrings Into Pathnames
-----------------------------------------

Parsing is the operation used to convert a namestring into a pathname.
Except in the case of parsing logical pathname namestrings, this
operation is implementation-dependent, because the format of namestrings
is implementation-dependent.

A conforming implementation is free to accommodate other file system
features in its pathname representation and provides a parser that can
process such specifications in namestrings.  Conforming programs must
not depend on any such features, since those features will not be
portable.


File: ansicl,  Node: Pathnames,  Next: Logical Pathnames,  Prev: Overview of Filenames,  Up: Filenames

19.2 Pathnames
==============

* Menu:

* Pathname Components::
* Interpreting Pathname Component Values::
* Merging Pathnames::


File: ansicl,  Node: Pathname Components,  Next: Interpreting Pathname Component Values,  Up: Pathnames

19.2.1 Pathname Components
--------------------------

A pathname has six components: a host, a device, a directory, a name, a
type, and a version.

19.2.1.1 The Pathname Host Component
....................................

The name of the file system on which the file resides, or the name of a
logical host.

19.2.1.2 The Pathname Device Component
......................................

Corresponds to the “device” or “file structure” concept in many host
file systems: the name of a logical or physical device containing files.

19.2.1.3 The Pathname Directory Component
.........................................

Corresponds to the “directory” concept in many host file systems: the
name of a group of related files.

19.2.1.4 The Pathname Name Component
....................................

The “name” part of a group of files that can be thought of as
conceptually related.

19.2.1.5 The Pathname Type Component
....................................

Corresponds to the “filetype” or “extension” concept in many host file
systems.  This says what kind of file this is.  This component is always
a string, ‘nil’, :wild, or :unspecific.

19.2.1.6 The Pathname Version Component
.......................................

Corresponds to the “version number” concept in many host file systems.

The version is either a positive integer or a symbol from the following
list: ‘nil’, :wild, :unspecific, or :newest (refers to the largest
version number that already exists in the file system when reading a
file, or to a version number greater than any already existing in the
file system when writing a new file).  Implementations can define other
special version symbols.


File: ansicl,  Node: Interpreting Pathname Component Values,  Next: Merging Pathnames,  Prev: Pathname Components,  Up: Pathnames

19.2.2 Interpreting Pathname Component Values
---------------------------------------------

19.2.2.1 Strings in Component Values
....................................

19.2.2.1.1 Special Characters in Pathname Components
....................................................

Strings in pathname component values never contain special characters
that represent separation between pathname fields, such as slash in
Unix filenames.  Whether separator characters are permitted as part of a
string in a pathname component is implementation-defined; however, if
the implementation does permit it, it must arrange to properly “quote”
the character for the file system when constructing a namestring.  For
example,

      ;; In a TOPS-20 implementation, which uses ^V to quote
      (NAMESTRING (MAKE-PATHNAME :HOST "OZ" :NAME "<TEST>"))
     → #P"OZ:PS:^V<TEST^V>"
     not→ #P"OZ:PS:<TEST>"

19.2.2.1.2 Case in Pathname Components
......................................

Namestrings always use local file system case conventions, but Common
Lisp functions that manipulate pathname components allow the caller to
select either of two conventions for representing case in component
values by supplying a value for the :case keyword argument.  The next
figure lists the functions relating to pathnames that permit a :case
argument:

make-pathname     pathname-directory   pathname-name
pathname-device   pathname-host        pathname-type

Figure 19.2: Pathname functions using a :CASE argument

19.2.2.1.2.1 Local Case in Pathname Components
..............................................

For the functions in *note Figure 19.2: PathnameCaseFuns, a value of
:local for the :case argument (the default for these functions)
indicates that the functions should receive and yield strings in
component values as if they were already represented according to the
host file system’s convention for case.

If the file system supports both cases, strings given or received as
pathname component values under this protocol are to be used exactly as
written.  If the file system only supports one case, the strings will be
translated to that case.

19.2.2.1.2.2 Common Case in Pathname Components
...............................................

For the functions in *note Figure 19.2: PathnameCaseFuns, a value of
:common for the :case argument that these functions should receive and
yield strings in component values according to the following
conventions:

   • All uppercase means to use a file system’s customary case.
   • All lowercase means to use the opposite of the customary case.
   • Mixed case represents itself.

Note that these conventions have been chosen in such a way that
translation from :local to :common and back to :local is
information-preserving.

19.2.2.2 Special Pathname Component Values
..........................................

19.2.2.2.1 NIL as a Component Value
...................................

As a pathname component value, ‘nil’ represents that the component is
“unfilled”; see *note Section 19.2.3 (Merging Pathnames): Merging
Pathnames.

The value of any pathname component can be ‘nil’.

When constructing a pathname, ‘nil’ in the host component might mean a
default host rather than an actual ‘nil’ in some implementations.

19.2.2.2.2 :WILD as a Component Value
.....................................

If :wild is the value of a pathname component, that component is
considered to be a wildcard, which matches anything.

A conforming program must be prepared to encounter a value of :wild as
the value of any pathname component, or as an element of a list that is
the value of the directory component.

When constructing a pathname, a conforming program may use :wild as the
value of any or all of the directory, name, type, or version component,
but must not use :wild as the value of the host, or device component.

If :wild is used as the value of the directory component in the
construction of a pathname, the effect is equivalent to specifying the
list ‘(:absolute :wild-inferiors)’, or the same as ‘(:absolute :wild)’
in a file system that does not support :wild-inferiors.

19.2.2.2.3 :UNSPECIFIC as a Component Value
...........................................

If :unspecific is the value of a pathname component, the component is
considered to be “absent” or to “have no meaning” in the filename being
represented by the pathname.

Whether a value of :unspecific is permitted for any component on any
given file system accessible to the implementation is
implementation-defined.  A conforming program must never unconditionally
use a :unspecific as the value of a pathname component because such a
value is not guaranteed to be permissible in all implementations.
However, a conforming program can, if it is careful, successfully
manipulate user-supplied data which contains or refers to non-portable
pathname components.  And certainly a conforming program should be
prepared for the possibility that any components of a pathname could be
:unspecific.

When readingconforming programs should be prepared for the value to be
:unspecific.

When writingthe consequences are undefined if :unspecific is given for a
pathname in a file system for which it does not make sense.

19.2.2.2.3.1 Relation between component values NIL and :UNSPECIFIC
..................................................................

If a pathname is converted to a namestring, the symbols ‘nil’ and
:unspecific cause the field to be treated as if it were empty.  That is,
both ‘nil’ and :unspecific cause the component not to appear in the
namestring.

However, when merging a pathname with a set of defaults, only a
‘nil’ value for a component will be replaced with the default for that
component, while a value of :unspecific will be left alone as if the
field were “filled”; see the function *note merge-pathnames:: and *note
Section 19.2.3 (Merging Pathnames): Merging Pathnames.

19.2.2.3 Restrictions on Wildcard Pathnames
...........................................

Wildcard pathnames can be used with ‘directory’ but not with ‘open’, and
return true from ‘wild-pathname-p’.  When examining wildcard components
of a wildcard pathname, conforming programs must be prepared to
encounter any of the following additional values in any component or any
element of a list that is the directory component:

   • The symbol :wild, which matches anything.

   • A string containing implementation-dependent special wildcard
     characters.

   • Any object, representing an implementation-dependent wildcard
     pattern.

19.2.2.4 Restrictions on Examining Pathname Components
......................................................

The space of possible objects that a conforming program must be prepared
to readas the value of a pathname component is substantially larger than
the space of possible objects that a conforming program is permitted to
writeinto such a component.

While the values discussed in the subsections of this section, in *note
Section 19.2.2.2 (Special Pathname Component Values):
SpecialComponentValues, and in *note Section 19.2.2.3 (Restrictions on
Wildcard Pathnames): WildcardRestrictions. apply to values that might be
seen when reading the component values, substantially more restrictive
rules apply to constructing pathnames; see *note Section 19.2.2.5
(Restrictions on Constructing Pathnames): ConstructingPathnames.

When examining pathname components, conforming programs should be aware
of the following restrictions.

19.2.2.4.1 Restrictions on Examining a Pathname Host Component
..............................................................

It is implementation-dependent what object is used to represent the
host.

19.2.2.4.2 Restrictions on Examining a Pathname Device Component
................................................................

The device might be a string, :wild, :unspecific, or ‘nil’.

Note that :wild might result from an attempt to readthe pathname
component, even though portable programs are restricted from writingsee
*note Section 19.2.2.3 (Restrictions on Wildcard Pathnames):
WildcardRestrictions. and *note Section 19.2.2.5 (Restrictions on
Constructing Pathnames): ConstructingPathnames.

19.2.2.4.3 Restrictions on Examining a Pathname Directory Component
...................................................................

The directory might be a string, :wild, :unspecific, or ‘nil’.

The directory can be a list of strings and symbols.  The car of the list
is one of the symbols :absolute or :relative , meaning:

:absolute

     A list whose car is the symbol :absolute represents a directory
     path starting from the root directory.  The list ‘(:absolute)’
     represents the root directory.  The list ‘(:absolute "foo" "bar"
     "baz")’ represents the directory called ‘"/foo/bar/baz"’ in Unix
     (except possibly for case).

:relative

     A list whose car is the symbol :relative represents a directory
     path starting from a default directory.  The list ‘(:relative)’ has
     the same meaning as ‘nil’ and hence is not used.  The list
     ‘(:relative "foo" "bar")’ represents the directory named ‘"bar"’ in
     the directory named ‘"foo"’ in the default directory.

Each remaining element of the list is a string or a symbol.

Each string names a single level of directory structure.  The strings
should contain only the directory names themselves—no punctuation
characters.

In place of a string, at any point in the list, symbols can occur to
indicate special file notations.  The next figure lists the symbols that
have standard meanings.  Implementations are permitted to add additional
objects of any type that is disjoint from ‘string’ if necessary to
represent features of their file systems that cannot be represented with
the standard strings and symbols.

Supplying any non-string, including any of the symbols listed below, to
a file system for which it does not make sense signals an error of type
‘file-error’.  For example, Unix does not support :wild-inferiors in
most implementations.

Symbol            Meaning
-----------------------------------------------------------------------
:wild             Wildcard match of one level of directory structure
:wild-inferiors   Wildcard match of any number of directory levels
:up               Go upward in directory structure (semantic)
:back             Go upward in directory structure (syntactic)

Figure 19.3: Special Markers In Directory Component

The following notes apply to the previous figure:

Invalid Combinations

     Using :absolute or :wild-inferiors immediately followed by :up or
     :back signals an error of type ‘file-error’.

Syntactic vs Semantic

     “Syntactic” means that the action of :back depends only on the
     pathname and not on the contents of the file system.

     “Semantic” means that the action of :up depends on the contents of
     the file system; to resolve a pathname containing :up to a pathname
     whose directory component contains only :absolute and strings
     requires probing the file system.

     :up differs from :back only in file systems that support multiple
     names for directories, perhaps via symbolic links.  For example,
     suppose that there is a directory ‘(:absolute "X" "Y" "Z")’ linked
     to ‘(:absolute "A" "B" "C")’ and there also exist directories
     ‘(:absolute "A" "B" "Q")’ and ‘(:absolute "X" "Y" "Q")’.  Then
     ‘(:absolute "X" "Y" "Z" :up "Q")’ designates ‘(:absolute "A" "B"
     "Q")’ while ‘(:absolute "X" "Y" "Z" :back "Q")’ designates
     ‘(:absolute "X" "Y" "Q")’

19.2.2.4.3.1 Directory Components in Non-Hierarchical File Systems
..................................................................

In non-hierarchical file systems, the only valid list values for the
directory component of a pathname are ‘(:absolute string)’ and
‘(:absolute :wild)’.  :relative directories and the keywords
:wild-inferiors, :up, and :back are not used in non-hierarchical file
systems.

19.2.2.4.4 Restrictions on Examining a Pathname Name Component
..............................................................

The name might be a string, :wild, :unspecific, or ‘nil’.

19.2.2.4.5 Restrictions on Examining a Pathname Type Component
..............................................................

The type might be a string, :wild, :unspecific, or ‘nil’.

19.2.2.4.6 Restrictions on Examining a Pathname Version Component
.................................................................

The version can be any symbol or any integer.

The symbol :newest refers to the largest version number that already
exists in the file system when reading, overwriting, appending,
superseding, or directory listing an existing file.  The symbol :newest
refers to the smallest version number greater than any existing version
number when creating a new file.

The symbols ‘nil’, :unspecific, and :wild have special meanings and
restrictions; see *note Section 19.2.2.2 (Special Pathname Component
Values): SpecialComponentValues. and *note Section 19.2.2.5
(Restrictions on Constructing Pathnames): ConstructingPathnames.

Other symbols and integers have implementation-defined meaning.

19.2.2.4.7 Notes about the Pathname Version Component
.....................................................

It is suggested, but not required, that implementations do the
following:

   • Use positive integers starting at 1 as version numbers.

   • Recognize the symbol :oldest to designate the smallest existing
     version number.

   • Use keywords for other special versions.

19.2.2.5 Restrictions on Constructing Pathnames
...............................................

When constructing a pathname from components, conforming programs must
follow these rules:

   • Any component can be ‘nil’.  ‘nil’ in the host might mean a default
     host rather than an actual ‘nil’ in some implementations.

   • The host, device, directory, name, and type can be strings.  There
     are implementation-dependent limits on the number and type of
     characters in these strings.

   • The directory can be a list of strings and symbols.  There are
     implementation-dependent limits on the list’s length and contents.

   • The version can be :newest.

   • Any component can be taken from the corresponding component of
     another pathname.  When the two pathnames are for different file
     systems (in implementations that support multiple file systems), an
     appropriate translation occurs.  If no meaningful translation is
     possible, an error is signaled.  The definitions of “appropriate”
     and “meaningful” are implementation-dependent.

   • An implementation might support other values for some components,
     but a portable program cannot use those values.  A conforming
     program can use implementation-dependent values but this can make
     it non-portable; for example, it might work only with Unix file
     systems.


File: ansicl,  Node: Merging Pathnames,  Prev: Interpreting Pathname Component Values,  Up: Pathnames

19.2.3 Merging Pathnames
------------------------

Merging takes a pathname with unfilled components and supplies values
for those components from a source of defaults.

If a component’s value is ‘nil’, that component is considered to be
unfilled.  If a component’s value is any non-nil object, including
:unspecific, that component is considered to be filled.

Except as explicitly specified otherwise, for functions that manipulate
or inquire about files in the file system, the pathname argument to such
a function is merged with ‘*default-pathname-defaults*’ before accessing
the file system (as if by ‘merge-pathnames’).

19.2.3.1 Examples of Merging Pathnames
......................................

Although the following examples are possible to execute only in
implementations which permit :unspecific in the indicated position
andwhich permit four-letter type components, they serve to illustrate
the basic concept of pathname merging.

 

 

      (pathname-type
        (merge-pathnames (make-pathname :type "LISP")
                         (make-pathname :type "TEXT")))
     → "LISP"
      
      (pathname-type
        (merge-pathnames (make-pathname :type nil)
                         (make-pathname :type "LISP")))
     → "LISP"
      
      (pathname-type
        (merge-pathnames (make-pathname :type :unspecific)
                         (make-pathname :type "LISP")))
     → :UNSPECIFIC


File: ansicl,  Node: Logical Pathnames,  Next: pathname (System Class),  Prev: Pathnames,  Up: Filenames

19.3 Logical Pathnames
======================

* Menu:

* Syntax of Logical Pathname Namestrings::
* Logical Pathname Components::


File: ansicl,  Node: Syntax of Logical Pathname Namestrings,  Next: Logical Pathname Components,  Up: Logical Pathnames

19.3.1 Syntax of Logical Pathname Namestrings
---------------------------------------------

The syntax of a logical pathname namestring is as follows.  (Note that
unlike many notational descriptions in this document, this is a
syntactic description of character sequences, not a structural
description of objects.)

LOGICAL-PATHNAME::=
     [↓host HOST-MARKER]
     [↓RELATIVE-DIRECTORY-MARKER] {↓directory DIRECTORY-MARKER}*
     [↓name] [TYPE-MARKER ↓type [VERSION-MARKER ↓version]]

HOST::=
     ↓word
DIRECTORY::=
     ↓word | ↓wildcard-word | ↓wild-inferiors-word
NAME::=
     ↓word | ↓wildcard-word
TYPE::=
     ↓word | ↓wildcard-word
VERSION::=
     ↓pos-int | NEWEST-WORD | WILDCARD-VERSION

HOST-MARKER—a colon.

RELATIVE-DIRECTORY-MARKER—a semicolon.

DIRECTORY-MARKER—a semicolon.

TYPE-MARKER—a dot.

VERSION-MARKER—a dot.

WILD-INFERIORS-WORD—The two character sequence “‘**’” (two asterisks).

NEWEST-WORD—The six character sequence “‘newest’” or the six character
sequence “‘NEWEST’”.

WILDCARD-VERSION—an asterisk.

WILDCARD-WORD—one or more asterisks, uppercase letters, digits, and
hyphens, including at least one asterisk, with no two asterisks
adjacent.

WORD—one or more uppercase letters, digits, and hyphens.

POS-INT—a positive integer.

19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings
..........................................................................

19.3.1.1.1 The Host part of a Logical Pathname Namestring
.........................................................

The HOST must have been defined as a logical pathname host; this can be
done by using ‘setf’ of ‘logical-pathname-translations’.

The logical pathname host name ‘"SYS"’ is reserved for the
implementation.  The existence and meaning of ‘SYS:’ logical pathnames
is implementation-defined.

19.3.1.1.2 The Device part of a Logical Pathname Namestring
...........................................................

There is no syntax for a logical pathname device since the device
component of a logical pathname is always :unspecific; see *note Section
19.3.2.1 (Unspecific Components of a Logical Pathname):
LogicalPathCompUnspecific.

19.3.1.1.3 The Directory part of a Logical Pathname Namestring
..............................................................

If a RELATIVE-DIRECTORY-MARKER precedes the DIRECTORIES, the directory
component parsed is as relative; otherwise, the directory component is
parsed as absolute.

If a WILD-INFERIORS-MARKER is specified, it parses into :wild-inferiors.

19.3.1.1.4 The Type part of a Logical Pathname Namestring
.........................................................

The TYPE of a logical pathname for a source file is ‘"LISP"’.  This
should be translated into whatever type is appropriate in a physical
pathname.

19.3.1.1.5 The Version part of a Logical Pathname Namestring
............................................................

Some file systems do not have VERSIONS.  Logical pathname translation to
such a file system ignores the VERSION.  This implies that a program
cannot rely on being able to store more than one version of a file named
by a logical pathname.

If a WILDCARD-VERSION is specified, it parses into :wild.

19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring
..........................................................

Each asterisk in a WILDCARD-WORD matches a sequence of zero or more
characters.  The WILDCARD-WORD “‘*’” parses into :wild; other
wildcard-words parse into strings.

19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring
.............................................................

When parsing WORDS and WILDCARD-WORDS, lowercase letters are translated
to uppercase.

19.3.1.1.8 Other Syntax in a Logical Pathname Namestring
........................................................

The consequences of using characters other than those specified here in
a logical pathname namestring are unspecified.

The consequences of using any value not specified here as a logical
pathname component are unspecified.


File: ansicl,  Node: Logical Pathname Components,  Prev: Syntax of Logical Pathname Namestrings,  Up: Logical Pathnames

19.3.2 Logical Pathname Components
----------------------------------

19.3.2.1 Unspecific Components of a Logical Pathname
....................................................

The device component of a logical pathname is always :unspecific; no
other component of a logical pathname can be :unspecific.

19.3.2.2 Null Strings as Components of a Logical Pathname
.........................................................

The null string, ‘""’, is not a valid value for any component of a
logical pathname.


File: ansicl,  Node: pathname (System Class),  Next: logical-pathname (System Class),  Prev: Logical Pathnames,  Up: Filenames

pathname (System Class)
=======================

Class Precedence List:
......................

‘pathname’, ‘t’

Description:
............

A pathname is a structured object which represents a filename.

There are two kinds of pathnames—physical pathnames and logical
pathnames.


File: ansicl,  Node: logical-pathname (System Class),  Next: pathname (Function),  Prev: pathname (System Class),  Up: Filenames

logical-pathname (System Class)
===============================

Class Precedence List:
......................

‘logical-pathname’, ‘pathname’, ‘t’

Description:
............

A pathname that uses a namestring syntax that is
implementation-independent, and that has component values that are
implementation-independent.  Logical pathnames do not refer directly to
filenames

See Also:
.........

*note Section 20.1 (File System Concepts): File System Concepts, *note
Section 2.4.8.14 (Sharpsign P): SharpsignP, *note Section 22.1.3.11
(Printing Pathnames): PrintingPathnames.


File: ansicl,  Node: pathname (Function),  Next: make-pathname,  Prev: logical-pathname (System Class),  Up: Filenames

pathname (Function)
===================

Syntax:
.......

 -- Function: pathname pathspec → pathname

Arguments and Values:
.....................

PATHSPEC—a pathname designator.

PATHNAME—a pathname.

Description:
............

Returns the pathname denoted by PATHSPEC.

If the PATHSPEC designator is a stream, the stream can be either open or
closed; in both cases, the ‘pathname’ returned corresponds to the
filename used to open the file.  ‘pathname’ returns the same pathname
for a file stream after it is closed as it did when it was open.

If the PATHSPEC designator is a file stream created by opening a logical
pathname, a logical pathname is returned.

Examples:
.........

      ;; There is a great degree of variability permitted here.  The next
      ;; several examples are intended to illustrate just a few of the many
      ;; possibilities.  Whether the name is canonicalized to a particular
      ;; case (either upper or lower) depends on both the file system and the
      ;; implementation since two different implementations using the same
      ;; file system might differ on many issues.  How information is stored
      ;; internally (and possibly presented in #S notation) might vary,
      ;; possibly requiring `accessors' such as PATHNAME-NAME to perform case
      ;; conversion upon access.  The format of a namestring is dependent both
      ;; on the file system and the implementation since, for example, one
      ;; implementation might include the host name in a namestring, and
      ;; another might not.  #S notation would generally only be used in a
      ;; situation where no appropriate namestring could be constructed for use
      ;; with #P.
      (setq p1 (pathname "test"))
     → #P"CHOCOLATE:TEST" ; with case canonicalization (e.g., VMS)
     or→ #P"VANILLA:test"   ; without case canonicalization (e.g., Unix)
     or→ #P"test"
     or→ #S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")
     or→ #S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")
      (setq p2 (pathname "test"))
     → #P"CHOCOLATE:TEST"
     or→ #P"VANILLA:test"
     or→ #P"test"
     or→ #S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")
     or→ #S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")
      (pathnamep p1) → true
      (eq p1 (pathname p1)) → true
      (eq p1 p2)
     → true
     or→ false
      (with-open-file (stream "test" :direction :output)
        (pathname stream))
     → #P"ORANGE-CHOCOLATE:>Gus>test.lisp.newest"

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: ansicl,  Node: make-pathname,  Next: pathnamep,  Prev: pathname (Function),  Up: Filenames

make-pathname (Function)
========================

Syntax:
.......

 -- Function: make-pathname &key host device directory name type version
          defaults case → pathname

Arguments and Values:
.....................

HOST—a valid physical pathname host.  Complicated defaulting behavior;
see below.

DEVICE—a valid pathname device.  Complicated defaulting behavior; see
below.

DIRECTORY—a valid pathname directory.  Complicated defaulting behavior;
see below.

NAME—a valid pathname name.  Complicated defaulting behavior; see below.

TYPE—a valid pathname type.  Complicated defaulting behavior; see below.

VERSION—a valid pathname version.  Complicated defaulting behavior; see
below.

DEFAULTS—a pathname designator.  The default is a pathname whose host
component is the same as the host component of the value of
‘*default-pathname-defaults*’, and whose other components are all ‘nil’.

CASE—one of :common or :local.  The default is :local.

PATHNAME—a pathname.

Description:
............

Constructs and returns a pathname from the supplied keyword arguments.

After the components supplied explicitly by HOST, DEVICE, DIRECTORY,
NAME, TYPE, and VERSION are filled in, the merging rules used by
‘merge-pathnames’ are used to fill in any unsupplied components from the
defaults supplied by DEFAULTS.

Whenever a pathname is constructed the components may be canonicalized
if appropriate.  For the explanation of the arguments that can be
supplied for each component, see *note Section 19.2.1 (Pathname
Components): Pathname Components.

If CASE is supplied, it is treated as described in *note Section
19.2.2.1.2 (Case in Pathname Components): PathnameComponentCase.

The resulting PATHNAME is a logical pathname if and only its host
component is a logical host or a string that names a defined logical
host.

If the DIRECTORY is a string, it should be the name of a top level
directory, and should not contain any punctuation characters; that is,
specifying a string, str, is equivalent to specifying the list
‘(:absolute str)’.  Specifying the symbol :wild is equivalent to
specifying the list ‘(:absolute :wild-inferiors)’, or ‘(:absolute
:wild)’ in a file system that does not support :wild-inferiors.

Examples:
.........

      ;; Implementation A -- an implementation with access to a single
      ;;  Unix file system.  This implementation happens to never display
      ;;  the `host' information in a namestring, since there is only one host.
      (make-pathname :directory '(:absolute "public" "games")
                     :name "chess" :type "db")
     → #P"/public/games/chess.db"
      
      
      ;; Implementation B -- an implementation with access to one or more
      ;;  VMS file systems.  This implementation displays `host' information
      ;;  in the namestring only when the host is not the local host.
      ;;  It uses a double colon to separate a host name from the host's local
      ;;  file name.
      (make-pathname :directory '(:absolute "PUBLIC" "GAMES")
                     :name "CHESS" :type "DB")
     → #P"SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
      (make-pathname :host "BOBBY"
                     :directory '(:absolute "PUBLIC" "GAMES")
                     :name "CHESS" :type "DB")
     → #P"BOBBY::SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
      
      
      ;; Implementation C -- an implementation with simultaneous access to
      ;;  multiple file systems from the same Lisp image.  In this
      ;;  implementation, there is a convention that any text preceding the
      ;;  first colon in a pathname namestring is a host name.
      (dolist (case '(:common :local))
        (dolist (host '("MY-LISPM" "MY-VAX" "MY-UNIX"))
          (print (make-pathname :host host :case case
                                :directory '(:absolute "PUBLIC" "GAMES")
                                :name "CHESS" :type "DB"))))
     ▷ #P"MY-LISPM:>public>games>chess.db"
     ▷ #P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
     ▷ #P"MY-UNIX:/public/games/chess.db"
     ▷ #P"MY-LISPM:>public>games>chess.db"
     ▷ #P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
     ▷ #P"MY-UNIX:/PUBLIC/GAMES/CHESS.DB"
     → NIL

Affected By:
............

The file system.

See Also:
.........

*note merge-pathnames::, *note pathname (System Class)::, *note
logical-pathname (System Class)::, *note Section 20.1 (File System
Concepts): File System Concepts, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.

Notes:
......

Portable programs should not supply :unspecific for any component.  See
*note Section 19.2.2.2.3 (.UNSPECIFIC as a Component Value):
UnspecificComponent.


File: ansicl,  Node: pathnamep,  Next: pathname-host; pathname-device; pathname-directory; pathname-name; path+,  Prev: make-pathname,  Up: Filenames

pathnamep (Function)
====================

Syntax:
.......

 -- Function: pathnamep object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘pathname’; otherwise, returns false.

Examples:
.........

      (setq q "test")  → "test"
      (pathnamep q) → false
      (setq q (pathname "test"))
     → #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test" :TYPE NIL
            :VERSION NIL)
      (pathnamep q) → true
      (setq q (logical-pathname "SYS:SITE;FOO.SYSTEM"))
     → #P"SYS:SITE;FOO.SYSTEM"
      (pathnamep q) → true

Notes:
......

      (pathnamep OBJECT) ≡ (typep OBJECT 'pathname)


File: ansicl,  Node: pathname-host; pathname-device; pathname-directory; pathname-name; path+,  Next: load-logical-pathname-translations,  Prev: pathnamep,  Up: Filenames

pathname-host, pathname-device, pathname-directory, pathname-name, pathname-type, pathname-version (Function)
=============================================================================================================

Syntax:
.......

 -- Function: pathname-host pathname &key case → host

 -- Function: pathname-device pathname &key case → device

 -- Function: pathname-directory pathname &key case → directory

 -- Function: pathname-name pathname &key case → name

 -- Function: pathname-type pathname &key case → type

 -- Function: pathname-version pathname → version

Arguments and Values:
.....................

PATHNAME—a pathname designator.

CASE—one of :local or :common.  The default is :local.

HOST—a valid pathname host.

DEVICE—a valid pathname device.

DIRECTORY—a valid pathname directory.

NAME—a valid pathname name.

TYPE—a valid pathname type.

VERSION—a valid pathname version.

Description:
............

These functions return the components of PATHNAME.

If the PATHNAME designator is a pathname, it represents the name used to
open the file.  This may be, but is not required to be, the actual name
of the file.

If CASE is supplied, it is treated as described in *note Section
19.2.2.1.2 (Case in Pathname Components): PathnameComponentCase.

Examples:
.........

      (setq q (make-pathname :host "KATHY"
                             :directory "CHAPMAN"
                             :name "LOGIN" :type "COM"))
     → #P"KATHY::[CHAPMAN]LOGIN.COM"
      (pathname-host q) → "KATHY"
      (pathname-name q) → "LOGIN"
      (pathname-type q) → "COM"

      ;; Because namestrings are used, the results shown in the remaining
      ;; examples are not necessarily the only possible results.  Mappings
      ;; from namestring representation to pathname representation are
      ;; dependent both on the file system involved and on the implementation
      ;; (since there may be several implementations which can manipulate the
      ;; the same file system, and those implementations are not constrained
      ;; to agree on all details). Consult the documentation for each
      ;; implementation for specific information on how namestrings are treated
      ;; that implementation.

      ;; VMS
      (pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP"))
     → (:ABSOLUTE "FOO" "BAR")
      (pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP") :case :common)
     → (:ABSOLUTE "FOO" "BAR")

      ;; Unix
      (pathname-directory "foo.l") → NIL
      (pathname-device "foo.l") → :UNSPECIFIC
      (pathname-name "foo.l") → "foo"
      (pathname-name "foo.l" :case :local) → "foo"
      (pathname-name "foo.l" :case :common) → "FOO"
      (pathname-type "foo.l") → "l"
      (pathname-type "foo.l" :case :local) → "l"
      (pathname-type "foo.l" :case :common) → "L"
      (pathname-type "foo") → :UNSPECIFIC
      (pathname-type "foo" :case :common) → :UNSPECIFIC
      (pathname-type "foo.") → ""
      (pathname-type "foo." :case :common) → ""
      (pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)
     → (:ABSOLUTE "foo" "bar")
      (pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)
     → (:ABSOLUTE "FOO" "BAR")
      (pathname-directory (parse-namestring "../baz.lisp"))
     → (:RELATIVE :UP)
      (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz"))
     → (:ABSOLUTE "foo" "BAR" :UP "Mum")
      (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz") :case :common)
     → (:ABSOLUTE "FOO" "bar" :UP "Mum")
      (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l"))
     → (:ABSOLUTE "foo" :WILD "bar")
      (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l") :case :common)
     → (:ABSOLUTE "FOO" :WILD "BAR")

      ;; Symbolics LMFS
      (pathname-directory (parse-namestring ">foo>**>bar>baz.lisp"))
     → (:ABSOLUTE "foo" :WILD-INFERIORS "bar")
      (pathname-directory (parse-namestring ">foo>*>bar>baz.lisp"))
     → (:ABSOLUTE "foo" :WILD "bar")
      (pathname-directory (parse-namestring ">foo>*>bar>baz.lisp") :case :common)
     → (:ABSOLUTE "FOO" :WILD "BAR")
      (pathname-device (parse-namestring ">foo>baz.lisp")) → :UNSPECIFIC

Affected By:
............

The implementation and the host file system.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its first argument is not
a pathname.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: ansicl,  Node: load-logical-pathname-translations,  Next: logical-pathname-translations,  Prev: pathname-host; pathname-device; pathname-directory; pathname-name; path+,  Up: Filenames

load-logical-pathname-translations (Function)
=============================================

Syntax:
.......

 -- Function: load-logical-pathname-translations host → just-loaded

Arguments and Values:
.....................

HOST—a string.

just-loaded—a generalized boolean.

Description:
............

Searches for and loads the definition of a logical host named HOST, if
it is not already defined.  The specific nature of the search is
implementation-defined.

If the HOST is already defined, no attempt to find or load a definition
is attempted, and false is returned.  If the HOST is not already
defined, but a definition is successfully found and loaded, true is
returned.  Otherwise, an error is signaled.

Examples:
.........

      (translate-logical-pathname "hacks:weather;barometer.lisp.newest")
     ▷ Error: The logical host HACKS is not defined.
      (load-logical-pathname-translations "HACKS")
     ▷ ;; Loading SYS:SITE;HACKS.TRANSLATIONS
     ▷ ;; Loading done.
     → true
      (translate-logical-pathname "hacks:weather;barometer.lisp.newest")
     → #P"HELIUM:[SHARED.HACKS.WEATHER]BAROMETER.LSP;0"
      (load-logical-pathname-translations "HACKS")
     → false

Exceptional Situations:
.......................

If no definition is found, an error of type ‘error’ is signaled.

See Also:
.........

*note logical-pathname (System Class)::

Notes:
......

Logical pathname definitions will be created not just by implementors
but also by programmers.  As such, it is important that the search
strategy be documented.  For example, an implementation might define
that the definition of a HOST is to be found in a file called
“HOST.translations” in some specifically named directory.


File: ansicl,  Node: logical-pathname-translations,  Next: logical-pathname (Function),  Prev: load-logical-pathname-translations,  Up: Filenames

logical-pathname-translations (Accessor)
========================================

Syntax:
.......

 -- Function: logical-pathname-translations host → translations
(setf (logical-pathname-translations host) new-translations)

Arguments and Values:
.....................

HOST—a logical host designator.

TRANSLATIONS, NEW-TRANSLATIONS—a list.

Description:
............

Returns the host’s list of translations.  Each translation is a list of
at least two elements: from-wildcard and to-wildcard.  Any additional
elements are implementation-defined.  From-wildcard is a logical
pathname whose host is HOST.  To-wildcard is a pathname.

‘(setf (logical-pathname-translations HOST) translations)’ sets a
logical pathname host’s list of translations.  If HOST is a string that
has not been previously used as a logical pathname host, a new logical
pathname host is defined; otherwise an existing host’s translations are
replaced.  logical pathname host names are compared with ‘string-equal’.

When setting the translations list, each from-wildcard can be a logical
pathname whose host is HOST or a logical pathname namestring parseable
by ‘(parse-namestring string host)’, where host represents the
appropriate object as defined by ‘parse-namestring’.  Each to-wildcard
can be anything coercible to a pathname by ‘(pathname to-wildcard)’.  If
to-wildcard coerces to a logical pathname, ‘translate-logical-pathname’
will perform repeated translation steps when it uses it.

HOST is either the host component of a logical pathname or a string that
has been defined as a logical pathname host name by ‘setf’ of
‘logical-pathname-translations’.

Examples:
.........

      ;;;A very simple example of setting up a logical pathname host.  No
      ;;;translations are necessary to get around file system restrictions, so
      ;;;all that is necessary is to specify the root of the physical directory
      ;;;tree that contains the logical file system.
      ;;;The namestring syntax on the right-hand side is implementation-dependent.
      (setf (logical-pathname-translations "foo")
            '(("**;*.*.*"              "MY-LISPM:>library>foo>**>")))
      
      ;;;Sample use of that logical pathname.  The return value
      ;;;is implementation-dependent.
      (translate-logical-pathname "foo:bar;baz;mum.quux.3")
     → #P"MY-LISPM:>library>foo>bar>baz>mum.quux.3"
      
      
      ;;;A more complex example, dividing the files among two file servers
      ;;;and several different directories.  This Unix doesn't support
      ;;;:WILD-INFERIORS in the directory, so each directory level must
      ;;;be translated individually.  No file name or type translations
      ;;;are required except for .MAIL to .MBX.
      ;;;The namestring syntax on the right-hand side is implementation-dependent.
      (setf (logical-pathname-translations "prog")
            '(("RELEASED;*.*.*"        "MY-UNIX:/sys/bin/my-prog/")
              ("RELEASED;*;*.*.*"      "MY-UNIX:/sys/bin/my-prog/*/")
              ("EXPERIMENTAL;*.*.*"    "MY-UNIX:/usr/Joe/development/prog/")
              ("EXPERIMENTAL;DOCUMENTATION;*.*.*"
                                       "MY-VAX:SYS$DISK:[JOE.DOC]")
              ("EXPERIMENTAL;*;*.*.*"  "MY-UNIX:/usr/Joe/development/prog/*/")
              ("MAIL;**;*.MAIL"        "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))
      
      ;;;Sample use of that logical pathname.  The return value
      ;;;is implementation-dependent.
      (translate-logical-pathname "prog:mail;save;ideas.mail.3")
     → #P"MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3"
      
      
      ;;;Example translations for a program that uses three files main.lisp,
      ;;;auxiliary.lisp, and documentation.lisp.  These translations might be
      ;;;supplied by a software supplier as examples.
      
      ;;;For Unix with long file names
      (setf (logical-pathname-translations "prog")
            '(("CODE;*.*.*"             "/lib/prog/")))
      
      ;;;Sample use of that logical pathname.  The return value
      ;;;is implementation-dependent.
      (translate-logical-pathname "prog:code;documentation.lisp")
     → #P"/lib/prog/documentation.lisp"
      
      ;;;For Unix with 14-character file names, using .lisp as the type
      (setf (logical-pathname-translations "prog")
            '(("CODE;DOCUMENTATION.*.*" "/lib/prog/docum.*")
              ("CODE;*.*.*"             "/lib/prog/")))

      ;;;Sample use of that logical pathname.  The return value
      ;;;is implementation-dependent.
      (translate-logical-pathname "prog:code;documentation.lisp")
     → #P"/lib/prog/docum.lisp"
      
      
      ;;;For Unix with 14-character file names, using .l as the type
      ;;;The second translation shortens the compiled file type to .b
      (setf (logical-pathname-translations "prog")
            `(("**;*.LISP.*"            ,(logical-pathname "PROG:**;*.L.*"))
              (,(compile-file-pathname (logical-pathname "PROG:**;*.LISP.*"))
                                        ,(logical-pathname "PROG:**;*.B.*"))
              ("CODE;DOCUMENTATION.*.*" "/lib/prog/documentatio.*")
              ("CODE;*.*.*"             "/lib/prog/")))
      
      ;;;Sample use of that logical pathname.  The return value
      ;;;is implementation-dependent.
      (translate-logical-pathname "prog:code;documentation.lisp")
     → #P"/lib/prog/documentatio.l"
      
      
      ;;;For a Cray with 6 character names and no directories, types, or versions.
      (setf (logical-pathname-translations "prog")
            (let ((l '(("MAIN" "PGMN")
                       ("AUXILIARY" "PGAUX")
                       ("DOCUMENTATION" "PGDOC")))
                  (logpath (logical-pathname "prog:code;"))
                  (phypath (pathname "XXX")))
              (append
                ;; Translations for source files
                (mapcar #'(lambda (x)
                            (let ((log (first x))
                                  (phy (second x)))
                              (list (make-pathname :name log
                                                   :type "LISP"
                                                   :version :wild
                                                   :defaults logpath)
                                    (make-pathname :name phy
                                                   :defaults phypath))))
                        l)
                ;; Translations for compiled files
                (mapcar #'(lambda (x)
                            (let* ((log (first x))
                                   (phy (second x))
                                   (com (compile-file-pathname
                                          (make-pathname :name log
                                                         :type "LISP"
                                                         :version :wild
                                                         :defaults logpath))))
                              (setq phy (concatenate 'string phy "B"))
                              (list com
                                    (make-pathname :name phy
                                                   :defaults phypath))))
                        l))))

      ;;;Sample use of that logical pathname.  The return value
      ;;;is implementation-dependent.
      (translate-logical-pathname "prog:code;documentation.lisp")
     → #P"PGDOC"

Exceptional Situations:
.......................

If HOST is incorrectly supplied, an error of type ‘type-error’ is
signaled.

See Also:
.........

*note logical-pathname (System Class)::, *note Section 19.1.2 (Pathnames
as Filenames): Pathnames as Filenames.

Notes:
......

Implementations can define additional functions that operate on logical
pathname hosts, for example to specify additional translation rules or
options.


File: ansicl,  Node: logical-pathname (Function),  Next: *default-pathname-defaults*,  Prev: logical-pathname-translations,  Up: Filenames

logical-pathname (Function)
===========================

Syntax:
.......

 -- Function: logical-pathname pathspec → logical-pathname

Arguments and Values:
.....................

PATHSPEC—a logical pathname, a logical pathname namestring, or a stream.

LOGICAL-PATHNAME—a logical pathname.

Description:
............

‘logical-pathname’ converts PATHSPEC to a logical pathname and returns
the new logical pathname.  If PATHSPEC is a logical pathname namestring,
it should contain a host component and its following colon.  If PATHSPEC
is a stream, it should be one for which ‘pathname’ returns a logical
pathname.

If PATHSPEC is a stream, the stream can be either open or closed.
‘logical-pathname’ returns the same logical pathname after a file is
closed as it did when the file was open.  It is an error if PATHSPEC is
a stream that is created with ‘make-two-way-stream’, ‘make-echo-stream’,
‘make-broadcast-stream’, ‘make-concatenated-stream’,
‘make-string-input-stream’, or ‘make-string-output-stream’.

Exceptional Situations:
.......................

Signals an error of type ‘type-error’ if PATHSPEC isn’t supplied
correctly.

See Also:
.........

*note logical-pathname (System Class)::, *note
translate-logical-pathname::, *note Section 19.3 (Logical Pathnames):
Logical Pathnames.


File: ansicl,  Node: *default-pathname-defaults*,  Next: namestring; file-namestring; directory-namestring; host-namestring; eno+,  Prev: logical-pathname (Function),  Up: Filenames

*default-pathname-defaults* (Variable)
======================================

Value Type:
...........

a pathname object.

Initial Value:
..............

An implementation-dependent pathname, typically in the working directory
that was current when Common Lisp was started up.

Description:
............

a pathname, used as the default whenever a function needs a default
pathname and one is not supplied.

Examples:
.........

      ;; This example illustrates a possible usage for a hypothetical Lisp running on a
      ;; DEC TOPS-20 file system.  Since pathname conventions vary between Lisp
      ;; implementations and host file system types, it is not possible to provide a
      ;; general-purpose, conforming example.
      *default-pathname-defaults* → #P"PS:<FRED>"
      (merge-pathnames (make-pathname :name "CALENDAR"))
     → #P"PS:<FRED>CALENDAR"
      (let ((*default-pathname-defaults* (pathname "<MARY>")))
        (merge-pathnames (make-pathname :name "CALENDAR")))
     → #P"<MARY>CALENDAR"

Affected By:
............

The implementation.


File: ansicl,  Node: namestring; file-namestring; directory-namestring; host-namestring; eno+,  Next: parse-namestring,  Prev: *default-pathname-defaults*,  Up: Filenames

namestring, file-namestring, directory-namestring, host-namestring, enough-namestring (Function)
================================================================================================

Syntax:
.......

 -- Function: namestring pathname → namestring

 -- Function: file-namestring pathname → namestring
 -- Function: directory-namestring pathname → namestring
 -- Function: host-namestring pathname → namestring

 -- Function: enough-namestring pathname &optional defaults → namestring

Arguments and Values:
.....................

PATHNAME—a pathname designator.

DEFAULTS—a pathname designator.  The default is the value of
‘*default-pathname-defaults*’.

NAMESTRING—a string or ‘nil’.

Description:
............

These functions convert PATHNAME into a namestring.  The name
represented by PATHNAME is returned as a namestring in an
implementation-dependent canonical form.

‘namestring’ returns the full form of PATHNAME.

‘file-namestring’ returns just the name, type, and version components of
PATHNAME.

‘directory-namestring’ returns the directory name portion.

‘host-namestring’ returns the host name.

‘enough-namestring’ returns an abbreviated namestring that is just
sufficient to identify the file named by PATHNAME when considered
relative to the DEFAULTS.  It is required that

      (merge-pathnames (enough-namestring pathname defaults) defaults)
     ≡ (merge-pathnames (parse-namestring pathname nil defaults) defaults)

in all cases, and the result of ‘enough-namestring’ is the shortest
reasonable string that will satisfy this criterion.

It is not necessarily possible to construct a valid namestring by
concatenating some of the three shorter namestrings in some order.

Examples:
.........

      (namestring "getty")
     → "getty"
      (setq q (make-pathname :host "kathy"
                              :directory
                                (pathname-directory *default-pathname-defaults*)
                              :name "getty"))
     → #S(PATHNAME :HOST "kathy" :DEVICE NIL :DIRECTORY directory-name
            :NAME "getty" :TYPE NIL :VERSION NIL)
      (file-namestring q) → "getty"
      (directory-namestring q) → directory-name
      (host-namestring q) → "kathy"

      ;;;Using Unix syntax and the wildcard conventions used by the
      ;;;particular version of Unix on which this example was created:
      (namestring
        (translate-pathname "/usr/dmr/hacks/frob.l"
                            "/usr/d*/hacks/*.l"
                            "/usr/d*/backup/hacks/backup-*.*"))
     → "/usr/dmr/backup/hacks/backup-frob.l"
      (namestring
        (translate-pathname "/usr/dmr/hacks/frob.l"
                            "/usr/d*/hacks/fr*.l"
                            "/usr/d*/backup/hacks/backup-*.*"))
     → "/usr/dmr/backup/hacks/backup-ob.l"

      ;;;This is similar to the above example but uses two different hosts,
      ;;;U: which is a Unix and V: which is a VMS.  Note the translation
      ;;;of file type and alphabetic case conventions.
      (namestring
        (translate-pathname "U:/usr/dmr/hacks/frob.l"
                            "U:/usr/d*/hacks/*.l"
                            "V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))
     → "V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP"
      (namestring
        (translate-pathname "U:/usr/dmr/hacks/frob.l"
                            "U:/usr/d*/hacks/fr*.l"
                            "V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))
     → "V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP"

See Also:
.........

*note truename::, *note merge-pathnames::, *note pathname (System
Class)::, *note logical-pathname (System Class)::, *note Section 20.1
(File System Concepts): File System Concepts, *note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.


File: ansicl,  Node: parse-namestring,  Next: wild-pathname-p,  Prev: namestring; file-namestring; directory-namestring; host-namestring; eno+,  Up: Filenames

parse-namestring (Function)
===========================

Syntax:
.......

 -- Function: parse-namestring thing &optional host default-pathname
          &key start end junk-allowed → pathname, position

Arguments and Values:
.....................

THING—a string, a pathname, or a stream associated with a file.

HOST—a valid pathname host, a logical host, or ‘nil’.

DEFAULT-PATHNAME—a pathname designator.  The default is the value of
‘*default-pathname-defaults*’.

START, END—bounding index designators of THING.  The defaults for START
and END are ‘0’ and ‘nil’, respectively.

JUNK-ALLOWED—a generalized boolean.  The default is false.

PATHNAME—a pathname, or ‘nil’.

POSITION—a bounding index designator for THING.

Description:
............

Converts THING into a pathname.

The HOST supplies a host name with respect to which the parsing occurs.

If THING is a stream associated with a file, processing proceeds as if
the pathname used to open that file had been supplied instead.

If THING is a pathname, the HOST and the host component of THING are
compared.  If they match, two values are immediately returned: THING and
START; otherwise (if they do not match), an error is signaled.

Otherwise (if THING is a string), ‘parse-namestring’ parses the name of
a file within the substring of THING bounded by START and END.

If THING is a string then the substring of THING bounded by START and
END is parsed into a pathname as follows:

   • If HOST is a logical host then THING is parsed as a logical
     pathname namestring on the HOST.

   • If HOST is ‘nil’ and THING is a syntactically valid logical
     pathname namestring containing an explicit host, then it is parsed
     as a logical pathname namestring.

   • If HOST is ‘nil’, DEFAULT-PATHNAME is a logical pathname, and THING
     is a syntactically valid logical pathname namestring without an
     explicit host, then it is parsed as a logical pathname namestring
     on the host that is the host component of DEFAULT-PATHNAME.

   • Otherwise, the parsing of THING is implementation-defined.

In the first of these cases, the host portion of the logical pathname
namestring and its following colon are optional.

If the host portion of the namestring and HOST are both present and do
not match, an error is signaled.

If JUNK-ALLOWED is true, then the primary value is the pathname parsed
or, if no syntactically correct pathname was seen, ‘nil’.  If
JUNK-ALLOWED is false, then the entire substring is scanned, and the
primary value is the pathname parsed.

In either case, the secondary value is the index into THING of the
delimiter that terminated the parse, or the index beyond the substring
if the parse terminated at the end of the substring (as will always be
the case if JUNK-ALLOWED is false).

Parsing a null string always succeeds, producing a pathname with all
components (except the host) equal to ‘nil’.

If THING contains an explicit host name and no explicit device name,
then it is implementation-defined whether ‘parse-namestring’ will supply
the standard default device for that host as the device component of the
resulting pathname.

Examples:
.........

      (setq q (parse-namestring "test"))
     → #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test"
            :TYPE NIL :VERSION NIL)
      (pathnamep q) → true
      (parse-namestring "test")
     → #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test"
            :TYPE NIL :VERSION NIL), 4
      (setq s (open xxx)) → #<Input File Stream...>
      (parse-namestring s)
     → #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME xxx
            :TYPE NIL :VERSION NIL), 0
      (parse-namestring "test" nil nil :start 2 :end 4 )
      → #S(PATHNAME ...), 15
      (parse-namestring "foo.lisp")
     → #P"foo.lisp"

Exceptional Situations:
.......................

If JUNK-ALLOWED is false, an error of type ‘parse-error’ is signaled if
THING does not consist entirely of the representation of a pathname,
possibly surrounded on either side by whitespaceappropriate to the
cultural conventions of the implementation.

If HOST is supplied and not ‘nil’, and THING contains a manifest host
name, an error of type ‘error’ is signaled if the hosts do not match.

If THING is a logical pathname namestring and if the host portion of the
namestring and HOST are both present and do not match, an error of type
‘error’ is signaled.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.2.2.2.3 (.UNSPECIFIC as a Component Value):
UnspecificComponent, *note Section 19.1.2 (Pathnames as Filenames):
Pathnames as Filenames.


File: ansicl,  Node: wild-pathname-p,  Next: pathname-match-p,  Prev: parse-namestring,  Up: Filenames

wild-pathname-p (Function)
==========================

Syntax:
.......

 -- Function: wild-pathname-p pathname &optional field-key →
          generalized-boolean

Arguments and Values:
.....................

PATHNAME—a pathname designator.

FIELD-KEY—one of :host, :device :directory, :name, :type, :version, or
‘nil’.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘wild-pathname-p’ tests PATHNAME for the presence of wildcard
components.

If PATHNAME is a pathname (as returned by ‘pathname’) it represents the
name used to open the file.  This may be, but is not required to be, the
actual name of the file.

If FIELD-KEY is not supplied or ‘nil’, ‘wild-pathname-p’ returns true if
PATHNAME has any wildcard components, ‘nil’  if PATHNAME has none.  If
FIELD-KEY is non-nil, ‘wild-pathname-p’ returns true if the indicated
component of PATHNAME is a wildcard, ‘nil’ if the component is not a
wildcard.

Examples:
.........

      ;;;The following examples are not portable.  They are written to run
      ;;;with particular file systems and particular wildcard conventions.
      ;;;Other implementations will behave differently.  These examples are
      ;;;intended to be illustrative, not to be prescriptive.

      (wild-pathname-p (make-pathname :name :wild)) → true
      (wild-pathname-p (make-pathname :name :wild) :name) → true
      (wild-pathname-p (make-pathname :name :wild) :type) → false
      (wild-pathname-p (pathname "s:>foo>**>")) → true ;Lispm
      (wild-pathname-p (pathname :name "F*O")) → true ;Most places

Exceptional Situations:
.......................

If PATHNAME is not a pathname, a string, or a stream associated with a
file an error of type ‘type-error’ is signaled.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.

Notes:
......

Not all implementations support wildcards in all fields.  See *note
Section 19.2.2.2.2 (.WILD as a Component Value): WildComponents. and
*note Section 19.2.2.3 (Restrictions on Wildcard Pathnames):
WildcardRestrictions.


File: ansicl,  Node: pathname-match-p,  Next: translate-logical-pathname,  Prev: wild-pathname-p,  Up: Filenames

pathname-match-p (Function)
===========================

Syntax:
.......

 -- Function: pathname-match-p pathname wildcard → generalized-boolean

Arguments and Values:
.....................

PATHNAME—a pathname designator.

WILDCARD—a designator for a wild pathname.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘pathname-match-p’ returns true if PATHNAME matches WILDCARD, otherwise
‘nil’.  The matching rules are implementation-defined but should be
consistent with ‘directory’.  Missing components of WILDCARD default to
:wild.

It is valid for PATHNAME to be a wild pathname; a wildcard field in
PATHNAME only matches a wildcard field in WILDCARD (i.e.,
‘pathname-match-p’ is not commutative).  It is valid for WILDCARD to be
a non-wild pathname.

Exceptional Situations:
.......................

If PATHNAME or WILDCARD is not a pathname, string, or stream associated
with a file an error of type ‘type-error’ is signaled.

See Also:
.........

*note directory::, *note pathname (System Class)::, *note
logical-pathname (System Class)::, *note Section 20.1 (File System
Concepts): File System Concepts, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: ansicl,  Node: translate-logical-pathname,  Next: translate-pathname,  Prev: pathname-match-p,  Up: Filenames

translate-logical-pathname (Function)
=====================================

Syntax:
.......

 -- Function: translate-logical-pathname pathname &key →
          physical-pathname

Arguments and Values:
.....................

PATHNAME—a pathname designator, or a logical pathname namestring.

PHYSICAL-PATHNAME—a physical pathname.

Description:
............

Translates PATHNAME to a physical pathname, which it returns.

If PATHNAME is a stream, the stream can be either open or closed.
‘translate-logical-pathname’ returns the same physical pathname after a
file is closed as it did when the file was open.  It is an error if
PATHNAME is a stream that is created with ‘make-two-way-stream’,
‘make-echo-stream’, ‘make-broadcast-stream’, ‘make-concatenated-stream’,
‘make-string-input-stream’, ‘make-string-output-stream’.

If PATHNAME is a logical pathname namestring, the host portion of the
logical pathname namestring and its following colon are required.

PATHNAME is first coerced to a pathname.  If the coerced PATHNAME is a
physical pathname, it is returned.  If the coerced PATHNAME is a logical
pathname, the first matching translation (according to
‘pathname-match-p’) of the logical pathname host is applied, as if by
calling ‘translate-pathname’.  If the result is a logical pathname, this
process is repeated.  When the result is finally a physical pathname, it
is returned.  If no translation matches, an error is signaled.

‘translate-logical-pathname’ might perform additional translations,
typically to provide translation of file types to local naming
conventions, to accomodate physical file systems with limited length
names, or to deal with special character requirements such as
translating hyphens to underscores or uppercase letters to lowercase.
Any such additional translations are implementation-defined.  Some
implementations do no additional translations.

There are no specified keyword arguments for
‘translate-logical-pathname’, but implementations are permitted to
extend it by adding keyword arguments.

Examples:
.........

See ‘logical-pathname-translations’.

Exceptional Situations:
.......................

If PATHNAME is incorrectly supplied, an error of type ‘type-error’ is
signaled.

If no translation matches, an error of type ‘file-error’ is signaled.

See Also:
.........

*note logical-pathname (Function)::, *note
logical-pathname-translations::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: ansicl,  Node: translate-pathname,  Next: merge-pathnames,  Prev: translate-logical-pathname,  Up: Filenames

translate-pathname (Function)
=============================

Syntax:
.......

 -- Function: translate-pathname source from-wildcard to-wildcard &key →
          translated-pathname

Arguments and Values:
.....................

SOURCE—a pathname designator.

FROM-WILDCARD—a pathname designator.

TO-WILDCARD—a pathname designator.

TRANSLATED-PATHNAME—a pathname.

Description:
............

‘translate-pathname’ translates SOURCE (that matches FROM-WILDCARD) into
a corresponding pathname that matches TO-WILDCARD, and returns the
corresponding pathname.

The resulting pathname is TO-WILDCARD with each wildcard or missing
field replaced by a portion of SOURCE.  A “wildcard field” is a pathname
component with a value of :wild, a :wild element of a list-valued
directory component, or an implementation-defined portion of a
component, such as the ‘"*"’ in the complex wildcard string ‘"foo*bar"’
that some implementations support.  An implementation that adds other
wildcard features, such as regular expressions, must define how
‘translate-pathname’ extends to those features.  A “missing field” is a
pathname component with a value of ‘nil’.

The portion of SOURCE that is copied into the resulting pathname is
implementation-defined.  Typically it is determined by the user
interface conventions of the file systems involved.  Usually it is the
portion of SOURCE that matches a wildcard field of FROM-WILDCARD that is
in the same position as the wildcard or missing field of TO-WILDCARD.
If there is no wildcard field in FROM-WILDCARD at that position, then
usually it is the entire corresponding pathname component of SOURCE, or
in the case of a list-valued directory component, the entire
corresponding list element.

During the copying of a portion of SOURCE into the resulting pathname,
additional implementation-defined translations of case or file naming
conventions might occur, especially when FROM-WILDCARD and TO-WILDCARD
are for different hosts.

It is valid for SOURCE to be a wild pathname; in general this will
produce a wild result.  It is valid for FROM-WILDCARD and/or TO-WILDCARD
to be non-wild pathnames.

There are no specified keyword arguments for ‘translate-pathname’, but
implementations are permitted to extend it by adding keyword arguments.

‘translate-pathname’ maps customary case in SOURCE into customary case
in the output pathname.

Examples:
.........

      ;; The results of the following five forms are all implementation-dependent.
      ;; The second item in particular is shown with multiple results just to
      ;; emphasize one of many particular variations which commonly occurs.
      (pathname-name (translate-pathname "foobar" "foo*" "*baz")) → "barbaz"
      (pathname-name (translate-pathname "foobar" "foo*" "*"))
     → "foobar"
     or→ "bar"
      (pathname-name (translate-pathname "foobar" "*"    "foo*")) → "foofoobar"
      (pathname-name (translate-pathname "bar"    "*"    "foo*")) → "foobar"
      (pathname-name (translate-pathname "foobar" "foo*" "baz*")) → "bazbar"

      (defun translate-logical-pathname-1 (pathname rules)
        (let ((rule (assoc pathname rules :test #'pathname-match-p)))
          (unless rule (error "No translation rule for ~A" pathname))
          (translate-pathname pathname (first rule) (second rule))))
      (translate-logical-pathname-1 "FOO:CODE;BASIC.LISP"
                            '(("FOO:DOCUMENTATION;" "MY-UNIX:/doc/foo/")
                              ("FOO:CODE;"          "MY-UNIX:/lib/foo/")
                              ("FOO:PATCHES;*;"     "MY-UNIX:/lib/foo/patch/*/")))
     → #P"MY-UNIX:/lib/foo/basic.l"

     ;;;This example assumes one particular set of wildcard conventions
     ;;;Not all file systems will run this example exactly as written
      (defun rename-files (from to)
        (dolist (file (directory from))
          (rename-file file (translate-pathname file from to))))
      (rename-files "/usr/me/*.lisp" "/dev/her/*.l")
        ;Renames /usr/me/init.lisp to /dev/her/init.l
      (rename-files "/usr/me/pcl*/*" "/sys/pcl/*/")
        ;Renames /usr/me/pcl-5-may/low.lisp to /sys/pcl/pcl-5-may/low.lisp
        ;In some file systems the result might be /sys/pcl/5-may/low.lisp
      (rename-files "/usr/me/pcl*/*" "/sys/library/*/")
        ;Renames /usr/me/pcl-5-may/low.lisp to /sys/library/pcl-5-may/low.lisp
        ;In some file systems the result might be /sys/library/5-may/low.lisp
      (rename-files "/usr/me/foo.bar" "/usr/me2/")
        ;Renames /usr/me/foo.bar to /usr/me2/foo.bar
      (rename-files "/usr/joe/*-recipes.text" "/usr/jim/cookbook/joe's-*-rec.text")
        ;Renames /usr/joe/lamb-recipes.text to /usr/jim/cookbook/joe's-lamb-rec.text
        ;Renames /usr/joe/pork-recipes.text to /usr/jim/cookbook/joe's-pork-rec.text
        ;Renames /usr/joe/veg-recipes.text to /usr/jim/cookbook/joe's-veg-rec.text

Exceptional Situations:
.......................

If any of SOURCE, FROM-WILDCARD, or TO-WILDCARD is not a pathname, a
string, or a stream associated with a file an error of type ‘type-error’
is signaled.

‘(pathname-match-p SOURCE FROM-WILDCARD)’ must be true or an error of
type ‘error’ is signaled.

See Also:
.........

*note namestring::, *note pathname-host::, *note pathname (System
Class)::, *note logical-pathname (System Class)::, *note Section 20.1
(File System Concepts): File System Concepts, *note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.

Notes:
......

The exact behavior of ‘translate-pathname’ cannot be dictated by the
Common Lisp language and must be allowed to vary, depending on the user
interface conventions of the file systems involved.

The following is an implementation guideline.  One file system performs
this operation by examining each piece of the three pathnames in turn,
where a piece is a pathname component or a list element of a structured
component such as a hierarchical directory.  Hierarchical directory
elements in FROM-WILDCARD and TO-WILDCARD are matched by whether they
are wildcards, not by depth in the directory hierarchy.  If the piece in
TO-WILDCARD is present and not wild, it is copied into the result.  If
the piece in TO-WILDCARD is :wild or ‘nil’, the piece in SOURCE is
copied into the result.  Otherwise, the piece in TO-WILDCARD might be a
complex wildcard such as ‘"foo*bar"’ and the piece in FROM-WILDCARD
should be wild; the portion of the piece in SOURCE that matches the
wildcard portion of the piece in FROM-WILDCARD replaces the wildcard
portion of the piece in TO-WILDCARD and the value produced is used in
the result.


File: ansicl,  Node: merge-pathnames,  Prev: translate-pathname,  Up: Filenames

merge-pathnames (Function)
==========================

Syntax:
.......

 -- Function: merge-pathnames pathname &optional default-pathname
          default-version → merged-pathname

Arguments and Values:
.....................

PATHNAME—a pathname designator.

DEFAULT-PATHNAME—a pathname designator.  The default is the value of
‘*default-pathname-defaults*’.

DEFAULT-VERSION—a valid pathname version.  The default is :newest.

MERGED-PATHNAME—a pathname.

Description:
............

Constructs a pathname from PATHNAME by filling in any unsupplied
components with the corresponding values from DEFAULT-PATHNAME and
DEFAULT-VERSION.

Defaulting of pathname components is done by filling in components taken
from another pathname.  This is especially useful for cases such as a
program that has an input file and an output file.  Unspecified
components of the output pathname will come from the input pathname,
except that the type should not default to the type of the input
pathname but rather to the appropriate default type for output from the
program; for example, see the function *note compile-file-pathname::.

If no version is supplied, DEFAULT-VERSION is used.  If DEFAULT-VERSION
is ‘nil’, the version component will remain unchanged.

If PATHNAME explicitly specifies a host and not a device, and if the
host component of DEFAULT-PATHNAME matches the host component of
PATHNAME, then the device is taken from the DEFAULT-PATHNAME; otherwise
the device will be the default file device for that host.  If PATHNAME
does not specify a host, device, directory, name, or type, each such
component is copied from DEFAULT-PATHNAME.  If PATHNAME does not specify
a name, then the version, if not provided, will come from
DEFAULT-PATHNAME, just like the other components.  If PATHNAME does
specify a name, then the version is not affected by DEFAULT-PATHNAME.
If this process leaves the version missing, the DEFAULT-VERSION is used.
If the host’s file name syntax provides a way to input a version without
a name or type, the user can let the name and type default but supply a
version different from the one in DEFAULT-PATHNAME.

If PATHNAME is a stream, PATHNAME effectively becomes ‘(pathname
PATHNAME)’.  ‘merge-pathnames’ can be used on either an open or a closed
stream.

If PATHNAME is a pathname it represents the name used to open the file.
This may be, but is not required to be, the actual name of the file.

‘merge-pathnames’ recognizes a logical pathname namestring when
DEFAULT-PATHNAME is a logical pathname, or when the namestring begins
with the name of a defined logical host followed by a colon.  In the
first of these two cases, the host portion of the logical pathname
namestring and its following colon are optional.

‘merge-pathnames’ returns a logical pathname if and only if its first
argument is a logical pathname, or its first argument is a logical
pathname namestring with an explicit host, or its first argument does
not specify a host and the DEFAULT-PATHNAME is a logical pathname.

Pathname merging treats a relative directory specially.  If
‘(pathname-directory PATHNAME)’ is a list whose car is :relative, and
‘(pathname-directory DEFAULT-PATHNAME)’ is a list, then the merged
directory is the value of

      (append (pathname-directory DEFAULT-PATHNAME)
              (cdr  ;remove :relative from the front
                (pathname-directory PATHNAME)))

except that if the resulting list contains a string or :wild immediately
followed by :back, both of them are removed.  This removal of redundant
:back keywords is repeated as many times as possible.  If
‘(pathname-directory DEFAULT-PATHNAME)’ is not a list or
‘(pathname-directory PATHNAME)’ is not a list whose car is :relative,
the merged directory is ‘(or (pathname-directory PATHNAME)
(pathname-directory DEFAULT-PATHNAME))’

‘merge-pathnames’ maps customary case in PATHNAME into customary case in
the output pathname.

Examples:
.........

      (merge-pathnames "CMUC::FORMAT"
                       "CMUC::PS:<LISPIO>.FASL")
     → #P"CMUC::PS:<LISPIO>FORMAT.FASL.0"

See Also:
.........

*note *default-pathname-defaults*::, *note pathname (System Class)::,
*note logical-pathname (System Class)::, *note Section 20.1 (File System
Concepts): File System Concepts, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.

Notes:
......

The net effect is that if just a name is supplied, the host, device,
directory, and type will come from DEFAULT-PATHNAME, but the version
will come from DEFAULT-VERSION.  If nothing or just a directory is
supplied, the name, type, and version will come from DEFAULT-PATHNAME
together.


File: ansicl,  Node: Files,  Next: Streams,  Prev: Filenames,  Up: Top

20 Files
********

* Menu:

* File System Concepts::

Dictionary

* directory::
* probe-file::
* ensure-directories-exist::
* truename::
* file-author::
* file-write-date::
* rename-file::
* delete-file::
* file-error::
* file-error-pathname::


File: ansicl,  Node: File System Concepts,  Next: directory,  Up: Files

20.1 File System Concepts
=========================

This section describes the Common Lisp interface to file systems.  The
model used by this interface assumes that “files” are named by
“filenames”, that a filename can be represented by a pathname object,
and that given a pathname a “stream” can be constructed that connects to
a file whose filename it represents.

For information about opening and closing files, and manipulating their
contents, see *note Chapter 21 (Streams): Streams.

The next figure lists some operators that are applicable to files and
directories.

compile-file   file-length       open
delete-file    file-position     probe-file
directory      file-write-date   rename-file
file-author    load              with-open-file

Figure 20.1: File and Directory Operations

* Menu:

* Coercion of Streams to Pathnames::
* File Operations on Open and Closed Streams::
* Truenames::


File: ansicl,  Node: Coercion of Streams to Pathnames,  Next: File Operations on Open and Closed Streams,  Up: File System Concepts

20.1.1 Coercion of Streams to Pathnames
---------------------------------------

A “stream associated with a file” is either a file stream or a synonym
stream whose target is a “stream associated with a file”.  Such streams
can be used as pathname designators.

Normally, when a stream associated with a file is used as a pathname
designator, it denotes the pathname used to open the file; this may be,
but is not required to be, the actual name of the file.

Some functions, such as ‘truename’ and ‘delete-file’, coerce streams to
pathnames in a different way that involves referring to the actual file
that is open, which might or might not be the file whose name was opened
originally.  Such special situations are always notated specifically and
are not the default.


File: ansicl,  Node: File Operations on Open and Closed Streams,  Next: Truenames,  Prev: Coercion of Streams to Pathnames,  Up: File System Concepts

20.1.2 File Operations on Open and Closed Streams
-------------------------------------------------

Many functions that perform file operations accept either open or closed
streams as arguments; see *note Section 21.1.3 (Stream Arguments to
Standardized Functions): Stream Arguments to Standardized Functions.

Of these, the functions in the next figure treat open and closed streams
differently.

delete-file   file-author       probe-file
directory     file-write-date   truename

Figure 20.2: File Functions that Treat Open and Closed Streams
Differently

Since treatment of open streams by the file system may vary considerably
between implementations, however, a closed stream might be the most
reliable kind of argument for some of these functions—in particular,
those in the next figure.  For example, in some file systems, open files
are written under temporary names and not renamed until closed and/or
are held invisible until closed.  In general, any code that is intended
to be portable should use such functions carefully.

directory   probe-file   truename

Figure 20.3: File Functions where Closed Streams Might Work Best


File: ansicl,  Node: Truenames,  Prev: File Operations on Open and Closed Streams,  Up: File System Concepts

20.1.3 Truenames
----------------

Many file systems permit more than one filename to designate a
particular file.

Even where multiple names are possible, most file systems have a
convention for generating a canonical filename in such situations.  Such
a canonical filename (or the pathname representing such a filename) is
called a “truename”.

The truename of a file may differ from other filenames for the file
because of symbolic links, version numbers, logical device translations
in the file system, logical pathname translations within Common Lisp, or
other artifacts of the file system.

The truename for a file is often, but not necessarily, unique for each
file.  For instance, a Unix file with multiple hard links could have
several truenames.

20.1.3.1 Examples of Truenames
..............................

For example, a DEC TOPS-20 system with files ‘PS:<JOE>FOO.TXT.1’ and
‘PS:<JOE>FOO.TXT.2’ might permit the second file to be referred to as
‘PS:<JOE>FOO.TXT.0’, since the “‘.0’” notation denotes “newest” version
of several files.  In the same file system, a “logical device” “‘JOE:’”
might be taken to refer to ‘PS:<JOE>’” and so the names ‘JOE:FOO.TXT.2’
or ‘JOE:FOO.TXT.0’ might refer to ‘PS:<JOE>FOO.TXT.2’.  In all of these
cases, the truename of the file would probably be ‘PS:<JOE>FOO.TXT.2’.

If a file is a symbolic link to another file (in a file system
permitting such a thing), it is conventional for the truename to be the
canonical name of the file after any symbolic links have been followed;
that is, it is the canonical name of the file whose contents would
become available if an input stream to that file were opened.

In the case of a file still being created (that is, of an output stream
open to such a file), the exact truename of the file might not be known
until the stream is closed.  In this case, the function ‘truename’ might
return different values for such a stream before and after it was
closed.  In fact, before it is closed, the name returned might not even
be a valid name in the file system—for example, while a file is being
written, it might have version :newest and might only take on a specific
numeric value later when the file is closed even in a file system where
all files have numeric versions.


File: ansicl,  Node: directory,  Next: probe-file,  Prev: File System Concepts,  Up: Files

directory (Function)
====================

Syntax:
.......

 -- Function: directory pathspec &key → pathnames

Arguments and Values:
.....................

PATHSPEC—a pathname designator, which may contain wild components.

PATHNAMES—a list of physical pathnames.

Description:
............

Determines which, if any, files that are present in the file system have
names matching PATHSPEC, and returns a fresh list of pathnames
corresponding to the truenames of those files.

An implementation may be extended to accept implementation-defined
keyword arguments to ‘directory’.

Affected By:
............

The host computer’s file system.

Exceptional Situations:
.......................

If the attempt to obtain a directory listing is not successful, an error
of type ‘file-error’ is signaled.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note ensure-directories-exist::, *note Section 20.1 (File
System Concepts): File System Concepts, *note Section 21.1.1.1.2 (Open
and Closed Streams): File Operations on Open and Closed Streams, *note
Section 19.1.2 (Pathnames as Filenames): Pathnames as Filenames.

Notes:
......

If the PATHSPEC is not wild, the resulting list will contain either zero
or one elements.

Common Lisp specifies “&key” in the argument list to ‘directory’ even
though no standardized keyword arguments to ‘directory’ are defined.
“‘:allow-other-keys t’” may be used in conforming programs in order to
quietly ignore any additional keywords which are passed by the program
but not supported by the implementation.


File: ansicl,  Node: probe-file,  Next: ensure-directories-exist,  Prev: directory,  Up: Files

probe-file (Function)
=====================

Syntax:
.......

 -- Function: probe-file pathspec → truename

Arguments and Values:
.....................

PATHSPEC—a pathname designator.

TRUENAME—a physical pathname or ‘nil’.

Description:
............

‘probe-file’ tests whether a file exists.

‘probe-file’ returns false if there is no file named PATHSPEC, and
otherwise returns the truename of PATHSPEC.

If the PATHSPEC designator is an open stream, then ‘probe-file’ produces
the truename of its associated file.  If PATHSPEC is a stream, whether
open or closed, it is coerced to a pathname as if by the function
‘pathname’.

Affected By:
............

The host computer’s file system.

Exceptional Situations:
.......................

An error of type ‘file-error’ is signaled if PATHSPEC is wild.

An error of type ‘file-error’ is signaled if the file system cannot
perform the requested operation.

See Also:
.........

*note truename::, *note open::, *note ensure-directories-exist::, *note
pathname (System Class)::, *note logical-pathname (System Class)::,
*note Section 20.1 (File System Concepts): File System Concepts, *note
Section 21.1.1.1.2 (Open and Closed Streams): File Operations on Open
and Closed Streams, *note Section 19.1.2 (Pathnames as Filenames):
Pathnames as Filenames.


File: ansicl,  Node: ensure-directories-exist,  Next: truename,  Prev: probe-file,  Up: Files

ensure-directories-exist (Function)
===================================

Syntax:
.......

 -- Function: ensure-directories-exist pathspec &key verbose → pathspec,
          created

Arguments and Values:
.....................

PATHSPEC—a pathname designator.

VERBOSE—a generalized boolean.

CREATED—a generalized boolean.

Description:
............

Tests whether the directories containing the specified file actually
exist, and attempts to create them if they do not.

If the containing directories do not exist and if VERBOSE is true, then
the implementation is permitted (but not required) to perform output to
standard output saying what directories were created.  If the containing
directories exist, or if VERBOSE is false, this function performs no
output.

The primary value is the given pathspec so that this operation can be
straightforwardly composed with other file manipulation expressions.
The secondary value, CREATED, is true if any directories were created.

Affected By:
............

The host computer’s file system.

Exceptional Situations:
.......................

An error of type ‘file-error’ is signaled if the host, device, or
directory part of PATHSPEC is wild.

If the directory creation attempt is not successful, an error of type
‘file-error’ is signaled; if this occurs, it might be the case that
none, some, or all of the requested creations have actually occurred
within the file system.

See Also:
.........

*note probe-file::, *note open::, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: ansicl,  Node: truename,  Next: file-author,  Prev: ensure-directories-exist,  Up: Files

truename (Function)
===================

Syntax:
.......

 -- Function: truename filespec → truename

Arguments and Values:
.....................

FILESPEC—a pathname designator.

TRUENAME—a physical pathname.

Description:
............

‘truename’ tries to find the file indicated by FILESPEC and returns its
truename.  If the FILESPEC designator is an open stream, its associated
file is used.  If FILESPEC is a stream, ‘truename’ can be used whether
the stream is open or closed.  It is permissible for ‘truename’ to
return more specific information after the stream is closed than when
the stream was open.  If FILESPEC is a pathname it represents the name
used to open the file.  This may be, but is not required to be, the
actual name of the file.

Examples:
.........

     ;; An example involving version numbers.  Note that the precise nature of
     ;; the truename is implementation-dependent while the file is still open.
      (with-open-file (stream ">vistor>test.text.newest")
        (values (pathname stream)
                (truename stream)))
     → #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"
     or→ #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.newest"
     or→ #P"S:>vistor>test.text.newest", #P"S:>vistor>_temp_._temp_.1"

     ;; In this case, the file is closed when the truename is tried, so the
     ;; truename information is reliable.
      (with-open-file (stream ">vistor>test.text.newest")
        (close stream)
        (values (pathname stream)
                (truename stream)))
     → #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"

     ;; An example involving TOP-20's implementation-dependent concept
     ;; of logical devices -- in this case, "DOC:" is shorthand for
     ;; "PS:<DOCUMENTATION>" ...
      (with-open-file (stream "CMUC::DOC:DUMPER.HLP")
        (values (pathname stream)
                (truename stream)))
     → #P"CMUC::DOC:DUMPER.HLP", #P"CMUC::PS:<DOCUMENTATION>DUMPER.HLP.13"

Exceptional Situations:
.......................

An error of type ‘file-error’ is signaled if an appropriate file cannot
be located within the file system for the given FILESPEC, or if the file
system cannot perform the requested operation.

An error of type ‘file-error’ is signaled if PATHNAME is wild.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.

Notes:
......

‘truename’ may be used to account for any filename translations
performed by the file system.


File: ansicl,  Node: file-author,  Next: file-write-date,  Prev: truename,  Up: Files

file-author (Function)
======================

Syntax:
.......

 -- Function: file-author pathspec → author

Arguments and Values:
.....................

PATHSPEC—a pathname designator.

AUTHOR—a string or ‘nil’.

Description:
............

Returns a string naming the author of the file specified by PATHSPEC, or
‘nil’ if the author’s name cannot be determined.

Examples:
.........

      (with-open-file (stream ">relativity>general.text")
        (file-author s))
     → "albert"

Affected By:
............

The host computer’s file system.

Other users of the file named by PATHSPEC.

Exceptional Situations:
.......................

An error of type ‘file-error’ is signaled if PATHSPEC is wild.

An error of type ‘file-error’ is signaled if the file system cannot
perform the requested operation.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: ansicl,  Node: file-write-date,  Next: rename-file,  Prev: file-author,  Up: Files

file-write-date (Function)
==========================

Syntax:
.......

 -- Function: file-write-date pathspec → date

Arguments and Values:
.....................

PATHSPEC—a pathname designator.

DATE—a universal time or ‘nil’.

Description:
............

Returns a universal time representing the time at which the file
specified by PATHSPEC was last written (or created), or returns ‘nil’ if
such a time cannot be determined.

Examples:
.........

      (with-open-file (s "noel.text"
                         :direction :output :if-exists :error)
        (format s "~&Dear Santa,~2%I was good this year.  ~
                     Please leave lots of toys.~2%Love, Sue~
                  ~2%attachments: milk, cookies~%")
        (truename s))
     → #P"CUPID:/susan/noel.text"
      (with-open-file (s "noel.text")
        (file-write-date s))
     → 2902600800

Affected By:
............

The host computer’s file system.

Exceptional Situations:
.......................

An error of type ‘file-error’ is signaled if PATHSPEC is wild.

An error of type ‘file-error’ is signaled if the file system cannot
perform the requested operation.

See Also:
.........

*note Section 25.1.4.2 (Universal Time): UniversalTime, *note Section
19.1.2 (Pathnames as Filenames): Pathnames as Filenames.


File: ansicl,  Node: rename-file,  Next: delete-file,  Prev: file-write-date,  Up: Files

rename-file (Function)
======================

Syntax:
.......

 -- Function: rename-file filespec new-name → defaulted-new-name,
          old-truename, new-truename

Arguments and Values:
.....................

FILESPEC—a pathname designator.

NEW-NAME—a pathname designator other than a stream.

DEFAULTED-NEW-NAME—a pathname

OLD-TRUENAME—a physical pathname.

NEW-TRUENAME—a physical pathname.

Description:
............

‘rename-file’ modifies the file system in such a way that the file
indicated by FILESPEC is renamed to DEFAULTED-NEW-NAME.

It is an error to specify a filename containing a wild component, for
FILESPEC to contain a ‘nil’ component where the file system does not
permit a ‘nil’ component, or for the result of defaulting missing
components of NEW-NAME from FILESPEC to contain a ‘nil’ component where
the file system does not permit a ‘nil’ component.

If NEW-NAME is a logical pathname, ‘rename-file’ returns a logical
pathname as its primary value.

‘rename-file’ returns three values if successful.  The primary value,
DEFAULTED-NEW-NAME, is the resulting name which is composed of NEW-NAME
with any missing components filled in by performing a ‘merge-pathnames’
operation using FILESPEC as the defaults.  The secondary value,
OLD-TRUENAME, is the truename of the file before it was renamed.  The
tertiary value, NEW-TRUENAME, is the truename of the file after it was
renamed.

If the FILESPEC designator is an open stream, then the stream itself and
the file associated with it are affected (if the file system permits).

Examples:
.........

     ;; An example involving logical pathnames.
      (with-open-file (stream "sys:chemistry;lead.text"
                              :direction :output :if-exists :error)
        (princ "eureka" stream)
        (values (pathname stream) (truename stream)))
     → #P"SYS:CHEMISTRY;LEAD.TEXT.NEWEST", #P"Q:>sys>chem>lead.text.1"
      (rename-file "sys:chemistry;lead.text" "gold.text")
     → #P"SYS:CHEMISTRY;GOLD.TEXT.NEWEST",
        #P"Q:>sys>chem>lead.text.1",
        #P"Q:>sys>chem>gold.text.1"

Exceptional Situations:
.......................

If the renaming operation is not successful, an error of type
‘file-error’ is signaled.

An error of type ‘file-error’ might be signaled if FILESPEC is wild.

See Also:
.........

*note truename::, *note pathname (System Class)::, *note
logical-pathname (System Class)::, *note Section 20.1 (File System
Concepts): File System Concepts, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: ansicl,  Node: delete-file,  Next: file-error,  Prev: rename-file,  Up: Files

delete-file (Function)
======================

Syntax:
.......

 -- Function: delete-file filespec → ‘t’

Arguments and Values:
.....................

FILESPEC—a pathname designator.

Description:
............

Deletes the file specified by FILESPEC.

If the FILESPEC designator is an open stream, then FILESPEC and the file
associated with it are affected (if the file system permits), in which
case FILESPEC might be closed immediately, and the deletion might be
immediate or delayed until FILESPEC is explicitly closed, depending on
the requirements of the file system.

It is implementation-dependent whether an attempt to delete a
nonexistent file is considered to be successful.

‘delete-file’ returns true if it succeeds, or signals an error of type
‘file-error’ if it does not.

The consequences are undefined if FILESPEC has a wild component, or if
FILESPEC has a ‘nil’ component and the file system does not permit a
‘nil’ component.

Examples:
.........

      (with-open-file (s "delete-me.text" :direction :output :if-exists :error))
     → NIL
      (setq p (probe-file "delete-me.text")) → #P"R:>fred>delete-me.text.1"
      (delete-file p) → T
      (probe-file "delete-me.text") → false
      (with-open-file (s "delete-me.text" :direction :output :if-exists :error)
        (delete-file s))
     → T
      (probe-file "delete-me.text") → false

Exceptional Situations:
.......................

If the deletion operation is not successful, an error of type
‘file-error’ is signaled.

An error of type ‘file-error’ might be signaled if FILESPEC is wild.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: ansicl,  Node: file-error,  Next: file-error-pathname,  Prev: delete-file,  Up: Files

file-error (Condition Type)
===========================

Class Precedence List:
......................

‘file-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘file-error’ consists of error conditions that occur during an
attempt to open or close a file, or during some low-level transactions
with a file system.  The “offending pathname” is initialized by the
:pathname initialization argument to ‘make-condition’, and is accessed
by the function ‘file-error-pathname’.

See Also:
.........

*note file-error-pathname::, *note open::, *note probe-file::, *note
directory::, *note ensure-directories-exist::


File: ansicl,  Node: file-error-pathname,  Prev: file-error,  Up: Files

file-error-pathname (Function)
==============================

Syntax:
.......

 -- Function: file-error-pathname condition → pathspec

Arguments and Values:
.....................

CONDITION—a condition of type ‘file-error’.

PATHSPEC—a pathname designator.

Description:
............

Returns the “offending pathname” of a condition of type ‘file-error’.

Exceptional Situations:
.......................

See Also:
.........

*note file-error::, *note Chapter 9 (Conditions): Conditions.


File: ansicl,  Node: Streams,  Next: Printer,  Prev: Files,  Up: Top

21 Streams
**********

* Menu:

* Stream Concepts::

Dictionary

* stream::
* broadcast-stream::
* concatenated-stream::
* echo-stream::
* file-stream::
* string-stream::
* synonym-stream::
* two-way-stream::
* input-stream-p; output-stream-p::
* interactive-stream-p::
* open-stream-p::
* stream-element-type::
* streamp::
* read-byte::
* write-byte::
* peek-char::
* read-char::
* read-char-no-hang::
* terpri; fresh-line::
* unread-char::
* write-char::
* read-line::
* write-string; write-line::
* read-sequence::
* write-sequence::
* file-length::
* file-position::
* file-string-length::
* open::
* stream-external-format::
* with-open-file::
* close::
* with-open-stream::
* listen::
* clear-input::
* finish-output; force-output; clear-output::
* y-or-n-p; yes-or-no-p::
* make-synonym-stream::
* synonym-stream-symbol::
* broadcast-stream-streams::
* make-broadcast-stream::
* make-two-way-stream::
* two-way-stream-input-stream; two-way-stream-output-stream::
* echo-stream-input-stream; echo-stream-output-stream::
* make-echo-stream::
* concatenated-stream-streams::
* make-concatenated-stream::
* get-output-stream-string::
* make-string-input-stream::
* make-string-output-stream::
* with-input-from-string::
* with-output-to-string::
* *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+::
* *terminal-io*::
* stream-error::
* stream-error-stream::
* end-of-file::


File: ansicl,  Node: Stream Concepts,  Next: stream,  Up: Streams

21.1 Stream Concepts
====================

* Menu:

* Introduction to Streams::
* Stream Variables::
* Stream Arguments to Standardized Functions::
* Restrictions on Composite Streams::


File: ansicl,  Node: Introduction to Streams,  Next: Stream Variables,  Up: Stream Concepts

21.1.1 Introduction to Streams
------------------------------

A “stream” is an object that can be used with an input or output
function to identify an appropriate source or sink of characters or
bytes for that operation.  A “character” “stream” is a source or sink of
characters.  A “binary” “stream” is a source or sink of bytes.

Some operations may be performed on any kind of stream; the next
figure provides a list of standardized operations that are potentially
useful with any kind of stream.

close                  stream-element-type
input-stream-p         streamp
interactive-stream-p   with-open-stream
output-stream-p

Figure 21.1: Some General-Purpose Stream Operations

Other operations are only meaningful on certain stream types.  For
example, ‘read-char’ is only defined for character streams and
‘read-byte’ is only defined for binary streams.

21.1.1.1 Abstract Classifications of Streams
............................................

21.1.1.1.1 Input, Output, and Bidirectional Streams
...................................................

A stream, whether a character stream or a binary stream, can be an
“input” “stream” (source of data), an “output” “stream” (sink for data),
both, or (e.g., when “‘:direction :probe’” is given to ‘open’) neither.

The next figure shows operators relating to input streams.

clear-input   read-byte             read-from-string
listen        read-char             read-line
peek-char     read-char-no-hang     read-preserving-whitespace
read          read-delimited-list   unread-char

Figure 21.2: Operators relating to Input Streams.

The next figure shows operators relating to output streams.

clear-output    prin1             write
finish-output   prin1-to-string   write-byte
force-output    princ             write-char
format          princ-to-string   write-line
fresh-line      print             write-string
pprint          terpri            write-to-string

Figure 21.3: Operators relating to Output Streams.

A stream that is both an input stream and an output stream is called a
“bidirectional” “stream”.  See the functions *note input-stream-p:: and
‘output-stream-p’.

Any of the operators listed in *note Figure 21.2: InputStreamOps. or
*note Figure 21.3: OutputStreamOps. can be used with bidirectional
streams.  In addition, the next figure shows a list of operators that
relate specificaly to bidirectional streams.

y-or-n-p   yes-or-no-p

Figure 21.4: Operators relating to Bidirectional Streams.

21.1.1.1.2 Open and Closed Streams
..................................

Streams are either “open” or “closed”.

Except as explicitly specified otherwise, operations that create and
return streams return open streams.

The action of closing a stream marks the end of its use as a source or
sink of data, permitting the implementation to reclaim its internal data
structures, and to free any external resources which might have been
locked by the stream when it was opened.

Except as explicitly specified otherwise, the consequences are undefined
when a closed stream is used where a stream is called for.

Coercion of streams to pathnames is permissible for closed streams; in
some situations, such as for a truename computation, the result might be
different for an open stream and for that same stream once it has been
closed.

21.1.1.1.3 Interactive Streams
..............................

An “interactive stream” is one on which it makes sense to perform
interactive querying.

The precise meaning of an interactive stream is implementation-defined,
and may depend on the underlying operating system.  Some examples of the
things that an implementation might choose to use as identifying
characteristics of an interactive stream include:

   • The stream is connected to a person (or equivalent) in such a way
     that the program can prompt for information and expect to receive
     different input depending on the prompt.

   • The program is expected to prompt for input and support “normal
     input editing”.

   • ‘read-char’ might wait for the user to type something before
     returning instead of immediately returning a character or
     end-of-file.

The general intent of having some streams be classified as interactive
streams is to allow them to be distinguished from streams containing
batch (or background or command-file) input.  Output to batch streams is
typically discarded or saved for later viewing, so interactive queries
to such streams might not have the expected effect.

Terminal I/O might or might not be an interactive stream.

21.1.1.2 Abstract Classifications of Streams
............................................

21.1.1.2.4 File Streams
.......................

Some streams, called “file streams”, provide access to files.  An object
of class ‘file-stream’ is used to represent a file stream.

The basic operation for opening a file is ‘open’, which typically
returns a file stream (see its dictionary entry for details).  The basic
operation for closing a stream is ‘close’.  The macro ‘with-open-file’
is useful to express the common idiom of opening a file for the duration
of a given body of code, and assuring that the resulting stream is
closed upon exit from that body.

21.1.1.3 Other Subclasses of Stream
...................................

The class ‘stream’ has a number of subclasses defined by this
specification.  The next figure shows some information about these
subclasses.

Class                   Related Operators
---------------------------------------------------------
‘broadcast-stream’      ‘make-broadcast-stream’
                        ‘broadcast-stream-streams’
‘concatenated-stream’   ‘make-concatenated-stream’
                        ‘concatenated-stream-streams’
‘echo-stream’           ‘make-echo-stream’
                        ‘echo-stream-input-stream’
                        ‘echo-stream-output-stream’
‘string-stream’         ‘make-string-input-stream’
                        ‘with-input-from-string’
                        ‘make-string-output-stream’
                        ‘with-output-to-string’
                        ‘get-output-stream-string’
‘synonym-stream’        ‘make-synonym-stream’
                        ‘synonym-stream-symbol’
‘two-way-stream’        ‘make-two-way-stream’
                        ‘two-way-stream-input-stream’
                        ‘two-way-stream-output-stream’

Figure 21.5: Defined Names related to Specialized Streams


File: ansicl,  Node: Stream Variables,  Next: Stream Arguments to Standardized Functions,  Prev: Introduction to Streams,  Up: Stream Concepts

21.1.2 Stream Variables
-----------------------

Variables whose values must be streams are sometimes called “stream
variables”.

Certain stream variables are defined by this specification to be the
proper source of input or output in various situations where no specific
stream has been specified instead.  A complete list of such standardized
stream variables appears in the next figure.  The consequences are
undefined if at any time the value of any of these variables is not an
open stream.

Glossary Term     Variable Name
----------------------------------------
debug I/O         ‘*debug-io*’
error output      ‘*error-output*’
query I/O         ‘*query-io*’
standard input    ‘*standard-input*’
standard output   ‘*standard-output*’
terminal I/O      ‘*terminal-io*’
trace output      ‘*trace-output*’

Figure 21.6: Standardized Stream Variables

Note that, by convention, standardized stream variables have names
ending in “‘-input*’” if they must be input streams, ending in
“‘-output*’” if they must be output streams, or ending in “‘-io*’” if
they must be bidirectional streams.

User programs may assign or bind any standardized stream variable except
‘*terminal-io*’.


File: ansicl,  Node: Stream Arguments to Standardized Functions,  Next: Restrictions on Composite Streams,  Prev: Stream Variables,  Up: Stream Concepts

21.1.3 Stream Arguments to Standardized Functions
-------------------------------------------------

The operators in the next figure accept stream arguments that might be
either open or closed streams.

broadcast-stream-streams      file-author        pathnamep
close                         file-namestring    probe-file
compile-file                  file-write-date    rename-file
compile-file-pathname         host-namestring    streamp
concatenated-stream-streams   load               synonym-stream-symbol
delete-file                   logical-pathname   translate-logical-pathname
directory                     merge-pathnames    translate-pathname
directory-namestring          namestring         truename
dribble                       open               two-way-stream-input-stream
echo-stream-input-stream      open-stream-p      two-way-stream-output-stream
echo-stream-ouput-stream      parse-namestring   wild-pathname-p
ed                            pathname           with-open-file
enough-namestring             pathname-match-p

Figure 21.7: Operators that accept either Open or Closed Streams

The operators in the next figure accept stream arguments that must be
open streams.

clear-input                output-stream-p           read-char-no-hang
clear-output               peek-char                 read-delimited-list
file-length                pprint                    read-line
file-position              pprint-fill               read-preserving-whitespace
file-string-length         pprint-indent             stream-element-type
finish-output              pprint-linear             stream-external-format
force-output               pprint-logical-block      terpri
format                     pprint-newline            unread-char
fresh-line                 pprint-tab                with-open-stream
get-output-stream-string   pprint-tabular            write
input-stream-p             prin1                     write-byte
interactive-stream-p       princ                     write-char
listen                     print                     write-line
make-broadcast-stream      print-object              write-string
make-concatenated-stream   print-unreadable-object   y-or-n-p
make-echo-stream           read                      yes-or-no-p
make-synonym-stream        read-byte
make-two-way-stream        read-char

Figure 21.8: Operators that accept Open Streams only


File: ansicl,  Node: Restrictions on Composite Streams,  Prev: Stream Arguments to Standardized Functions,  Up: Stream Concepts

21.1.4 Restrictions on Composite Streams
----------------------------------------

The consequences are undefined if any component of a composite stream is
closed before the composite stream is closed.

The consequences are undefined if the synonym stream symbol is not bound
to an open stream from the time of the synonym stream’s creation until
the time it is closed.


File: ansicl,  Node: stream,  Next: broadcast-stream,  Prev: Stream Concepts,  Up: Streams

stream (System Class)
=====================

Class Precedence List:
......................

‘stream’, ‘t’

Description:
............

A stream is an object that can be used with an input or output function
to identify an appropriate source or sink of characters or bytes for
that operation.

For more complete information, see *note Section 21.1 (Stream Concepts):
Stream Concepts.

See Also:
.........

*note Section 21.1 (Stream Concepts): Stream Concepts, *note Section
22.1.3.13 (Printing Other Objects): PrintingOtherObjects, *note Chapter
22 (Printer): Printer, *note Chapter 23 (Reader): Reader.


File: ansicl,  Node: broadcast-stream,  Next: concatenated-stream,  Prev: stream,  Up: Streams

broadcast-stream (System Class)
===============================

Class Precedence List:
......................

‘broadcast-stream’, ‘stream’, ‘t’

Description:
............

A broadcast stream is an output stream which has associated with it a
set of zero or more output streams such that any output sent to the
broadcast stream gets passed on as output to each of the associated
output streams.  (If a broadcast stream has no component streams, then
all output to the broadcast stream is discarded.)

The set of operations that may be performed on a broadcast stream is the
intersection of those for its associated output streams.

Some output operations (e.g., ‘fresh-line’) return values based on the
state of the stream at the time of the operation.  Since these values
might differ for each of the component streams, it is necessary to
describe their return value specifically:

   • ‘stream-element-type’ returns the value from the last component
     stream, or ‘t’ if there are no component streams.

   • ‘fresh-line’ returns the value from the last component stream, or
     ‘nil’ if there are no component streams.

   • The functions ‘file-length’, ‘file-position’, ‘file-string-length’,
     and ‘stream-external-format’ return the value from the last
     component stream; if there are no component streams, ‘file-length’
     and ‘file-position’ return ‘0’, ‘file-string-length’ returns ‘1’,
     and ‘stream-external-format’ returns :default.

   • The functions ‘streamp’ and ‘output-stream-p’ always return true
     for broadcast streams.

   • The functions ‘open-stream-p’ tests whether the broadcast stream is
     open

   • The functions ‘input-stream-p’ and interactive-stream-p return an
     implementation-defined, generalized boolean value.

   • For the input operations ‘clear-input’ ‘listen’, ‘peek-char’,
     ‘read-byte’, ‘read-char-no-hang’, ‘read-char’, ‘read-line’, and
     ‘unread-char’, the consequences are undefined if the indicated
     operation is performed.  However, an implementation is permitted to
     define such a behavior as an implementation-dependent extension.

For any output operations not having their return values explicitly
specified above or elsewhere in this document, it is defined that the
values returned by such an operation are the values resulting from
performing the operation on the last of its component streams; the
values resulting from performing the operation on all preceding streams
are discarded.  If there are no component streams, the value is
implementation-dependent.

See Also:
.........

*note broadcast-stream-streams::, *note make-broadcast-stream::


File: ansicl,  Node: concatenated-stream,  Next: echo-stream,  Prev: broadcast-stream,  Up: Streams

concatenated-stream (System Class)
==================================

Class Precedence List:
......................

‘concatenated-stream’, ‘stream’, ‘t’

Description:
............

A concatenated stream is an input stream which is a composite stream of
zero or more other input streams, such that the sequence of data which
can be read from the concatenated stream is the same as the
concatenation of the sequences of data which could be read from each of
the constituent streams.

Input from a concatenated stream is taken from the first of the
associated input streams until it reaches end of filethen that stream is
discarded, and subsequent input is taken from the next input stream, and
so on.  An end of file on the associated input streams is always managed
invisibly by the concatenated stream—the only time a client of a
concatenated stream sees an end of file is when an attempt is made to
obtain data from the concatenated stream but it has no remaining input
streams from which to obtain such data.

See Also:
.........

*note concatenated-stream-streams::, *note make-concatenated-stream::


File: ansicl,  Node: echo-stream,  Next: file-stream,  Prev: concatenated-stream,  Up: Streams

echo-stream (System Class)
==========================

Class Precedence List:
......................

‘echo-stream’, ‘stream’, ‘t’

Description:
............

An echo stream is a bidirectional stream that gets its input from an
associated input stream and sends its output to an associated output
stream.

All input taken from the input stream is echoed to the output stream.
Whether the input is echoed immediately after it is encountered, or
after it has been read from the input stream is
implementation-dependent.

See Also:
.........

*note echo-stream-input-stream::, *note echo-stream-output-stream::,
*note make-echo-stream::


File: ansicl,  Node: file-stream,  Next: string-stream,  Prev: echo-stream,  Up: Streams

file-stream (System Class)
==========================

Class Precedence List:
......................

‘file-stream’, ‘stream’, ‘t’

Description:
............

An object of type ‘file-stream’ is a stream the direct source or sink of
which is a file.  Such a stream is created explicitly by ‘open’ and
‘with-open-file’, and implicitly by functions such as ‘load’ that
process files.

See Also:
.........

*note load::, *note open::, *note with-open-file::


File: ansicl,  Node: string-stream,  Next: synonym-stream,  Prev: file-stream,  Up: Streams

string-stream (System Class)
============================

Class Precedence List:
......................

‘string-stream’, ‘stream’, ‘t’

Description:
............

A string stream is a stream which reads input from or writes output to
an associated string.

The stream element type of a string stream is always a subtype of type
‘character’.

See Also:
.........

*note make-string-input-stream::, *note make-string-output-stream::,
*note with-input-from-string::, *note with-output-to-string::


File: ansicl,  Node: synonym-stream,  Next: two-way-stream,  Prev: string-stream,  Up: Streams

synonym-stream (System Class)
=============================

Class Precedence List:
......................

‘synonym-stream’, ‘stream’, ‘t’

Description:
............

A stream that is an alias for another stream, which is the value of a
dynamic variable whose name is the synonym stream symbol of the synonym
stream.

Any operations on a synonym stream will be performed on the stream that
is then the value of the dynamic variable named by the synonym stream
symbol.  If the value of the variable should change, or if the variable
should be bound, then the stream will operate on the new value of the
variable.

See Also:
.........

*note make-synonym-stream::, *note synonym-stream-symbol::


File: ansicl,  Node: two-way-stream,  Next: input-stream-p; output-stream-p,  Prev: synonym-stream,  Up: Streams

two-way-stream (System Class)
=============================

Class Precedence List:
......................

‘two-way-stream’, ‘stream’, ‘t’

Description:
............

A bidirectional composite stream that receives its input from an
associated input stream and sends its output to an associated output
stream.

See Also:
.........

*note make-two-way-stream::, *note two-way-stream-input-stream::, *note
two-way-stream-output-stream::


File: ansicl,  Node: input-stream-p; output-stream-p,  Next: interactive-stream-p,  Prev: two-way-stream,  Up: Streams

input-stream-p, output-stream-p (Function)
==========================================

Syntax:
.......

 -- Function: input-stream-p stream → generalized-boolean
 -- Function: output-stream-p stream → generalized-boolean

Arguments and Values:
.....................

STREAM—a stream.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘input-stream-p’ returns true if STREAM is an input stream; otherwise,
returns false.

‘output-stream-p’ returns true if STREAM is an output stream; otherwise,
returns false.

Examples:
.........

      (input-stream-p *standard-input*) → true
      (input-stream-p *terminal-io*) → true
      (input-stream-p (make-string-output-stream)) → false

      (output-stream-p *standard-output*) → true
      (output-stream-p *terminal-io*) → true
      (output-stream-p (make-string-input-stream "jr")) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.


File: ansicl,  Node: interactive-stream-p,  Next: open-stream-p,  Prev: input-stream-p; output-stream-p,  Up: Streams

interactive-stream-p (Function)
===============================

Syntax:
.......

 -- Function: interactive-stream-p stream → generalized-boolean

Arguments and Values:
.....................

STREAM—a stream.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if STREAM is an interactive stream; otherwise, returns
false.

Examples:
.........

      (when (> measured limit)
        (let ((error (round (* (- measured limit) 100)
                            limit)))
          (unless (if (interactive-stream-p *query-io*)
                      (yes-or-no-p "The frammis is out of tolerance by ~D%.~@
                                    Is it safe to proceed? " error)
                      (< error 15))  ;15% is acceptable
            (error "The frammis is out of tolerance by ~D%." error))))

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.

See Also:
.........

*note Section 21.1 (Stream Concepts): Stream Concepts.


File: ansicl,  Node: open-stream-p,  Next: stream-element-type,  Prev: interactive-stream-p,  Up: Streams

open-stream-p (Function)
========================

Syntax:
.......

 -- Function: open-stream-p stream → generalized-boolean

Arguments and Values:
.....................

STREAM—a stream.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if STREAM is an open stream; otherwise, returns false.

Streams are open until they have been explicitly closed with ‘close’, or
until they are implicitly closed due to exit from a
‘with-output-to-string’, ‘with-open-file’, ‘with-input-from-string’, or
‘with-open-stream’ form.

Examples:
.........

      (open-stream-p *standard-input*) → true

Affected By:
............

‘close’.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.


File: ansicl,  Node: stream-element-type,  Next: streamp,  Prev: open-stream-p,  Up: Streams

stream-element-type (Function)
==============================

Syntax:
.......

 -- Function: stream-element-type stream → typespec

Arguments and Values:
.....................

STREAM—a stream.

TYPESPEC—a type specifier.

Description:
............

‘stream-element-type’ returns a type specifier that indicates the types
of objects that may be read from or written to STREAM.

Streams created by ‘open’ have an element type restricted to ‘integer’
or a subtype of type ‘character’.

Examples:
.........

     ;; Note that the stream must accomodate at least the specified type,
     ;; but might accomodate other types.  Further note that even if it does
     ;; accomodate exactly the specified type, the type might be specified in
     ;; any of several ways.
      (with-open-file (s "test" :element-type '(integer 0 1)
                                :if-exists :error
                                :direction :output)
        (stream-element-type s))
     → INTEGER
     or→ (UNSIGNED-BYTE 16)
     or→ (UNSIGNED-BYTE 8)
     or→ BIT
     or→ (UNSIGNED-BYTE 1)
     or→ (INTEGER 0 1)
     or→ (INTEGER 0 (2))

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.


File: ansicl,  Node: streamp,  Next: read-byte,  Prev: stream-element-type,  Up: Streams

streamp (Function)
==================

Syntax:
.......

 -- Function: streamp object → generalized-boolean

Arguments and Values:
.....................

OBJECT—an object.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘stream’; otherwise, returns false.

‘streamp’ is unaffected by whether OBJECT, if it is a stream, is open or
closed.

Examples:
.........

      (streamp *terminal-io*) → true
      (streamp 1) → false

Notes:
......

      (streamp OBJECT) ≡ (typep OBJECT 'stream)


File: ansicl,  Node: read-byte,  Next: write-byte,  Prev: streamp,  Up: Streams

read-byte (Function)
====================

Syntax:
.......

 -- Function: read-byte stream &optional eof-error-p eof-value → byte

Arguments and Values:
.....................

STREAM—a binary input stream.

EOF-ERROR-P—a generalized boolean.  The default is true.

EOF-VALUE—an object.  The default is ‘nil’.

BYTE—an integer, or the EOF-VALUE.

Description:
............

‘read-byte’ reads and returns one byte from STREAM.

If an end of filethe EOF-VALUE is returned.

Examples:
.........

      (with-open-file (s "temp-bytes"
                          :direction :output
                          :element-type 'unsigned-byte)
         (write-byte 101 s)) → 101
      (with-open-file (s "temp-bytes" :element-type 'unsigned-byte)
         (format t "~S ~S" (read-byte s) (read-byte s nil 'eof)))
     ▷ 101 EOF
     → NIL

Side Effects:
.............

Modifies STREAM.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.

Should signal an error of type ‘error’ if STREAM is not a binary input
stream.

If there are no bytes remaining in the STREAM and EOF-ERROR-P is true,
an error of type ‘end-of-file’ is signaled.

See Also:
.........

*note read-char::, *note read-sequence::, *note write-byte::


File: ansicl,  Node: write-byte,  Next: peek-char,  Prev: read-byte,  Up: Streams

write-byte (Function)
=====================

Syntax:
.......

 -- Function: write-byte byte stream → byte

Arguments and Values:
.....................

BYTE—an integer of the stream element type of stream.

STREAM—a binary output stream.

Description:
............

‘write-byte’ writes one byte, BYTE, to STREAM.

Examples:
.........

      (with-open-file (s "temp-bytes"
                         :direction :output
                         :element-type 'unsigned-byte)
         (write-byte 101 s)) → 101

Side Effects:
.............

STREAM is modified.

Affected By:
............

The element type of the STREAM.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.
Should signal an error of type ‘error’ if STREAM is not a binary output
stream.

Might signal an error of type ‘type-error’ if BYTE is not an integer of
the stream element type of stream.

See Also:
.........

*note read-byte::, *note write-char::, *note write-sequence::


File: ansicl,  Node: peek-char,  Next: read-char,  Prev: write-byte,  Up: Streams

peek-char (Function)
====================

Syntax:
.......

 -- Function: peek-char &optional peek-type input-stream eof-error-p
          eof-value recursive-p → char

Arguments and Values:
.....................

PEEK-TYPE—a character or ‘t’ or ‘nil’.

INPUT-STREAM—input stream designator.  The default is standard input.

EOF-ERROR-P—a generalized boolean.  The default is true.

EOF-VALUE—an object.  The default is ‘nil’.

RECURSIVE-P—a generalized boolean.  The default is false.

CHAR—a character or the EOF-VALUE.

Description:
............

‘peek-char’ obtains the next character in INPUT-STREAM without actually
reading it, thus leaving the character to be read at a later time.  It
can also be used to skip over and discard intervening characters in the
INPUT-STREAM until a particular character is found.

If PEEK-TYPE is not supplied or ‘nil’, ‘peek-char’ returns the next
character to be read from INPUT-STREAM, without actually removing it
from INPUT-STREAM.  The next time input is done from INPUT-STREAM, the
character will still be there.  If PEEK-TYPE is ‘t’, then ‘peek-char’
skips over whitespacebut not comments, and then performs the peeking
operation on the next character.  The last character examined, the one
that starts an object, is not removed from INPUT-STREAM.  If PEEK-TYPE
is a character, then ‘peek-char’ skips over input characters until a
character that is ‘char=’ to that character is found; that character is
left in INPUT-STREAM.

If an end of fileEOF-VALUE is returned.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ‘read’ or a similar function used by the Lisp
reader.

When INPUT-STREAM is an echo stream, characters that are only peeked at
are not echoed.  In the case that PEEK-TYPE is not ‘nil’, the characters
that are passed by ‘peek-char’ are treated as if by ‘read-char’, and so
are echoed unless they have been marked otherwise by ‘unread-char’.

Examples:
.........

      (with-input-from-string (input-stream "    1 2 3 4 5")
         (format t "~S ~S ~S"
                 (peek-char t input-stream)
                 (peek-char #\4 input-stream)
                 (peek-char nil input-stream)))
     ▷ #\1 #\4 #\4
     → NIL

Affected By:
............

‘*readtable*’, ‘*standard-input*’, ‘*terminal-io*’.

Exceptional Situations:
.......................

If EOF-ERROR-P is true and an end of filean error of type ‘end-of-file’
is signaled.

If PEEK-TYPE is a character, an end of fileand EOF-ERROR-P is true, an
error of type ‘end-of-file’ is signaled.

If RECURSIVE-P is true and an end of filean error of type ‘end-of-file’
is signaled.


File: ansicl,  Node: read-char,  Next: read-char-no-hang,  Prev: peek-char,  Up: Streams

read-char (Function)
====================

Syntax:
.......

 -- Function: read-char &optional input-stream eof-error-p eof-value
          recursive-p → char

Arguments and Values:
.....................

INPUT-STREAM—an input stream designator.  The default is standard input.

EOF-ERROR-P—a generalized boolean.  The default is true.

EOF-VALUE—an object.  The default is ‘nil’.

RECURSIVE-P—a generalized boolean.  The default is false.

CHAR—a character or the EOF-VALUE.

Description:
............

‘read-char’ returns the next character from INPUT-STREAM.

When INPUT-STREAM is an ECHO STREAM, the character is echoed on
INPUT-STREAM the first time the character is seen.  Characters that are
not echoed by ‘read-char’ are those that were put there by ‘unread-char’
and hence are assumed to have been echoed already by a previous call to
‘read-char’.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ‘read’ or a similar function used by the Lisp
reader.

If an end of fileEOF-VALUE is returned.

Examples:
.........

      (with-input-from-string (is "0123")
         (do ((c (read-char is) (read-char is nil 'the-end)))
             ((not (characterp c)))
          (format t "~S " c)))
     ▷ #\0 #\1 #\2 #\3
     → NIL

Affected By:
............

‘*standard-input*’, ‘*terminal-io*’.

Exceptional Situations:
.......................

If an end of fileEOF-ERROR-P is true, an error of type ‘end-of-file’ is
signaled.

See Also:
.........

*note read-byte::, *note read-sequence::, *note write-char::, *note
read::

Notes:
......

The corresponding output function is ‘write-char’.


File: ansicl,  Node: read-char-no-hang,  Next: terpri; fresh-line,  Prev: read-char,  Up: Streams

read-char-no-hang (Function)
============================

Syntax:
.......

 -- Function: read-char-no-hang &optional input-stream eof-error-p
          eof-value recursive-p → char

Arguments and Values:
.....................

INPUT-STREAM—an input stream designator.  The default is standard input.

EOF-ERROR-P—a generalized boolean.  The default is true.

EOF-VALUE—an object.  The default is ‘nil’.

RECURSIVE-P—a generalized boolean.  The default is false.

CHAR—a character or ‘nil’ or the EOF-VALUE.

Description:
............

‘read-char-no-hang’ returns a character from INPUT-STREAM if such a
character is available.  If no character is available,
‘read-char-no-hang’ returns ‘nil’.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ‘read’ or a similar function used by the Lisp
reader.

If an end of fileEOF-VALUE is returned.

Examples:
.........

     ;; This code assumes an implementation in which a newline is not
     ;; required to terminate input from the console.
      (defun test-it ()
        (unread-char (read-char))
        (list (read-char-no-hang)
              (read-char-no-hang)
              (read-char-no-hang)))
     → TEST-IT
     ;; Implementation A, where a Newline is not required to terminate
     ;; interactive input on the console.
      (test-it)
     ▷ a
     → (#\a NIL NIL)
     ;; Implementation B, where a Newline is required to terminate
     ;; interactive input on the console, and where that Newline remains
     ;; on the input stream.
      (test-it)
     ▷ a↩
     → (#\a #\Newline NIL)

Affected By:
............

‘*standard-input*’, ‘*terminal-io*’.

Exceptional Situations:
.......................

If an end of filewhen EOF-ERROR-P is true, an error of type
‘end-of-file’ is signaled .

See Also:
.........

*note listen::

Notes:
......

‘read-char-no-hang’ is exactly like ‘read-char’, except that if it would
be necessary to wait in order to get a character (as from a keyboard),
‘nil’ is immediately returned without waiting.


File: ansicl,  Node: terpri; fresh-line,  Next: unread-char,  Prev: read-char-no-hang,  Up: Streams

terpri, fresh-line (Function)
=============================

Syntax:
.......

 -- Function: terpri &optional output-stream → ‘nil’
 -- Function: fresh-line &optional output-stream → generalized-boolean

Arguments and Values:
.....................

OUTPUT-STREAM—an output stream designator.  The default is standard
output.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

‘terpri’ outputs a newline to OUTPUT-STREAM.

‘fresh-line’ is similar to ‘terpri’ but outputs a newline only if the
OUTPUT-STREAM is not already at the start of a line.  If for some reason
this cannot be determined, then a newline is output anyway.
‘fresh-line’ returns true if it outputs a newline; otherwise it returns
false.

Examples:
.........

      (with-output-to-string (s)
         (write-string "some text" s)
         (terpri s)
         (terpri s)
         (write-string "more text" s))
     → "some text

     more text"
      (with-output-to-string (s)
         (write-string "some text" s)
         (fresh-line s)
         (fresh-line s)
         (write-string "more text" s))
     → "some text
     more text"

Side Effects:
.............

The OUTPUT-STREAM is modified.

Affected By:
............

‘*standard-output*’, ‘*terminal-io*’.

Exceptional Situations:
.......................

None.

Notes:
......

‘terpri’ is identical in effect to

      (write-char #\Newline output-stream)


File: ansicl,  Node: unread-char,  Next: write-char,  Prev: terpri; fresh-line,  Up: Streams

unread-char (Function)
======================

Syntax:
.......

 -- Function: unread-char character &optional input-stream → ‘nil’

Arguments and Values:
.....................

CHARACTER—a character; must be the last character that was read from
INPUT-STREAM.

INPUT-STREAM—an input stream designator.  The default is standard input.

Description:
............

‘unread-char’ places CHARACTER back onto the front of INPUT-STREAM so
that it will again be the next character in INPUT-STREAM.

When INPUT-STREAM is an echo stream, no attempt is made to undo any
echoing of the character that might already have been done on
INPUT-STREAM.  However, characters placed on INPUT-STREAM by
‘unread-char’ are marked in such a way as to inhibit later re-echo by
‘read-char’.

It is an error to invoke ‘unread-char’ twice consecutively on the same
stream without an intervening call to ‘read-char’ (or some other input
operation which implicitly reads characters) on that stream.

Invoking ‘peek-char’ or ‘read-char’ commits all previous characters.
The consequences of invoking ‘unread-char’ on any character preceding
that which is returned by ‘peek-char’ (including those passed over by
‘peek-char’ that has a non-nil PEEK-TYPE) are unspecified.  In
particular, the consequences of invoking ‘unread-char’ after ‘peek-char’
are unspecified.

Examples:
.........

      (with-input-from-string (is "0123")
         (dotimes (i 6)
           (let ((c (read-char is)))
             (if (evenp i) (format t "~&~S ~S~%" i c) (unread-char c is)))))
     ▷ 0 #\0
     ▷ 2 #\1
     ▷ 4 #\2
     → NIL

Affected By:
............

‘*standard-input*’, ‘*terminal-io*’.

See Also:
.........

*note peek-char::, *note read-char::, *note Section 21.1 (Stream
Concepts): Stream Concepts.

Notes:
......

‘unread-char’ is intended to be an efficient mechanism for allowing the
Lisp reader and other parsers to perform one-character lookahead in
INPUT-STREAM.


File: ansicl,  Node: write-char,  Next: read-line,  Prev: unread-char,  Up: Streams

write-char (Function)
=====================

Syntax:
.......

 -- Function: write-char character &optional output-stream → character

Arguments and Values:
.....................

CHARACTER—a character.

OUTPUT-STREAM—an output stream designator.  The default is standard
output.

Description:
............

‘write-char’ outputs CHARACTER to OUTPUT-STREAM.

Examples:
.........

      (write-char #\a)
     ▷ a
     → #\a
      (with-output-to-string (s)
        (write-char #\a s)
        (write-char #\Space s)
        (write-char #\b s))
     → "a b"

Side Effects:
.............

The OUTPUT-STREAM is modified.

Affected By:
............

‘*standard-output*’, ‘*terminal-io*’.

See Also:
.........

*note read-char::, *note write-byte::, *note write-sequence::


File: ansicl,  Node: read-line,  Next: write-string; write-line,  Prev: write-char,  Up: Streams

read-line (Function)
====================

Syntax:
.......

 -- Function: read-line &optional input-stream eof-error-p eof-value
          recursive-p → line, missing-newline-p

Arguments and Values:
.....................

INPUT-STREAM—an input stream designator.  The default is standard input.

EOF-ERROR-P—a generalized boolean.  The default is true.

EOF-VALUE—an object.  The default is ‘nil’.

RECURSIVE-P—a generalized boolean.  The default is false.

LINE—a string or the EOF-VALUE.

MISSING-NEWLINE-P—a generalized boolean.

Description:
............

Reads from INPUT-STREAM a line of text that is terminated by a newline
or end of file.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ‘read’ or a similar function used by the Lisp
reader.

The primary value, LINE, is the line that is read, represented as a
string (without the trailing newline, if any).  If EOF-ERROR-P is false
and the end of file for INPUT-STREAM is reached before any characters
are read, EOF-VALUE is returned as the LINE.

The secondary value, MISSING-NEWLINE-P, is a generalized boolean that is
false if the LINE was terminated by a newline, or true if the LINE was
terminated by the end of file for INPUT-STREAM (or if the LINE is the
EOF-VALUE).

Examples:
.........

      (setq a "line 1
      line2")
     → "line 1
      line2"
      (read-line (setq input-stream (make-string-input-stream a)))
     → "line 1", false
      (read-line input-stream)
     → "line2", true
      (read-line input-stream nil nil)
     → NIL, true

Affected By:
............

‘*standard-input*’, ‘*terminal-io*’.

Exceptional Situations:
.......................

If an end of filean error is signaled if EOF-ERROR-P is true.

See Also:
.........

*note read::

Notes:
......

The corresponding output function is ‘write-line’.


File: ansicl,  Node: write-string; write-line,  Next: read-sequence,  Prev: read-line,  Up: Streams

write-string, write-line (Function)
===================================

Syntax:
.......

 -- Function: write-string string &optional output-stream &key start end
          → string
 -- Function: write-line string &optional output-stream &key start end →
          string

Arguments and Values:
.....................

STRING—a string.

OUTPUT-STREAM—an output stream designator.  The default is standard
output.

START, END—bounding index designators of STRING.  The defaults for START
and END are ‘0’ and ‘nil’, respectively.

Description:
............

‘write-string’ writes the characters of the subsequence of STRING
bounded by START and END to OUTPUT-STREAM.  ‘write-line’ does the same
thing, but then outputs a newline afterwards.

Examples:
.........

      (prog1 (write-string "books" nil :end 4) (write-string "worms"))
     ▷ bookworms
     → "books"
      (progn (write-char #\*)
             (write-line "test12" *standard-output* :end 5)
             (write-line "*test2")
             (write-char #\*)
             nil)
     ▷ *test1
     ▷ *test2
     ▷ *
     → NIL

Affected By:
............

‘*standard-output*’, ‘*terminal-io*’.

See Also:
.........

*note read-line::, *note write-char::

Notes:
......

‘write-line’ and ‘write-string’ return STRING, not the substring bounded
by START and END.

      (write-string string)
     ≡ (dotimes (i (length string)
           (write-char (char string i)))

      (write-line string)
     ≡ (prog1 (write-string string) (terpri))


File: ansicl,  Node: read-sequence,  Next: write-sequence,  Prev: write-string; write-line,  Up: Streams

read-sequence (Function)
========================

Syntax:
.......

 -- Function: read-sequence sequence stream &key start end → position

SEQUENCE—a sequence.

STREAM—an input stream.

START, END—bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

POSITION—an integer greater than or equal to zero, and less than or
equal to the length of the SEQUENCE.

Description:
............

Destructively modifies SEQUENCE by replacing the elements of SEQUENCE
bounded by START and END with elements read from STREAM.

SEQUENCE is destructively modified by copying successive elements into
it from STREAM.  If the end of file for STREAM is reached before copying
all elements of the subsequence, then the extra elements near the end of
SEQUENCE are not updated.

POSITION is the index of the first element of SEQUENCE that was not
updated, which might be less than END because the end of file was
reached.

Examples:
.........

      (defvar *data* (make-array 15 :initial-element nil))
      (values (read-sequence *data* (make-string-input-stream "test string")) *data*)
      → 11, #(#\t #\e #\s #\t #\Space #\s #\t #\r #\i #\n #\g NIL NIL NIL NIL)

Side Effects:
.............

Modifies STREAM and SEQUENCE.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.  Should signal an error of type ‘type-error’
if START is not a non-negative integer.  Should signal an error of type
‘type-error’ if END is not a non-negative integer or ‘nil’.

Might signal an error of type ‘type-error’ if an element read from the
STREAM is not a member of the element type of the SEQUENCE.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
write-sequence::, *note read-line::

Notes:
......

‘read-sequence’ is identical in effect to iterating over the indicated
subsequence and reading one element at a time from STREAM and storing it
into SEQUENCE, but may be more efficient than the equivalent loop.  An
efficient implementation is more likely to exist for the case where the
SEQUENCE is a vector with the same element type as the STREAM.


File: ansicl,  Node: write-sequence,  Next: file-length,  Prev: read-sequence,  Up: Streams

write-sequence (Function)
=========================

Syntax:
.......

 -- Function: write-sequence sequence stream &key start end → sequence

SEQUENCE—a sequence.

STREAM—an output stream.

START, END—bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

Description:
............

‘write-sequence’ writes the elements of the subsequence of SEQUENCE
bounded by START and END to STREAM.

Examples:
.........

      (write-sequence "bookworms" *standard-output* :end 4)
      ▷ book
      → "bookworms"

Side Effects:
.............

Modifies STREAM.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.  Should signal an error of type ‘type-error’
if START is not a non-negative integer.  Should signal an error of type
‘type-error’ if END is not a non-negative integer or ‘nil’.

Might signal an error of type ‘type-error’ if an element of the bounded
sequence is not a member of the stream element type of the STREAM.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
read-sequence::, *note write-string::, *note write-line::

Notes:
......

‘write-sequence’ is identical in effect to iterating over the indicated
subsequence and writing one element at a time to STREAM, but may be more
efficient than the equivalent loop.  An efficient implementation is more
likely to exist for the case where the SEQUENCE is a vector with the
same element type as the STREAM.


File: ansicl,  Node: file-length,  Next: file-position,  Prev: write-sequence,  Up: Streams

file-length (Function)
======================

Syntax:
.......

 -- Function: file-length stream → length

Arguments and Values:
.....................

STREAM—a stream associated with a file.

LENGTH—a non-negative integer or ‘nil’.

Description:
............

‘file-length’ returns the length of STREAM, or ‘nil’ if the length
cannot be determined.

For a binary file, the length is measured in units of the element type
of the STREAM.

Examples:
.........

      (with-open-file (s "decimal-digits.text"
                         :direction :output :if-exists :error)
        (princ "0123456789" s)
        (truename s))
     → #P"A:>Joe>decimal-digits.text.1"
      (with-open-file (s "decimal-digits.text")
        (file-length s))
     → 10

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream
associated with a file.

See Also:
.........

*note open::


File: ansicl,  Node: file-position,  Next: file-string-length,  Prev: file-length,  Up: Streams

file-position (Function)
========================

Syntax:
.......

 -- Function: file-position stream → position
 -- Function: file-position stream position-spec → success-p

Arguments and Values:
.....................

STREAM—a stream.

POSITION-SPEC—a file position designator.

POSITION—a file position or ‘nil’.

SUCCESS-P—a generalized boolean.

Description:
............

Returns or changes the current position within a STREAM.

When POSITION-SPEC is not supplied, ‘file-position’ returns the current
file position in the STREAM, or ‘nil’ if this cannot be determined.

When POSITION-SPEC is supplied, the file position in STREAM is set to
that file position (if possible).  ‘file-position’ returns true if the
repositioning is performed successfully, or false if it is not.

An integer returned by ‘file-position’ of one argument should be
acceptable as POSITION-SPEC for use with the same file.

For a character file, performing a single ‘read-char’ or ‘write-char’
operation may cause the file position to be increased by more than 1
because of character-set translations (such as translating between the
Common Lisp ‘#\Newline’ character and an external ASCII
carriage-return/line-feed sequence) and other aspects of the
implementation.  For a binary file, every ‘read-byte’ or ‘write-byte’
operation increases the file position by 1.

Examples:
.........

      (defun tester ()
        (let ((noticed '()) file-written)
          (flet ((notice (x) (push x noticed) x))
            (with-open-file (s "test.bin"
                               :element-type '(unsigned-byte 8)
                               :direction :output
                               :if-exists :error)
               (notice (file-position s)) ;1
               (write-byte 5 s)
               (write-byte 6 s)
               (let ((p (file-position s)))
                 (notice p) ;2
                 (notice (when p (file-position s (1- p))))) ;3
               (write-byte 7 s)
               (notice (file-position s)) ;4
               (setq file-written (truename s)))
             (with-open-file (s file-written
                                :element-type '(unsigned-byte 8)
                                :direction :input)
               (notice (file-position s)) ;5
               (let ((length (file-length s)))
                 (notice length) ;6
                 (when length
                   (dotimes (i length)
                     (notice (read-byte s)))))) ;7,...
             (nreverse noticed))))
     → tester
      (tester)
     → (0 2 T 2 0 2 5 7)
     or→ (0 2 NIL 3 0 3 5 6 7)
     or→ (NIL NIL NIL NIL NIL NIL)

Side Effects:
.............

When the POSITION-SPEC argument is supplied, the file position in the
STREAM might be moved.

Affected By:
............

The value returned by ‘file-position’ increases monotonically as input
or output operations are performed.

Exceptional Situations:
.......................

If POSITION-SPEC is supplied, but is too large or otherwise
inappropriate, an error is signaled.

See Also:
.........

*note file-length::, *note file-string-length::, *note open::

Notes:
......

Implementations that have character files represented as a sequence of
records of bounded size might choose to encode the file position as, for
example, «record-number»*«max-record-size»+«character-within-record».
This is a valid encoding because it increases monotonically as each
character is read or written, though not necessarily by 1 at each step.
An integer might then be considered “inappropriate” as POSITION-SPEC to
‘file-position’ if, when decoded into record number and character
number, it turned out that the supplied record was too short for the
specified character number.


File: ansicl,  Node: file-string-length,  Next: open,  Prev: file-position,  Up: Streams

file-string-length (Function)
=============================

Syntax:
.......

 -- Function: file-string-length stream object → length

Arguments and Values:
.....................

STREAM—an output character file stream.

OBJECT—a string or a character.

LENGTH—a non-negative integer, or ‘nil’.

Description:
............

‘file-string-length’ returns the difference between what ‘(file-position
STREAM)’ would be after writing OBJECT and its current value, or
‘nil’ if this cannot be determined.

The returned value corresponds to the current state of STREAM at the
time of the call and might not be the same if it is called again when
the state of the stream has changed.


File: ansicl,  Node: open,  Next: stream-external-format,  Prev: file-string-length,  Up: Streams

open (Function)
===============

Syntax:
.......

 -- Function: open filespec &key direction element-type
          if-exists if-does-not-exist external-format → stream

Arguments and Values:
.....................

FILESPEC—a pathname designator.

DIRECTION—one of :input, :output, :io, or :probe.  The default is
:input.

ELEMENT-TYPE—a type specifier for recognizable subtype of ‘character’;
or a type specifier for a finite recognizable subtype of integer; or one
of the symbols signed-byte, unsigned-byte, or :default.  The default is
‘character’.

IF-EXISTS—one of :error, :new-version, :rename, :rename-and-delete,
:overwrite, :append, :supersede, or ‘nil’.  The default is :new-version
if the version component of FILESPEC is :newest, or :error otherwise.

IF-DOES-NOT-EXIST—one of :error, :create, or ‘nil’.  The default is
:error if DIRECTION is :input or IF-EXISTS is :overwrite or :append;
:create if DIRECTION is :output or :io, and IF-EXISTS is neither
:overwrite nor :append; or ‘nil’ when DIRECTION is :probe.

EXTERNAL-FORMAT—an external file format designator.  The default is
:default.

STREAM—a file stream or ‘nil’.

Description:
............

‘open’ creates, opens, and returns a file stream that is connected to
the file specified by FILESPEC.  FILESPEC is the name of the file to be
opened.  If the FILESPEC designator is a stream, that stream is not
closed first or otherwise affected.

The keyword arguments to ‘open’ specify the characteristics of the file
stream that is returned, and how to handle errors.

If DIRECTION is :input or :probe, or if IF-EXISTS is not :new-version
and the version component of the FILESPEC is :newest, then the file
opened is that file already existing in the file system that has a
version greater than that of any other file in the file system whose
other pathname components are the same as those of FILESPEC.

An implementation is required to recognize all of the ‘open’ keyword
options and to do something reasonable in the context of the host
operating system.  For example, if a file system does not support
distinct file versions and does not distinguish the notions of deletion
and expunging, :new-version might be treated the same as :rename or
:supersede, and :rename-and-delete might be treated the same as
:supersede.

:direction

     These are the possible values for DIRECTION, and how they affect
     the nature of the stream that is created:

     :input

          Causes the creation of an input file stream.

     :output

          Causes the creation of an output file stream.

     :io

          Causes the creation of a bidirectional file stream.

     :probe

          Causes the creation of a “no-directional” file stream; in
          effect, the file stream is created and then closed prior to
          being returned by ‘open’.

:element-type

     The ELEMENT-TYPE specifies the unit of transaction for the file
     stream.  If it is :default, the unit is determined by file system,
     possibly based on the file.

:if-exists

     IF-EXISTS specifies the action to be taken if DIRECTION is :output
     or :io and a file of the name FILESPEC already exists.  If
     DIRECTION is :input, not supplied, or :probe, IF-EXISTS is ignored.
     These are the results of ‘open’ as modified by IF-EXISTS:

     :error

          An error of type ‘file-error’ is signaled.

     :new-version

          A new file is created with a larger version number.

     :rename

          The existing file is renamed to some other name and then a new
          file is created.

     :rename-and-delete

          The existing file is renamed to some other name, then it is
          deleted but not expunged, and then a new file is created.

     :overwrite

          Output operations on the stream destructively modify the
          existing file.  If DIRECTION is :io the file is opened in a
          bidirectional mode that allows both reading and writing.  The
          file pointer is initially positioned at the beginning of the
          file; however, the file is not truncated back to length zero
          when it is opened.

     :append

          Output operations on the stream destructively modify the
          existing file.  The file pointer is initially positioned at
          the end of the file.

          If DIRECTION is :io, the file is opened in a bidirectional
          mode that allows both reading and writing.

     :supersede

          The existing file is superseded; that is, a new file with the
          same name as the old one is created.  If possible, the
          implementation should not destroy the old file until the new
          stream is closed.

     ‘nil’

          No file or stream is created; instead, ‘nil’ is returned to
          indicate failure.

:if-does-not-exist

     IF-DOES-NOT-EXIST specifies the action to be taken if a file of
     name FILESPEC does not already exist.  These are the results of
     ‘open’ as modified by IF-DOES-NOT-EXIST:

     :error

          An error of type ‘file-error’ is signaled.

     :create

          An empty file is created.  Processing continues as if the file
          had already existed but no processing as directed by IF-EXISTS
          is performed.

     ‘nil’

          No file or stream is created; instead, ‘nil’ is returned to
          indicate failure.

:external-format

     This option selects an external file format for the file: The only
     standardized value for this option is :default, although
     implementations are permitted to define additional external file
     formats and implementation-dependent values returned by
     ‘stream-external-format’ can also be used by conforming programs.

     The EXTERNAL-FORMAT is meaningful for any kind of file stream whose
     element type is a subtype of character.  This option is ignored for
     streams for which it is not meaningful; however, implementations
     may define other element types for which it is meaningful.  The
     consequences are unspecified if a character is written that cannot
     be represented by the given external file format.

When a file is opened, a file stream is constructed to serve as the file
system’s ambassador to the Lisp environment; operations on the file
stream are reflected by operations on the file in the file system.

A file can be deleted, renamed, or destructively modified by ‘open’.

For information about opening relative pathnames, see *note Section
19.2.3 (Merging Pathnames): Merging Pathnames.

Examples:
.........

      (open filespec :direction :probe)  → #<Closed Probe File Stream...>
      (setq q (merge-pathnames (user-homedir-pathname) "test"))
     → #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
         :NAME "test" :TYPE NIL :VERSION :NEWEST>
      (open filespec :if-does-not-exist :create) → #<Input File Stream...>
      (setq s (open filespec :direction :probe)) → #<Closed Probe File Stream...>
      (truename s) → #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY
         directory-name :NAME filespec :TYPE extension :VERSION 1>
      (open s :direction :output :if-exists nil) → NIL

Affected By:
............

The nature and state of the host computer’s file system.

Exceptional Situations:
.......................

If IF-EXISTS is :error, (subject to the constraints on the meaning of
IF-EXISTS listed above), an error of type ‘file-error’ is signaled.

If IF-DOES-NOT-EXIST is :error (subject to the constraints on the
meaning of IF-DOES-NOT-EXIST listed above), an error of type
‘file-error’ is signaled.

If it is impossible for an implementation to handle some option in a
manner close to what is specified here, an error of type ‘error’ might
be signaled.

An error of type ‘file-error’ is signaled if ‘(wild-pathname-p
FILESPEC)’ returns true.

An error of type ‘error’ is signaled if the EXTERNAL-FORMAT is not
understood by the implementation.

The various file systems in existence today have widely differing
capabilities, and some aspects of the file system are beyond the scope
of this specification to define.  A given implementation might not be
able to support all of these options in exactly the manner stated.  An
implementation is required to recognize all of these option keywords and
to try to do something “reasonable” in the context of the host file
system.  Where necessary to accomodate the file system, an
implementation deviate slightly from the semantics specified here
without being disqualified for consideration as a conforming
implementation.  If it is utterly impossible for an implementation to
handle some option in a manner similar to what is specified here, it may
simply signal an error.

With regard to the :element-type option, if a type is requested that is
not supported by the file system, a substitution of types such as that
which goes on in upgrading is permissible.  As a minimum requirement, it
should be the case that opening an output stream to a file in a given
element type and later opening an input stream to the same file in the
same element type should work compatibly.

See Also:
.........

*note with-open-file::, *note close::, *note pathname (System Class)::,
*note logical-pathname (System Class)::, *note Section 19.2.3 (Merging
Pathnames): Merging Pathnames, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.

Notes:
......

‘open’ does not automatically close the file when an abnormal exit
occurs.

When ELEMENT-TYPE is a subtype of ‘character’, ‘read-char’ and/or
‘write-char’ can be used on the resulting file stream.

When ELEMENT-TYPE is a subtype of integer, ‘read-byte’ and/or
‘write-byte’ can be used on the resulting file stream.

When ELEMENT-TYPE is :default, the type can be determined by using
‘stream-element-type’.


File: ansicl,  Node: stream-external-format,  Next: with-open-file,  Prev: open,  Up: Streams

stream-external-format (Function)
=================================

Syntax:
.......

 -- Function: stream-external-format stream → format

Arguments and Values:
.....................

STREAM—a file stream.

FORMAT—an external file format.

Description:
............

Returns an external file format designator for the STREAM.

Examples:
.........

      (with-open-file (stream "test" :direction :output)
        (stream-external-format stream))
     → :DEFAULT
     or→ :ISO8859/1-1987
     or→ (:ASCII :SAIL)
     or→ ACME::PROPRIETARY-FILE-FORMAT-17
     or→ #<FILE-FORMAT :ISO646-1983 2343673>

See Also:
.........

the :external-format argument to the function ‘open’ and the
‘with-open-file’ macro.

Notes:
......

The FORMAT returned is not necessarily meaningful to other
implementations.


File: ansicl,  Node: with-open-file,  Next: close,  Prev: stream-external-format,  Up: Streams

with-open-file (macro)
======================

Syntax:
.......

 -- Macro: with-open-file (stream filespec {options}*) {declaration}*
          {form}* → results

Arguments and Values:
.....................

STREAM—a variable.

FILESPEC—a pathname designator.

OPTIONS—forms; evaluated.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—the values returned by the FORMS.

Description:
............

‘with-open-file’ uses ‘open’ to create a file stream to file named by
FILESPEC.  FILESPEC is the name of the file to be opened.  OPTIONS are
used as keyword arguments to ‘open’.

The stream object to which the STREAM variable is bound has dynamic
extent; its extent ends when the form is exited.

‘with-open-file’ evaluates the FORMS as an implicit progn with STREAM
bound to the value returned by ‘open’.

When control leaves the body, either normally or abnormally (such as by
use of ‘throw’), the file is automatically closed.  If a new output file
is being written, and control leaves abnormally, the file is aborted and
the file system is left, so far as possible, as if the file had never
been opened.

It is possible by the use of ‘:if-exists nil’ or ‘:if-does-not-exist
nil’ for STREAM to be bound to ‘nil’.  Users of ‘:if-does-not-exist nil’
should check for a valid stream.

The consequences are undefined if an attempt is made to assign the
STREAM variable.  The compiler may choose to issue a warning if such an
attempt is detected.

Examples:
.........

      (setq p (merge-pathnames "test"))
     → #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
         :NAME "test" :TYPE NIL :VERSION :NEWEST>
      (with-open-file (s p :direction :output :if-exists :supersede)
         (format s "Here are a couple~%of test data lines~%")) → NIL
      (with-open-file (s p)
         (do ((l (read-line s) (read-line s nil 'eof)))
             ((eq l 'eof) "Reached end of file.")
          (format t "~&*** ~A~%" l)))
     ▷ *** Here are a couple
     ▷ *** of test data lines
     → "Reached end of file."

     ;; Normally one would not do this intentionally because it is
     ;; not perspicuous, but beware when using :IF-DOES-NOT-EXIST NIL
     ;; that this doesn't happen to you accidentally...
      (with-open-file (foo "no-such-file" :if-does-not-exist nil)
        (read foo))
     ▷ hello?
     → HELLO? ;This value was read from the terminal, not a file!

     ;; Here's another bug to avoid...
      (with-open-file (foo "no-such-file" :direction :output :if-does-not-exist nil)
        (format foo "Hello"))
     → "Hello" ;FORMAT got an argument of NIL!

Side Effects:
.............

Creates a stream to the file named by FILENAME (upon entry), and closes
the stream (upon exit).  In some implementations, the file might be
locked in some way while it is open.  If the stream is an output stream,
a file might be created.

Affected By:
............

The host computer’s file system.

Exceptional Situations:
.......................

See the function *note open::.

See Also:
.........

*note open::, *note close::, *note pathname (System Class)::, *note
logical-pathname (System Class)::, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: ansicl,  Node: close,  Next: with-open-stream,  Prev: with-open-file,  Up: Streams

close (Function)
================

Syntax:
.......

 -- Function: close stream &key abort → result

Arguments and Values:
.....................

STREAM—a stream (either open or closed).

ABORT—a generalized boolean.  The default is false.

RESULT—‘t’ if the STREAM was open at the time it was received as an
argument, or implementation-dependent otherwise.

Description:
............

‘close’ closes STREAM.  Closing a stream means that it may no longer be
used in input or output operations.  The act of closing a file stream
ends the association between the stream and its associated file; the
transaction with the file system is terminated, and input/output may no
longer be performed on the stream.

If ABORT is true, an attempt is made to clean up any side effects of
having created STREAM.  If STREAM performs output to a file that was
created when the stream was created, the file is deleted and any
previously existing file is not superseded.

It is permissible to close an already closed stream, but in that case
the RESULT is implementation-dependent.

After STREAM is closed, it is still possible to perform the following
query operations upon it: ‘streamp’, ‘pathname’, ‘truename’,
‘merge-pathnames’, ‘pathname-host’, ‘pathname-device’,
‘pathname-directory’,‘pathname-name’, ‘pathname-type’,
‘pathname-version’, ‘namestring’, ‘file-namestring’,
‘directory-namestring’, ‘host-namestring’, ‘enough-namestring’, ‘open’,
‘probe-file’, and ‘directory’.

The effect of ‘close’ on a constructed stream is to close the argument
STREAM only.  There is no effect on the constituents of composite
streams.

For a stream created with ‘make-string-output-stream’, the result of
‘get-output-stream-string’ is unspecified after ‘close’.

Examples:
.........

      (setq s (make-broadcast-stream)) → #<BROADCAST-STREAM>
      (close s) → T
      (output-stream-p s) → true

Side Effects:
.............

The STREAM is closed (if necessary).  If ABORT is true and the STREAM is
an output file stream, its associated file might be deleted.

See Also:
.........

*note open::


File: ansicl,  Node: with-open-stream,  Next: listen,  Prev: close,  Up: Streams

with-open-stream (Macro)
========================

Syntax:
.......

 -- Macro: with-open-stream (var stream) {declaration}* {form}* →
          {result}*

Arguments and Values:
.....................

VAR—a variable name.

STREAM—a form; evaluated to produce a stream.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—the values returned by the FORMS.

Description:
............

‘with-open-stream’ performs a series of operations on STREAM, returns a
value, and then closes the STREAM.

VAR is bound to the value of STREAM, and then FORMS are executed as an
implicit progn.  STREAM is automatically closed on exit from
‘with-open-stream’, no matter whether the exit is normal or abnormal.
The STREAM has dynamic extent; its extent ends when the form is exited.

The consequences are undefined if an attempt is made to assign the the
variable VAR with the FORMS.

Examples:
.........

      (with-open-stream (s (make-string-input-stream "1 2 3 4"))
         (+ (read s) (read s) (read s))) → 6

Side Effects:
.............

The STREAM is closed (upon exit).

See Also:
.........

*note close::


File: ansicl,  Node: listen,  Next: clear-input,  Prev: with-open-stream,  Up: Streams

listen (Function)
=================

Syntax:
.......

 -- Function: listen &optional input-stream → generalized-boolean

Arguments and Values:
.....................

INPUT-STREAM—an input stream designator.  The default is standard input.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

Returns true if there is a character immediately available from
INPUT-STREAM; otherwise, returns false.  On a non-interactive
INPUT-STREAM, ‘listen’ returns true except when at end of fileIf an end
of file is encountered, ‘listen’ returns false.  ‘listen’ is intended to
be used when INPUT-STREAM obtains characters from an interactive device
such as a keyboard.

Examples:
.........

      (progn (unread-char (read-char)) (list (listen) (read-char)))
     ▷ 1
     → (T #\1)
      (progn (clear-input) (listen))
     → NIL ;Unless you're a very fast typist!

Affected By:
............

‘*standard-input*’

See Also:
.........

*note interactive-stream-p::, *note read-char-no-hang::


File: ansicl,  Node: clear-input,  Next: finish-output; force-output; clear-output,  Prev: listen,  Up: Streams

clear-input (Function)
======================

Syntax:
.......

 -- Function: clear-input &optional input-stream → ‘nil’

Arguments and Values:
.....................

INPUT-STREAM—an input stream designator.  The default is standard input.

Description:
............

Clears any available input from INPUT-STREAM.

If ‘clear-input’ does not make sense for INPUT-STREAM, then
‘clear-input’ does nothing.

Examples:
.........

     ;; The exact I/O behavior of this example might vary from implementation
     ;; to implementation depending on the kind of interactive buffering that
     ;; occurs.  (The call to SLEEP here is intended to help even out the
     ;; differences in implementations which do not do line-at-a-time buffering.)

     (defun read-sleepily (&optional (clear-p nil) (zzz 0))
       (list (progn (print '>) (read))
             ;; Note that input typed within the first ZZZ seconds
             ;; will be discarded.
             (progn (print '>)
                    (if zzz (sleep zzz))
                    (print '>>)
                    (if clear-p (clear-input))
                    (read))))

     (read-sleepily)
     ▷ > 10
     ▷ >
     ▷ >> 20
     → (10 20)

     (read-sleepily t)
     ▷ > 10
     ▷ >
     ▷ >> 20
     → (10 20)

     (read-sleepily t 10)
     ▷ > 10
     ▷ > 20  ; Some implementations won't echo typeahead here.
     ▷ >> 30
     → (10 30)

Side Effects:
.............

The INPUT-STREAM is modified.

Affected By:
............

‘*standard-input*’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INPUT-STREAM is not a
stream designator.

See Also:
.........

*note clear-output::


File: ansicl,  Node: finish-output; force-output; clear-output,  Next: y-or-n-p; yes-or-no-p,  Prev: clear-input,  Up: Streams

finish-output, force-output, clear-output (Function)
====================================================

Syntax:
.......

 -- Function: finish-output &optional output-stream → ‘nil’
 -- Function: force-output &optional output-stream → ‘nil’
 -- Function: clear-output &optional output-stream → ‘nil’

Arguments and Values:
.....................

OUTPUT-STREAM—an output stream designator.  The default is standard
output.

Description:
............

‘finish-output’, ‘force-output’, and ‘clear-output’ exercise control
over the internal handling of buffered stream output.

‘finish-output’ attempts to ensure that any buffered output sent to
OUTPUT-STREAM has reached its destination, and then returns.

‘force-output’ initiates the emptying of any internal buffers but does
not wait for completion or acknowledgment to return.

‘clear-output’ attempts to abort any outstanding output operation in
progress in order to allow as little output as possible to continue to
the destination.

If any of these operations does not make sense for OUTPUT-STREAM, then
it does nothing.  The precise actions of these functions are
implementation-dependent.

Examples:
.........

     ;; Implementation A
      (progn (princ "am i seen?") (clear-output))
     → NIL

     ;; Implementation B
      (progn (princ "am i seen?") (clear-output))
     ▷ am i seen?
     → NIL

Affected By:
............

‘*standard-output*’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if OUTPUT-STREAM is not a
stream designator.

See Also:
.........

*note clear-input::


File: ansicl,  Node: y-or-n-p; yes-or-no-p,  Next: make-synonym-stream,  Prev: finish-output; force-output; clear-output,  Up: Streams

y-or-n-p, yes-or-no-p (Function)
================================

Syntax:
.......

 -- Function: y-or-n-p &optional control &rest arguments →
          generalized-boolean
 -- Function: yes-or-no-p &optional control &rest arguments →
          generalized-boolean

Arguments and Values:
.....................

CONTROL—a format control.

ARGUMENTS—format arguments for CONTROL.

GENERALIZED-BOOLEAN—a generalized boolean.

Description:
............

These functions ask a question and parse a response from the user.  They
return true if the answer is affirmative, or false if the answer is
negative.

‘y-or-n-p’ is for asking the user a question whose answer is either
“yes” or “no.” It is intended that the reply require the user to answer
a yes-or-no question with a single character.  ‘yes-or-no-p’ is also for
asking the user a question whose answer is either “Yes” or “No.” It is
intended that the reply require the user to take more action than just a
single keystroke, such as typing the full word ‘yes’ or ‘no’ followed by
a newline.

‘y-or-n-p’ types out a message (if supplied), reads an answer in some
implementation-dependent manner (intended to be short and simple, such
as reading a single character such as ‘Y’ or ‘N’).  ‘yes-or-no-p’ types
out a message (if supplied), attracts the user’s attention (for example,
by ringing the terminal’s bell), and reads an answer in some
implementation-dependent manner (intended to be multiple characters,
such as ‘YES’ or ‘NO’).

If FORMAT-CONTROL is supplied and not ‘nil’, then a ‘fresh-line’
operation is performed; then a message is printed as if FORMAT-CONTROL
and ARGUMENTS were given to ‘format’.  In any case, ‘yes-or-no-p’ and
‘y-or-n-p’ will provide a prompt such as “‘(Y or N)’” or “‘(Yes or No)’”
if appropriate.

All input and output are performed using query I/O.

Examples:
.........

      (y-or-n-p "(t or nil) given by")
     ▷ (t or nil) given by (Y or N) Y
     → true
      (yes-or-no-p "a ~S message" 'frightening)
     ▷ a FRIGHTENING message (Yes or No) no
     → false
      (y-or-n-p "Produce listing file?")
     ▷ Produce listing file?
     ▷ Please respond with Y or N. n
     → false

Side Effects:
.............

Output to and input from query I/O will occur.

Affected By:
............

‘*query-io*’.

See Also:
.........

*note format::

Notes:
......

‘yes-or-no-p’ and ‘yes-or-no-p’ do not add question marks to the end of
the prompt string, so any desired question mark or other punctuation
should be explicitly included in the text query.


File: ansicl,  Node: make-synonym-stream,  Next: synonym-stream-symbol,  Prev: y-or-n-p; yes-or-no-p,  Up: Streams

make-synonym-stream (Function)
==============================

Syntax:
.......

 -- Function: make-synonym-stream symbol → synonym-stream

Arguments and Values:
.....................

SYMBOL—a symbol that names a dynamic variable.

SYNONYM-STREAM—a synonym stream.

Description:
............

Returns a synonym stream whose synonym stream symbol is SYMBOL.

Examples:
.........

      (setq a-stream (make-string-input-stream "a-stream")
             b-stream (make-string-input-stream "b-stream"))
     → #<String Input Stream>
      (setq s-stream (make-synonym-stream 'c-stream))
     → #<SYNONYM-STREAM for C-STREAM>
      (setq c-stream a-stream)
     → #<String Input Stream>
      (read s-stream) → A-STREAM
      (setq c-stream b-stream)
     → #<String Input Stream>
      (read s-stream) → B-STREAM

Exceptional Situations:
.......................

Should signal ‘type-error’ if its argument is not a symbol.

See Also:
.........

*note Section 21.1 (Stream Concepts): Stream Concepts.


File: ansicl,  Node: synonym-stream-symbol,  Next: broadcast-stream-streams,  Prev: make-synonym-stream,  Up: Streams

synonym-stream-symbol (Function)
================================

Syntax:
.......

 -- Function: synonym-stream-symbol synonym-stream → symbol

Arguments and Values:
.....................

SYNONYM-STREAM—a synonym stream.

SYMBOL—a symbol.

Description:
............

Returns the symbol whose ‘symbol-value’ the SYNONYM-STREAM is using.

See Also:
.........

*note make-synonym-stream::


File: ansicl,  Node: broadcast-stream-streams,  Next: make-broadcast-stream,  Prev: synonym-stream-symbol,  Up: Streams

broadcast-stream-streams (Function)
===================================

Syntax:
.......

 -- Function: broadcast-stream-streams broadcast-stream → streams

Arguments and Values:
.....................

BROADCAST-STREAM—a broadcast stream.

STREAMS—a list of streams.

Description:
............

Returns a list of output streams that constitute all the streams to
which the BROADCAST-STREAM is broadcasting.


File: ansicl,  Node: make-broadcast-stream,  Next: make-two-way-stream,  Prev: broadcast-stream-streams,  Up: Streams

make-broadcast-stream (Function)
================================

Syntax:
.......

 -- Function: make-broadcast-stream &rest streams → broadcast-stream

Arguments and Values:
.....................

STREAM—an output stream.

BROADCAST-STREAM—a broadcast stream.

Description:
............

Returns a broadcast stream.

Examples:
.........

      (setq a-stream (make-string-output-stream)
             b-stream (make-string-output-stream)) → #<String Output Stream>
      (format (make-broadcast-stream a-stream b-stream)
               "this will go to both streams") → NIL
      (get-output-stream-string a-stream) → "this will go to both streams"
      (get-output-stream-string b-stream) → "this will go to both streams"

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not an output
stream.

See Also:
.........

*note broadcast-stream-streams::


File: ansicl,  Node: make-two-way-stream,  Next: two-way-stream-input-stream; two-way-stream-output-stream,  Prev: make-broadcast-stream,  Up: Streams

make-two-way-stream (Function)
==============================

Syntax:
.......

 -- Function: make-two-way-stream input-stream output-stream →
          two-way-stream

Arguments and Values:
.....................

INPUT-STREAM—a stream.

OUTPUT-STREAM—a stream.

TWO-WAY-STREAM—a two-way stream.

Description:
............

Returns a two-way stream that gets its input from INPUT-STREAM and sends
its output to OUTPUT-STREAM.

Examples:
.........

      (with-output-to-string (out)
         (with-input-from-string (in "input...")
           (let ((two (make-two-way-stream in out)))
             (format two "output...")
             (setq what-is-read (read two))))) → "output..."
      what-is-read → INPUT...

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INPUT-STREAM is not an
input stream.  Should signal an error of type ‘type-error’ if
OUTPUT-STREAM is not an output stream.


File: ansicl,  Node: two-way-stream-input-stream; two-way-stream-output-stream,  Next: echo-stream-input-stream; echo-stream-output-stream,  Prev: make-two-way-stream,  Up: Streams

two-way-stream-input-stream, two-way-stream-output-stream (Function)
====================================================================

Syntax:
.......

 -- Function: two-way-stream-input-stream two-way-stream → input-stream
 -- Function: two-way-stream-output-stream two-way-stream →
          output-stream

Arguments and Values:
.....................

TWO-WAY-STREAM—a two-way stream.

INPUT-STREAM—an input stream.

OUTPUT-STREAM—an output stream.

Description:
............

‘two-way-stream-input-stream’ returns the stream from which
TWO-WAY-STREAM receives input.

‘two-way-stream-output-stream’ returns the stream to which
TWO-WAY-STREAM sends output.


File: ansicl,  Node: echo-stream-input-stream; echo-stream-output-stream,  Next: make-echo-stream,  Prev: two-way-stream-input-stream; two-way-stream-output-stream,  Up: Streams

echo-stream-input-stream, echo-stream-output-stream (Function)
==============================================================

Syntax:
.......

 -- Function: echo-stream-input-stream echo-stream → input-stream
 -- Function: echo-stream-output-stream echo-stream → output-stream

Arguments and Values:
.....................

ECHO-STREAM—an echo stream.

INPUT-STREAM—an input stream.

‘output-stream’—an output stream.

Description:
............

‘echo-stream-input-stream’ returns the input stream from which
ECHO-STREAM receives input.

‘echo-stream-output-stream’ returns the output stream to which
ECHO-STREAM sends output.


File: ansicl,  Node: make-echo-stream,  Next: concatenated-stream-streams,  Prev: echo-stream-input-stream; echo-stream-output-stream,  Up: Streams

make-echo-stream (Function)
===========================

Syntax:
.......

 -- Function: make-echo-stream input-stream output-stream → echo-stream

Arguments and Values:
.....................

INPUT-STREAM—an input stream.

OUTPUT-STREAM—an output stream.

ECHO-STREAM—an echo stream.

Description:
............

Creates and returns an echo stream that takes input from INPUT-STREAM
and sends output to OUTPUT-STREAM.

Examples:
.........

      (let ((out (make-string-output-stream)))
         (with-open-stream
             (s (make-echo-stream
                 (make-string-input-stream "this-is-read-and-echoed")
                 out))
           (read s)
           (format s " * this-is-direct-output")
           (get-output-stream-string out)))
     → "this-is-read-and-echoed * this-is-direct-output"

See Also:
.........

*note echo-stream-input-stream::, *note echo-stream-output-stream::,
*note make-two-way-stream::


File: ansicl,  Node: concatenated-stream-streams,  Next: make-concatenated-stream,  Prev: make-echo-stream,  Up: Streams

concatenated-stream-streams (Function)
======================================

Syntax:
.......

 -- Function: concatenated-stream-streams concatenated-stream → streams

Arguments and Values:
.....................

CONCATENATED-STREAM—a concatenated stream.

STREAMS—a list of input streams.

Description:
............

Returns a list of input streams that constitute the ordered set of
streams the CONCATENATED-STREAM still has to read from, starting with
the current one it is reading from.  The list may be empty if no more
streams remain to be read.

The consequences are undefined if the list structure of the STREAMS is
ever modified.


File: ansicl,  Node: make-concatenated-stream,  Next: get-output-stream-string,  Prev: concatenated-stream-streams,  Up: Streams

make-concatenated-stream (Function)
===================================

Syntax:
.......

 -- Function: make-concatenated-stream &rest input-streams →
          concatenated-stream

Arguments and Values:
.....................

INPUT-STREAM—an input stream.

CONCATENATED-STREAM—a concatenated stream.

Description:
............

Returns a concatenated stream that has the indicated INPUT-STREAMS
initially associated with it.

Examples:
.........

      (read (make-concatenated-stream
              (make-string-input-stream "1")
              (make-string-input-stream "2"))) → 12

Exceptional Situations:
.......................

Should signal ‘type-error’ if any argument is not an input stream.

See Also:
.........

*note concatenated-stream-streams::


File: ansicl,  Node: get-output-stream-string,  Next: make-string-input-stream,  Prev: make-concatenated-stream,  Up: Streams

get-output-stream-string (Function)
===================================

Syntax:
.......

 -- Function: get-output-stream-string string-output-stream → string

Arguments and Values:
.....................

STRING-OUTPUT-STREAM—a stream.

STRING—a string.

Description:
............

Returns a string containing, in order, all the characters that have been
output to STRING-OUTPUT-STREAM.  This operation clears any characters on
STRING-OUTPUT-STREAM, so the STRING contains only those characters which
have been output since the last call to ‘get-output-stream-string’ or
since the creation of the STRING-OUTPUT-STREAM, whichever occurred most
recently.

Examples:
.........

      (setq a-stream (make-string-output-stream)
             a-string "abcdefghijklm") → "abcdefghijklm"
      (write-string a-string a-stream) → "abcdefghijklm"
      (get-output-stream-string a-stream) → "abcdefghijklm"
      (get-output-stream-string a-stream) → ""

Side Effects:
.............

The STRING-OUTPUT-STREAM is cleared.

Exceptional Situations:
.......................

The consequences are undefined if STREAM-OUTPUT-STRING is closed.

The consequences are undefined if STRING-OUTPUT-STREAM is a stream that
was not produced by ‘make-string-output-stream’.  The consequences are
undefined if STRING-OUTPUT-STREAM was created implicitly by
‘with-output-to-string’ or ‘format’.

See Also:
.........

*note make-string-output-stream::


File: ansicl,  Node: make-string-input-stream,  Next: make-string-output-stream,  Prev: get-output-stream-string,  Up: Streams

make-string-input-stream (Function)
===================================

Syntax:
.......

 -- Function: make-string-input-stream string &optional start end →
          string-stream

Arguments and Values:
.....................

STRING—a string.

START, END—bounding index designators of STRING.  The defaults for START
and END are ‘0’ and ‘nil’, respectively.

STRING-STREAM—an input string stream.

Description:
............

Returns an input string stream.  This stream will supply, in order, the
characters in the substring of STRING bounded by START and END.  After
the last character has been supplied, the string stream will then be at
end of file.

Examples:
.........

      (let ((string-stream (make-string-input-stream "1 one ")))
        (list (read string-stream nil nil)
              (read string-stream nil nil)
              (read string-stream nil nil)))
     → (1 ONE NIL)

      (read (make-string-input-stream "prefixtargetsuffix" 6 12)) → TARGET

See Also:
.........

*note with-input-from-string::


File: ansicl,  Node: make-string-output-stream,  Next: with-input-from-string,  Prev: make-string-input-stream,  Up: Streams

make-string-output-stream (Function)
====================================

Syntax:
.......

 -- Function: make-string-output-stream &key element-type →
          string-stream

Arguments and Values:
.....................

ELEMENT-TYPE—a type specifier.  The default is ‘character’.

STRING-STREAM—an output string stream.

Description:
............

Returns an output string stream that accepts characters and makes
available (via ‘get-output-stream-string’) a string that contains the
characters that were actually output.

The ELEMENT-TYPE names the type of the elements of the string; a string
is constructed of the most specialized type that can accommodate
elements of that element-type.

Examples:
.........

      (let ((s (make-string-output-stream)))
        (write-string "testing... " s)
        (prin1 1234 s)
        (get-output-stream-string s))
     → "testing... 1234"

.

See Also:
.........

*note get-output-stream-string::, *note with-output-to-string::


File: ansicl,  Node: with-input-from-string,  Next: with-output-to-string,  Prev: make-string-output-stream,  Up: Streams

with-input-from-string (Macro)
==============================

Syntax:
.......

 -- Macro: with-input-from-string (var string &key index start end)
          {declaration}* {form}* → {result}*

Arguments and Values:
.....................

VAR—a variable name.

STRING—a form; evaluated to produce a string.

INDEX—a place.

START, END—bounding index designators of STRING.  The defaults for START
and END are ‘0’ and ‘nil’, respectively.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULT—the values returned by the FORMS.

Description:
............

Creates an input string stream, provides an opportunity to perform
operations on the stream (returning zero or more values), and then
closes the string stream.

STRING is evaluated first, and VAR is bound to a character input string
stream that supplies characters from the subsequence of the resulting
string bounded by START and END.  The body is executed as an implicit
progn.

The input string stream is automatically closed on exit from
‘with-input-from-string’, no matter whether the exit is normal or
abnormal.  The input string stream to which the variable VAR is bound
has dynamic extent; its extent ends when the form is exited.

The INDEX is a pointer within the STRING to be advanced.  If
‘with-input-from-string’ is exited normally, then INDEX will have as its
value the index into the STRING indicating the first character not read
which is ‘(length STRING)’ if all characters were used.  The place
specified by INDEX is not updated as reading progresses, but only at the
end of the operation.

START and INDEX may both specify the same variable, which is a pointer
within the STRING to be advanced, perhaps repeatedly by some containing
loop.

The consequences are undefined if an attempt is made to assign the
variable VAR.

Examples:
.........

      (with-input-from-string (s "XXX1 2 3 4xxx"
                                  :index ind
                                  :start 3 :end 10)
         (+ (read s) (read s) (read s))) → 6
      ind → 9
      (with-input-from-string (s "Animal Crackers" :index j :start 6)
        (read s)) → CRACKERS

The variable ‘j’ is set to ‘15’.

Side Effects:
.............

The value of the place named by INDEX, if any, is modified.

See Also:
.........

*note make-string-input-stream::, *note Section 3.6 (Traversal Rules and
Side Effects): Traversal Rules and Side Effects.


File: ansicl,  Node: with-output-to-string,  Next: *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+,  Prev: with-input-from-string,  Up: Streams

with-output-to-string (Macro)
=============================

Syntax:
.......

 -- Macro: with-output-to-string (var &optional string-form &key
          element-type) {declaration}* {form}* → {result}*

Arguments and Values:
.....................

VAR—a variable name.

STRING-FORM—a form or ‘nil’; if non-nil, evaluated to produce STRING.

STRING—a string that has a fill pointer.

ELEMENT-TYPE—a type specifier; evaluated.  The default is ‘character’.

DECLARATION—a declare expression; not evaluated.

FORMS—an implicit progn.

RESULTS—If a STRING-FORM is not supplied or ‘nil’, a string; otherwise,
the values returned by the FORMS.

Description:
............

‘with-output-to-string’ creates a character output stream, performs a
series of operations that may send results to this stream, and then
closes the stream.

The ELEMENT-TYPE names the type of the elements of the stream; a stream
is constructed of the most specialized type that can accommodate
elements of the given type.

The body is executed as an implicit progn with VAR bound to an output
string stream.  All output to that string stream is saved in a string.

If STRING is supplied, ELEMENT-TYPE is ignored, and the output is
incrementally appended to STRING as if by use of ‘vector-push-extend’.

The output stream is automatically closed on exit from
‘with-output-from-string’, no matter whether the exit is normal or
abnormal.  The output string stream to which the variable VAR is bound
has dynamic extent; its extent ends when the form is exited.

If no STRING is provided, then ‘with-output-from-string’ produces a
stream that accepts characters and returns a string of the indicated
ELEMENT-TYPE.  If STRING is provided, ‘with-output-to-string’ returns
the results of evaluating the last FORM.

The consequences are undefined if an attempt is made to assign the
variable VAR.

Examples:
.........

      (setq fstr (make-array '(0) :element-type 'base-char
                                  :fill-pointer 0 :adjustable t)) → ""
      (with-output-to-string (s fstr)
         (format s "here's some output")
         (input-stream-p s)) → false
      fstr → "here's some output"

Side Effects:
.............

The STRING is modified.

Exceptional Situations:
.......................

The consequences are undefined if destructive modifications are
performed directly on the STRING during the dynamic extent of the call.

See Also:
.........

*note make-string-output-stream::, *note vector-push-extend::, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and Side
Effects.


File: ansicl,  Node: *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+,  Next: *terminal-io*,  Prev: with-output-to-string,  Up: Streams

*debug-io*, *error-output*, *query-io*, *standard-input*, *standard-output*, *trace-output* (Variable)
======================================================================================================

Value Type:
...........

For ‘*standard-input*’: an input stream

For ‘*error-output*’, ‘*standard-output*’, and ‘*trace-output*’: an
output stream.

For ‘*debug-io*’, ‘*query-io*’: a bidirectional stream.

Initial Value:
..............

implementation-dependent, but it must be an open stream that is not a
generalized synonym stream to an I/O customization variables but that
might be a generalized synonym stream to the value of some I/O
customization variable.  The initial value might also be a generalized
synonym stream to either the symbol ‘*terminal-io*’ or to the stream
that is its value.

Description:
............

These variables are collectively called the standardized I/O
customization variables.  They can be bound or assigned in order to
change the default destinations for input and/or output used by various
standardized operators and facilities.

The value of ‘*debug-io*’, called debug I/O, is a stream to be used for
interactive debugging purposes.

The value of ‘*error-output*’, called error output, is a stream to which
warnings and non-interactive error messages should be sent.

The value of ‘*query-io*’, called query I/O, is a bidirectional stream
to be used when asking questions of the user.  The question should be
output to this stream, and the answer read from it.

The value of ‘*standard-input*’, called standard input, is a stream that
is used by many operators as a default source of input when no specific
input stream is explicitly supplied.

The value of ‘*standard-output*’, called standard output, is a stream
that is used by many operators as a default destination for output when
no specific output stream is explicitly supplied.

The value of ‘*trace-output*’, called trace output, is the stream on
which traced functions (see ‘trace’) and the ‘time’ macro print their
output.

Examples:
.........

      (with-output-to-string (*error-output*)
        (warn "this string is sent to *error-output*"))
      → "Warning: this string is sent to *error-output*
     " ;The exact format of this string is implementation-dependent.
      
      
      (with-input-from-string (*standard-input* "1001")
         (+ 990 (read))) → 1991
      
      
      (progn (setq out (with-output-to-string (*standard-output*)
                          (print "print and format t send things to")
                          (format t "*standard-output* now going to a string")))
             :done)
     → :DONE
      out
     → "
     \"print and format t send things to\" *standard-output* now going to a string"
      
      
      (defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))
     → FACT
      (trace fact)
     → (FACT)
     ;; Of course, the format of traced output is implementation-dependent.
      (with-output-to-string (*trace-output*)
        (fact 3))
     → "
     1 Enter FACT 3
     | 2 Enter FACT 2
     |   3 Enter FACT 1
     |   3 Exit FACT 1
     | 2 Exit FACT 2
     1 Exit FACT 6"

See Also:
.........

*note *terminal-io*::, *note synonym-stream::, *note time (Macro)::,
*note trace::, *note Chapter 9 (Conditions): Conditions, *note Chapter
23 (Reader): Reader, *note Chapter 22 (Printer): Printer.

Notes:
......

The intent of the constraints on the initial value of the I/O
customization variables is to ensure that it is always safe to bind or
assign such a variable to the value of another I/O customization
variable, without unduly restricting implementation flexibility.

It is common for an implementation to make the initial values of
‘*debug-io*’ and ‘*query-io*’ be the same stream, and to make the
initial values of ‘*error-output*’ and ‘*standard-output*’ be the same
stream.

The functions ‘y-or-n-p’ and ‘yes-or-no-p’ use query I/O for their input
and output.

In the normal Lisp read-eval-print loop, input is read from standard
input.  Many input functions, including ‘read’ and ‘read-char’, take a
stream argument that defaults to standard input.

In the normal Lisp read-eval-print loop, output is sent to standard
output.  Many output functions, including ‘print’ and ‘write-char’, take
a stream argument that defaults to standard output.

A program that wants, for example, to divert output to a file should do
so by binding ‘*standard-output*’; that way error messages sent to
‘*error-output*’ can still get to the user by going through
‘*terminal-io*’ (if ‘*error-output*’ is bound to ‘*terminal-io*’), which
is usually what is desired.


File: ansicl,  Node: *terminal-io*,  Next: stream-error,  Prev: *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+,  Up: Streams

*terminal-io* (Variable)
========================

Value Type:
...........

a bidirectional stream.

Initial Value:
..............

implementation-dependent, but it must be an open stream that is not a
generalized synonym stream to an I/O customization variables but that
might be a generalized synonym stream to the value of some I/O
customization variable.

Description:
............

The value of ‘*terminal-io*’, called terminal I/O, is ordinarily a
bidirectional stream that connects to the user’s console.  Typically,
writing to this stream would cause the output to appear on a display
screen, for example, and reading from the stream would accept input from
a keyboard.  It is intended that standard input functions such as ‘read’
and ‘read-char’, when used with this stream, cause echoing of the input
into the output side of the stream.  The means by which this is
accomplished are implementation-dependent.

The effect of changing the value of ‘*terminal-io*’, either by binding
or assignment, is implementation-defined.

Examples:
.........

      (progn (prin1 'foo) (prin1 'bar *terminal-io*))
     ▷ FOOBAR
     → BAR
      (with-output-to-string (*standard-output*)
        (prin1 'foo)
        (prin1 'bar *terminal-io*))
     ▷ BAR
     → "FOO"

See Also:
.........

*note *debug-io*::, *note *error-output*::, *note *query-io*::, *note
*standard-input*::, *note *standard-output*::, *note *trace-output*::


File: ansicl,  Node: stream-error,  Next: stream-error-stream,  Prev: *terminal-io*,  Up: Streams

stream-error (Condition Type)
=============================

Class Precedence List:
......................

‘stream-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘stream-error’ consists of error conditions that are related to
receiving input from or sending output to a stream.  The “offending
stream” is initialized by the :stream initialization argument to
‘make-condition’, and is accessed by the function ‘stream-error-stream’.

See Also:
.........

*note stream-error-stream::


File: ansicl,  Node: stream-error-stream,  Next: end-of-file,  Prev: stream-error,  Up: Streams

stream-error-stream (Function)
==============================

Syntax:
.......

 -- Function: stream-error-stream condition → stream

Arguments and Values:
.....................

CONDITION—a condition of type ‘stream-error’.

STREAM—a stream.

Description:
............

Returns the offending stream of a condition of type ‘stream-error’.

Examples:
.........

      (with-input-from-string (s "(FOO")
        (handler-case (read s)
          (end-of-file (c)
            (format nil "~&End of file on ~S." (stream-error-stream c)))))
     "End of file on #<String Stream>."

See Also:
.........

*note stream-error::, *note Chapter 9 (Conditions): Conditions.


File: ansicl,  Node: end-of-file,  Prev: stream-error-stream,  Up: Streams

end-of-file (Condition Type)
============================

Class Precedence List:
......................

‘end-of-file’, ‘stream-error’, ‘error’, ‘serious-condition’,
‘condition’, ‘t’

Description:
............

The type ‘end-of-file’ consists of error conditions related to read
operations that are done on streams that have no more data.

See Also:
.........

*note stream-error-stream::


File: ansicl,  Node: Printer,  Next: Reader,  Prev: Streams,  Up: Top

22 Printer
**********

* Menu:

* The Lisp Printer::
* The Lisp Pretty Printer::
* Formatted Output::

Dictionary

* copy-pprint-dispatch::
* formatter::
* pprint-dispatch::
* pprint-exit-if-list-exhausted::
* pprint-fill; pprint-linear; pprint-tabular::
* pprint-indent::
* pprint-logical-block::
* pprint-newline::
* pprint-pop::
* pprint-tab::
* print-object::
* print-unreadable-object::
* set-pprint-dispatch::
* write; prin1; print; pprint; princ::
* write-to-string; prin1-to-string; princ-to-string::
* *print-array*::
* *print-base*; *print-radix*::
* *print-case*::
* *print-circle*::
* *print-escape*::
* *print-gensym*::
* *print-level*; *print-length*::
* *print-lines*::
* *print-miser-width*::
* *print-pprint-dispatch*::
* *print-pretty*::
* *print-readably*::
* *print-right-margin*::
* print-not-readable::
* print-not-readable-object::
* format::


File: ansicl,  Node: The Lisp Printer,  Next: The Lisp Pretty Printer,  Up: Printer

22.1 The Lisp Printer
=====================

* Menu:

* Overview of The Lisp Printer::
* Printer Dispatching::
* Default Print-Object Methods::
* Examples of Printer Behavior::


File: ansicl,  Node: Overview of The Lisp Printer,  Next: Printer Dispatching,  Up: The Lisp Printer

22.1.1 Overview of The Lisp Printer
-----------------------------------

Common Lisp provides a representation of most objects in the form of
printed text called the printed representation.  Functions such as
‘print’ take an object and send the characters of its printed
representation to a stream.  The collection of routines that does this
is known as the (Common Lisp) printer.

Reading a printed representation typically produces an object that is
‘equal’ to the originally printed object.

22.1.1.1 Multiple Possible Textual Representations
..................................................

Most objects have more than one possible textual representation.  For
example, the positive integer with a magnitude of twenty-seven can be
textually expressed in any of these ways:

      27    27.    #o33    #x1B    #b11011    #.(* 3 3 3)    81/3

A list containing the two symbols ‘A’ and ‘B’ can also be textually
expressed in a variety of ways:

      (A B)    (a b)    (  a  b )    (\A |B|)
     (|\A|
       B
     )

In general, from the point of view of the Lisp reader, wherever
whitespace is permissible in a textual representation, any number of
spaces and newlines can appear in standard syntax.

When a function such as ‘print’ produces a printed representation, it
must choose from among many possible textual representations.  In most
cases, it chooses a program readable representation, but in certain
cases it might use a more compact notation that is not program-readable.

A number of option variables, called “printer control variables”, are
provided to permit control of individual aspects of the printed
representation of objects.  The next figure shows the standardized
printer control variables; there might also be implementation-defined
printer control variables.

*print-array*    *print-gensym*        *print-pprint-dispatch*
*print-base*     *print-length*        *print-pretty*
*print-case*     *print-level*         *print-radix*
*print-circle*   *print-lines*         *print-readably*
*print-escape*   *print-miser-width*   *print-right-margin*

Figure 22.1: Standardized Printer Control Variables

In addition to the printer control variables, the following additional
defined names relate to or affect the behavior of the Lisp printer:

*package*                     *read-eval*   readtable-case
*read-default-float-format*   *readtable*

Figure 22.2: Additional Influences on the Lisp printer.

22.1.1.1.1 Printer Escaping
...........................

The variable ‘*print-escape*’ controls whether the Lisp printer tries to
produce notations such as escape characters and package prefixes.

The variable ‘*print-readably*’ can be used to override many of the
individual aspects controlled by the other printer control variables
when program-readable output is especially important.

One of the many effects of making the value of ‘*print-readably*’ be
true is that the Lisp printer behaves as if ‘*print-escape*’ were also
true.  For notational convenience, we say that if the value of either
‘*print-readably*’ or ‘*print-escape*’ is true, then “printer escaping”
is “enabled”; and we say that if the values of both ‘*print-readably*’
and ‘*print-escape*’ are false, then printer escaping is “disabled”.


File: ansicl,  Node: Printer Dispatching,  Next: Default Print-Object Methods,  Prev: Overview of The Lisp Printer,  Up: The Lisp Printer

22.1.2 Printer Dispatching
--------------------------

The Lisp printer makes its determination of how to print an object as
follows:

If the value of ‘*print-pretty*’ is true, printing is controlled by the
current pprint dispatch table; see *note Section 22.2.1.4 (Pretty Print
Dispatch Tables): PPrintDispatchTables.

Otherwise (if the value of ‘*print-pretty*’ is false), the object’s
‘print-object’ method is used; see *note Section 22.1.3 (Default
Print-Object Methods): Default Print-Object Methods.


File: ansicl,  Node: Default Print-Object Methods,  Next: Examples of Printer Behavior,  Prev: Printer Dispatching,  Up: The Lisp Printer

22.1.3 Default Print-Object Methods
-----------------------------------

This section describes the default behavior of ‘print-object’ methods
for the standardized types.

22.1.3.1 Printing Numbers
.........................

22.1.3.1.1 Printing Integers
............................

Integers are printed in the radix specified by the current output base
in positional notation, most significant digit first.  If appropriate, a
radix specifier can be printed; see ‘*print-radix*’.  If an integer is
negative, a minus sign is printed and then the absolute value of the
integer is printed.  The integer zero is represented by the single digit
‘0’ and never has a sign.  A decimal point might be printed, depending
on the value of ‘*print-radix*’.

For related information about the syntax of an integer, see *note
Section 2.3.2.1.1 (Syntax of an Integer): SyntaxOfIntegers.

22.1.3.1.2 Printing Ratios
..........................

Ratios are printed as follows: the absolute value of the numerator is
printed, as for an integer; then a ‘/’; then the denominator.  The
numerator and denominator are both printed in the radix specified by the
current output base; they are obtained as if by ‘numerator’ and
‘denominator’, and so ratios are printed in reduced form (lowest terms).
If appropriate, a radix specifier can be printed; see ‘*print-radix*’.
If the ratio is negative, a minus sign is printed before the numerator.

For related information about the syntax of a ratio, see *note Section
2.3.2.1.2 (Syntax of a Ratio): SyntaxOfRatios.

22.1.3.1.3 Printing Floats
..........................

If the magnitude of the float is either zero or between 10^-3
(inclusive) and 10^7 (exclusive), it is printed as the integer part of
the number, then a decimal point, followed by the fractional part of the
number; there is always at least one digit on each side of the decimal
point.  If the sign of the number (as determined by ‘float-sign’) is
negative, then a minus sign is printed before the number.  If the format
of the number does not match that specified by
‘*read-default-float-format*’, then the exponent marker for that format
and the digit ‘0’ are also printed.  For example, the base of the
natural logarithms as a short float might be printed as ‘2.71828S0’.

For non-zero magnitudes outside of the range 10^-3 to 10^7, a float is
printed in computerized scientific notation.  The representation of the
number is scaled to be between 1 (inclusive) and 10 (exclusive) and then
printed, with one digit before the decimal point and at least one digit
after the decimal point.  Next the exponent marker for the format is
printed, except that if the format of the number matches that specified
by ‘*read-default-float-format*’, then the exponent marker ‘E’ is used.
Finally, the power of ten by which the fraction must be multiplied to
equal the original number is printed as a decimal integer.  For example,
Avogadro’s number as a short float is printed as ‘6.02S23’.

For related information about the syntax of a float, see *note Section
2.3.2.2 (Syntax of a Float): SyntaxOfFloats.

22.1.3.1.4 Printing Complexes
.............................

A complex is printed as ‘#C’, an open parenthesis, the printed
representation of its real part, a space, the printed representation of
its imaginary part, and finally a close parenthesis.

For related information about the syntax of a complex, see *note Section
2.3.2.3 (Syntax of a Complex): SyntaxOfComplexes. and *note Section
2.4.8.11 (Sharpsign C): SharpsignC.

22.1.3.1.5 Note about Printing Numbers
......................................

The printed representation of a number must not contain escape
characters; see *note Section 2.3.1.1.1 (Escape Characters and Potential
Numbers): EscCharsAndPotentialNums.

22.1.3.2 Printing Characters
............................

When printer escaping is disabled, a character prints as itself; it is
sent directly to the output stream.  When printer escaping is enabled,
then ‘#\’ syntax is used.

When the printer types out the name of a character, it uses the same
table as the ‘#\’ reader macro would use; therefore any character name
that is typed out is acceptable as input (in that implementation).  If a
non-graphic character has a standardized namethat name is preferred over
non-standard names for printing in ‘#\’ notation.  For the graphic
standard characters, the character itself is always used for printing in
‘#\’ notation—even if the character also has a name

For details about the ‘#\’ reader macro, see *note Section 2.4.8.1
(Sharpsign Backslash): SharpsignBackslash.

22.1.3.3 Printing Symbols
.........................

When printer escaping is disabled, only the characters of the symbol’s
name are output (but the case in which to print characters in the name
is controlled by ‘*print-case*’; see *note Section 22.1.3.3.2 (Effect of
Readtable Case on the Lisp Printer): ReadtableCasePrintEffect.).

The remainder of this section applies only when printer escaping is
enabled.

When printing a symbol, the printer inserts enough single escape and/or
multiple escape characters (backslashes and/or vertical-bars) so that if
‘read’ were called with the same ‘*readtable*’ and with ‘*read-base*’
bound to the current output base, it would return the same symbol (if it
is not apparently uninterned) or an uninterned symbol with the same
print name (otherwise).

For example, if the value of ‘*print-base*’ were ‘16’ when printing the
symbol ‘face’, it would have to be printed as ‘\FACE’ or ‘\Face’ or
‘|FACE|’, because the token ‘face’ would be read as a hexadecimal number
(decimal value 64206) if the value of ‘*read-base*’ were ‘16’.

For additional restrictions concerning characters with nonstandard
syntax types in the current readtable, see the variable *note
*print-readably*::

For information about how the Lisp reader parses symbols, see *note
Section 2.3.4 (Symbols as Tokens): Symbols as Tokens. and *note Section
2.4.8.5 (Sharpsign Colon): SharpsignColon.

‘nil’ might be printed as ‘()’ when ‘*print-pretty*’ is true and printer
escaping is enabled.

22.1.3.3.1 Package Prefixes for Symbols
.......................................

Package prefixes are printed if necessary.  The rules for package
prefixes are as follows.  When the symbol is printed, if it is in the
‘KEYWORD’ package, then it is printed with a preceding colon; otherwise,
if it is accessible in the current package, it is printed without any
package prefix; otherwise, it is printed with a package prefix.

A symbol that is apparently uninterned is printed preceded by “‘#:’” if
‘*print-gensym*’ is true and printer escaping is enabled; if
‘*print-gensym*’ is false or printer escaping is disabled, then the
symbol is printed without a prefix, as if it were in the current
package.

Because the ‘#:’ syntax does not intern the following symbol, it is
necessary to use circular-list syntax if ‘*print-circle*’ is true and
the same uninterned symbol appears several times in an expression to be
printed.  For example, the result of

      (let ((x (make-symbol "FOO"))) (list x x))

would be printed as ‘(#:foo #:foo)’ if ‘*print-circle*’ were false, but
as ‘(#1=#:foo #1#)’ if ‘*print-circle*’ were true.

A summary of the preceding package prefix rules follows:

‘foo:bar’

     ‘foo:bar’ is printed when symbol ‘bar’ is external in its home
     package ‘foo’ and is not accessible in the current package.

‘foo::bar’

     ‘foo::bar’ is printed when ‘bar’ is internal in its home package
     ‘foo’ and is not accessible in the current package.

‘:bar’

     ‘:bar’ is printed when the home package of ‘bar’ is the ‘KEYWORD’
     package.

‘#:bar’

     ‘#:bar’ is printed when ‘bar’ is apparently uninterned, even in the
     pathological case that ‘bar’ has no home package but is
     nevertheless somehow accessible in the current package.

22.1.3.3.2 Effect of Readtable Case on the Lisp Printer
.......................................................

When printer escaping is disabled, or the characters under consideration
are not already quoted specifically by single escape or multiple escape
syntax, the readtable case of the current readtable affects the way the
Lisp printer writes symbols in the following ways:

:upcase

     When the readtable case is :upcase, uppercase characters are
     printed in the case specified by ‘*print-case*’, and lowercase
     characters are printed in their own case.

:downcase

     When the readtable case is :downcase, uppercase characters are
     printed in their own case, and lowercase characters are printed in
     the case specified by ‘*print-case*’.

:preserve

     When the readtable case is :preserve, all alphabetic characters are
     printed in their own case.

:invert

     When the readtable case is :invert, the case of all alphabetic
     characters in single case symbol names is inverted.  Mixed-case
     symbol names are printed as is.

The rules for escaping alphabetic characters in symbol names are
affected by the ‘readtable-case’ if printer escaping is enabled.
Alphabetic characters are escaped as follows:

:upcase

     When the readtable case is :upcase, all lowercase characters must
     be escaped.

:downcase

     When the readtable case is :downcase, all uppercase characters must
     be escaped.

:preserve

     When the readtable case is :preserve, no alphabetic characters need
     be escaped.

:invert

     When the readtable case is :invert, no alphabetic characters need
     be escaped.

22.1.3.3.2.1 Examples of Effect of Readtable Case on the Lisp Printer
.....................................................................

      (defun test-readtable-case-printing ()
        (let ((*readtable* (copy-readtable nil))
              (*print-case* *print-case*))
          (format t "READTABLE-CASE *PRINT-CASE*  Symbol-name  Output~
                   ~%--------------------------------------------------~
                   ~%")
          (dolist (readtable-case '(:upcase :downcase :preserve :invert))
            (setf (readtable-case *readtable*) readtable-case)
            (dolist (print-case '(:upcase :downcase :capitalize))
              (dolist (symbol '(|ZEBRA| |Zebra| |zebra|))
                (setq *print-case* print-case)
                (format t "~&:~A~15T:~A~29T~A~42T~A"
                        (string-upcase readtable-case)
                        (string-upcase print-case)
                        (symbol-name symbol)
                        (prin1-to-string symbol)))))))

The output from ‘(test-readtable-case-printing)’ should be as follows:

         READTABLE-CASE *PRINT-CASE*  Symbol-name  Output
         --------------------------------------------------
         :UPCASE        :UPCASE       ZEBRA        ZEBRA
         :UPCASE        :UPCASE       Zebra        |Zebra|
         :UPCASE        :UPCASE       zebra        |zebra|
         :UPCASE        :DOWNCASE     ZEBRA        zebra
         :UPCASE        :DOWNCASE     Zebra        |Zebra|
         :UPCASE        :DOWNCASE     zebra        |zebra|
         :UPCASE        :CAPITALIZE   ZEBRA        Zebra
         :UPCASE        :CAPITALIZE   Zebra        |Zebra|
         :UPCASE        :CAPITALIZE   zebra        |zebra|
         :DOWNCASE      :UPCASE       ZEBRA        |ZEBRA|
         :DOWNCASE      :UPCASE       Zebra        |Zebra|
         :DOWNCASE      :UPCASE       zebra        ZEBRA
         :DOWNCASE      :DOWNCASE     ZEBRA        |ZEBRA|
         :DOWNCASE      :DOWNCASE     Zebra        |Zebra|
         :DOWNCASE      :DOWNCASE     zebra        zebra
         :DOWNCASE      :CAPITALIZE   ZEBRA        |ZEBRA|
         :DOWNCASE      :CAPITALIZE   Zebra        |Zebra|
         :DOWNCASE      :CAPITALIZE   zebra        Zebra
         :PRESERVE      :UPCASE       ZEBRA        ZEBRA
         :PRESERVE      :UPCASE       Zebra        Zebra
         :PRESERVE      :UPCASE       zebra        zebra
         :PRESERVE      :DOWNCASE     ZEBRA        ZEBRA
         :PRESERVE      :DOWNCASE     Zebra        Zebra
         :PRESERVE      :DOWNCASE     zebra        zebra
         :PRESERVE      :CAPITALIZE   ZEBRA        ZEBRA
         :PRESERVE      :CAPITALIZE   Zebra        Zebra
         :PRESERVE      :CAPITALIZE   zebra        zebra
         :INVERT        :UPCASE       ZEBRA        zebra
         :INVERT        :UPCASE       Zebra        Zebra
         :INVERT        :UPCASE       zebra        ZEBRA
         :INVERT        :DOWNCASE     ZEBRA        zebra
         :INVERT        :DOWNCASE     Zebra        Zebra
         :INVERT        :DOWNCASE     zebra        ZEBRA
         :INVERT        :CAPITALIZE   ZEBRA        zebra
         :INVERT        :CAPITALIZE   Zebra        Zebra
         :INVERT        :CAPITALIZE   zebra        ZEBRA

22.1.3.4 Printing Strings
.........................

The characters of the string are output in order.  If printer escaping
is enabled, a double-quote is output before and after, and all
double-quotes and single escapes are preceded by backslash.  The
printing of strings is not affected by ‘*print-array*’.  Only the active
elements of the string are printed.

For information on how the Lisp reader parses strings, see *note Section
2.4.5 (Double-Quote): Double-Quote.

22.1.3.5 Printing Lists and Conses
..................................

Wherever possible, list notation is preferred over dot notation.
Therefore the following algorithm is used to print a cons x:

  1. A left-parenthesis is printed.

      

      

  2. The car of x is printed.

      

      

  3. If the cdr of x is itself a cons, it is made to be the current cons
     (i.e., x becomes that cons), a space is printed, and step 2 is
     re-entered.

      

      

  4. If the cdr of x is not null, a space, a dot, a space, and the cdr
     of x are printed.

      

      

  5. A right-parenthesis is printed.

Actually, the above algorithm is only used when ‘*print-pretty*’ is
false.  When ‘*print-pretty*’ is true (or when ‘pprint’ is used),
additional whitespacemay replace the use of a single space, and a more
elaborate algorithm with similar goals but more presentational
flexibility is used; see *note Section 22.1.2 (Printer Dispatching):
Printer Dispatching.

Although the two expressions below are equivalent, and the reader
accepts either one and produces the same cons, the printer always prints
such a cons in the second form.

      (a . (b . ((c . (d . nil)) . (e . nil))))
      (a b (c d) e)

The printing of conses is affected by ‘*print-level*’, ‘*print-length*’,
and ‘*print-circle*’.

Following are examples of printed representations of lists:

      (a . b)     ;A dotted pair of a and b
      (a.b)       ;A list of one element, the symbol named a.b
      (a. b)      ;A list of two elements a. and b
      (a .b)      ;A list of two elements a and .b
      (a b . c)   ;A dotted list of a and b with c at the end; two conses
      .iot        ;The symbol whose name is .iot
      (. b)       ;Invalid -- an error is signaled if an attempt is made to read
                  ;this syntax.
      (a .)       ;Invalid -- an error is signaled.
      (a .. b)    ;Invalid -- an error is signaled.
      (a . . b)   ;Invalid -- an error is signaled.
      (a b c ...) ;Invalid -- an error is signaled.
      (a \. b)    ;A list of three elements a, ., and b
      (a |.| b)   ;A list of three elements a, ., and b
      (a \... b)  ;A list of three elements a, ..., and b
      (a |...| b) ;A list of three elements a, ..., and b

For information on how the Lisp reader parses lists and conses, see
*note Section 2.4.1 (Left-Parenthesis): Left-Parenthesis.

22.1.3.6 Printing Bit Vectors
.............................

A bit vector is printed as ‘#*’ followed by the bits of the bit vector
in order.  If ‘*print-array*’ is false, then the bit vector is printed
in a format (using ‘#<’) that is concise but not readable.  Only the
active elements of the bit vector are printed.

For information on Lisp reader parsing of bit vectors, see *note Section
2.4.8.4 (Sharpsign Asterisk): SharpsignStar.

22.1.3.7 Printing Other Vectors
...............................

If ‘*print-array*’ is true and ‘*print-readably*’ is false, any vector
other than a string or bit vector is printed using general-vector
syntax; this means that information about specialized vector
representations does not appear.  The printed representation of a
zero-length vector is ‘#()’.  The printed representation of a
non-zero-length vector begins with ‘#(’.  Following that, the first
element of the vector is printed.  If there are any other elements, they
are printed in turn, with each such additional element preceded by a
space if ‘*print-pretty*’ is false, or whitespaceA right-parenthesis
after the last element terminates the printed representation of the
vector.  The printing of vectors is affected by ‘*print-level*’ and
‘*print-length*’.  If the vector has a fill pointer, then only those
elements below the fill pointer are printed.

If both ‘*print-array*’ and ‘*print-readably*’ are false, the vector is
not printed as described above, but in a format (using ‘#<’) that is
concise but not readable.

If ‘*print-readably*’ is true, the vector prints in an
implementation-defined manner; see the variable *note
*print-readably*::.

For information on how the Lisp reader parses these “other vectors,” see
*note Section 2.4.8.3 (Sharpsign Left-Parenthesis): SharpsignLeftParen.

22.1.3.8 Printing Other Arrays
..............................

If ‘*print-array*’ is true and ‘*print-readably*’ is false, any array
other than a vector is printed using ‘#’‘n’‘A’ format.  Let ‘n’ be the
rank of the array.  Then ‘#’ is printed, then ‘n’ as a decimal integer,
then ‘A’, then ‘n’ open parentheses.  Next the elements are scanned in
row-major order, using ‘write’ on each element, and separating elements
from each other with whitespaceThe array’s dimensions are numbered 0 to
‘n’-1 from left to right, and are enumerated with the rightmost index
changing fastest.  Every time the index for dimension ‘j’ is
incremented, the following actions are taken:

   • If ‘j’ < ‘n’-1, then a close parenthesis is printed.

   • If incrementing the index for dimension ‘j’ caused it to equal
     dimension ‘j’, that index is reset to zero and the index for
     dimension ‘j’-1 is incremented (thereby performing these three
     steps recursively), unless ‘j’=0, in which case the entire
     algorithm is terminated.  If incrementing the index for dimension
     ‘j’ did not cause it to equal dimension ‘j’, then a space is
     printed.

   • If ‘j’ < ‘n’-1, then an open parenthesis is printed.

This causes the contents to be printed in a format suitable for
:initial-contents to ‘make-array’.  The lists effectively printed by
this procedure are subject to truncation by ‘*print-level*’ and
‘*print-length*’.

If the array is of a specialized type, containing bits or characters,
then the innermost lists generated by the algorithm given above can
instead be printed using bit-vector or string syntax, provided that
these innermost lists would not be subject to truncation by
‘*print-length*’.

If both ‘*print-array*’ and ‘*print-readably*’ are false, then the array
is printed in a format (using ‘#<’) that is concise but not readable.

If ‘*print-readably*’ is true, the array prints in an
implementation-defined manner; see the variable *note
*print-readably*::.  In particular, this may be important for arrays
having some dimension ‘0’.

For information on how the Lisp reader parses these “other arrays,” see
*note Section 2.4.8.12 (Sharpsign A): SharpsignA.

22.1.3.9 Examples of Printing Arrays
....................................

      (let ((a (make-array '(3 3)))
            (*print-pretty* t)
            (*print-array* t))
        (dotimes (i 3) (dotimes (j 3) (setf (aref a i j) (format nil "<~D,~D>" i j))))
        (print a)
        (print (make-array 9 :displaced-to a)))
     ▷ #2A(("<0,0>" "<0,1>" "<0,2>")
     ▷     ("<1,0>" "<1,1>" "<1,2>")
     ▷     ("<2,0>" "<2,1>" "<2,2>"))
     ▷ #("<0,0>" "<0,1>" "<0,2>" "<1,0>" "<1,1>" "<1,2>" "<2,0>" "<2,1>" "<2,2>")
     → #<ARRAY 9 indirect 36363476>

22.1.3.10 Printing Random States
................................

A specific syntax for printing objects of type ‘random-state’ is not
specified.  However, every implementation must arrange to print a random
state object in such a way that, within the same implementation, ‘read’
can construct from the printed representation a copy of the random state
object as if the copy had been made by ‘make-random-state’.

If the type random state is effectively implemented by using the
machinery for ‘defstruct’, the usual structure syntax can then be used
for printing random state objects; one might look something like

      #S(RANDOM-STATE :DATA #(14 49 98436589 786345 8734658324 ... ))

where the components are implementation-dependent.

22.1.3.11 Printing Pathnames
............................

When printer escaping is enabled, the syntax ‘#P"..."’ is how a pathname
is printed by ‘write’ and the other functions herein described.  The
‘"..."’ is the namestring representation of the pathname.

When printer escaping is disabled, ‘write’ writes a pathname P by
writing ‘(namestring P)’ instead.

For information on how the Lisp reader parses pathnames, see *note
Section 2.4.8.14 (Sharpsign P): SharpsignP.

22.1.3.12 Printing Structures
.............................

By default, a structure of type S is printed using ‘#S’ syntax.  This
behavior can be customized by specifying a :print-function or
:print-object option to the ‘defstruct’ form that defines S, or by
writing a ‘print-object’ method that is specialized for objects of type
S.

Different structures might print out in different ways; the default
notation for structures is:

      #S(STRUCTURE-NAME {SLOT-KEY SLOT-VALUE}*)

where ‘#S’ indicates structure syntax, STRUCTURE-NAME is a structure
name, each SLOT-KEY is an initialization argument name for a slot in the
structure, and each corresponding SLOT-VALUE is a representation of the
object in that slot.

For information on how the Lisp reader parses structures, see *note
Section 2.4.8.13 (Sharpsign S): SharpsignS.

22.1.3.13 Printing Other Objects
................................

Other objects are printed in an implementation-dependent manner.  It is
not required that an implementation print those objects readably.

For example, hash tables, readtables, packages, streams, and functions
might not print readably.

A common notation to use in this circumstance is ‘#<...>’.  Since ‘#<’
is not readable by the Lisp reader, the precise format of the text which
follows is not important, but a common format to use is that provided by
the ‘print-unreadable-object’ macro.

For information on how the Lisp reader treats this notation, see *note
Section 2.4.8.20 (Sharpsign Less-Than-Sign): SharpsignLeftAngle.  For
information on how to notate objects that cannot be printed readably,
see *note Section 2.4.8.6 (Sharpsign Dot): SharpsignDot.


File: ansicl,  Node: Examples of Printer Behavior,  Prev: Default Print-Object Methods,  Up: The Lisp Printer

22.1.4 Examples of Printer Behavior
-----------------------------------

      (let ((*print-escape* t)) (fresh-line) (write #\a))
     ▷ #\a
     → #\a
      (let ((*print-escape* nil) (*print-readably* nil))
        (fresh-line)
        (write #\a))
     ▷ a
     → #\a
      (progn (fresh-line) (prin1 #\a))
     ▷ #\a
     → #\a
      (progn (fresh-line) (print #\a))
     ▷
     ▷ #\a
     → #\a
      (progn (fresh-line) (princ #\a))
     ▷ a
     → #\a
      
      
      (dolist (val '(t nil))
        (let ((*print-escape* val) (*print-readably* val))
          (print '#\a)
          (prin1 #\a) (write-char #\Space)
          (princ #\a) (write-char #\Space)
          (write #\a)))
     ▷ #\a #\a a #\a
     ▷ #\a #\a a a
     → NIL
      
      
      (progn (fresh-line) (write '(let ((a 1) (b 2)) (+ a b))))
     ▷ (LET ((A 1) (B 2)) (+ A B))
     → (LET ((A 1) (B 2)) (+ A B))
      
      
      (progn (fresh-line) (pprint '(let ((a 1) (b 2)) (+ a b))))
     ▷ (LET ((A 1)
     ▷       (B 2))
     ▷   (+ A B))
     → (LET ((A 1) (B 2)) (+ A B))
      
      
      (progn (fresh-line)
             (write '(let ((a 1) (b 2)) (+ a b)) :pretty t))
     ▷ (LET ((A 1)
     ▷       (B 2))
     ▷   (+ A B))
     → (LET ((A 1) (B 2)) (+ A B))
      
      
      (with-output-to-string (s)
         (write 'write :stream s)
         (prin1 'prin1 s))
     → "WRITEPRIN1"


File: ansicl,  Node: The Lisp Pretty Printer,  Next: Formatted Output,  Prev: The Lisp Printer,  Up: Printer

22.2 The Lisp Pretty Printer
============================

* Menu:

* Pretty Printer Concepts::
* Examples of using the Pretty Printer::
* Notes about the Pretty Printer's Background::


File: ansicl,  Node: Pretty Printer Concepts,  Next: Examples of using the Pretty Printer,  Up: The Lisp Pretty Printer

22.2.1 Pretty Printer Concepts
------------------------------

The facilities provided by the “pretty printer” permit programs to
redefine the way in which code is displayed, and allow the full power of
pretty printing to be applied to complex combinations of data
structures.

Whether any given style of output is in fact “pretty” is inherently a
somewhat subjective issue.  However, since the effect of the pretty
printer can be customized by conforming programs, the necessary
flexibility is provided for individual programs to achieve an arbitrary
degree of aesthetic control.

By providing direct access to the mechanisms within the pretty printer
that make dynamic decisions about layout, the macros and functions
‘pprint-logical-block’, ‘pprint-newline’, and ‘pprint-indent’ make it
possible to specify pretty printing layout rules as a part of any
function that produces output.  They also make it very easy for the
detection of circularity and sharing, and abbreviation based on length
and nesting depth to be supported by the function.

The pretty printer is driven entirely by dispatch based on the value of
‘*print-pprint-dispatch*’.  The function ‘set-pprint-dispatch’ makes it
possible for conforming programs to associate new pretty printing
functions with a type.

22.2.1.1 Dynamic Control of the Arrangement of Output
.....................................................

The actions of the pretty printer when a piece of output is too large to
fit in the space available can be precisely controlled.  Three concepts
underlie the way these operations work—“logical blocks”, “conditional
newlines”, and “sections”.  Before proceeding further, it is important
to define these terms.

The first line of the next figure shows a schematic piece of output.
Each of the characters in the output is represented by “‘-’”.  The
positions of conditional newlines are indicated by digits.  The
beginnings and ends of logical blocks are indicated by “‘<’” and “‘>’”
respectively.

The output as a whole is a logical block and the outermost section.
This section is indicated by the ‘0’’s on the second line of Figure 1.
Logical blocks nested within the output are specified by the macro
‘pprint-logical-block’.  Conditional newline positions are specified by
calls to ‘pprint-newline’.  Each conditional newline defines two
sections (one before it and one after it) and is associated with a third
(the section immediately containing it).

The section after a conditional newline consists of: all the output up
to, but not including, (a) the next conditional newline immediately
contained in the same logical block; or if (a) is not applicable, (b)
the next newline that is at a lesser level of nesting in logical blocks;
or if (b) is not applicable, (c) the end of the output.

The section before a conditional newline consists of: all the output
back to, but not including, (a) the previous conditional newline that is
immediately contained in the same logical block; or if (a) is not
applicable, (b) the beginning of the immediately containing logical
block.  The last four lines in Figure 1 indicate the sections before and
after the four conditional newlines.

The section immediately containing a conditional newline is the shortest
section that contains the conditional newline in question.  In the next
figure, the first conditional newline is immediately contained in the
section marked with ‘0’’s, the second and third conditional newlines are
immediately contained in the section before the fourth conditional
newline, and the fourth conditional newline is immediately contained in
the section after the first conditional newline.

      <-1---<--<--2---3->--4-->->
      000000000000000000000000000
      11 111111111111111111111111
                22 222
                   333 3333
             44444444444444 44444

Figure 22.3: Example of Logical Blocks, Conditional Newlines, and
Sections

Whenever possible, the pretty printer displays the entire contents of a
section on a single line.  However, if the section is too long to fit in
the space available, line breaks are inserted at conditional newline
positions within the section.

22.2.1.2 Format Directive Interface
...................................

The primary interface to operations for dynamically determining the
arrangement of output is provided through the functions and macros of
the pretty printer.  The next figure shows the defined names related to
pretty printing.

*print-lines*             pprint-dispatch                 pprint-pop
*print-miser-width*       pprint-exit-if-list-exhausted   pprint-tab
*print-pprint-dispatch*   pprint-fill                     pprint-tabular
*print-right-margin*      pprint-indent                   set-pprint-dispatch
copy-pprint-dispatch      pprint-linear                   write
format                    pprint-logical-block
formatter                 pprint-newline

Figure 22.4: Defined names related to pretty printing.

The next figure identifies a set of format directives which serve as an
alternate interface to the same pretty printing operations in a more
textually compact form.

‘~I’    ‘~W’       ‘~<... :>’
‘~:T’   ‘~/.../’   ‘~_’

Figure 22.5: Format directives related to Pretty Printing

22.2.1.3 Compiling Format Strings
.................................

A format string is essentially a program in a special-purpose language
that performs printing, and that is interpreted by the function
‘format’.  The ‘formatter’ macro provides the efficiency of using a
compiled function to do that same printing but without losing the
textual compactness of format strings.

A “format control” is either a format string or a function that was
returned by the the ‘formatter’ macro.

22.2.1.4 Pretty Print Dispatch Tables
.....................................

A “pprint dispatch table” is a mapping from keys to pairs of values.
Each key is a type specifier.  The values associated with a key are a
“function” (specifically, a function designator or ‘nil’) and a
“numerical priority” (specifically, a real).  Basic insertion and
retrieval is done based on the keys with the equality of keys being
tested by ‘equal’.

When ‘*print-pretty*’ is true, the “current pprint dispatch table” (in
‘*print-pprint-dispatch*’) controls how objects are printed.  The
information in this table takes precedence over all other mechanisms for
specifying how to print objects.  In particular, it has priority over
user-defined ‘print-object’ methods because the current pprint dispatch
table is consulted first.

The function is chosen from the current pprint dispatch table by finding
the highest priority function that is associated with a type specifier
that matches the object; if there is more than one such function, it is
implementation-dependent which is used.

However, if there is no information in the table about how to pretty
print a particular kind of object, a function is invoked which uses
‘print-object’ to print the object.  The value of ‘*print-pretty*’ is
still true when this function is called, and individual methods for
‘print-object’ might still elect to produce output in a special format
conditional on the value of ‘*print-pretty*’.

22.2.1.5 Pretty Printer Margins
...............................

A primary goal of pretty printing is to keep the output between a pair
of margins.  The column where the output begins is taken as the left
margin.  If the current column cannot be determined at the time output
begins, the left margin is assumed to be zero.  The right margin is
controlled by ‘*print-right-margin*’.


File: ansicl,  Node: Examples of using the Pretty Printer,  Next: Notes about the Pretty Printer's Background,  Prev: Pretty Printer Concepts,  Up: The Lisp Pretty Printer

22.2.2 Examples of using the Pretty Printer
-------------------------------------------

As an example of the interaction of logical blocks, conditional
newlines, and indentation, consider the function ‘simple-pprint-defun’
below.  This function prints out lists whose cars are ‘defun’ in the
standard way assuming that the list has exactly length ‘4’.

     (defun simple-pprint-defun (*standard-output* list)
       (pprint-logical-block (*standard-output* list :prefix "(" :suffix ")")
         (write (first list))
         (write-char #\Space)
         (pprint-newline :miser)
         (pprint-indent :current 0)
         (write (second list))
         (write-char #\Space)
         (pprint-newline :fill)
         (write (third list))
         (pprint-indent :block 1)
         (write-char #\Space)
         (pprint-newline :linear)
         (write (fourth list))))

Suppose that one evaluates the following:

     (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y)))

If the line width available is greater than or equal to ‘26’, then all
of the output appears on one line.  If the line width available is
reduced to ‘25’, a line break is inserted at the linear-style
conditional newline before the expression ‘(* x y)’, producing the
output shown.  The ‘(pprint-indent :block 1)’ causes ‘(* x y)’ to be
printed at a relative indentation of ‘1’ in the logical block.

      (DEFUN PROD (X Y)
        (* X Y))

If the line width available is ‘15’, a line break is also inserted at
the fill style conditional newline before the argument list.  The call
on ‘(pprint-indent :current 0)’ causes the argument list to line up
under the function name.

     (DEFUN PROD
            (X Y)
       (* X Y))

If ‘*print-miser-width*’ were greater than or equal to 14, the example
output above would have been as follows, because all indentation changes
are ignored in miser mode and line breaks are inserted at miser-style
conditional newlines.

      (DEFUN
       PROD
       (X Y)
       (* X Y))

As an example of a per-line prefix, consider that evaluating the
following produces the output shown with a line width of ‘20’ and
‘*print-miser-width*’ of ‘nil’.

      (pprint-logical-block (*standard-output* nil :per-line-prefix ";;; ")
        (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y))))

      ;;; (DEFUN PROD
      ;;;        (X Y)
      ;;;   (* X Y))

As a more complex (and realistic) example, consider the function
‘pprint-let’ below.  This specifies how to print a ‘let’ form in the
traditional style.  It is more complex than the example above, because
it has to deal with nested structure.  Also, unlike the example above it
contains complete code to readably print any possible list that begins
with the symbol ‘let’.  The outermost ‘pprint-logical-block’ form
handles the printing of the input list as a whole and specifies that
parentheses should be printed in the output.  The second
‘pprint-logical-block’ form handles the list of binding pairs.  Each
pair in the list is itself printed by the innermost
‘pprint-logical-block’.  (A ‘loop’ form is used instead of merely
decomposing the pair into two objects so that readable output will be
produced no matter whether the list corresponding to the pair has one
element, two elements, or (being malformed) has more than two elements.)
A space and a fill-style conditional newline are placed after each pair
except the last.  The loop at the end of the topmost
‘pprint-logical-block’ form prints out the forms in the body of the
‘let’ form separated by spaces and linear-style conditional newlines.

      (defun pprint-let (*standard-output* list)
        (pprint-logical-block (nil list :prefix "(" :suffix ")")
          (write (pprint-pop))
          (pprint-exit-if-list-exhausted)
          (write-char #\Space)
          (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
            (pprint-exit-if-list-exhausted)
            (loop (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
                    (pprint-exit-if-list-exhausted)
                    (loop (write (pprint-pop))
                          (pprint-exit-if-list-exhausted)
                          (write-char #\Space)
                          (pprint-newline :linear)))
                  (pprint-exit-if-list-exhausted)
                  (write-char #\Space)
                  (pprint-newline :fill)))
          (pprint-indent :block 1)
          (loop (pprint-exit-if-list-exhausted)
                (write-char #\Space)
                (pprint-newline :linear)
                (write (pprint-pop)))))

Suppose that one evaluates the following with ‘*print-level*’ being 4,
and ‘*print-circle*’ being true.

      (pprint-let *standard-output*
                  '#1=(let (x (*print-length* (f (g 3)))
                            (z . 2) (k (car y)))
                        (setq x (sqrt z)) #1#))

If the line length is greater than or equal to ‘77’, the output produced
appears on one line.  However, if the line length is ‘76’, line breaks
are inserted at the linear-style conditional newlines separating the
forms in the body and the output below is produced.  Note that, the
degenerate binding pair ‘x’ is printed readably even though it fails to
be a list; a depth abbreviation marker is printed in place of ‘(g 3)’;
the binding pair ‘(z . 2)’ is printed readably even though it is not a
proper list; and appropriate circularity markers are printed.

      #1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y)))
           (SETQ X (SQRT Z))
           #1#)

If the line length is reduced to ‘35’, a line break is inserted at one
of the fill-style conditional newlines separating the binding pairs.

      #1=(LET (X (*PRINT-PRETTY* (F #))
               (Z . 2) (K (CAR Y)))
           (SETQ X (SQRT Z))
           #1#)

Suppose that the line length is further reduced to ‘22’ and
‘*print-length*’ is set to ‘3’.  In this situation, line breaks are
inserted after both the first and second binding pairs.  In addition,
the second binding pair is itself broken across two lines.  Clause (b)
of the description of fill-style conditional newlines (see the function
*note pprint-newline::) prevents the binding pair ‘(z . 2)’ from being
printed at the end of the third line.  Note that the length abbreviation
hides the circularity from view and therefore the printing of
circularity markers disappears.

      (LET (X
            (*PRINT-LENGTH*
             (F #))
            (Z . 2) ...)
        (SETQ X (SQRT Z))
        ...)

The next function prints a vector using “‘#(...)’” notation.

     (defun pprint-vector (*standard-output* v)
       (pprint-logical-block (nil nil :prefix "#(" :suffix ")")
         (let ((end (length v)) (i 0))
           (when (plusp end)
             (loop (pprint-pop)
                   (write (aref v i))
                   (if (= (incf i) end) (return nil))
                   (write-char #\Space)
                   (pprint-newline :fill))))))

Evaluating the following with a line length of 15 produces the output
shown.

      (pprint-vector *standard-output* '#(12 34 567 8 9012 34 567 89 0 1 23))

      #(12 34 567 8
        9012 34 567
        89 0 1 23)

As examples of the convenience of specifying pretty printing with format
strings, consider that the functions ‘simple-pprint-defun’ and
‘pprint-let’ used as examples above can be compactly defined as follows.
(The function ‘pprint-vector’ cannot be defined using ‘format’ because
the data structure it traverses is not a list.)

     (defun simple-pprint-defun (*standard-output* list)
       (format T "~:<~W ~@_~:I~W ~:_~W~1I ~_~W~:>" list))

     (defun pprint-let (*standard-output* list)
       (format T "~:<~W~^~:<~@{~:<~@{~W~^~_~}~:>~^~:_~}~:>~1I~@{~^~_~W~}~:>" list))

In the following example, the first form restores
‘*print-pprint-dispatch*’ to the equivalent of its initial value.  The
next two forms then set up a special way to pretty print ratios.  Note
that the more specific type specifier has to be associated with a higher
priority.

      (setq *print-pprint-dispatch* (copy-pprint-dispatch nil))

      (set-pprint-dispatch 'ratio
        #'(lambda (s obj)
            (format s "#.(/ ~W ~W)"
                      (numerator obj) (denominator obj))))

      (set-pprint-dispatch '(and ratio (satisfies minusp))
        #'(lambda (s obj)
            (format s "#.(- (/ ~W ~W))"
                    (- (numerator obj)) (denominator obj)))
        5)

      (pprint '(1/3 -2/3))
      (#.(/ 1 3) #.(- (/ 2 3)))

The following two forms illustrate the definition of pretty printing
functions for types of code.  The first form illustrates how to specify
the traditional method for printing quoted objects using single-quote.
Note the care taken to ensure that data lists that happen to begin with
quote will be printed readably.  The second form specifies that lists
beginning with the symbol ‘my-let’ should print the same way that lists
beginning with ‘let’ print when the initial pprint dispatch table is in
effect.

      (set-pprint-dispatch '(cons (member quote)) ()
        #'(lambda (s list)
            (if (and (consp (cdr list)) (null (cddr list)))
               (funcall (formatter "'~W") s (cadr list))
               (pprint-fill s list))))

      (set-pprint-dispatch '(cons (member my-let))
                           (pprint-dispatch '(let) nil))

The next example specifies a default method for printing lists that do
not correspond to function calls.  Note that the functions
‘pprint-linear’, ‘pprint-fill’, and ‘pprint-tabular’ are all defined
with optional COLON-P and AT-SIGN-P arguments so that they can be used
as ‘pprint dispatch functions’ as well as ‘~/.../’ functions.

      (set-pprint-dispatch '(cons (not (and symbol (satisfies fboundp))))
                           #'pprint-fill -5)

      ;; Assume a line length of 9
      (pprint '(0 b c d e f g h i j k))
      (0 b c d
       e f g h
       i j k)

This final example shows how to define a pretty printing function for a
user defined data structure.

      (defstruct family mom kids)

      (set-pprint-dispatch 'family
        #'(lambda (s f)
            (funcall (formatter "~@<#<~;~W and ~2I~_~/pprint-fill/~;>~:>")
                    s (family-mom f) (family-kids f))))

The pretty printing function for the structure ‘family’ specifies how to
adjust the layout of the output so that it can fit aesthetically into a
variety of line widths.  In addition, it obeys the printer control
variables ‘*print-level*’, ‘*print-length*’, ‘*print-lines*’,
‘*print-circle*’ and ‘*print-escape*’, and can tolerate several
different kinds of malformity in the data structure.  The output below
shows what is printed out with a right margin of ‘25’, ‘*print-pretty*’
being true, ‘*print-escape*’ being false, and a malformed ‘kids’ list.

      (write (list 'principal-family
                   (make-family :mom "Lucy"
                                :kids '("Mark" "Bob" . "Dan")))
             :right-margin 25 :pretty T :escape nil :miser-width nil)
      (PRINCIPAL-FAMILY
       #<Lucy and
           Mark Bob . Dan>)

Note that a pretty printing function for a structure is different from
the structure’s ‘print-object’ method.  While ‘print-object’ methods are
permanently associated with a structure, pretty printing functions are
stored in pprint dispatch tables and can be rapidly changed to reflect
different printing needs.  If there is no pretty printing function for a
structure in the current pprint dispatch table, its ‘print-object’
method is used instead.


File: ansicl,  Node: Notes about the Pretty Printer's Background,  Prev: Examples of using the Pretty Printer,  Up: The Lisp Pretty Printer

22.2.3 Notes about the Pretty Printer’s Background
--------------------------------------------------

For a background reference to the abstract concepts detailed in this
section, see ‘XP: A Common Lisp Pretty Printing System’.  The details of
that paper are not binding on this document, but may be helpful in
establishing a conceptual basis for understanding this material.


File: ansicl,  Node: Formatted Output,  Next: copy-pprint-dispatch,  Prev: The Lisp Pretty Printer,  Up: Printer

22.3 Formatted Output
=====================

‘format’ is useful for producing nicely formatted text, producing
good-looking messages, and so on.  ‘format’ can generate and return a
string or output to DESTINATION.

The CONTROL-STRING argument to ‘format’ is actually a format control.
That is, it can be either a format string or a function, for example a
function returned by the ‘formatter’ macro.

If it is a function, the function is called with the appropriate output
stream as its first argument and the data arguments to ‘format’ as its
remaining arguments.  The function should perform whatever output is
necessary and return the unused tail of the arguments (if any).

The compilation process performed by ‘formatter’ produces a function
that would do with its arguments as the ‘format’ interpreter would do
with those arguments.

The remainder of this section describes what happens if the
CONTROL-STRING is a format string.

CONTROL-STRING is composed of simple text (characters) and embedded
directives.

‘format’ writes the simple text as is; each embedded directive specifies
further text output that is to appear at the corresponding point within
the simple text.  Most directives use one or more elements of ARGS to
create their output.

A directive consists of a tilde, optional prefix parameters separated by
commas, optional colon and at-sign modifiers, and a single character
indicating what kind of directive this is.  There is no required
ordering between the at-sign and colon modifier.  The case of the
directive character is ignored.  Prefix parameters are notated as signed
(sign is optional) decimal numbers, or as a single-quote followed by a
character.  For example, ‘~5,'0d’ can be used to print an integer in
decimal radix in five columns with leading zeros, or ‘~5,'*d’ to get
leading asterisks.

In place of a prefix parameter to a directive, ‘V’ (or ‘v’) can be used.
In this case, ‘format’ takes an argument from ARGS as a parameter to the
directive.  The argument should be an integer or character.  If the ARG
used by a ‘V’ parameter is ‘nil’, the effect is as if the parameter had
been omitted.  ‘#’ can be used in place of a prefix parameter; it
represents the number of ARGS remaining to be processed.  When used
within a recursive format, in the context of ‘~?’ or ‘~{’, the ‘#’
prefix parameter represents the number of format arguments remaining
within the recursive call.

Examples of format strings:

‘"~S"’         ;This is an S directive with no parameters or modifiers.
‘"~3,-4:@s"’   ;This is an S directive with two parameters, ‘3’ and ‘-4’,
               ; and both the colon and at-sign flags.
‘"~,+4S"’      ;Here the first prefix parameter is omitted and takes
               ; on its default value, while the second parameter is ‘4’.

Figure 22.6: Examples of format control strings

‘format’ sends the output to DESTINATION.  If DESTINATION is ‘nil’,
‘format’ creates and returns a string containing the output from
CONTROL-STRING.  If DESTINATION is non-nil, it must be a string with a
fill pointer, a stream, or the symbol ‘t’.  If DESTINATION is a string
with a fill pointer, the output is added to the end of the string.  If
DESTINATION is a stream, the output is sent to that stream.  If
DESTINATION is ‘t’, the output is sent to standard output.

In the description of the directives that follows, the term arg in
general refers to the next item of the set of ARGS to be processed.  The
word or phrase at the beginning of each description is a mnemonic for
the directive.  ‘format’ directives do not bind any of the printer
control variables (‘*print-...*’) except as specified in the following
descriptions.  Implementations may specify the binding of new,
implementation-specific printer control variables for each ‘format’
directive, but they may neither bind any standard printer control
variables not specified in description of a ‘format’ directive nor fail
to bind any standard printer control variables as specified in the
description.

* Menu:

* FORMAT Basic Output::
* FORMAT Radix Control::
* FORMAT Floating-Point Printers::
* FORMAT Printer Operations::
* FORMAT Pretty Printer Operations::
* FORMAT Layout Control::
* FORMAT Control-Flow Operations::
* FORMAT Miscellaneous Operations::
* FORMAT Miscellaneous Pseudo-Operations::
* Additional Information about FORMAT Operations::
* Examples of FORMAT::
* Notes about FORMAT::


File: ansicl,  Node: FORMAT Basic Output,  Next: FORMAT Radix Control,  Up: Formatted Output

22.3.1 FORMAT Basic Output
--------------------------

22.3.1.1 Tilde C: Character
...........................

The next arg should be a character; it is printed according to the
modifier flags.

‘~C’ prints the character as if by using ‘write-char’ if it is a simple
character.  Characters that are not simple are not necessarily printed
as if by ‘write-char’, but are displayed in an implementation-defined,
abbreviated format.  For example,

      (format nil "~C" #\A) → "A"
      (format nil "~C" #\Space) → " "

‘~:C’ is the same as ‘~C’ for printing characters, but other characters
are “spelled out.” The intent is that this is a “pretty” format for
printing characters.  For simple characters that are not printing, what
is spelled out is the name of the character (see ‘char-name’).  For
characters that are not simple and not printing, what is spelled out is
implementation-defined.  For example,

      (format nil "~:C" #\A) → "A"
      (format nil "~:C" #\Space) → "Space"
     ;; This next example assumes an implementation-defined "Control" attribute.
      (format nil "~:C" #\Control-Space)
     → "Control-Space"
     or→ "c-Space"

‘~:@C’ prints what ‘~:C’ would, and then if the character requires
unusual shift keys on the keyboard to type it, this fact is mentioned.
For example,

      (format nil "~:@C" #\Control-Partial) → "Control-∂ (Top-F)"

This is the format used for telling the user about a key he is expected
to type, in prompts, for instance.  The precise output may depend not
only on the implementation, but on the particular I/O devices in use.

‘~@C’ prints the character in a way that the Lisp reader can understand,
using ‘#\’ syntax.

‘~@C’ binds ‘*print-escape*’ to ‘t’.

22.3.1.2 Tilde Percent: Newline
...............................

This outputs a ‘#\Newline’ character, thereby terminating the current
output line and beginning a new one.  ‘~n%’ outputs n newlines.  No arg
is used.

22.3.1.3 Tilde Ampersand: Fresh-Line
....................................

Unless it can be determined that the output stream is already at the
beginning of a line, this outputs a newline.  ‘~n&’ calls ‘fresh-line’
and then outputs n− 1 newlines.  ‘~0&’ does nothing.

22.3.1.4 Tilde Vertical-Bar: Page
.................................

This outputs a page separator character, if possible.  ‘~n|’ does this n
times.

22.3.1.5 Tilde Tilde: Tilde
...........................

This outputs a tilde.  ‘~n~’ outputs n tildes.


File: ansicl,  Node: FORMAT Radix Control,  Next: FORMAT Floating-Point Printers,  Prev: FORMAT Basic Output,  Up: Formatted Output

22.3.2 FORMAT Radix Control
---------------------------

22.3.2.1 Tilde R: Radix
.......................

‘~nR’ prints arg in radix n.  The modifier flags and any remaining
parameters are used as for the ‘~D’ directive.  ‘~D’ is the same as
‘~10R’.  The full form is
‘~radix,mincol,padchar,commachar,comma-intervalR’.

If no prefix parameters are given to ‘~R’, then a different
interpretation is given.  The argument should be an integer.  For
example, if arg is 4:

   • ‘~R’ prints arg as a cardinal English number: ‘four’.

   • ‘~:R’ prints arg as an ordinal English number: ‘fourth’.

   • ‘~@R’ prints arg as a Roman numeral: ‘IV’.

   • ‘~:@R’ prints arg as an old Roman numeral: ‘IIII’.

For example:

      (format nil "~,,' ,4:B" 13) → "1101"
      (format nil "~,,' ,4:B" 17) → "1 0001"
      (format nil "~19,0,' ,4:B" 3333) → "0000 1101 0000 0101"
      (format nil "~3,,,' ,2:R" 17) → "1 22"
      (format nil "~,,'|,2:D" #xFFFF) →  "6|55|35"

If and only if the first parameter, n, is supplied, ‘~R’ binds
‘*print-escape*’ to false, ‘*print-radix*’ to false, ‘*print-base*’ to
n, and ‘*print-readably*’ to false.

If and only if no parameters are supplied, ‘~R’ binds ‘*print-base*’ to
‘10’.

22.3.2.2 Tilde D: Decimal
.........................

An arg, which should be an integer, is printed in decimal radix.  ‘~D’
will never put a decimal point after the number.

‘~mincolD’ uses a column width of mincol; spaces are inserted on the
left if the number requires fewer than mincol columns for its digits and
sign.  If the number doesn’t fit in mincol columns, additional columns
are used as needed.

‘~mincol,padcharD’ uses padchar as the pad character instead of space.

If arg is not an integer, it is printed in ‘~A’ format and decimal base.

The ‘@’ modifier causes the number’s sign to be printed always; the
default is to print it only if the number is negative.  The ‘:’ modifier
causes commas to be printed between groups of digits; commachar may be
used to change the character used as the comma.  comma-interval must be
an integer and defaults to 3.  When the ‘:’ modifier is given to any of
these directives, the commachar is printed between groups of
comma-interval digits.

Thus the most general form of ‘~D’ is
‘~mincol,padchar,commachar,comma-intervalD’.

‘~D’ binds ‘*print-escape*’ to false, ‘*print-radix*’ to false,
‘*print-base*’ to ‘10’, and ‘*print-readably*’ to false.

22.3.2.3 Tilde B: Binary
........................

This is just like ‘~D’ but prints in binary radix (radix 2) instead of
decimal.  The full form is therefore
‘~mincol,padchar,commachar,comma-intervalB’.

‘~B’ binds ‘*print-escape*’ to false, ‘*print-radix*’ to false,
‘*print-base*’ to ‘2’, and ‘*print-readably*’ to false.

22.3.2.4 Tilde O: Octal
.......................

This is just like ‘~D’ but prints in octal radix (radix 8) instead of
decimal.  The full form is therefore
‘~mincol,padchar,commachar,comma-intervalO’.

‘~O’ binds ‘*print-escape*’ to false, ‘*print-radix*’ to false,
‘*print-base*’ to ‘8’, and ‘*print-readably*’ to false.

22.3.2.5 Tilde X: Hexadecimal
.............................

This is just like ‘~D’ but prints in hexadecimal radix (radix 16)
instead of decimal.  The full form is therefore
‘~mincol,padchar,commachar,comma-intervalX’.

‘~X’ binds ‘*print-escape*’ to false, ‘*print-radix*’ to false,
‘*print-base*’ to ‘16’, and ‘*print-readably*’ to false.


File: ansicl,  Node: FORMAT Floating-Point Printers,  Next: FORMAT Printer Operations,  Prev: FORMAT Radix Control,  Up: Formatted Output

22.3.3 FORMAT Floating-Point Printers
-------------------------------------

22.3.3.1 Tilde F: Fixed-Format Floating-Point
.............................................

The next arg is printed as a float.

The full form is ‘~w,d,k,overflowchar,padcharF’.  The parameter w is the
width of the field to be printed; d is the number of digits to print
after the decimal point; k is a scale factor that defaults to zero.

Exactly w characters will be output.  First, leading copies of the
character padchar (which defaults to a space) are printed, if necessary,
to pad the field on the left.  If the arg is negative, then a minus sign
is printed; if the arg is not negative, then a plus sign is printed if
and only if the ‘@’ modifier was supplied.  Then a sequence of digits,
containing a single embedded decimal point, is printed; this represents
the magnitude of the value of arg times 10^k, rounded to d fractional
digits.  When rounding up and rounding down would produce printed values
equidistant from the scaled value of arg, then the implementation is
free to use either one.  For example, printing the argument ‘6.375’
using the format ‘~4,2F’ may correctly produce either ‘6.37’ or ‘6.38’.
Leading zeros are not permitted, except that a single zero digit is
output before the decimal point if the printed value is less than one,
and this single zero digit is not output at all if w=d+1.

If it is impossible to print the value in the required format in a field
of width w, then one of two actions is taken.  If the parameter
overflowchar is supplied, then w copies of that parameter are printed
instead of the scaled value of arg.  If the overflowchar parameter is
omitted, then the scaled value is printed using more than w characters,
as many more as may be needed.

If the w parameter is omitted, then the field is of variable width.  In
effect, a value is chosen for w in such a way that no leading pad
characters need to be printed and exactly d characters will follow the
decimal point.  For example, the directive ‘~,2F’ will print exactly two
digits after the decimal point and as many as necessary before the
decimal point.

If the parameter d is omitted, then there is no constraint on the number
of digits to appear after the decimal point.  A value is chosen for d in
such a way that as many digits as possible may be printed subject to the
width constraint imposed by the parameter w and the constraint that no
trailing zero digits may appear in the fraction, except that if the
fraction to be printed is zero, then a single zero digit should appear
after the decimal point if permitted by the width constraint.

If both w and d are omitted, then the effect is to print the value using
ordinary free-format output; ‘prin1’ uses this format for any number
whose magnitude is either zero or between 10^-3 (inclusive) and 10^7
(exclusive).

If w is omitted, then if the magnitude of arg is so large (or, if d is
also omitted, so small) that more than 100 digits would have to be
printed, then an implementation is free, at its discretion, to print the
number using exponential notation instead, as if by the directive ‘~E’
(with all parameters to ‘~E’ defaulted, not taking their values from the
‘~F’ directive).

If arg is a rational number, then it is coerced to be a single float and
then printed.  Alternatively, an implementation is permitted to process
a rational number by any other method that has essentially the same
behavior but avoids loss of precision or overflow because of the
coercion.  If w and d are not supplied and the number has no exact
decimal representation, for example ‘1/3’, some precision cutoff must be
chosen by the implementation since only a finite number of digits may be
printed.

If arg is a complex number or some non-numeric object, then it is
printed using the format directive ‘~wD’, thereby printing it in decimal
radix and a minimum field width of w.

‘~F’ binds ‘*print-escape*’ to false and ‘*print-readably*’ to false.

22.3.3.2 Tilde E: Exponential Floating-Point
............................................

The next arg is printed as a float in exponential notation.

The full form is ‘~w,d,e,k,overflowchar,padchar,exponentcharE’.  The
parameter w is the width of the field to be printed; d is the number of
digits to print after the decimal point; e is the number of digits to
use when printing the exponent; k is a scale factor that defaults to one
(not zero).

Exactly w characters will be output.  First, leading copies of the
character padchar (which defaults to a space) are printed, if necessary,
to pad the field on the left.  If the arg is negative, then a minus sign
is printed; if the arg is not negative, then a plus sign is printed if
and only if the ‘@’ modifier was supplied.  Then a sequence of digits
containing a single embedded decimal point is printed.  The form of this
sequence of digits depends on the scale factor k.  If k is zero, then d
digits are printed after the decimal point, and a single zero digit
appears before the decimal point if the total field width will permit
it.  If k is positive, then it must be strictly less than d+2; k
significant digits are printed before the decimal point, and d− k+1
digits are printed after the decimal point.  If k is negative, then it
must be strictly greater than − d; a single zero digit appears before
the decimal point if the total field width will permit it, and after the
decimal point are printed first − k zeros and then d+k significant
digits.  The printed fraction must be properly rounded.  When rounding
up and rounding down would produce printed values equidistant from the
scaled value of arg, then the implementation is free to use either one.
For example, printing the argument ‘637.5’ using the format ‘~8,2E’ may
correctly produce either ‘6.37E+2’ or ‘6.38E+2’.

Following the digit sequence, the exponent is printed.  First the
character parameter exponentchar is printed; if this parameter is
omitted, then the exponent marker that ‘prin1’ would use is printed, as
determined from the type of the float and the current value of
‘*read-default-float-format*’.  Next, either a plus sign or a minus sign
is printed, followed by e digits representing the power of ten by which
the printed fraction must be multiplied to properly represent the
rounded value of arg.

If it is impossible to print the value in the required format in a field
of width w, possibly because k is too large or too small or because the
exponent cannot be printed in e character positions, then one of two
actions is taken.  If the parameter overflowchar is supplied, then w
copies of that parameter are printed instead of the scaled value of arg.
If the overflowchar parameter is omitted, then the scaled value is
printed using more than w characters, as many more as may be needed; if
the problem is that d is too small for the supplied k or that e is too
small, then a larger value is used for d or e as may be needed.

If the w parameter is omitted, then the field is of variable width.  In
effect a value is chosen for w in such a way that no leading pad
characters need to be printed.

If the parameter d is omitted, then there is no constraint on the number
of digits to appear.  A value is chosen for d in such a way that as many
digits as possible may be printed subject to the width constraint
imposed by the parameter w, the constraint of the scale factor k, and
the constraint that no trailing zero digits may appear in the fraction,
except that if the fraction to be printed is zero then a single zero
digit should appear after the decimal point.

If the parameter e is omitted, then the exponent is printed using the
smallest number of digits necessary to represent its value.

If all of w, d, and e are omitted, then the effect is to print the value
using ordinary free-format exponential-notation output; ‘prin1’ uses a
similar format for any non-zero number whose magnitude is less than
10^-3 or greater than or equal to 10^7.  The only difference is that the
‘~E’ directive always prints a plus or minus sign in front of the
exponent, while ‘prin1’ omits the plus sign if the exponent is
non-negative.

If arg is a rational number, then it is coerced to be a single float and
then printed.  Alternatively, an implementation is permitted to process
a rational number by any other method that has essentially the same
behavior but avoids loss of precision or overflow because of the
coercion.  If w and d are unsupplied and the number has no exact decimal
representation, for example ‘1/3’, some precision cutoff must be chosen
by the implementation since only a finite number of digits may be
printed.

If arg is a complex number or some non-numeric object, then it is
printed using the format directive ‘~wD’, thereby printing it in decimal
radix and a minimum field width of w.

‘~E’ binds ‘*print-escape*’ to false and ‘*print-readably*’ to false.

22.3.3.3 Tilde G: General Floating-Point
........................................

The next arg is printed as a float in either fixed-format or exponential
notation as appropriate.

The full form is ‘~w,d,e,k,overflowchar,padchar,exponentcharG’.  The
format in which to print arg depends on the magnitude (absolute value)
of the arg.  Let n be an integer such that 10^n-1 ≤ |arg| < 10^n.  Let
ee equal e+2, or 4 if e is omitted.  Let ww equal w− ee, or ‘nil’ if w
is omitted.  If d is omitted, first let q be the number of digits needed
to print arg with no loss of information and without leading or trailing
zeros; then let d equal ‘(max q (min n 7))’.  Let dd equal d− n.

If 0 ≤ dd ≤ d, then arg is printed as if by the format directives

‘~ww,dd,,overflowchar,padcharF~ee@T’

Note that the scale factor k is not passed to the ‘~F’ directive.  For
all other values of dd, arg is printed as if by the format directive

‘~w,d,e,k,overflowchar,padchar,exponentcharE’

In either case, an ‘@’ modifier is supplied to the ‘~F’ or ‘~E’
directive if and only if one was supplied to the ‘~G’ directive.

‘~G’ binds ‘*print-escape*’ to false and ‘*print-readably*’ to false.

22.3.3.4 Tilde Dollarsign: Monetary Floating-Point
..................................................

The next arg is printed as a float in fixed-format notation.

The full form is ‘~d,n,w,padchar$’.  The parameter d is the number of
digits to print after the decimal point (default value 2); n is the
minimum number of digits to print before the decimal point (default
value 1); w is the minimum total width of the field to be printed
(default value 0).

First padding and the sign are output.  If the arg is negative, then a
minus sign is printed; if the arg is not negative, then a plus sign is
printed if and only if the ‘@’ modifier was supplied.  If the ‘:’
modifier is used, the sign appears before any padding, and otherwise
after the padding.  If w is supplied and the number of other characters
to be output is less than w, then copies of padchar (which defaults to a
space) are output to make the total field width equal w.  Then n digits
are printed for the integer part of arg, with leading zeros if
necessary; then a decimal point; then d digits of fraction, properly
rounded.

If the magnitude of arg is so large that more than m digits would have
to be printed, where m is the larger of w and 100, then an
implementation is free, at its discretion, to print the number using
exponential notation instead, as if by the directive ‘~w,q,,,,padcharE’,
where w and padchar are present or omitted according to whether they
were present or omitted in the ‘~$’ directive, and where q=d+n− 1, where
d and n are the (possibly default) values given to the ‘~$’ directive.

If arg is a rational number, then it is coerced to be a single float and
then printed.  Alternatively, an implementation is permitted to process
a rational number by any other method that has essentially the same
behavior but avoids loss of precision or overflow because of the
coercion.

If arg is a complex number or some non-numeric object, then it is
printed using the format directive ‘~wD’, thereby printing it in decimal
radix and a minimum field width of w.

‘~$’ binds ‘*print-escape*’ to false and ‘*print-readably*’ to false.


File: ansicl,  Node: FORMAT Printer Operations,  Next: FORMAT Pretty Printer Operations,  Prev: FORMAT Floating-Point Printers,  Up: Formatted Output

22.3.4 FORMAT Printer Operations
--------------------------------

22.3.4.1 Tilde A: Aesthetic
...........................

An arg, any object, is printed without escape characters (as by
‘princ’).  If arg is a string, its characters will be output verbatim.
If arg is ‘nil’ it will be printed as ‘nil’; the colon modifier (‘~:A’)
will cause an arg of ‘nil’ to be printed as (), but if arg is a
composite structure, such as a list or vector, any contained occurrences
of ‘nil’ will still be printed as ‘nil’.

‘~mincolA’ inserts spaces on the right, if necessary, to make the width
at least mincol columns.  The ‘@’ modifier causes the spaces to be
inserted on the left rather than the right.

‘~mincol,colinc,minpad,padcharA’ is the full form of ‘~A’, which allows
control of the padding.  The string is padded on the right (or on the
left if the ‘@’ modifier is used) with at least minpad copies of
padchar; padding characters are then inserted colinc characters at a
time until the total width is at least mincol.  The defaults are ‘0’ for
mincol and minpad, ‘1’ for colinc, and the space character for padchar.

‘~A’ binds ‘*print-escape*’ to false, and ‘*print-readably*’ to false.

22.3.4.2 Tilde S: Standard
..........................

This is just like ‘~A’, but arg is printed with escape characters (as by
‘prin1’ rather than ‘princ’).  The output is therefore suitable for
input to ‘read’.  ‘~S’ accepts all the arguments and modifiers that ‘~A’
does.

‘~S’ binds ‘*print-escape*’ to ‘t’.

22.3.4.3 Tilde W: Write
.......................

An argument, any object, is printed obeying every printer control
variable (as by ‘write’).  In addition, ‘~W’ interacts correctly with
depth abbreviation, by not resetting the depth counter to zero.  ‘~W’
does not accept parameters.  If given the colon modifier, ‘~W’ binds
‘*print-pretty*’ to true.  If given the at-sign modifier, ‘~W’ binds
‘*print-level*’ and ‘*print-length*’ to ‘nil’.

‘~W’ provides automatic support for the detection of circularity and
sharing.  If the value of ‘*print-circle*’ is not ‘nil’ and ‘~W’ is
applied to an argument that is a circular (or shared) reference, an
appropriate ‘#N#’ marker is inserted in the output instead of printing
the argument.

